<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0025)http://www.w3.org/TR/xslt -->
<HTML><HEAD><TITLE>XSL Transformations (XSLT)</TITLE>
<META http-equiv=Content-Type content="text/html; charset=iso-8859-1"><LINK 
href="REC-xslt-19991116_files/W3C-REC.css" type=text/css rel=stylesheet>
<STYLE type=text/css>P.element-syntax {
	BORDER-RIGHT: thin solid; BORDER-TOP: thin solid; BORDER-LEFT: thin solid; BORDER-BOTTOM: thin solid
}
CODE {
	FONT-FAMILY: monospace
}
</STYLE>

<META content="MSHTML 6.00.2900.3268" name=GENERATOR></HEAD>
<BODY>
<DIV class=head><A href="http://www.w3.org/"><IMG height=48 alt=W3C 
src="REC-xslt-19991116_files/w3c_home.png" width=72></A> 
<H1>XSL Transformations (XSLT)<BR>Version 1.0</H1>
<H2>W3C Recommendation 16 November 1999</H2>
<DL>
  <DT>This version: 
  <DD><A 
  href="http://www.w3.org/TR/1999/REC-xslt-19991116">http://www.w3.org/TR/1999/REC-xslt-19991116</A> 
  <BR>(available in <A 
  href="http://www.w3.org/TR/1999/REC-xslt-19991116.xml">XML</A> or <A 
  href="http://www.w3.org/TR/1999/REC-xslt-19991116.html">HTML</A>) 
  <DT>Latest version: 
  <DD><A href="http://www.w3.org/TR/xslt">http://www.w3.org/TR/xslt</A> <BR>
  <DT>Previous versions: 
  <DD><A 
  href="http://www.w3.org/TR/1999/PR-xslt-19991008">http://www.w3.org/TR/1999/PR-xslt-19991008</A> 
  <BR><A 
  href="http://www.w3.org/1999/08/WD-xslt-19990813">http://www.w3.org/1999/08/WD-xslt-19990813</A> 
  <BR><A 
  href="http://www.w3.org/1999/07/WD-xslt-19990709">http://www.w3.org/1999/07/WD-xslt-19990709</A> 
  <BR><A 
  href="http://www.w3.org/TR/1999/WD-xslt-19990421">http://www.w3.org/TR/1999/WD-xslt-19990421</A> 
  <BR><A 
  href="http://www.w3.org/TR/1998/WD-xsl-19981216">http://www.w3.org/TR/1998/WD-xsl-19981216</A> 
  <BR><A 
  href="http://www.w3.org/TR/1998/WD-xsl-19980818">http://www.w3.org/TR/1998/WD-xsl-19980818</A> 
  <BR>
  <DT>Editor: 
  <DD>James Clark <A href="mailto:jjc@jclark.com">mailto:jjc@jclark.com</A> 
  <BR></DD></DL>
<P class=copyright><A 
href="http://www.w3.org/Consortium/Legal/ipr-notice.html#Copyright">Copyright</A> 
&nbsp;©&nbsp; 1999 <A href="http://www.w3.org/">W3C</A><SUP>®</SUP> (<A 
href="http://www.lcs.mit.edu/">MIT</A>, <A 
href="http://www.inria.fr/">INRIA</A>, <A 
href="http://www.keio.ac.jp/">Keio</A>), All Rights Reserved. W3C <A 
href="http://www.w3.org/Consortium/Legal/ipr-notice.html#Legal_Disclaimer">liability</A>, 
<A 
href="http://www.w3.org/Consortium/Legal/ipr-notice.html#W3C_Trademarks">trademark</A>, 
<A href="http://www.w3.org/Consortium/Legal/copyright-documents.html">document 
use</A> and <A 
href="http://www.w3.org/Consortium/Legal/copyright-software.html">software 
licensing</A> rules apply.</P>
<HR title="Separator for header">
</DIV>
<H2><A name=abstract>Abstract</A></H2>
<P>This specification defines the syntax and semantics of XSLT, which is a 
language for transforming XML documents into other XML documents.</P>
<P>XSLT is designed for use as part of XSL, which is a stylesheet language for 
XML. In addition to XSLT, XSL includes an XML vocabulary for specifying 
formatting. XSL specifies the styling of an XML document by using XSLT to 
describe how the document is transformed into another XML document that uses the 
formatting vocabulary.</P>
<P>XSLT is also designed to be used independently of XSL. However, XSLT is not 
intended as a completely general-purpose XML transformation language. Rather it 
is designed primarily for the kinds of transformations that are needed when XSLT 
is used as part of XSL.</P>
<H2><A name=status>Status of this document</A></H2>
<P>This document has been reviewed by W3C Members and other interested parties 
and has been endorsed by the Director as a W3C <A 
href="http://www.w3.org/Consortium/Process/#RecsW3C">Recommendation</A>. It is a 
stable document and may be used as reference material or cited as a normative 
reference from other documents. W3C's role in making the Recommendation is to 
draw attention to the specification and to promote its widespread deployment. 
This enhances the functionality and interoperability of the Web.</P>
<P>The list of known errors in this specification is available at <A 
href="http://www.w3.org/1999/11/REC-xslt-19991116-errata">http://www.w3.org/1999/11/REC-xslt-19991116-errata</A>.</P>
<P>Comments on this specification may be sent to <A 
href="mailto:xsl-editors@w3.org">xsl-editors@w3.org</A>; <A 
href="http://lists.w3.org/Archives/Public/xsl-editors">archives</A> of the 
comments are available. Public discussion of XSL, including XSL Transformations, 
takes place on the <A 
href="http://www.mulberrytech.com/xsl/xsl-list/index.html">XSL-List</A> mailing 
list.</P>
<P>The English version of this specification is the only normative version. 
However, for translations of this document, see <A 
href="http://www.w3.org/Style/XSL/translations.html">http://www.w3.org/Style/XSL/translations.html</A>.</P>
<P>A list of current W3C Recommendations and other technical documents can be 
found at <A href="http://www.w3.org/TR">http://www.w3.org/TR</A>.</P>
<P>This specification has been produced as part of the <A 
href="http://www.w3.org/Style/Activity">W3C Style activity</A>.</P>
<H2><A name=contents>Table of contents</A></H2>1 <A 
href="http://www.w3.org/TR/xslt#section-Introduction">Introduction</A> <BR>2 <A 
href="http://www.w3.org/TR/xslt#section-Stylesheet-Structure">Stylesheet 
Structure</A> <BR>&nbsp;&nbsp;&nbsp;&nbsp;2.1 <A 
href="http://www.w3.org/TR/xslt#xslt-namespace">XSLT Namespace</A> 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;2.2 <A 
href="http://www.w3.org/TR/xslt#stylesheet-element">Stylesheet Element</A> 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;2.3 <A 
href="http://www.w3.org/TR/xslt#result-element-stylesheet">Literal Result 
Element as Stylesheet</A> <BR>&nbsp;&nbsp;&nbsp;&nbsp;2.4 <A 
href="http://www.w3.org/TR/xslt#qname">Qualified Names</A> 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;2.5 <A 
href="http://www.w3.org/TR/xslt#forwards">Forwards-Compatible Processing</A> 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;2.6 <A 
href="http://www.w3.org/TR/xslt#section-Combining-Stylesheets">Combining 
Stylesheets</A> <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.6.1 <A 
href="http://www.w3.org/TR/xslt#include">Stylesheet Inclusion</A> 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.6.2 <A 
href="http://www.w3.org/TR/xslt#import">Stylesheet Import</A> 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;2.7 <A 
href="http://www.w3.org/TR/xslt#section-Embedding-Stylesheets">Embedding 
Stylesheets</A> <BR>3 <A href="http://www.w3.org/TR/xslt#data-model">Data 
Model</A> <BR>&nbsp;&nbsp;&nbsp;&nbsp;3.1 <A 
href="http://www.w3.org/TR/xslt#root-node-children">Root Node Children</A> 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;3.2 <A 
href="http://www.w3.org/TR/xslt#base-uri">Base URI</A> 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;3.3 <A 
href="http://www.w3.org/TR/xslt#unparsed-entities">Unparsed Entities</A> 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;3.4 <A 
href="http://www.w3.org/TR/xslt#strip">Whitespace Stripping</A> <BR>4 <A 
href="http://www.w3.org/TR/xslt#section-Expressions">Expressions</A> <BR>5 <A 
href="http://www.w3.org/TR/xslt#rules">Template Rules</A> 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;5.1 <A 
href="http://www.w3.org/TR/xslt#section-Processing-Model">Processing Model</A> 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;5.2 <A 
href="http://www.w3.org/TR/xslt#patterns">Patterns</A> 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;5.3 <A 
href="http://www.w3.org/TR/xslt#section-Defining-Template-Rules">Defining 
Template Rules</A> <BR>&nbsp;&nbsp;&nbsp;&nbsp;5.4 <A 
href="http://www.w3.org/TR/xslt#section-Applying-Template-Rules">Applying 
Template Rules</A> <BR>&nbsp;&nbsp;&nbsp;&nbsp;5.5 <A 
href="http://www.w3.org/TR/xslt#conflict">Conflict Resolution for Template 
Rules</A> <BR>&nbsp;&nbsp;&nbsp;&nbsp;5.6 <A 
href="http://www.w3.org/TR/xslt#apply-imports">Overriding Template Rules</A> 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;5.7 <A 
href="http://www.w3.org/TR/xslt#modes">Modes</A> <BR>&nbsp;&nbsp;&nbsp;&nbsp;5.8 
<A href="http://www.w3.org/TR/xslt#built-in-rule">Built-in Template Rules</A> 
<BR>6 <A href="http://www.w3.org/TR/xslt#named-templates">Named Templates</A> 
<BR>7 <A 
href="http://www.w3.org/TR/xslt#section-Creating-the-Result-Tree">Creating the 
Result Tree</A> <BR>&nbsp;&nbsp;&nbsp;&nbsp;7.1 <A 
href="http://www.w3.org/TR/xslt#section-Creating-Elements-and-Attributes">Creating 
Elements and Attributes</A> 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7.1.1 <A 
href="http://www.w3.org/TR/xslt#literal-result-element">Literal Result 
Elements</A> <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7.1.2 <A 
href="http://www.w3.org/TR/xslt#section-Creating-Elements-with-xsl:element">Creating 
Elements with xsl:element</A> 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7.1.3 <A 
href="http://www.w3.org/TR/xslt#creating-attributes">Creating Attributes with 
xsl:attribute</A> <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7.1.4 <A 
href="http://www.w3.org/TR/xslt#attribute-sets">Named Attribute Sets</A> 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;7.2 <A 
href="http://www.w3.org/TR/xslt#section-Creating-Text">Creating Text</A> 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;7.3 <A 
href="http://www.w3.org/TR/xslt#section-Creating-Processing-Instructions">Creating 
Processing Instructions</A> <BR>&nbsp;&nbsp;&nbsp;&nbsp;7.4 <A 
href="http://www.w3.org/TR/xslt#section-Creating-Comments">Creating Comments</A> 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;7.5 <A 
href="http://www.w3.org/TR/xslt#copying">Copying</A> 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;7.6 <A 
href="http://www.w3.org/TR/xslt#section-Computing-Generated-Text">Computing 
Generated Text</A> <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7.6.1 <A 
href="http://www.w3.org/TR/xslt#value-of">Generating Text with xsl:value-of</A> 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7.6.2 <A 
href="http://www.w3.org/TR/xslt#attribute-value-templates">Attribute Value 
Templates</A> <BR>&nbsp;&nbsp;&nbsp;&nbsp;7.7 <A 
href="http://www.w3.org/TR/xslt#number">Numbering</A> 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7.7.1 <A 
href="http://www.w3.org/TR/xslt#convert">Number to String Conversion 
Attributes</A> <BR>8 <A href="http://www.w3.org/TR/xslt#for-each">Repetition</A> 
<BR>9 <A 
href="http://www.w3.org/TR/xslt#section-Conditional-Processing">Conditional 
Processing</A> <BR>&nbsp;&nbsp;&nbsp;&nbsp;9.1 <A 
href="http://www.w3.org/TR/xslt#section-Conditional-Processing-with-xsl:if">Conditional 
Processing with xsl:if</A> <BR>&nbsp;&nbsp;&nbsp;&nbsp;9.2 <A 
href="http://www.w3.org/TR/xslt#section-Conditional-Processing-with-xsl:choose">Conditional 
Processing with xsl:choose</A> <BR>10 <A 
href="http://www.w3.org/TR/xslt#sorting">Sorting</A> <BR>11 <A 
href="http://www.w3.org/TR/xslt#variables">Variables and Parameters</A> 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;11.1 <A 
href="http://www.w3.org/TR/xslt#section-Result-Tree-Fragments">Result Tree 
Fragments</A> <BR>&nbsp;&nbsp;&nbsp;&nbsp;11.2 <A 
href="http://www.w3.org/TR/xslt#variable-values">Values of Variables and 
Parameters</A> <BR>&nbsp;&nbsp;&nbsp;&nbsp;11.3 <A 
href="http://www.w3.org/TR/xslt#copy-of">Using Values of Variables and 
Parameters with xsl:copy-of</A> <BR>&nbsp;&nbsp;&nbsp;&nbsp;11.4 <A 
href="http://www.w3.org/TR/xslt#top-level-variables">Top-level Variables and 
Parameters</A> <BR>&nbsp;&nbsp;&nbsp;&nbsp;11.5 <A 
href="http://www.w3.org/TR/xslt#local-variables">Variables and Parameters within 
Templates</A> <BR>&nbsp;&nbsp;&nbsp;&nbsp;11.6 <A 
href="http://www.w3.org/TR/xslt#section-Passing-Parameters-to-Templates">Passing 
Parameters to Templates</A> <BR>12 <A 
href="http://www.w3.org/TR/xslt#add-func">Additional Functions</A> 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;12.1 <A 
href="http://www.w3.org/TR/xslt#document">Multiple Source Documents</A> 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;12.2 <A 
href="http://www.w3.org/TR/xslt#key">Keys</A> <BR>&nbsp;&nbsp;&nbsp;&nbsp;12.3 
<A href="http://www.w3.org/TR/xslt#format-number">Number Formatting</A> 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;12.4 <A 
href="http://www.w3.org/TR/xslt#misc-func">Miscellaneous Additional 
Functions</A> <BR>13 <A href="http://www.w3.org/TR/xslt#message">Messages</A> 
<BR>14 <A href="http://www.w3.org/TR/xslt#extension">Extensions</A> 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;14.1 <A 
href="http://www.w3.org/TR/xslt#extension-element">Extension Elements</A> 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;14.2 <A 
href="http://www.w3.org/TR/xslt#section-Extension-Functions">Extension 
Functions</A> <BR>15 <A href="http://www.w3.org/TR/xslt#fallback">Fallback</A> 
<BR>16 <A href="http://www.w3.org/TR/xslt#output">Output</A> 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;16.1 <A 
href="http://www.w3.org/TR/xslt#section-XML-Output-Method">XML Output Method</A> 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;16.2 <A 
href="http://www.w3.org/TR/xslt#section-HTML-Output-Method">HTML Output 
Method</A> <BR>&nbsp;&nbsp;&nbsp;&nbsp;16.3 <A 
href="http://www.w3.org/TR/xslt#section-Text-Output-Method">Text Output 
Method</A> <BR>&nbsp;&nbsp;&nbsp;&nbsp;16.4 <A 
href="http://www.w3.org/TR/xslt#disable-output-escaping">Disabling Output 
Escaping</A> <BR>17 <A 
href="http://www.w3.org/TR/xslt#conformance">Conformance</A> <BR>18 <A 
href="http://www.w3.org/TR/xslt#notation">Notation</A> <BR>
<H3>Appendices</H3>A <A 
href="http://www.w3.org/TR/xslt#section-References">References</A> 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;A.1 <A 
href="http://www.w3.org/TR/xslt#section-Normative-References">Normative 
References</A> <BR>&nbsp;&nbsp;&nbsp;&nbsp;A.2 <A 
href="http://www.w3.org/TR/xslt#section-Other-References">Other References</A> 
<BR>B <A href="http://www.w3.org/TR/xslt#element-syntax-summary">Element Syntax 
Summary</A> <BR>C <A href="http://www.w3.org/TR/xslt#dtd">DTD Fragment for XSLT 
Stylesheets</A> (Non-Normative)<BR>D <A 
href="http://www.w3.org/TR/xslt#section-Examples">Examples</A> 
(Non-Normative)<BR>&nbsp;&nbsp;&nbsp;&nbsp;D.1 <A 
href="http://www.w3.org/TR/xslt#section-Document-Example">Document Example</A> 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;D.2 <A 
href="http://www.w3.org/TR/xslt#data-example">Data Example</A> <BR>E <A 
href="http://www.w3.org/TR/xslt#section-Acknowledgements">Acknowledgements</A> 
(Non-Normative)<BR>F <A 
href="http://www.w3.org/TR/xslt#section-Changes-from-Proposed-Recommendation">Changes 
from Proposed Recommendation</A> (Non-Normative)<BR>G <A 
href="http://www.w3.org/TR/xslt#section-Features-under-Consideration-for-Future-Versions-of-XSLT">Features 
under Consideration for Future Versions of XSLT</A> (Non-Normative)<BR>
<HR>

<H2><A name=section-Introduction></A>1 Introduction</H2>
<P>This specification defines the syntax and semantics of the XSLT language. A 
transformation in the XSLT language is expressed as a well-formed XML document 
<A href="http://www.w3.org/TR/xslt#XML">[XML]</A> conforming to the Namespaces 
in XML Recommendation <A href="http://www.w3.org/TR/xslt#XMLNAMES">[XML 
Names]</A>, which may include both elements that are defined by XSLT and 
elements that are not defined by XSLT. <A 
name=dt-xslt-namespace></A>XSLT-defined elements are distinguished by belonging 
to a specific XML namespace (see <A 
href="http://www.w3.org/TR/xslt#xslt-namespace">[<B>2.1 XSLT 
Namespace</B>]</A>), which is referred to in this specification as the <B>XSLT 
namespace</B>. Thus this specification is a definition of the syntax and 
semantics of the XSLT namespace.</P>
<P>A transformation expressed in XSLT describes rules for transforming a source 
tree into a result tree. The transformation is achieved by associating patterns 
with templates. A pattern is matched against elements in the source tree. A 
template is instantiated to create part of the result tree. The result tree is 
separate from the source tree. The structure of the result tree can be 
completely different from the structure of the source tree. In constructing the 
result tree, elements from the source tree can be filtered and reordered, and 
arbitrary structure can be added.</P>
<P>A transformation expressed in XSLT is called a stylesheet. This is because, 
in the case when XSLT is transforming into the XSL formatting vocabulary, the 
transformation functions as a stylesheet.</P>
<P>This document does not specify how an XSLT stylesheet is associated with an 
XML document. It is recommended that XSL processors support the mechanism 
described in <A href="http://www.w3.org/TR/xslt#XMLSTYLE">[XML Stylesheet]</A>. 
When this or any other mechanism yields a sequence of more than one XSLT 
stylesheet to be applied simultaneously to a XML document, then the effect 
should be the same as applying a single stylesheet that imports each member of 
the sequence in order (see <A href="http://www.w3.org/TR/xslt#import">[<B>2.6.2 
Stylesheet Import</B>]</A>).</P>
<P>A stylesheet contains a set of template rules. A template rule has two parts: 
a pattern which is matched against nodes in the source tree and a template which 
can be instantiated to form part of the result tree. This allows a stylesheet to 
be applicable to a wide class of documents that have similar source tree 
structures.</P>
<P>A template is instantiated for a particular source element to create part of 
the result tree. A template can contain elements that specify literal result 
element structure. A template can also contain elements from the XSLT namespace 
that are instructions for creating result tree fragments. When a template is 
instantiated, each instruction is executed and replaced by the result tree 
fragment that it creates. Instructions can select and process descendant source 
elements. Processing a descendant element creates a result tree fragment by 
finding the applicable template rule and instantiating its template. Note that 
elements are only processed when they have been selected by the execution of an 
instruction. The result tree is constructed by finding the template rule for the 
root node and instantiating its template.</P>
<P>In the process of finding the applicable template rule, more than one 
template rule may have a pattern that matches a given element. However, only one 
template rule will be applied. The method for deciding which template rule to 
apply is described in <A href="http://www.w3.org/TR/xslt#conflict">[<B>5.5 
Conflict Resolution for Template Rules</B>]</A>.</P>
<P>A single template by itself has considerable power: it can create structures 
of arbitrary complexity; it can pull string values out of arbitrary locations in 
the source tree; it can generate structures that are repeated according to the 
occurrence of elements in the source tree. For simple transformations where the 
structure of the result tree is independent of the structure of the source tree, 
a stylesheet can often consist of only a single template, which functions as a 
template for the complete result tree. Transformations on XML documents that 
represent data are often of this kind (see <A 
href="http://www.w3.org/TR/xslt#data-example">[<B>D.2 Data Example</B>]</A>). 
XSLT allows a simplified syntax for such stylesheets (see <A 
href="http://www.w3.org/TR/xslt#result-element-stylesheet">[<B>2.3 Literal 
Result Element as Stylesheet</B>]</A>).</P>
<P>When a template is instantiated, it is always instantiated with respect to a 
<A name=dt-current-node></A><B>current node</B> and a <A 
name=dt-current-node-list></A><B>current node list</B>. The current node is 
always a member of the current node list. Many operations in XSLT are relative 
to the current node. Only a few instructions change the current node list or the 
current node (see <A href="http://www.w3.org/TR/xslt#rules">[<B>5 Template 
Rules</B>]</A> and <A href="http://www.w3.org/TR/xslt#for-each">[<B>8 
Repetition</B>]</A>); during the instantiation of one of these instructions, the 
current node list changes to a new list of nodes and each member of this new 
list becomes the current node in turn; after the instantiation of the 
instruction is complete, the current node and current node list revert to what 
they were before the instruction was instantiated.</P>
<P>XSLT makes use of the expression language defined by <A 
href="http://www.w3.org/TR/xslt#XPATH">[XPath]</A> for selecting elements for 
processing, for conditional processing and for generating text.</P>
<P>XSLT provides two "hooks" for extending the language, one hook for extending 
the set of instruction elements used in templates and one hook for extending the 
set of functions used in XPath expressions. These hooks are both based on XML 
namespaces. This version of XSLT does not define a mechanism for implementing 
the hooks. See <A href="http://www.w3.org/TR/xslt#extension">[<B>14 
Extensions</B>]</A>.</P>
<BLOCKQUOTE><B>NOTE:</B>The XSL WG intends to define such a mechanism in a 
  future version of this specification or in a separate 
specification.</BLOCKQUOTE>
<P>The element syntax summary notation used to describe the syntax of 
XSLT-defined elements is described in <A 
href="http://www.w3.org/TR/xslt#notation">[<B>18 Notation</B>]</A>.</P>
<P>The MIME media types <CODE>text/xml</CODE> and <CODE>application/xml</CODE> 
<A href="http://www.w3.org/TR/xslt#RFC2376">[RFC2376]</A> should be used for 
XSLT stylesheets. It is possible that a media type will be registered 
specifically for XSLT stylesheets; if and when it is, that media type may also 
be used.</P>
<H2><A name=section-Stylesheet-Structure></A>2 Stylesheet Structure</H2>
<H3><A name=xslt-namespace></A>2.1 XSLT Namespace</H3>
<P>The XSLT namespace has the URI 
<CODE>http://www.w3.org/1999/XSL/Transform</CODE>.</P>
<BLOCKQUOTE><B>NOTE:</B>The <CODE>1999</CODE> in the URI indicates the year in 
  which the URI was allocated by the W3C. It does not indicate the version of 
  XSLT being used, which is specified by attributes (see <A 
  href="http://www.w3.org/TR/xslt#stylesheet-element">[<B>2.2 Stylesheet 
  Element</B>]</A> and <A 
  href="http://www.w3.org/TR/xslt#result-element-stylesheet">[<B>2.3 Literal 
  Result Element as Stylesheet</B>]</A>).</BLOCKQUOTE>
<P>XSLT processors must use the XML namespaces mechanism <A 
href="http://www.w3.org/TR/xslt#XMLNAMES">[XML Names]</A> to recognize elements 
and attributes from this namespace. Elements from the XSLT namespace are 
recognized only in the stylesheet not in the source document. The complete list 
of XSLT-defined elements is specified in <A 
href="http://www.w3.org/TR/xslt#element-syntax-summary">[<B>B Element Syntax 
Summary</B>]</A>. Vendors must not extend the XSLT namespace with additional 
elements or attributes. Instead, any extension must be in a separate namespace. 
Any namespace that is used for additional instruction elements must be 
identified by means of the extension element mechanism specified in <A 
href="http://www.w3.org/TR/xslt#extension-element">[<B>14.1 Extension 
Elements</B>]</A>.</P>
<P>This specification uses a prefix of <CODE>xsl:</CODE> for referring to 
elements in the XSLT namespace. However, XSLT stylesheets are free to use any 
prefix, provided that there is a namespace declaration that binds the prefix to 
the URI of the XSLT namespace.</P>
<P>An element from the XSLT namespace may have any attribute not from the XSLT 
namespace, provided that the <A 
href="http://www.w3.org/TR/xpath#dt-expanded-name">expanded-name</A> of the 
attribute has a non-null namespace URI. The presence of such attributes must not 
change the behavior of XSLT elements and functions defined in this document. 
Thus, an XSLT processor is always free to ignore such attributes, and must 
ignore such attributes without giving an error if it does not recognize the 
namespace URI. Such attributes can provide, for example, unique identifiers, 
optimization hints, or documentation.</P>
<P>It is an error for an element from the XSLT namespace to have attributes with 
expanded-names that have null namespace URIs (i.e. attributes with unprefixed 
names) other than attributes defined for the element in this document.</P>
<BLOCKQUOTE><B>NOTE:</B>The conventions used for the names of XSLT elements, 
  attributes and functions are that names are all lower-case, use hyphens to 
  separate words, and use abbreviations only if they already appear in the 
  syntax of a related language such as XML or HTML.</BLOCKQUOTE>
<H3><A name=stylesheet-element></A>2.2 Stylesheet Element</H3>
<P class=element-syntax><A 
name=element-stylesheet></A><CODE>&lt;xsl:stylesheet<BR>&nbsp;&nbsp;id = 
<VAR>id</VAR> <BR>&nbsp;&nbsp;extension-element-prefixes = <VAR>tokens</VAR> 
<BR>&nbsp;&nbsp;exclude-result-prefixes = <VAR>tokens</VAR> 
<BR>&nbsp;&nbsp;<B>version</B> = <VAR>number</VAR>&gt;<BR>&nbsp;&nbsp;&lt;!-- 
Content: (<A href="http://www.w3.org/TR/xslt#element-import">xsl:import</A>*, 
<VAR>top-level-elements</VAR>) --&gt;<BR>&lt;/xsl:stylesheet&gt;</CODE></P>
<P class=element-syntax><A 
name=element-transform></A><CODE>&lt;xsl:transform<BR>&nbsp;&nbsp;id = 
<VAR>id</VAR> <BR>&nbsp;&nbsp;extension-element-prefixes = <VAR>tokens</VAR> 
<BR>&nbsp;&nbsp;exclude-result-prefixes = <VAR>tokens</VAR> 
<BR>&nbsp;&nbsp;<B>version</B> = <VAR>number</VAR>&gt;<BR>&nbsp;&nbsp;&lt;!-- 
Content: (<A href="http://www.w3.org/TR/xslt#element-import">xsl:import</A>*, 
<VAR>top-level-elements</VAR>) --&gt;<BR>&lt;/xsl:transform&gt;</CODE></P>
<P>A stylesheet is represented by an <CODE>xsl:stylesheet</CODE> element in an 
XML document. <CODE>xsl:transform</CODE> is allowed as a synonym for 
<CODE>xsl:stylesheet</CODE>.</P>
<P>An <CODE>xsl:stylesheet</CODE> element must have a <CODE>version</CODE> 
attribute, indicating the version of XSLT that the stylesheet requires. For this 
version of XSLT, the value should be <CODE>1.0</CODE>. When the value is not 
equal to <CODE>1.0</CODE>, forwards-compatible processing mode is enabled (see 
<A href="http://www.w3.org/TR/xslt#forwards">[<B>2.5 Forwards-Compatible 
Processing</B>]</A>).</P>
<P>The <CODE>xsl:stylesheet</CODE> element may contain the following types of 
elements:</P>
<UL>
  <LI>
  <P><CODE>xsl:import</CODE></P>
  <LI>
  <P><CODE>xsl:include</CODE></P>
  <LI>
  <P><CODE>xsl:strip-space</CODE></P>
  <LI>
  <P><CODE>xsl:preserve-space</CODE></P>
  <LI>
  <P><CODE>xsl:output</CODE></P>
  <LI>
  <P><CODE>xsl:key</CODE></P>
  <LI>
  <P><CODE>xsl:decimal-format</CODE></P>
  <LI>
  <P><CODE>xsl:namespace-alias</CODE></P>
  <LI>
  <P><CODE>xsl:attribute-set</CODE></P>
  <LI>
  <P><CODE>xsl:variable</CODE></P>
  <LI>
  <P><CODE>xsl:param</CODE></P>
  <LI>
  <P><CODE>xsl:template</CODE></P></LI></UL>
<P><A name=dt-top-level></A>An element occurring as a child of an 
<CODE>xsl:stylesheet</CODE> element is called a <B>top-level</B> element.</P>
<P>This example shows the structure of a stylesheet. Ellipses (<CODE>...</CODE>) 
indicate where attribute values or content have been omitted. Although this 
example shows one of each type of allowed element, stylesheets may contain zero 
or more of each of these elements.</P><PRE>&lt;xsl:stylesheet version="1.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;xsl:import href="..."/&gt;

  &lt;xsl:include href="..."/&gt;

  &lt;xsl:strip-space elements="..."/&gt;
  
  &lt;xsl:preserve-space elements="..."/&gt;

  &lt;xsl:output method="..."/&gt;

  &lt;xsl:key name="..." match="..." use="..."/&gt;

  &lt;xsl:decimal-format name="..."/&gt;

  &lt;xsl:namespace-alias stylesheet-prefix="..." result-prefix="..."/&gt;

  &lt;xsl:attribute-set name="..."&gt;
    ...
  &lt;/xsl:attribute-set&gt;

  &lt;xsl:variable name="..."&gt;...&lt;/xsl:variable&gt;

  &lt;xsl:param name="..."&gt;...&lt;/xsl:param&gt;

  &lt;xsl:template match="..."&gt;
    ...
  &lt;/xsl:template&gt;

  &lt;xsl:template name="..."&gt;
    ...
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</PRE>
<P>The order in which the children of the <CODE>xsl:stylesheet</CODE> element 
occur is not significant except for <CODE>xsl:import</CODE> elements and for 
error recovery. Users are free to order the elements as they prefer, and 
stylesheet creation tools need not provide control over the order in which the 
elements occur.</P>
<P>In addition, the <CODE>xsl:stylesheet</CODE> element may contain any element 
not from the XSLT namespace, provided that the expanded-name of the element has 
a non-null namespace URI. The presence of such top-level elements must not 
change the behavior of XSLT elements and functions defined in this document; for 
example, it would not be permitted for such a top-level element to specify that 
<CODE>xsl:apply-templates</CODE> was to use different rules to resolve 
conflicts. Thus, an XSLT processor is always free to ignore such top-level 
elements, and must ignore a top-level element without giving an error if it does 
not recognize the namespace URI. Such elements can provide, for example,</P>
<UL>
  <LI>
  <P>information used by extension elements or extension functions (see <A 
  href="http://www.w3.org/TR/xslt#extension">[<B>14 Extensions</B>]</A>),</P>
  <LI>
  <P>information about what to do with the result tree,</P>
  <LI>
  <P>information about how to obtain the source tree,</P>
  <LI>
  <P>metadata about the stylesheet,</P>
  <LI>
  <P>structured documentation for the stylesheet.</P></LI></UL>
<H3><A name=result-element-stylesheet></A>2.3 Literal Result Element as 
Stylesheet</H3>
<P>A simplified syntax is allowed for stylesheets that consist of only a single 
template for the root node. The stylesheet may consist of just a literal result 
element (see <A 
href="http://www.w3.org/TR/xslt#literal-result-element">[<B>7.1.1 Literal Result 
Elements</B>]</A>). Such a stylesheet is equivalent to a stylesheet with an 
<CODE>xsl:stylesheet</CODE> element containing a template rule containing the 
literal result element; the template rule has a match pattern of <CODE>/</CODE>. 
For example</P><PRE>&lt;html xsl:version="1.0"
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
      xmlns="http://www.w3.org/TR/xhtml1/strict"&gt;
  &lt;head&gt;
    &lt;title&gt;Expense Report Summary&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;Total Amount: &lt;xsl:value-of select="expense-report/total"/&gt;&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;</PRE>
<P>has the same meaning as</P><PRE>&lt;xsl:stylesheet version="1.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns="http://www.w3.org/TR/xhtml1/strict"&gt;
&lt;xsl:template match="/"&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Expense Report Summary&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;Total Amount: &lt;xsl:value-of select="expense-report/total"/&gt;&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
&lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</PRE>
<P>A literal result element that is the document element of a stylesheet must 
have an <CODE>xsl:version</CODE> attribute, which indicates the version of XSLT 
that the stylesheet requires. For this version of XSLT, the value should be 
<CODE>1.0</CODE>; the value must be a <A 
href="http://www.w3.org/TR/xpath#NT-Number">Number</A>. Other literal result 
elements may also have an <CODE>xsl:version</CODE> attribute. When the 
<CODE>xsl:version</CODE> attribute is not equal to <CODE>1.0</CODE>, 
forwards-compatible processing mode is enabled (see <A 
href="http://www.w3.org/TR/xslt#forwards">[<B>2.5 Forwards-Compatible 
Processing</B>]</A>).</P>
<P>The allowed content of a literal result element when used as a stylesheet is 
no different from when it occurs within a stylesheet. Thus, a literal result 
element used as a stylesheet cannot contain <A 
href="http://www.w3.org/TR/xslt#dt-top-level">top-level</A> elements.</P>
<P>In some situations, the only way that a system can recognize that an XML 
document needs to be processed by an XSLT processor as an XSLT stylesheet is by 
examining the XML document itself. Using the simplified syntax makes this 
harder.</P>
<BLOCKQUOTE><B>NOTE:</B>For example, another XML language (AXL) might also use 
  an <CODE>axl:version</CODE> on the document element to indicate that an XML 
  document was an AXL document that required processing by an AXL processor; if 
  a document had both an <CODE>axl:version</CODE> attribute and an 
  <CODE>xsl:version</CODE> attribute, it would be unclear whether the document 
  should be processed by an XSLT processor or an AXL processor.</BLOCKQUOTE>
<P>Therefore, the simplified syntax should not be used for XSLT stylesheets that 
may be used in such a situation. This situation can, for example, arise when an 
XSLT stylesheet is transmitted as a message with a MIME media type of 
<CODE>text/xml</CODE> or <CODE>application/xml</CODE> to a recipient that will 
use the MIME media type to determine how the message is processed.</P>
<H3><A name=qname></A>2.4 Qualified Names</H3>
<P>The name of an internal XSLT object, specifically a named template (see <A 
href="http://www.w3.org/TR/xslt#named-templates">[<B>6 Named 
Templates</B>]</A>), a mode (see <A 
href="http://www.w3.org/TR/xslt#modes">[<B>5.7 Modes</B>]</A>), an attribute set 
(see <A href="http://www.w3.org/TR/xslt#attribute-sets">[<B>7.1.4 Named 
Attribute Sets</B>]</A>), a key (see <A 
href="http://www.w3.org/TR/xslt#key">[<B>12.2 Keys</B>]</A>), a decimal-format 
(see <A href="http://www.w3.org/TR/xslt#format-number">[<B>12.3 Number 
Formatting</B>]</A>), a variable or a parameter (see <A 
href="http://www.w3.org/TR/xslt#variables">[<B>11 Variables and 
Parameters</B>]</A>) is specified as a <A 
href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</A>. If it has a 
prefix, then the prefix is expanded into a URI reference using the namespace 
declarations in effect on the attribute in which the name occurs. The <A 
href="http://www.w3.org/TR/xpath#dt-expanded-name">expanded-name</A> consisting 
of the local part of the name and the possibly null URI reference is used as the 
name of the object. The default namespace is <I>not</I> used for unprefixed 
names.</P>
<H3><A name=forwards></A>2.5 Forwards-Compatible Processing</H3>
<P>An element enables forwards-compatible mode for itself, its attributes, its 
descendants and their attributes if either it is an <CODE>xsl:stylesheet</CODE> 
element whose <CODE>version</CODE> attribute is not equal to <CODE>1.0</CODE>, 
or it is a literal result element that has an <CODE>xsl:version</CODE> attribute 
whose value is not equal to <CODE>1.0</CODE>, or it is a literal result element 
that does not have an <CODE>xsl:version</CODE> attribute and that is the 
document element of a stylesheet using the simplified syntax (see <A 
href="http://www.w3.org/TR/xslt#result-element-stylesheet">[<B>2.3 Literal 
Result Element as Stylesheet</B>]</A>). A literal result element that has an 
<CODE>xsl:version</CODE> attribute whose value is equal to <CODE>1.0</CODE> 
disables forwards-compatible mode for itself, its attributes, its descendants 
and their attributes.</P>
<P>If an element is processed in forwards-compatible mode, then:</P>
<UL>
  <LI>
  <P>if it is a <A href="http://www.w3.org/TR/xslt#dt-top-level">top-level</A> 
  element and XSLT 1.0 does not allow such elements as top-level elements, then 
  the element must be ignored along with its content;</P>
  <LI>
  <P>if it is an element in a template and XSLT 1.0 does not allow such elements 
  to occur in templates, then if the element is not instantiated, an error must 
  not be signaled, and if the element is instantiated, the XSLT must perform 
  fallback for the element as specified in <A 
  href="http://www.w3.org/TR/xslt#fallback">[<B>15 Fallback</B>]</A>;</P>
  <LI>
  <P>if the element has an attribute that XSLT 1.0 does not allow the element to 
  have or if the element has an optional attribute with a value that the XSLT 
  1.0 does not allow the attribute to have, then the attribute must be 
  ignored.</P></LI></UL>
<P>Thus, any XSLT 1.0 processor must be able to process the following stylesheet 
without error, although the stylesheet includes elements from the XSLT namespace 
that are not defined in this specification:</P><PRE>&lt;xsl:stylesheet version="1.1"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;xsl:template match="/"&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="system-property('xsl:version') &gt;= 1.1"&gt;
        &lt;xsl:exciting-new-1.1-feature/&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;html&gt;
        &lt;head&gt;
          &lt;title&gt;XSLT 1.1 required&lt;/title&gt;
        &lt;/head&gt;
        &lt;body&gt;
          &lt;p&gt;Sorry, this stylesheet requires XSLT 1.1.&lt;/p&gt;
        &lt;/body&gt;
        &lt;/html&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</PRE>
<BLOCKQUOTE><B>NOTE:</B>If a stylesheet depends crucially on a top-level 
  element introduced by a version of XSL after 1.0, then the stylesheet can use 
  an <CODE>xsl:message</CODE> element with <CODE>terminate="yes"</CODE> (see <A 
  href="http://www.w3.org/TR/xslt#message">[<B>13 Messages</B>]</A>) to ensure 
  that XSLT processors implementing earlier versions of XSL will not silently 
  ignore the top-level element. For example, <PRE>&lt;xsl:stylesheet version="1.5"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

  &lt;xsl:important-new-1.1-declaration/&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="system-property('xsl:version') &amp;lt; 1.1"&gt;
        &lt;xsl:message terminate="yes"&gt;
          &lt;xsl:text&gt;Sorry, this stylesheet requires XSLT 1.1.&lt;/xsl:text&gt;
        &lt;/xsl:message&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        ...
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;
  ...
&lt;/xsl:stylesheet&gt;</PRE></BLOCKQUOTE>
<P>If an <A href="http://www.w3.org/TR/xslt#dt-expression">expression</A> occurs 
in an attribute that is processed in forwards-compatible mode, then an XSLT 
processor must recover from errors in the expression as follows:</P>
<UL>
  <LI>
  <P>if the expression does not match the syntax allowed by the XPath grammar, 
  then an error must not be signaled unless the expression is actually 
  evaluated;</P>
  <LI>
  <P>if the expression calls a function with an unprefixed name that is not part 
  of the XSLT library, then an error must not be signaled unless the function is 
  actually called;</P>
  <LI>
  <P>if the expression calls a function with a number of arguments that XSLT 
  does not allow or with arguments of types that XSLT does not allow, then an 
  error must not be signaled unless the function is actually called.</P></LI></UL>
<H3><A name=section-Combining-Stylesheets></A>2.6 Combining Stylesheets</H3>
<P>XSLT provides two mechanisms to combine stylesheets:</P>
<UL>
  <LI>an inclusion mechanism that allows stylesheets to be combined without 
  changing the semantics of the stylesheets being combined, and 
  <LI>an import mechanism that allows stylesheets to override each other. 
</LI></UL>
<H4><A name=include></A>2.6.1 Stylesheet Inclusion</H4>
<P class=element-syntax><A name=element-include></A><CODE>&lt;!-- Category: 
top-level-element --&gt;<BR>&lt;xsl:include<BR>&nbsp;&nbsp;<B>href</B> = 
<VAR>uri-reference</VAR>&nbsp;/&gt;</CODE></P>
<P>An XSLT stylesheet may include another XSLT stylesheet using an 
<CODE>xsl:include</CODE> element. The <CODE>xsl:include</CODE> element has an 
<CODE>href</CODE> attribute whose value is a URI reference identifying the 
stylesheet to be included. A relative URI is resolved relative to the base URI 
of the <CODE>xsl:include</CODE> element (see <A 
href="http://www.w3.org/TR/xslt#base-uri">[<B>3.2 Base URI</B>]</A>).</P>
<P>The <CODE>xsl:include</CODE> element is only allowed as a <A 
href="http://www.w3.org/TR/xslt#dt-top-level">top-level</A> element.</P>
<P>The inclusion works at the XML tree level. The resource located by the 
<CODE>href</CODE> attribute value is parsed as an XML document, and the children 
of the <CODE>xsl:stylesheet</CODE> element in this document replace the 
<CODE>xsl:include</CODE> element in the including document. The fact that 
template rules or definitions are included does not affect the way they are 
processed.</P>
<P>The included stylesheet may use the simplified syntax described in <A 
href="http://www.w3.org/TR/xslt#result-element-stylesheet">[<B>2.3 Literal 
Result Element as Stylesheet</B>]</A>. The included stylesheet is treated the 
same as the equivalent <CODE>xsl:stylesheet</CODE> element.</P>
<P>It is an error if a stylesheet directly or indirectly includes itself.</P>
<BLOCKQUOTE><B>NOTE:</B>Including a stylesheet multiple times can cause errors 
  because of duplicate definitions. Such multiple inclusions are less obvious 
  when they are indirect. For example, if stylesheet <VAR>B</VAR> includes 
  stylesheet <VAR>A</VAR>, stylesheet <VAR>C</VAR> includes stylesheet 
  <VAR>A</VAR>, and stylesheet <VAR>D</VAR> includes both stylesheet 
  <VAR>B</VAR> and stylesheet <VAR>C</VAR>, then <VAR>A</VAR> will be included 
  indirectly by <VAR>D</VAR> twice. If all of <VAR>B</VAR>, <VAR>C</VAR> and 
  <VAR>D</VAR> are used as independent stylesheets, then the error can be 
  avoided by separating everything in <VAR>B</VAR> other than the inclusion of 
  <VAR>A</VAR> into a separate stylesheet <VAR>B'</VAR> and changing 
  <VAR>B</VAR> to contain just inclusions of <VAR>B'</VAR> and <VAR>A</VAR>, 
  similarly for <VAR>C</VAR>, and then changing <VAR>D</VAR> to include 
  <VAR>A</VAR>, <VAR>B'</VAR>, <VAR>C'</VAR>.</BLOCKQUOTE>
<H4><A name=import></A>2.6.2 Stylesheet Import</H4>
<P class=element-syntax><A 
name=element-import></A><CODE>&lt;xsl:import<BR>&nbsp;&nbsp;<B>href</B> = 
<VAR>uri-reference</VAR>&nbsp;/&gt;</CODE></P>
<P>An XSLT stylesheet may import another XSLT stylesheet using an 
<CODE>xsl:import</CODE> element. Importing a stylesheet is the same as including 
it (see <A href="http://www.w3.org/TR/xslt#include">[<B>2.6.1 Stylesheet 
Inclusion</B>]</A>) except that definitions and template rules in the importing 
stylesheet take precedence over template rules and definitions in the imported 
stylesheet; this is described in more detail below. The <CODE>xsl:import</CODE> 
element has an <CODE>href</CODE> attribute whose value is a URI reference 
identifying the stylesheet to be imported. A relative URI is resolved relative 
to the base URI of the <CODE>xsl:import</CODE> element (see <A 
href="http://www.w3.org/TR/xslt#base-uri">[<B>3.2 Base URI</B>]</A>).</P>
<P>The <CODE>xsl:import</CODE> element is only allowed as a <A 
href="http://www.w3.org/TR/xslt#dt-top-level">top-level</A> element. The 
<CODE>xsl:import</CODE> element children must precede all other element children 
of an <CODE>xsl:stylesheet</CODE> element, including any 
<CODE>xsl:include</CODE> element children. When <CODE>xsl:include</CODE> is used 
to include a stylesheet, any <CODE>xsl:import</CODE> elements in the included 
document are moved up in the including document to after any existing 
<CODE>xsl:import</CODE> elements in the including document.</P>
<P>For example,</P><PRE>&lt;xsl:stylesheet version="1.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;xsl:import href="article.xsl"/&gt;
  &lt;xsl:import href="bigfont.xsl"/&gt;
  &lt;xsl:attribute-set name="note-style"&gt;
    &lt;xsl:attribute name="font-style"&gt;italic&lt;/xsl:attribute&gt;
  &lt;/xsl:attribute-set&gt;
&lt;/xsl:stylesheet&gt;</PRE>
<P><A name=dt-import-tree></A>The <CODE>xsl:stylesheet</CODE> elements 
encountered during processing of a stylesheet that contains 
<CODE>xsl:import</CODE> elements are treated as forming an <B>import tree</B>. 
In the import tree, each <CODE>xsl:stylesheet</CODE> element has one import 
child for each <CODE>xsl:import</CODE> element that it contains. Any 
<CODE>xsl:include</CODE> elements are resolved before constructing the import 
tree. <A name=dt-import-precedence></A>An <CODE>xsl:stylesheet</CODE> element in 
the import tree is defined to have lower <B>import precedence</B> than another 
<CODE>xsl:stylesheet</CODE> element in the import tree if it would be visited 
before that <CODE>xsl:stylesheet</CODE> element in a post-order traversal of the 
import tree (i.e. a traversal of the import tree in which an 
<CODE>xsl:stylesheet</CODE> element is visited after its import children). Each 
definition and template rule has import precedence determined by the 
<CODE>xsl:stylesheet</CODE> element that contains it.</P>
<P>For example, suppose</P>
<UL>
  <LI>
  <P>stylesheet <VAR>A</VAR> imports stylesheets <VAR>B</VAR> and <VAR>C</VAR> 
  in that order;</P>
  <LI>
  <P>stylesheet <VAR>B</VAR> imports stylesheet <VAR>D</VAR>;</P>
  <LI>
  <P>stylesheet <VAR>C</VAR> imports stylesheet <VAR>E</VAR>.</P></LI></UL>
<P>Then the order of import precedence (lowest first) is <VAR>D</VAR>, 
<VAR>B</VAR>, <VAR>E</VAR>, <VAR>C</VAR>, <VAR>A</VAR>.</P>
<BLOCKQUOTE><B>NOTE:</B>Since <CODE>xsl:import</CODE> elements are required to 
  occur before any definitions or template rules, an implementation that 
  processes imported stylesheets at the point at which it encounters the 
  <CODE>xsl:import</CODE> element will encounter definitions and template rules 
  in increasing order of import precedence.</BLOCKQUOTE>
<P>In general, a definition or template rule with higher import precedence takes 
precedence over a definition or template rule with lower import precedence. This 
is defined in detail for each kind of definition and for template rules.</P>
<P>It is an error if a stylesheet directly or indirectly imports itself. Apart 
from this, the case where a stylesheet with a particular URI is imported in 
multiple places is not treated specially. The <A 
href="http://www.w3.org/TR/xslt#dt-import-tree">import tree</A> will have a 
separate <CODE>xsl:stylesheet</CODE> for each place that it is imported.</P>
<BLOCKQUOTE><B>NOTE:</B>If <CODE>xsl:apply-imports</CODE> is used (see <A 
  href="http://www.w3.org/TR/xslt#apply-imports">[<B>5.6 Overriding Template 
  Rules</B>]</A>), the behavior may be different from the behavior if the 
  stylesheet had been imported only at the place with the highest <A 
  href="http://www.w3.org/TR/xslt#dt-import-precedence">import 
precedence</A>.</BLOCKQUOTE>
<H3><A name=section-Embedding-Stylesheets></A>2.7 Embedding Stylesheets</H3>
<P>Normally an XSLT stylesheet is a complete XML document with the 
<CODE>xsl:stylesheet</CODE> element as the document element. However, an XSLT 
stylesheet may also be embedded in another resource. Two forms of embedding are 
possible:</P>
<UL>
  <LI>the XSLT stylesheet may be textually embedded in a non-XML resource, or 
  <LI>the <CODE>xsl:stylesheet</CODE> element may occur in an XML document other 
  than as the document element. </LI></UL>
<P>To facilitate the second form of embedding, the <CODE>xsl:stylesheet</CODE> 
element is allowed to have an ID attribute that specifies a unique 
identifier.</P>
<BLOCKQUOTE><B>NOTE:</B>In order for such an attribute to be used with the 
  XPath <B><A href="http://www.w3.org/TR/xpath#function-id">id</A></B> function, 
  it must actually be declared in the DTD as being an ID.</BLOCKQUOTE>
<P>The following example shows how the <CODE>xml-stylesheet</CODE> processing 
instruction <A href="http://www.w3.org/TR/xslt#XMLSTYLE">[XML Stylesheet]</A> 
can be used to allow a document to contain its own stylesheet. The URI reference 
uses a relative URI with a fragment identifier to locate the 
<CODE>xsl:stylesheet</CODE> element:</P><PRE>&lt;?xml-stylesheet type="text/xml" href="#style1"?&gt;
&lt;!DOCTYPE doc SYSTEM "doc.dtd"&gt;
&lt;doc&gt;
&lt;head&gt;
&lt;xsl:stylesheet id="style1"
                version="1.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns:fo="http://www.w3.org/1999/XSL/Format"&gt;
&lt;xsl:import href="doc.xsl"/&gt;
&lt;xsl:template match="id('foo')"&gt;
  &lt;fo:block font-weight="bold"&gt;&lt;xsl:apply-templates/&gt;&lt;/fo:block&gt;
&lt;/xsl:template&gt;
&lt;xsl:template match="xsl:stylesheet"&gt;
  &lt;!-- ignore --&gt;
&lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;para id="foo"&gt;
...
&lt;/para&gt;
&lt;/body&gt;
&lt;/doc&gt;</PRE>
<BLOCKQUOTE><B>NOTE:</B>A stylesheet that is embedded in the document to which 
  it is to be applied or that may be included or imported into an stylesheet 
  that is so embedded typically needs to contain a template rule that specifies 
  that <CODE>xsl:stylesheet</CODE> elements are to be ignored.</BLOCKQUOTE>
<H2><A name=data-model></A>3 Data Model</H2>
<P>The data model used by XSLT is the same as that used by <A 
href="http://www.w3.org/TR/xpath#data-model">XPath</A> with the additions 
described in this section. XSLT operates on source, result and stylesheet 
documents using the same data model. Any two XML documents that have the same 
tree will be treated the same by XSLT.</P>
<P>Processing instructions and comments in the stylesheet are ignored: the 
stylesheet is treated as if neither processing instruction nodes nor comment 
nodes were included in the tree that represents the stylesheet.</P>
<H3><A name=root-node-children></A>3.1 Root Node Children</H3>
<P>The normal restrictions on the children of the root node are relaxed for the 
result tree. The result tree may have any sequence of nodes as children that 
would be possible for an element node. In particular, it may have text node 
children, and any number of element node children. When written out using the 
XML output method (see <A href="http://www.w3.org/TR/xslt#output">[<B>16 
Output</B>]</A>), it is possible that a result tree will not be a well-formed 
XML document; however, it will always be a well-formed external general parsed 
entity.</P>
<P>When the source tree is created by parsing a well-formed XML document, the 
root node of the source tree will automatically satisfy the normal restrictions 
of having no text node children and exactly one element child. When the source 
tree is created in some other way, for example by using the DOM, the usual 
restrictions are relaxed for the source tree as for the result tree.</P>
<H3><A name=base-uri></A>3.2 Base URI</H3>
<P>Every node also has an associated URI called its base URI, which is used for 
resolving attribute values that represent relative URIs into absolute URIs. If 
an element or processing instruction occurs in an external entity, the base URI 
of that element or processing instruction is the URI of the external entity; 
otherwise, the base URI is the base URI of the document. The base URI of the 
document node is the URI of the document entity. The base URI for a text node, a 
comment node, an attribute node or a namespace node is the base URI of the 
parent of the node.</P>
<H3><A name=unparsed-entities></A>3.3 Unparsed Entities</H3>
<P>The root node has a mapping that gives the URI for each unparsed entity 
declared in the document's DTD. The URI is generated from the system identifier 
and public identifier specified in the entity declaration. The XSLT processor 
may use the public identifier to generate a URI for the entity instead of the 
URI specified in the system identifier. If the XSLT processor does not use the 
public identifier to generate the URI, it must use the system identifier; if the 
system identifier is a relative URI, it must be resolved into an absolute URI 
using the URI of the resource containing the entity declaration as the base URI 
<A href="http://www.w3.org/TR/xslt#RFC2396">[RFC2396]</A>.</P>
<H3><A name=strip></A>3.4 Whitespace Stripping</H3>
<P>After the tree for a source document or stylesheet document has been 
constructed, but before it is otherwise processed by XSLT, some text nodes are 
stripped. A text node is never stripped unless it contains only whitespace 
characters. Stripping the text node removes the text node from the tree. The 
stripping process takes as input a set of element names for which whitespace 
must be preserved. The stripping process is applied to both stylesheets and 
source documents, but the set of whitespace-preserving element names is 
determined differently for stylesheets and for source documents.</P>
<P>A text node is preserved if any of the following apply:</P>
<UL>
  <LI>
  <P>The element name of the parent of the text node is in the set of 
  whitespace-preserving element names.</P>
  <LI>
  <P>The text node contains at least one non-whitespace character. As in XML, a 
  whitespace character is #x20, #x9, #xD or #xA.</P>
  <LI>
  <P>An ancestor element of the text node has an <CODE>xml:space</CODE> 
  attribute with a value of <CODE>preserve</CODE>, and no closer ancestor 
  element has <CODE>xml:space</CODE> with a value of 
  <CODE>default</CODE>.</P></LI></UL>
<P>Otherwise, the text node is stripped.</P>
<P>The <CODE>xml:space</CODE> attributes are not stripped from the tree.</P>
<BLOCKQUOTE><B>NOTE:</B>This implies that if an <CODE>xml:space</CODE> 
  attribute is specified on a literal result element, it will be included in the 
  result.</BLOCKQUOTE>
<P>For stylesheets, the set of whitespace-preserving element names consists of 
just <CODE>xsl:text</CODE>.</P>
<P class=element-syntax><A name=element-strip-space></A><CODE>&lt;!-- Category: 
top-level-element --&gt;<BR>&lt;xsl:strip-space<BR>&nbsp;&nbsp;<B>elements</B> = 
<VAR>tokens</VAR>&nbsp;/&gt;</CODE></P>
<P class=element-syntax><A name=element-preserve-space></A><CODE>&lt;!-- 
Category: top-level-element 
--&gt;<BR>&lt;xsl:preserve-space<BR>&nbsp;&nbsp;<B>elements</B> = 
<VAR>tokens</VAR>&nbsp;/&gt;</CODE></P>
<P>For source documents, the set of whitespace-preserving element names is 
specified by <CODE>xsl:strip-space</CODE> and <CODE>xsl:preserve-space</CODE> <A 
href="http://www.w3.org/TR/xslt#dt-top-level">top-level</A> elements. These 
elements each have an <CODE>elements</CODE> attribute whose value is a 
whitespace-separated list of <A 
href="http://www.w3.org/TR/xpath#NT-NameTest">NameTest</A>s. Initially, the set 
of whitespace-preserving element names contains all element names. If an element 
name matches a <A href="http://www.w3.org/TR/xpath#NT-NameTest">NameTest</A> in 
an <CODE>xsl:strip-space</CODE> element, then it is removed from the set of 
whitespace-preserving element names. If an element name matches a <A 
href="http://www.w3.org/TR/xpath#NT-NameTest">NameTest</A> in an 
<CODE>xsl:preserve-space</CODE> element, then it is added to the set of 
whitespace-preserving element names. An element matches a <A 
href="http://www.w3.org/TR/xpath#NT-NameTest">NameTest</A> if and only if the <A 
href="http://www.w3.org/TR/xpath#NT-NameTest">NameTest</A> would be true for the 
element as an <A href="http://www.w3.org/TR/xpath#node-tests">XPath node 
test</A>. Conflicts between matches to <CODE>xsl:strip-space</CODE> and 
<CODE>xsl:preserve-space</CODE> elements are resolved the same way as conflicts 
between template rules (see <A href="http://www.w3.org/TR/xslt#conflict">[<B>5.5 
Conflict Resolution for Template Rules</B>]</A>). Thus, the applicable match for 
a particular element name is determined as follows:</P>
<UL>
  <LI>
  <P>First, any match with lower <A 
  href="http://www.w3.org/TR/xslt#dt-import-precedence">import precedence</A> 
  than another match is ignored.</P>
  <LI>
  <P>Next, any match with a <A 
  href="http://www.w3.org/TR/xpath#NT-NameTest">NameTest</A> that has a lower <A 
  href="http://www.w3.org/TR/xslt#dt-default-priority">default priority</A> than 
  the <A href="http://www.w3.org/TR/xslt#dt-default-priority">default 
  priority</A> of the <A 
  href="http://www.w3.org/TR/xpath#NT-NameTest">NameTest</A> of another match is 
  ignored.</P></LI></UL>
<P>It is an error if this leaves more than one match. An XSLT processor may 
signal the error; if it does not signal the error, it must recover by choosing, 
from amongst the matches that are left, the one that occurs last in the 
stylesheet.</P>
<H2><A name=section-Expressions></A>4 Expressions</H2>
<P>XSLT uses the expression language defined by XPath <A 
href="http://www.w3.org/TR/xslt#XPATH">[XPath]</A>. Expressions are used in XSLT 
for a variety of purposes including:</P>
<UL>
  <LI>selecting nodes for processing; 
  <LI>specifying conditions for different ways of processing a node; 
  <LI>generating text to be inserted in the result tree. </LI></UL>
<P><A name=dt-expression></A>An <B>expression</B> must match the XPath 
production <A href="http://www.w3.org/TR/xpath#NT-Expr">Expr</A>.</P>
<P>Expressions occur as the value of certain attributes on XSLT-defined elements 
and within curly braces in <A 
href="http://www.w3.org/TR/xslt#dt-attribute-value-template">attribute value 
template</A>s.</P>
<P>In XSLT, an outermost expression (i.e. an expression that is not part of 
another expression) gets its context as follows:</P>
<UL>
  <LI>
  <P>the context node comes from the <A 
  href="http://www.w3.org/TR/xslt#dt-current-node">current node</A></P>
  <LI>
  <P>the context position comes from the position of the <A 
  href="http://www.w3.org/TR/xslt#dt-current-node">current node</A> in the <A 
  href="http://www.w3.org/TR/xslt#dt-current-node-list">current node list</A>; 
  the first position is 1</P>
  <LI>
  <P>the context size comes from the size of the <A 
  href="http://www.w3.org/TR/xslt#dt-current-node-list">current node 
list</A></P>
  <LI>
  <P>the variable bindings are the bindings in scope on the element which has 
  the attribute in which the expression occurs (see <A 
  href="http://www.w3.org/TR/xslt#variables">[<B>11 Variables and 
  Parameters</B>]</A>)</P>
  <LI>
  <P>the set of namespace declarations are those in scope on the element which 
  has the attribute in which the expression occurs; this includes the implicit 
  declaration of the prefix <CODE>xml</CODE> required by the the XML Namespaces 
  Recommendation <A href="http://www.w3.org/TR/xslt#XMLNAMES">[XML Names]</A>; 
  the default namespace (as declared by <CODE>xmlns</CODE>) is not part of this 
  set</P>
  <LI>
  <P>the function library consists of the core function library together with 
  the additional functions defined in <A 
  href="http://www.w3.org/TR/xslt#add-func">[<B>12 Additional Functions</B>]</A> 
  and extension functions as described in <A 
  href="http://www.w3.org/TR/xslt#extension">[<B>14 Extensions</B>]</A>; it is 
  an error for an expression to include a call to any other function</P></LI></UL>
<H2><A name=rules></A>5 Template Rules</H2>
<H3><A name=section-Processing-Model></A>5.1 Processing Model</H3>
<P>A list of source nodes is processed to create a result tree fragment. The 
result tree is constructed by processing a list containing just the root node. A 
list of source nodes is processed by appending the result tree structure created 
by processing each of the members of the list in order. A node is processed by 
finding all the template rules with patterns that match the node, and choosing 
the best amongst them; the chosen rule's template is then instantiated with the 
node as the <A href="http://www.w3.org/TR/xslt#dt-current-node">current node</A> 
and with the list of source nodes as the <A 
href="http://www.w3.org/TR/xslt#dt-current-node-list">current node list</A>. A 
template typically contains instructions that select an additional list of 
source nodes for processing. The process of matching, instantiation and 
selection is continued recursively until no new source nodes are selected for 
processing.</P>
<P>Implementations are free to process the source document in any way that 
produces the same result as if it were processed using this processing 
model.</P>
<H3><A name=patterns></A>5.2 Patterns</H3>
<P><A name=dt-pattern></A>Template rules identify the nodes to which they apply 
by using a <B>pattern</B>. As well as being used in template rules, patterns are 
used for numbering (see <A href="http://www.w3.org/TR/xslt#number">[<B>7.7 
Numbering</B>]</A>) and for declaring keys (see <A 
href="http://www.w3.org/TR/xslt#key">[<B>12.2 Keys</B>]</A>). A pattern 
specifies a set of conditions on a node. A node that satisfies the conditions 
matches the pattern; a node that does not satisfy the conditions does not match 
the pattern. The syntax for patterns is a subset of the syntax for expressions. 
In particular, location paths that meet certain restrictions can be used as 
patterns. An expression that is also a pattern always evaluates to an object of 
type node-set. A node matches a pattern if the node is a member of the result of 
evaluating the pattern as an expression with respect to some possible context; 
the possible contexts are those whose context node is the node being matched or 
one of its ancestors.</P>
<P>Here are some examples of patterns:</P>
<UL>
  <LI>
  <P><CODE>para</CODE> matches any <CODE>para</CODE> element</P>
  <LI>
  <P><CODE>*</CODE> matches any element</P>
  <LI>
  <P><CODE>chapter|appendix</CODE> matches any <CODE>chapter</CODE> element and 
  any <CODE>appendix</CODE> element</P>
  <LI>
  <P><CODE>olist/item</CODE> matches any <CODE>item</CODE> element with an 
  <CODE>olist</CODE> parent</P>
  <LI>
  <P><CODE>appendix//para</CODE> matches any <CODE>para</CODE> element with an 
  <CODE>appendix</CODE> ancestor element</P>
  <LI>
  <P><CODE>/</CODE> matches the root node</P>
  <LI>
  <P><CODE>text()</CODE> matches any text node</P>
  <LI>
  <P><CODE>processing-instruction()</CODE> matches any processing 
instruction</P>
  <LI>
  <P><CODE>node()</CODE> matches any node other than an attribute node and the 
  root node</P>
  <LI>
  <P><CODE>id("W11")</CODE> matches the element with unique ID 
  <CODE>W11</CODE></P>
  <LI>
  <P><CODE>para[1]</CODE> matches any <CODE>para</CODE> element that is the 
  first <CODE>para</CODE> child element of its parent</P>
  <LI>
  <P><CODE>*[position()=1 and self::para]</CODE> matches any <CODE>para</CODE> 
  element that is the first child element of its parent</P>
  <LI>
  <P><CODE>para[last()=1]</CODE> matches any <CODE>para</CODE> element that is 
  the only <CODE>para</CODE> child element of its parent</P>
  <LI>
  <P><CODE>items/item[position()&gt;1]</CODE> matches any <CODE>item</CODE> 
  element that has a <CODE>items</CODE> parent and that is not the first 
  <CODE>item</CODE> child of its parent</P>
  <LI>
  <P><CODE>item[position() mod 2 = 1]</CODE> would be true for any 
  <CODE>item</CODE> element that is an odd-numbered <CODE>item</CODE> child of 
  its parent.</P>
  <LI>
  <P><CODE>div[@class="appendix"]//p</CODE> matches any <CODE>p</CODE> element 
  with a <CODE>div</CODE> ancestor element that has a <CODE>class</CODE> 
  attribute with value <CODE>appendix</CODE></P>
  <LI>
  <P><CODE>@class</CODE> matches any <CODE>class</CODE> attribute (<I>not</I> 
  any element that has a <CODE>class</CODE> attribute)</P>
  <LI>
  <P><CODE>@*</CODE> matches any attribute</P></LI></UL>
<P>A pattern must match the grammar for <A 
href="http://www.w3.org/TR/xslt#NT-Pattern">Pattern</A>. A <A 
href="http://www.w3.org/TR/xslt#NT-Pattern">Pattern</A> is a set of location 
path patterns separated by <CODE>|</CODE>. A location path pattern is a location 
path whose steps all use only the <CODE>child</CODE> or <CODE>attribute</CODE> 
axes. Although patterns must not use the <CODE>descendant-or-self</CODE> axis, 
patterns may use the <CODE>//</CODE> operator as well as the <CODE>/</CODE> 
operator. Location path patterns can also start with an <B><A 
href="http://www.w3.org/TR/xpath#function-id">id</A></B> or <B><A 
href="http://www.w3.org/TR/xslt#function-key">key</A></B> function call with a 
literal argument. Predicates in a pattern can use arbitrary expressions just 
like predicates in a location path.</P>
<H5>Patterns</H5>
<TABLE class=scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A name=NT-Pattern></A>[1]&nbsp;&nbsp;&nbsp;</TD>
    <TD>Pattern</TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><A 
      href="http://www.w3.org/TR/xslt#NT-LocationPathPattern">LocationPathPattern</A></TD>
    <TD></TD></TR>
  <TR vAlign=baseline>
    <TD></TD>
    <TD></TD>
    <TD></TD>
    <TD>| <A href="http://www.w3.org/TR/xslt#NT-Pattern">Pattern</A> '|' <A 
      href="http://www.w3.org/TR/xslt#NT-LocationPathPattern">LocationPathPattern</A></TD>
    <TD></TD></TR>
  <TR vAlign=baseline>
    <TD><A name=NT-LocationPathPattern></A>[2]&nbsp;&nbsp;&nbsp;</TD>
    <TD>LocationPathPattern</TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD>'/' <A 
      href="http://www.w3.org/TR/xslt#NT-RelativePathPattern">RelativePathPattern</A>?</TD>
    <TD></TD></TR>
  <TR vAlign=baseline>
    <TD></TD>
    <TD></TD>
    <TD></TD>
    <TD>| <A href="http://www.w3.org/TR/xslt#NT-IdKeyPattern">IdKeyPattern</A> 
      (('/' | '//') <A 
      href="http://www.w3.org/TR/xslt#NT-RelativePathPattern">RelativePathPattern</A>)?</TD>
    <TD></TD></TR>
  <TR vAlign=baseline>
    <TD></TD>
    <TD></TD>
    <TD></TD>
    <TD>| '//'? <A 
      href="http://www.w3.org/TR/xslt#NT-RelativePathPattern">RelativePathPattern</A></TD>
    <TD></TD></TR>
  <TR vAlign=baseline>
    <TD><A name=NT-IdKeyPattern></A>[3]&nbsp;&nbsp;&nbsp;</TD>
    <TD>IdKeyPattern</TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD>'id' '(' <A href="http://www.w3.org/TR/xpath#NT-Literal">Literal</A> 
      ')'</TD>
    <TD></TD></TR>
  <TR vAlign=baseline>
    <TD></TD>
    <TD></TD>
    <TD></TD>
    <TD>| 'key' '(' <A 
      href="http://www.w3.org/TR/xpath#NT-Literal">Literal</A> ',' <A 
      href="http://www.w3.org/TR/xpath#NT-Literal">Literal</A> ')'</TD>
    <TD></TD></TR>
  <TR vAlign=baseline>
    <TD><A name=NT-RelativePathPattern></A>[4]&nbsp;&nbsp;&nbsp;</TD>
    <TD>RelativePathPattern</TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><A href="http://www.w3.org/TR/xslt#NT-StepPattern">StepPattern</A></TD>
    <TD></TD></TR>
  <TR vAlign=baseline>
    <TD></TD>
    <TD></TD>
    <TD></TD>
    <TD>| <A 
      href="http://www.w3.org/TR/xslt#NT-RelativePathPattern">RelativePathPattern</A> 
      '/' <A href="http://www.w3.org/TR/xslt#NT-StepPattern">StepPattern</A></TD>
    <TD></TD></TR>
  <TR vAlign=baseline>
    <TD></TD>
    <TD></TD>
    <TD></TD>
    <TD>| <A 
      href="http://www.w3.org/TR/xslt#NT-RelativePathPattern">RelativePathPattern</A> 
      '//' <A href="http://www.w3.org/TR/xslt#NT-StepPattern">StepPattern</A></TD>
    <TD></TD></TR>
  <TR vAlign=baseline>
    <TD><A name=NT-StepPattern></A>[5]&nbsp;&nbsp;&nbsp;</TD>
    <TD>StepPattern</TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><A 
      href="http://www.w3.org/TR/xslt#NT-ChildOrAttributeAxisSpecifier">ChildOrAttributeAxisSpecifier</A> 
      <A href="http://www.w3.org/TR/xpath#NT-NodeTest">NodeTest</A> <A 
      href="http://www.w3.org/TR/xpath#NT-Predicate">Predicate</A>*</TD>
    <TD></TD></TR>
  <TR vAlign=baseline>
    <TD><A name=NT-ChildOrAttributeAxisSpecifier></A>[6]&nbsp;&nbsp;&nbsp;</TD>
    <TD>ChildOrAttributeAxisSpecifier</TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><A 
      href="http://www.w3.org/TR/xpath#NT-AbbreviatedAxisSpecifier">AbbreviatedAxisSpecifier</A></TD>
    <TD></TD></TR>
  <TR vAlign=baseline>
    <TD></TD>
    <TD></TD>
    <TD></TD>
    <TD>| ('child' | 'attribute') '::'</TD>
    <TD></TD></TR></TBODY></TABLE>
<P>A pattern is defined to match a node if and only if there is possible context 
such that when the pattern is evaluated as an expression with that context, the 
node is a member of the resulting node-set. When a node is being matched, the 
possible contexts have a context node that is the node being matched or any 
ancestor of that node, and a context node list containing just the context 
node.</P>
<P>For example, <CODE>p</CODE> matches any <CODE>p</CODE> element, because for 
any <CODE>p</CODE> if the expression <CODE>p</CODE> is evaluated with the parent 
of the <CODE>p</CODE> element as context the resulting node-set will contain 
that <CODE>p</CODE> element as one of its members.</P>
<BLOCKQUOTE><B>NOTE:</B>This matches even a <CODE>p</CODE> element that is the 
  document element, since the document root is the parent of the document 
  element.</BLOCKQUOTE>
<P>Although the semantics of patterns are specified indirectly in terms of 
expression evaluation, it is easy to understand the meaning of a pattern 
directly without thinking in terms of expression evaluation. In a pattern, 
<CODE>|</CODE> indicates alternatives; a pattern with one or more <CODE>|</CODE> 
separated alternatives matches if any one of the alternative matches. A pattern 
that consists of a sequence of <A 
href="http://www.w3.org/TR/xslt#NT-StepPattern">StepPattern</A>s separated by 
<CODE>/</CODE> or <CODE>//</CODE> is matched from right to left. The pattern 
only matches if the rightmost <A 
href="http://www.w3.org/TR/xslt#NT-StepPattern">StepPattern</A> matches and a 
suitable element matches the rest of the pattern; if the separator is 
<CODE>/</CODE> then only the parent is a suitable element; if the separator is 
<CODE>//</CODE>, then any ancestor is a suitable element. A <A 
href="http://www.w3.org/TR/xslt#NT-StepPattern">StepPattern</A> that uses the 
child axis matches if the <A 
href="http://www.w3.org/TR/xpath#NT-NodeTest">NodeTest</A> is true for the node 
and the node is not an attribute node. A <A 
href="http://www.w3.org/TR/xslt#NT-StepPattern">StepPattern</A> that uses the 
attribute axis matches if the <A 
href="http://www.w3.org/TR/xpath#NT-NodeTest">NodeTest</A> is true for the node 
and the node is an attribute node. When <CODE>[]</CODE> is present, then the 
first <A href="http://www.w3.org/TR/xpath#NT-PredicateExpr">PredicateExpr</A> in 
a <A href="http://www.w3.org/TR/xslt#NT-StepPattern">StepPattern</A> is 
evaluated with the node being matched as the context node and the siblings of 
the context node that match the <A 
href="http://www.w3.org/TR/xpath#NT-NodeTest">NodeTest</A> as the context node 
list, unless the node being matched is an attribute node, in which case the 
context node list is all the attributes that have the same parent as the 
attribute being matched and that match the <A 
href="http://www.w3.org/TR/xpath#NT-NameTest">NameTest</A>.</P>
<P>For example</P><PRE>appendix//ulist/item[position()=1]</PRE>
<P>matches a node if and only if all of the following are true:</P>
<UL>
  <LI>
  <P>the <A href="http://www.w3.org/TR/xpath#NT-NodeTest">NodeTest</A> 
  <CODE>item</CODE> is true for the node and the node is not an attribute; in 
  other words the node is an <CODE>item</CODE> element</P>
  <LI>
  <P>evaluating the <A 
  href="http://www.w3.org/TR/xpath#NT-PredicateExpr">PredicateExpr</A> 
  <CODE>position()=1</CODE> with the node as context node and the siblings of 
  the node that are <CODE>item</CODE> elements as the context node list yields 
  true</P>
  <LI>
  <P>the node has a parent that matches <CODE>appendix//ulist</CODE>; this will 
  be true if the parent is a <CODE>ulist</CODE> element that has an 
  <CODE>appendix</CODE> ancestor element.</P></LI></UL>
<H3><A name=section-Defining-Template-Rules></A>5.3 Defining Template Rules</H3>
<P class=element-syntax><A name=element-template></A><CODE>&lt;!-- Category: 
top-level-element --&gt;<BR>&lt;xsl:template<BR>&nbsp;&nbsp;match = 
<VAR>pattern</VAR> <BR>&nbsp;&nbsp;name = <VAR>qname</VAR> 
<BR>&nbsp;&nbsp;priority = <VAR>number</VAR> <BR>&nbsp;&nbsp;mode = 
<VAR>qname</VAR>&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: (<A 
href="http://www.w3.org/TR/xslt#element-param">xsl:param</A>*, 
<VAR>template</VAR>) --&gt;<BR>&lt;/xsl:template&gt;</CODE></P>
<P>A template rule is specified with the <CODE>xsl:template</CODE> element. The 
<CODE>match</CODE> attribute is a <A 
href="http://www.w3.org/TR/xslt#NT-Pattern">Pattern</A> that identifies the 
source node or nodes to which the rule applies. The <CODE>match</CODE> attribute 
is required unless the <CODE>xsl:template</CODE> element has a <CODE>name</CODE> 
attribute (see <A href="http://www.w3.org/TR/xslt#named-templates">[<B>6 Named 
Templates</B>]</A>). It is an error for the value of the <CODE>match</CODE> 
attribute to contain a <A 
href="http://www.w3.org/TR/xpath#NT-VariableReference">VariableReference</A>. 
The content of the <CODE>xsl:template</CODE> element is the template that is 
instantiated when the template rule is applied.</P>
<P>For example, an XML document might contain:</P><PRE>This is an &lt;emph&gt;important&lt;/emph&gt; point.</PRE>
<P>The following template rule matches <CODE>emph</CODE> elements and produces a 
<CODE>fo:inline-sequence</CODE> formatting object with a 
<CODE>font-weight</CODE> property of <CODE>bold</CODE>.</P><PRE>&lt;xsl:template match="emph"&gt;
  &lt;fo:inline-sequence font-weight="bold"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:inline-sequence&gt;
&lt;/xsl:template&gt;</PRE>
<BLOCKQUOTE><B>NOTE:</B>Examples in this document use the <CODE>fo:</CODE> 
  prefix for the namespace <CODE>http://www.w3.org/1999/XSL/Format</CODE>, which 
  is the namespace of the formatting objects defined in <A 
  href="http://www.w3.org/TR/xslt#XSL">[XSL]</A>.</BLOCKQUOTE>
<P>As described next, the <CODE>xsl:apply-templates</CODE> element recursively 
processes the children of the source element.</P>
<H3><A name=section-Applying-Template-Rules></A>5.4 Applying Template Rules</H3>
<P class=element-syntax><A name=element-apply-templates></A><CODE>&lt;!-- 
Category: instruction --&gt;<BR>&lt;xsl:apply-templates<BR>&nbsp;&nbsp;select = 
<VAR>node-set-expression</VAR> <BR>&nbsp;&nbsp;mode = 
<VAR>qname</VAR>&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: (<A 
href="http://www.w3.org/TR/xslt#element-sort">xsl:sort</A> | <A 
href="http://www.w3.org/TR/xslt#element-with-param">xsl:with-param</A>)* 
--&gt;<BR>&lt;/xsl:apply-templates&gt;</CODE></P>
<P>This example creates a block for a <CODE>chapter</CODE> element and then 
processes its immediate children.</P><PRE>&lt;xsl:template match="chapter"&gt;
  &lt;fo:block&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;</PRE>
<P>In the absence of a <CODE>select</CODE> attribute, the 
<CODE>xsl:apply-templates</CODE> instruction processes all of the children of 
the current node, including text nodes. However, text nodes that have been 
stripped as specified in <A href="http://www.w3.org/TR/xslt#strip">[<B>3.4 
Whitespace Stripping</B>]</A> will not be processed. If stripping of whitespace 
nodes has not been enabled for an element, then all whitespace in the content of 
the element will be processed as text, and thus whitespace between child 
elements will count in determining the position of a child element as returned 
by the <B><A 
href="http://www.w3.org/TR/xpath#function-position">position</A></B> 
function.</P>
<P>A <CODE>select</CODE> attribute can be used to process nodes selected by an 
expression instead of processing all children. The value of the 
<CODE>select</CODE> attribute is an <A 
href="http://www.w3.org/TR/xslt#dt-expression">expression</A>. The expression 
must evaluate to a node-set. The selected set of nodes is processed in document 
order, unless a sorting specification is present (see <A 
href="http://www.w3.org/TR/xslt#sorting">[<B>10 Sorting</B>]</A>). The following 
example processes all of the <CODE>author</CODE> children of the 
<CODE>author-group</CODE>:</P><PRE>&lt;xsl:template match="author-group"&gt;
  &lt;fo:inline-sequence&gt;
    &lt;xsl:apply-templates select="author"/&gt;
  &lt;/fo:inline-sequence&gt;
&lt;/xsl:template&gt;</PRE>
<P>The following example processes all of the <CODE>given-name</CODE>s of the 
<CODE>author</CODE>s that are children of <CODE>author-group</CODE>:</P><PRE>&lt;xsl:template match="author-group"&gt;
  &lt;fo:inline-sequence&gt;
    &lt;xsl:apply-templates select="author/given-name"/&gt;
  &lt;/fo:inline-sequence&gt;
&lt;/xsl:template&gt;</PRE>
<P>This example processes all of the <CODE>heading</CODE> descendant elements of 
the <CODE>book</CODE> element.</P><PRE>&lt;xsl:template match="book"&gt;
  &lt;fo:block&gt;
    &lt;xsl:apply-templates select=".//heading"/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;</PRE>
<P>It is also possible to process elements that are not descendants of the 
current node. This example assumes that a <CODE>department</CODE> element has 
<CODE>group</CODE> children and <CODE>employee</CODE> descendants. It finds an 
employee's department and then processes the <CODE>group</CODE> children of the 
<CODE>department</CODE>.</P><PRE>&lt;xsl:template match="employee"&gt;
  &lt;fo:block&gt;
    Employee &lt;xsl:apply-templates select="name"/&gt; belongs to group
    &lt;xsl:apply-templates select="ancestor::department/group"/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;</PRE>
<P>Multiple <CODE>xsl:apply-templates</CODE> elements can be used within a 
single template to do simple reordering. The following example creates two HTML 
tables. The first table is filled with domestic sales while the second table is 
filled with foreign sales.</P><PRE>&lt;xsl:template match="product"&gt;
  &lt;table&gt;
    &lt;xsl:apply-templates select="sales/domestic"/&gt;
  &lt;/table&gt;
  &lt;table&gt;
    &lt;xsl:apply-templates select="sales/foreign"/&gt;
  &lt;/table&gt;
&lt;/xsl:template&gt;</PRE>
<BLOCKQUOTE><B>NOTE:</B> It is possible for there to be two matching 
  descendants where one is a descendant of the other. This case is not treated 
  specially: both descendants will be processed as usual. For example, given a 
  source document <PRE>&lt;doc&gt;&lt;div&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/doc&gt;</PRE>the 
  rule <PRE>&lt;xsl:template match="doc"&gt;
  &lt;xsl:apply-templates select=".//div"/&gt;
&lt;/xsl:template&gt;</PRE>will process both the outer <CODE>div</CODE> and 
  inner <CODE>div</CODE> elements.</BLOCKQUOTE>
<BLOCKQUOTE><B>NOTE:</B>Typically, <CODE>xsl:apply-templates</CODE> is used to 
  process only nodes that are descendants of the current node. Such use of 
  <CODE>xsl:apply-templates</CODE> cannot result in non-terminating processing 
  loops. However, when <CODE>xsl:apply-templates</CODE> is used to process 
  elements that are not descendants of the current node, the possibility arises 
  of non-terminating loops. For example, <PRE style="COLOR: red">&lt;xsl:template match="foo"&gt;
  &lt;xsl:apply-templates select="."/&gt;
&lt;/xsl:template&gt;</PRE>Implementations may be able to detect such loops in 
  some cases, but the possibility exists that a stylesheet may enter a 
  non-terminating loop that an implementation is unable to detect. This may 
  present a denial of service security risk.</BLOCKQUOTE>
<H3><A name=conflict></A>5.5 Conflict Resolution for Template Rules</H3>
<P>It is possible for a source node to match more than one template rule. The 
template rule to be used is determined as follows:</P>
<OL>
  <LI>
  <P>First, all matching template rules that have lower <A 
  href="http://www.w3.org/TR/xslt#dt-import-precedence">import precedence</A> 
  than the matching template rule or rules with the highest import precedence 
  are eliminated from consideration.</P>
  <LI>
  <P>Next, all matching template rules that have lower priority than the 
  matching template rule or rules with the highest priority are eliminated from 
  consideration. The priority of a template rule is specified by the 
  <CODE>priority</CODE> attribute on the template rule. The value of this must 
  be a real number (positive or negative), matching the production <A 
  href="http://www.w3.org/TR/xpath#NT-Number">Number</A> with an optional 
  leading minus sign (<CODE>-</CODE>). <A name=dt-default-priority></A>The 
  <B>default priority</B> is computed as follows:</P>
  <UL>
    <LI>
    <P>If the pattern contains multiple alternatives separated by 
    <CODE>|</CODE>, then it is treated equivalently to a set of template rules, 
    one for each alternative.</P>
    <LI>
    <P>If the pattern has the form of a <A 
    href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</A> preceded by a 
    <A 
    href="http://www.w3.org/TR/xslt#NT-ChildOrAttributeAxisSpecifier">ChildOrAttributeAxisSpecifier</A> 
    or has the form <CODE>processing-instruction(</CODE><A 
    href="http://www.w3.org/TR/xpath#NT-Literal">Literal</A><CODE>)</CODE> 
    preceded by a <A 
    href="http://www.w3.org/TR/xslt#NT-ChildOrAttributeAxisSpecifier">ChildOrAttributeAxisSpecifier</A>, 
    then the priority is 0.</P>
    <LI>
    <P>If the pattern has the form <A 
    href="http://www.w3.org/TR/REC-xml-names#NT-NCName">NCName</A><CODE>:*</CODE> 
    preceded by a <A 
    href="http://www.w3.org/TR/xslt#NT-ChildOrAttributeAxisSpecifier">ChildOrAttributeAxisSpecifier</A>, 
    then the priority is -0.25.</P>
    <LI>
    <P>Otherwise, if the pattern consists of just a <A 
    href="http://www.w3.org/TR/xpath#NT-NodeTest">NodeTest</A> preceded by a <A 
    href="http://www.w3.org/TR/xslt#NT-ChildOrAttributeAxisSpecifier">ChildOrAttributeAxisSpecifier</A>, 
    then the priority is -0.5.</P>
    <LI>
    <P>Otherwise, the priority is 0.5.</P></LI></UL>
  <P>Thus, the most common kind of pattern (a pattern that tests for a node with 
  a particular type and a particular expanded-name) has priority 0. The next 
  less specific kind of pattern (a pattern that tests for a node with a 
  particular type and an expanded-name with a particular namespace URI) has 
  priority -0.25. Patterns less specific than this (patterns that just tests for 
  nodes with particular types) have priority -0.5. Patterns more specific than 
  the most common kind of pattern have priority 0.5.</P></LI></OL>
<P>It is an error if this leaves more than one matching template rule. An XSLT 
processor may signal the error; if it does not signal the error, it must recover 
by choosing, from amongst the matching template rules that are left, the one 
that occurs last in the stylesheet.</P>
<H3><A name=apply-imports></A>5.6 Overriding Template Rules</H3>
<P class=element-syntax><A name=element-apply-imports></A><CODE>&lt;!-- 
Category: instruction --&gt;<BR>&lt;xsl:apply-imports&nbsp;/&gt;</CODE></P>
<P>A template rule that is being used to override a template rule in an imported 
stylesheet (see <A href="http://www.w3.org/TR/xslt#conflict">[<B>5.5 Conflict 
Resolution for Template Rules</B>]</A>) can use the 
<CODE>xsl:apply-imports</CODE> element to invoke the overridden template 
rule.</P>
<P><A name=dt-current-template-rule></A>At any point in the processing of a 
stylesheet, there is a <B>current template rule</B>. Whenever a template rule is 
chosen by matching a pattern, the template rule becomes the current template 
rule for the instantiation of the rule's template. When an 
<CODE>xsl:for-each</CODE> element is instantiated, the current template rule 
becomes null for the instantiation of the content of the 
<CODE>xsl:for-each</CODE> element.</P>
<P><CODE>xsl:apply-imports</CODE> processes the current node using only template 
rules that were imported into the stylesheet element containing the current 
template rule; the node is processed in the current template rule's mode. It is 
an error if <CODE>xsl:apply-imports</CODE> is instantiated when the current 
template rule is null.</P>
<P>For example, suppose the stylesheet <CODE>doc.xsl</CODE> contains a template 
rule for <CODE>example</CODE> elements:</P><PRE>&lt;xsl:template match="example"&gt;
  &lt;pre&gt;&lt;xsl:apply-templates/&gt;&lt;/pre&gt;
&lt;/xsl:template&gt;</PRE>
<P>Another stylesheet could import <CODE>doc.xsl</CODE> and modify the treatment 
of <CODE>example</CODE> elements as follows:</P><PRE>&lt;xsl:import href="doc.xsl"/&gt;

&lt;xsl:template match="example"&gt;
  &lt;div style="border: solid red"&gt;
     &lt;xsl:apply-imports/&gt;
  &lt;/div&gt;
&lt;/xsl:template&gt;</PRE>
<P>The combined effect would be to transform an <CODE>example</CODE> into an 
element of the form:</P><PRE>&lt;div style="border: solid red"&gt;&lt;pre&gt;...&lt;/pre&gt;&lt;/div&gt;</PRE>
<H3><A name=modes></A>5.7 Modes</H3>
<P>Modes allow an element to be processed multiple times, each time producing a 
different result.</P>
<P>Both <CODE>xsl:template</CODE> and <CODE>xsl:apply-templates</CODE> have an 
optional <CODE>mode</CODE> attribute. The value of the <CODE>mode</CODE> 
attribute is a <A href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</A>, 
which is expanded as described in <A 
href="http://www.w3.org/TR/xslt#qname">[<B>2.4 Qualified Names</B>]</A>. If 
<CODE>xsl:template</CODE> does not have a <CODE>match</CODE> attribute, it must 
not have a <CODE>mode</CODE> attribute. If an <CODE>xsl:apply-templates</CODE> 
element has a <CODE>mode</CODE> attribute, then it applies only to those 
template rules from <CODE>xsl:template</CODE> elements that have a 
<CODE>mode</CODE> attribute with the same value; if an 
<CODE>xsl:apply-templates</CODE> element does not have a <CODE>mode</CODE> 
attribute, then it applies only to those template rules from 
<CODE>xsl:template</CODE> elements that do not have a <CODE>mode</CODE> 
attribute.</P>
<H3><A name=built-in-rule></A>5.8 Built-in Template Rules</H3>
<P>There is a built-in template rule to allow recursive processing to continue 
in the absence of a successful pattern match by an explicit template rule in the 
stylesheet. This template rule applies to both element nodes and the root node. 
The following shows the equivalent of the built-in template rule:</P><PRE>&lt;xsl:template match="*|/"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;</PRE>
<P>There is also a built-in template rule for each mode, which allows recursive 
processing to continue in the same mode in the absence of a successful pattern 
match by an explicit template rule in the stylesheet. This template rule applies 
to both element nodes and the root node. The following shows the equivalent of 
the built-in template rule for mode <CODE><VAR>m</VAR></CODE>.</P><PRE>&lt;xsl:template match="*|/" mode="<VAR>m</VAR>"&gt;
  &lt;xsl:apply-templates mode="<VAR>m</VAR>"/&gt;
&lt;/xsl:template&gt;</PRE>
<P>There is also a built-in template rule for text and attribute nodes that 
copies text through:</P><PRE>&lt;xsl:template match="text()|@*"&gt;
  &lt;xsl:value-of select="."/&gt;
&lt;/xsl:template&gt;</PRE>
<P>The built-in template rule for processing instructions and comments is to do 
nothing.</P><PRE>&lt;xsl:template match="processing-instruction()|comment()"/&gt;</PRE>
<P>The built-in template rule for namespace nodes is also to do nothing. There 
is no pattern that can match a namespace node; so, the built-in template rule is 
the only template rule that is applied for namespace nodes.</P>
<P>The built-in template rules are treated as if they were imported implicitly 
before the stylesheet and so have lower <A 
href="http://www.w3.org/TR/xslt#dt-import-precedence">import precedence</A> than 
all other template rules. Thus, the author can override a built-in template rule 
by including an explicit template rule.</P>
<H2><A name=named-templates></A>6 Named Templates</H2>
<P class=element-syntax><A name=element-call-template></A><CODE>&lt;!-- 
Category: instruction --&gt;<BR>&lt;xsl:call-template<BR>&nbsp;&nbsp;<B>name</B> 
= <VAR>qname</VAR>&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: <A 
href="http://www.w3.org/TR/xslt#element-with-param">xsl:with-param</A>* 
--&gt;<BR>&lt;/xsl:call-template&gt;</CODE></P>
<P>Templates can be invoked by name. An <CODE>xsl:template</CODE> element with a 
<CODE>name</CODE> attribute specifies a named template. The value of the 
<CODE>name</CODE> attribute is a <A 
href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</A>, which is expanded 
as described in <A href="http://www.w3.org/TR/xslt#qname">[<B>2.4 Qualified 
Names</B>]</A>. If an <CODE>xsl:template</CODE> element has a <CODE>name</CODE> 
attribute, it may, but need not, also have a <CODE>match</CODE> attribute. An 
<CODE>xsl:call-template</CODE> element invokes a template by name; it has a 
required <CODE>name</CODE> attribute that identifies the template to be invoked. 
Unlike <CODE>xsl:apply-templates</CODE>, <CODE>xsl:call-template</CODE> does not 
change the current node or the current node list.</P>
<P>The <CODE>match</CODE>, <CODE>mode</CODE> and <CODE>priority</CODE> 
attributes on an <CODE>xsl:template</CODE> element do not affect whether the 
template is invoked by an <CODE>xsl:call-template</CODE> element. Similarly, the 
<CODE>name</CODE> attribute on an <CODE>xsl:template</CODE> element does not 
affect whether the template is invoked by an <CODE>xsl:apply-templates</CODE> 
element.</P>
<P>It is an error if a stylesheet contains more than one template with the same 
name and same <A href="http://www.w3.org/TR/xslt#dt-import-precedence">import 
precedence</A>.</P>
<H2><A name=section-Creating-the-Result-Tree></A>7 Creating the Result Tree</H2>
<P>This section describes instructions that directly create nodes in the result 
tree.</P>
<H3><A name=section-Creating-Elements-and-Attributes></A>7.1 Creating Elements 
and Attributes</H3>
<H4><A name=literal-result-element></A>7.1.1 Literal Result Elements</H4>
<P>In a template, an element in the stylesheet that does not belong to the XSLT 
namespace and that is not an extension element (see <A 
href="http://www.w3.org/TR/xslt#extension-element">[<B>14.1 Extension 
Elements</B>]</A>) is instantiated to create an element node with the same <A 
href="http://www.w3.org/TR/xpath#dt-expanded-name">expanded-name</A>. The 
content of the element is a template, which is instantiated to give the content 
of the created element node. The created element node will have the attribute 
nodes that were present on the element node in the stylesheet tree, other than 
attributes with names in the XSLT namespace.</P>
<P>The created element node will also have a copy of the namespace nodes that 
were present on the element node in the stylesheet tree with the exception of 
any namespace node whose string-value is the XSLT namespace URI 
(<CODE>http://www.w3.org/1999/XSL/Transform</CODE>), a namespace URI declared as 
an extension namespace (see <A 
href="http://www.w3.org/TR/xslt#extension-element">[<B>14.1 Extension 
Elements</B>]</A>), or a namespace URI designated as an excluded namespace. A 
namespace URI is designated as an excluded namespace by using an 
<CODE>exclude-result-prefixes</CODE> attribute on an <CODE>xsl:stylesheet</CODE> 
element or an <CODE>xsl:exclude-result-prefixes</CODE> attribute on a literal 
result element. The value of both these attributes is a whitespace-separated 
list of namespace prefixes. The namespace bound to each of the prefixes is 
designated as an excluded namespace. It is an error if there is no namespace 
bound to the prefix on the element bearing the 
<CODE>exclude-result-prefixes</CODE> or <CODE>xsl:exclude-result-prefixes</CODE> 
attribute. The default namespace (as declared by <CODE>xmlns</CODE>) may be 
designated as an excluded namespace by including <CODE>#default</CODE> in the 
list of namespace prefixes. The designation of a namespace as an excluded 
namespace is effective within the subtree of the stylesheet rooted at the 
element bearing the <CODE>exclude-result-prefixes</CODE> or 
<CODE>xsl:exclude-result-prefixes</CODE> attribute; a subtree rooted at an 
<CODE>xsl:stylesheet</CODE> element does not include any stylesheets imported or 
included by children of that <CODE>xsl:stylesheet</CODE> element.</P>
<BLOCKQUOTE><B>NOTE:</B>When a stylesheet uses a namespace declaration only 
  for the purposes of addressing the source tree, specifying the prefix in the 
  <CODE>exclude-result-prefixes</CODE> attribute will avoid superfluous 
  namespace declarations in the result tree.</BLOCKQUOTE>
<P>The value of an attribute of a literal result element is interpreted as an <A 
href="http://www.w3.org/TR/xslt#dt-attribute-value-template">attribute value 
template</A>: it can contain expressions contained in curly braces 
(<CODE>{}</CODE>).</P>
<P><A name=dt-literal-namespace-uri></A>A namespace URI in the stylesheet tree 
that is being used to specify a namespace URI in the result tree is called a 
<B>literal namespace URI</B>. This applies to:</P>
<UL>
  <LI>
  <P>the namespace URI in the expanded-name of a literal result element in the 
  stylesheet</P>
  <LI>
  <P>the namespace URI in the expanded-name of an attribute specified on a 
  literal result element in the stylesheet</P>
  <LI>
  <P>the string-value of a namespace node on a literal result element in the 
  stylesheet</P></LI></UL>
<P class=element-syntax><A name=element-namespace-alias></A><CODE>&lt;!-- 
Category: top-level-element 
--&gt;<BR>&lt;xsl:namespace-alias<BR>&nbsp;&nbsp;<B>stylesheet-prefix</B> = 
<VAR>prefix</VAR> | "#default"<BR>&nbsp;&nbsp;<B>result-prefix</B> = 
<VAR>prefix</VAR> | "#default"&nbsp;/&gt;</CODE></P>
<P><A name=dt-alias></A>A stylesheet can use the 
<CODE>xsl:namespace-alias</CODE> element to declare that one namespace URI is an 
<B>alias</B> for another namespace URI. When a <A 
href="http://www.w3.org/TR/xslt#dt-literal-namespace-uri">literal namespace 
URI</A> has been declared to be an alias for another namespace URI, then the 
namespace URI in the result tree will be the namespace URI that the literal 
namespace URI is an alias for, instead of the literal namespace URI itself. The 
<CODE>xsl:namespace-alias</CODE> element declares that the namespace URI bound 
to the prefix specified by the <CODE>stylesheet-prefix</CODE> attribute is an 
alias for the namespace URI bound to the prefix specified by the 
<CODE>result-prefix</CODE> attribute. Thus, the <CODE>stylesheet-prefix</CODE> 
attribute specifies the namespace URI that will appear in the stylesheet, and 
the <CODE>result-prefix</CODE> attribute specifies the corresponding namespace 
URI that will appear in the result tree. The default namespace (as declared by 
<CODE>xmlns</CODE>) may be specified by using <CODE>#default</CODE> instead of a 
prefix. If a namespace URI is declared to be an alias for multiple different 
namespace URIs, then the declaration with the highest <A 
href="http://www.w3.org/TR/xslt#dt-import-precedence">import precedence</A> is 
used. It is an error if there is more than one such declaration. An XSLT 
processor may signal the error; if it does not signal the error, it must recover 
by choosing, from amongst the declarations with the highest import precedence, 
the one that occurs last in the stylesheet.</P>
<P>When literal result elements are being used to create element, attribute, or 
namespace nodes that use the XSLT namespace URI, the stylesheet must use an 
alias. For example, the stylesheet</P><PRE>&lt;xsl:stylesheet
  version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:fo="http://www.w3.org/1999/XSL/Format"
  xmlns:axsl="http://www.w3.org/1999/XSL/TransformAlias"&gt;

&lt;xsl:namespace-alias stylesheet-prefix="axsl" result-prefix="xsl"/&gt;

&lt;xsl:template match="/"&gt;
  &lt;axsl:stylesheet&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/axsl:stylesheet&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="block"&gt;
  &lt;axsl:template match="{.}"&gt;
     &lt;fo:block&gt;&lt;axsl:apply-templates/&gt;&lt;/fo:block&gt;
  &lt;/axsl:template&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</PRE>
<P>will generate an XSLT stylesheet from a document of the form:</P><PRE>&lt;elements&gt;
&lt;block&gt;p&lt;/block&gt;
&lt;block&gt;h1&lt;/block&gt;
&lt;block&gt;h2&lt;/block&gt;
&lt;block&gt;h3&lt;/block&gt;
&lt;block&gt;h4&lt;/block&gt;
&lt;/elements&gt;</PRE>
<BLOCKQUOTE><B>NOTE:</B>It may be necessary also to use aliases for namespaces 
  other than the XSLT namespace URI. For example, literal result elements 
  belonging to a namespace dealing with digital signatures might cause XSLT 
  stylesheets to be mishandled by general-purpose security software; using an 
  alias for the namespace would avoid the possibility of such 
mishandling.</BLOCKQUOTE>
<H4><A name=section-Creating-Elements-with-xsl:element></A>7.1.2 Creating 
Elements with <CODE>xsl:element</CODE></H4>
<P class=element-syntax><A name=element-element></A><CODE>&lt;!-- Category: 
instruction --&gt;<BR>&lt;xsl:element<BR>&nbsp;&nbsp;<B>name</B> = { 
<VAR>qname</VAR> }<BR>&nbsp;&nbsp;namespace = { <VAR>uri-reference</VAR> 
}<BR>&nbsp;&nbsp;use-attribute-sets = 
<VAR>qnames</VAR>&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: <VAR>template</VAR> 
--&gt;<BR>&lt;/xsl:element&gt;</CODE></P>
<P>The <CODE>xsl:element</CODE> element allows an element to be created with a 
computed name. The <A 
href="http://www.w3.org/TR/xpath#dt-expanded-name">expanded-name</A> of the 
element to be created is specified by a required <CODE>name</CODE> attribute and 
an optional <CODE>namespace</CODE> attribute. The content of the 
<CODE>xsl:element</CODE> element is a template for the attributes and children 
of the created element.</P>
<P>The <CODE>name</CODE> attribute is interpreted as an <A 
href="http://www.w3.org/TR/xslt#dt-attribute-value-template">attribute value 
template</A>. It is an error if the string that results from instantiating the 
attribute value template is not a <A 
href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</A>. An XSLT processor 
may signal the error; if it does not signal the error, then it must recover by 
making the the result of instantiating the <CODE>xsl:element</CODE> element be 
the sequence of nodes created by instantiating the content of the 
<CODE>xsl:element</CODE> element, excluding any initial attribute nodes. If the 
<CODE>namespace</CODE> attribute is not present then the <A 
href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</A> is expanded into an 
expanded-name using the namespace declarations in effect for the 
<CODE>xsl:element</CODE> element, including any default namespace 
declaration.</P>
<P>If the <CODE>namespace</CODE> attribute is present, then it also is 
interpreted as an <A 
href="http://www.w3.org/TR/xslt#dt-attribute-value-template">attribute value 
template</A>. The string that results from instantiating the attribute value 
template should be a URI reference. It is not an error if the string is not a 
syntactically legal URI reference. If the string is empty, then the 
expanded-name of the element has a null namespace URI. Otherwise, the string is 
used as the namespace URI of the expanded-name of the element to be created. The 
local part of the <A 
href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</A> specified by the 
<CODE>name</CODE> attribute is used as the local part of the expanded-name of 
the element to be created.</P>
<P>XSLT processors may make use of the prefix of the <A 
href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</A> specified in the 
<CODE>name</CODE> attribute when selecting the prefix used for outputting the 
created element as XML; however, they are not required to do so.</P>
<H4><A name=creating-attributes></A>7.1.3 Creating Attributes with 
<CODE>xsl:attribute</CODE></H4>
<P class=element-syntax><A name=element-attribute></A><CODE>&lt;!-- Category: 
instruction --&gt;<BR>&lt;xsl:attribute<BR>&nbsp;&nbsp;<B>name</B> = { 
<VAR>qname</VAR> }<BR>&nbsp;&nbsp;namespace = { <VAR>uri-reference</VAR> 
}&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: <VAR>template</VAR> 
--&gt;<BR>&lt;/xsl:attribute&gt;</CODE></P>
<P>The <CODE>xsl:attribute</CODE> element can be used to add attributes to 
result elements whether created by literal result elements in the stylesheet or 
by instructions such as <CODE>xsl:element</CODE>. The <A 
href="http://www.w3.org/TR/xpath#dt-expanded-name">expanded-name</A> of the 
attribute to be created is specified by a required <CODE>name</CODE> attribute 
and an optional <CODE>namespace</CODE> attribute. Instantiating an 
<CODE>xsl:attribute</CODE> element adds an attribute node to the containing 
result element node. The content of the <CODE>xsl:attribute</CODE> element is a 
template for the value of the created attribute.</P>
<P>The <CODE>name</CODE> attribute is interpreted as an <A 
href="http://www.w3.org/TR/xslt#dt-attribute-value-template">attribute value 
template</A>. It is an error if the string that results from instantiating the 
attribute value template is not a <A 
href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</A> or is the string 
<CODE>xmlns</CODE>. An XSLT processor may signal the error; if it does not 
signal the error, it must recover by not adding the attribute to the result 
tree. If the <CODE>namespace</CODE> attribute is not present, then the <A 
href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</A> is expanded into an 
expanded-name using the namespace declarations in effect for the 
<CODE>xsl:attribute</CODE> element, <I>not</I> including any default namespace 
declaration.</P>
<P>If the <CODE>namespace</CODE> attribute is present, then it also is 
interpreted as an <A 
href="http://www.w3.org/TR/xslt#dt-attribute-value-template">attribute value 
template</A>. The string that results from instantiating it should be a URI 
reference. It is not an error if the string is not a syntactically legal URI 
reference. If the string is empty, then the expanded-name of the attribute has a 
null namespace URI. Otherwise, the string is used as the namespace URI of the 
expanded-name of the attribute to be created. The local part of the <A 
href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</A> specified by the 
<CODE>name</CODE> attribute is used as the local part of the expanded-name of 
the attribute to be created.</P>
<P>XSLT processors may make use of the prefix of the <A 
href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</A> specified in the 
<CODE>name</CODE> attribute when selecting the prefix used for outputting the 
created attribute as XML; however, they are not required to do so and, if the 
prefix is <CODE>xmlns</CODE>, they must not do so. Thus, although it is not an 
error to do:</P><PRE>&lt;xsl:attribute name="xmlns:xsl" namespace="whatever"&gt;http://www.w3.org/1999/XSL/Transform&lt;/xsl:attribute&gt;</PRE>
<P>it will not result in a namespace declaration being output.</P>
<P>Adding an attribute to an element replaces any existing attribute of that 
element with the same expanded-name.</P>
<P>The following are all errors:</P>
<UL>
  <LI>
  <P>Adding an attribute to an element after children have been added to it; 
  implementations may either signal the error or ignore the attribute.</P>
  <LI>
  <P>Adding an attribute to a node that is not an element; implementations may 
  either signal the error or ignore the attribute.</P>
  <LI>
  <P>Creating nodes other than text nodes during the instantiation of the 
  content of the <CODE>xsl:attribute</CODE> element; implementations may either 
  signal the error or ignore the offending nodes.</P></LI></UL>
<BLOCKQUOTE><B>NOTE:</B>When an <CODE>xsl:attribute</CODE> contains a text 
  node with a newline, then the XML output must contain a character reference. 
  For example, <PRE>&lt;xsl:attribute name="a"&gt;x
y&lt;/xsl:attribute&gt;</PRE>will result in the output <PRE>a="x&amp;#xA;y"</PRE>(or with any equivalent character reference). The 
  XML output cannot be <PRE>a="x
y"</PRE>This is because XML 1.0 requires newline characters in attribute 
  values to be normalized into spaces but requires character references to 
  newline characters not to be normalized. The attribute values in the data 
  model represent the attribute value after normalization. If a newline 
  occurring in an attribute value in the tree were output as a newline character 
  rather than as character reference, then the attribute value in the tree 
  created by reparsing the XML would contain a space not a newline, which would 
  mean that the tree had not been output correctly.</BLOCKQUOTE>
<H4><A name=attribute-sets></A>7.1.4 Named Attribute Sets</H4>
<P class=element-syntax><A name=element-attribute-set></A><CODE>&lt;!-- 
Category: top-level-element 
--&gt;<BR>&lt;xsl:attribute-set<BR>&nbsp;&nbsp;<B>name</B> = <VAR>qname</VAR> 
<BR>&nbsp;&nbsp;use-attribute-sets = 
<VAR>qnames</VAR>&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: <A 
href="http://www.w3.org/TR/xslt#element-attribute">xsl:attribute</A>* 
--&gt;<BR>&lt;/xsl:attribute-set&gt;</CODE></P>
<P>The <CODE>xsl:attribute-set</CODE> element defines a named set of attributes. 
The <CODE>name</CODE> attribute specifies the name of the attribute set. The 
value of the <CODE>name</CODE> attribute is a <A 
href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</A>, which is expanded 
as described in <A href="http://www.w3.org/TR/xslt#qname">[<B>2.4 Qualified 
Names</B>]</A>. The content of the <CODE>xsl:attribute-set</CODE> element 
consists of zero or more <CODE>xsl:attribute</CODE> elements that specify the 
attributes in the set.</P>
<P>Attribute sets are used by specifying a <CODE>use-attribute-sets</CODE> 
attribute on <CODE>xsl:element</CODE>, <CODE>xsl:copy</CODE> (see <A 
href="http://www.w3.org/TR/xslt#copying">[<B>7.5 Copying</B>]</A>) or 
<CODE>xsl:attribute-set</CODE> elements. The value of the 
<CODE>use-attribute-sets</CODE> attribute is a whitespace-separated list of 
names of attribute sets. Each name is specified as a <A 
href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</A>, which is expanded 
as described in <A href="http://www.w3.org/TR/xslt#qname">[<B>2.4 Qualified 
Names</B>]</A>. Specifying a <CODE>use-attribute-sets</CODE> attribute is 
equivalent to adding <CODE>xsl:attribute</CODE> elements for each of the 
attributes in each of the named attribute sets to the beginning of the content 
of the element with the <CODE>use-attribute-sets</CODE> attribute, in the same 
order in which the names of the attribute sets are specified in the 
<CODE>use-attribute-sets</CODE> attribute. It is an error if use of 
<CODE>use-attribute-sets</CODE> attributes on <CODE>xsl:attribute-set</CODE> 
elements causes an attribute set to directly or indirectly use itself.</P>
<P>Attribute sets can also be used by specifying an 
<CODE>xsl:use-attribute-sets</CODE> attribute on a literal result element. The 
value of the <CODE>xsl:use-attribute-sets</CODE> attribute is a 
whitespace-separated list of names of attribute sets. The 
<CODE>xsl:use-attribute-sets</CODE> attribute has the same effect as the 
<CODE>use-attribute-sets</CODE> attribute on <CODE>xsl:element</CODE> with the 
additional rule that attributes specified on the literal result element itself 
are treated as if they were specified by <CODE>xsl:attribute</CODE> elements 
before any actual <CODE>xsl:attribute</CODE> elements but after any 
<CODE>xsl:attribute</CODE> elements implied by the 
<CODE>xsl:use-attribute-sets</CODE> attribute. Thus, for a literal result 
element, attributes from attribute sets named in an 
<CODE>xsl:use-attribute-sets</CODE> attribute will be added first, in the order 
listed in the attribute; next, attributes specified on the literal result 
element will be added; finally, any attributes specified by 
<CODE>xsl:attribute</CODE> elements will be added. Since adding an attribute to 
an element replaces any existing attribute of that element with the same name, 
this means that attributes specified in attribute sets can be overridden by 
attributes specified on the literal result element itself.</P>
<P>The template within each <CODE>xsl:attribute</CODE> element in an 
<CODE>xsl:attribute-set</CODE> element is instantiated each time the attribute 
set is used; it is instantiated using the same current node and current node 
list as is used for instantiating the element bearing the 
<CODE>use-attribute-sets</CODE> or <CODE>xsl:use-attribute-sets</CODE> 
attribute. However, it is the position in the stylesheet of the 
<CODE>xsl:attribute</CODE> element rather than of the element bearing the 
<CODE>use-attribute-sets</CODE> or <CODE>xsl:use-attribute-sets</CODE> attribute 
that determines which variable bindings are visible (see <A 
href="http://www.w3.org/TR/xslt#variables">[<B>11 Variables and 
Parameters</B>]</A>); thus, only variables and parameters declared by <A 
href="http://www.w3.org/TR/xslt#dt-top-level">top-level</A> 
<CODE>xsl:variable</CODE> and <CODE>xsl:param</CODE> elements are visible.</P>
<P>The following example creates a named attribute set <CODE>title-style</CODE> 
and uses it in a template rule.</P><PRE>&lt;xsl:template match="chapter/heading"&gt;
  &lt;fo:block quadding="start" xsl:use-attribute-sets="title-style"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:attribute-set name="title-style"&gt;
  &lt;xsl:attribute name="font-size"&gt;12pt&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="font-weight"&gt;bold&lt;/xsl:attribute&gt;
&lt;/xsl:attribute-set&gt;</PRE>
<P>Multiple definitions of an attribute set with the same expanded-name are 
merged. An attribute from a definition that has higher <A 
href="http://www.w3.org/TR/xslt#dt-import-precedence">import precedence</A> 
takes precedence over an attribute from a definition that has lower <A 
href="http://www.w3.org/TR/xslt#dt-import-precedence">import precedence</A>. It 
is an error if there are two attribute sets that have the same expanded-name and 
equal import precedence and that both contain the same attribute, unless there 
is a definition of the attribute set with higher <A 
href="http://www.w3.org/TR/xslt#dt-import-precedence">import precedence</A> that 
also contains the attribute. An XSLT processor may signal the error; if it does 
not signal the error, it must recover by choosing from amongst the definitions 
that specify the attribute that have the highest import precedence the one that 
was specified last in the stylesheet. Where the attributes in an attribute set 
were specified is relevant only in merging the attributes into the attribute 
set; it makes no difference when the attribute set is used.</P>
<H3><A name=section-Creating-Text></A>7.2 Creating Text</H3>
<P>A template can also contain text nodes. Each text node in a template 
remaining after whitespace has been stripped as specified in <A 
href="http://www.w3.org/TR/xslt#strip">[<B>3.4 Whitespace Stripping</B>]</A> 
will create a text node with the same string-value in the result tree. Adjacent 
text nodes in the result tree are automatically merged.</P>
<P>Note that text is processed at the tree level. Thus, markup of 
<CODE>&amp;lt;</CODE> in a template will be represented in the stylesheet tree 
by a text node that includes the character <CODE>&lt;</CODE>. This will create a 
text node in the result tree that contains a <CODE>&lt;</CODE> character, which 
will be represented by the markup <CODE>&amp;lt;</CODE> (or an equivalent 
character reference) when the result tree is externalized as an XML document 
(unless output escaping is disabled as described in <A 
href="http://www.w3.org/TR/xslt#disable-output-escaping">[<B>16.4 Disabling 
Output Escaping</B>]</A>).</P>
<P class=element-syntax><A name=element-text></A><CODE>&lt;!-- Category: 
instruction --&gt;<BR>&lt;xsl:text<BR>&nbsp;&nbsp;disable-output-escaping = 
"yes" | "no"&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: #PCDATA 
--&gt;<BR>&lt;/xsl:text&gt;</CODE></P>
<P>Literal data characters may also be wrapped in an <CODE>xsl:text</CODE> 
element. This wrapping may change what whitespace characters are stripped (see 
<A href="http://www.w3.org/TR/xslt#strip">[<B>3.4 Whitespace Stripping</B>]</A>) 
but does not affect how the characters are handled by the XSLT processor 
thereafter.</P>
<BLOCKQUOTE><B>NOTE:</B>The <CODE>xml:lang</CODE> and <CODE>xml:space</CODE> 
  attributes are not treated specially by XSLT. In particular, 
  <UL>
    <LI>
    <P>it is the responsibility of the stylesheet author explicitly to generate 
    any <CODE>xml:lang</CODE> or <CODE>xml:space</CODE> attributes that are 
    needed in the result;</P>
    <LI>
    <P>specifying an <CODE>xml:lang</CODE> or <CODE>xml:space</CODE> attribute 
    on an element in the XSLT namespace will not cause any <CODE>xml:lang</CODE> 
    or <CODE>xml:space</CODE> attributes to appear in the 
result.</P></LI></UL></BLOCKQUOTE>
<H3><A name=section-Creating-Processing-Instructions></A>7.3 Creating Processing 
Instructions</H3>
<P class=element-syntax><A name=element-processing-instruction></A><CODE>&lt;!-- 
Category: instruction 
--&gt;<BR>&lt;xsl:processing-instruction<BR>&nbsp;&nbsp;<B>name</B> = { 
<VAR>ncname</VAR> }&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: <VAR>template</VAR> 
--&gt;<BR>&lt;/xsl:processing-instruction&gt;</CODE></P>
<P>The <CODE>xsl:processing-instruction</CODE> element is instantiated to create 
a processing instruction node. The content of the 
<CODE>xsl:processing-instruction</CODE> element is a template for the 
string-value of the processing instruction node. The 
<CODE>xsl:processing-instruction</CODE> element has a required <CODE>name</CODE> 
attribute that specifies the name of the processing instruction node. The value 
of the <CODE>name</CODE> attribute is interpreted as an <A 
href="http://www.w3.org/TR/xslt#dt-attribute-value-template">attribute value 
template</A>.</P>
<P>For example, this</P><PRE>&lt;xsl:processing-instruction name="xml-stylesheet"&gt;href="book.css" type="text/css"&lt;/xsl:processing-instruction&gt;</PRE>
<P>would create the processing instruction</P><PRE>&lt;?xml-stylesheet href="book.css" type="text/css"?&gt;</PRE>
<P>It is an error if the string that results from instantiating the 
<CODE>name</CODE> attribute is not both an <A 
href="http://www.w3.org/TR/REC-xml-names#NT-NCName">NCName</A> and a <A 
href="http://www.w3.org/TR/REC-xml#NT-PITarget">PITarget</A>. An XSLT processor 
may signal the error; if it does not signal the error, it must recover by not 
adding the processing instruction to the result tree.</P>
<BLOCKQUOTE><B>NOTE:</B>This means that 
  <CODE>xsl:processing-instruction</CODE> cannot be used to output an XML 
  declaration. The <CODE>xsl:output</CODE> element should be used instead (see 
  <A href="http://www.w3.org/TR/xslt#output">[<B>16 Output</B>]</A>).</BLOCKQUOTE>
<P>It is an error if instantiating the content of 
<CODE>xsl:processing-instruction</CODE> creates nodes other than text nodes. An 
XSLT processor may signal the error; if it does not signal the error, it must 
recover by ignoring the offending nodes together with their content.</P>
<P>It is an error if the result of instantiating the content of the 
<CODE>xsl:processing-instruction</CODE> contains the string <CODE>?&gt;</CODE>. 
An XSLT processor may signal the error; if it does not signal the error, it must 
recover by inserting a space after any occurrence of <CODE>?</CODE> that is 
followed by a <CODE>&gt;</CODE>.</P>
<H3><A name=section-Creating-Comments></A>7.4 Creating Comments</H3>
<P class=element-syntax><A name=element-comment></A><CODE>&lt;!-- Category: 
instruction --&gt;<BR>&lt;xsl:comment&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: 
<VAR>template</VAR> --&gt;<BR>&lt;/xsl:comment&gt;</CODE></P>
<P>The <CODE>xsl:comment</CODE> element is instantiated to create a comment node 
in the result tree. The content of the <CODE>xsl:comment</CODE> element is a 
template for the string-value of the comment node.</P>
<P>For example, this</P><PRE>&lt;xsl:comment&gt;This file is automatically generated. Do not edit!&lt;/xsl:comment&gt;</PRE>
<P>would create the comment</P><PRE>&lt;!--This file is automatically generated. Do not edit!--&gt;</PRE>
<P>It is an error if instantiating the content of <CODE>xsl:comment</CODE> 
creates nodes other than text nodes. An XSLT processor may signal the error; if 
it does not signal the error, it must recover by ignoring the offending nodes 
together with their content.</P>
<P>It is an error if the result of instantiating the content of the 
<CODE>xsl:comment</CODE> contains the string <CODE>--</CODE> or ends with 
<CODE>-</CODE>. An XSLT processor may signal the error; if it does not signal 
the error, it must recover by inserting a space after any occurrence of 
<CODE>-</CODE> that is followed by another <CODE>-</CODE> or that ends the 
comment.</P>
<H3><A name=copying></A>7.5 Copying</H3>
<P class=element-syntax><A name=element-copy></A><CODE>&lt;!-- Category: 
instruction --&gt;<BR>&lt;xsl:copy<BR>&nbsp;&nbsp;use-attribute-sets = 
<VAR>qnames</VAR>&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: <VAR>template</VAR> 
--&gt;<BR>&lt;/xsl:copy&gt;</CODE></P>
<P>The <CODE>xsl:copy</CODE> element provides an easy way of copying the current 
node. Instantiating the <CODE>xsl:copy</CODE> element creates a copy of the 
current node. The namespace nodes of the current node are automatically copied 
as well, but the attributes and children of the node are not automatically 
copied. The content of the <CODE>xsl:copy</CODE> element is a template for the 
attributes and children of the created node; the content is instantiated only 
for nodes of types that can have attributes or children (i.e. root nodes and 
element nodes).</P>
<P>The <CODE>xsl:copy</CODE> element may have a <CODE>use-attribute-sets</CODE> 
attribute (see <A href="http://www.w3.org/TR/xslt#attribute-sets">[<B>7.1.4 
Named Attribute Sets</B>]</A>). This is used only when copying element 
nodes.</P>
<P>The root node is treated specially because the root node of the result tree 
is created implicitly. When the current node is the root node, 
<CODE>xsl:copy</CODE> will not create a root node, but will just use the content 
template.</P>
<P>For example, the identity transformation can be written using 
<CODE>xsl:copy</CODE> as follows:</P><PRE>&lt;xsl:template match="@*|node()"&gt;
  &lt;xsl:copy&gt;
    &lt;xsl:apply-templates select="@*|node()"/&gt;
  &lt;/xsl:copy&gt;
&lt;/xsl:template&gt;</PRE>
<P>When the current node is an attribute, then if it would be an error to use 
<CODE>xsl:attribute</CODE> to create an attribute with the same name as the 
current node, then it is also an error to use <CODE>xsl:copy</CODE> (see <A 
href="http://www.w3.org/TR/xslt#creating-attributes">[<B>7.1.3 Creating 
Attributes with <CODE>xsl:attribute</CODE></B>]</A>).</P>
<P>The following example shows how <CODE>xml:lang</CODE> attributes can be 
easily copied through from source to result. If a stylesheet defines the 
following named template:</P><PRE>&lt;xsl:template name="apply-templates-copy-lang"&gt;
 &lt;xsl:for-each select="@xml:lang"&gt;
   &lt;xsl:copy/&gt;
 &lt;/xsl:for-each&gt;
 &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;</PRE>
<P>then it can simply do</P><PRE>&lt;xsl:call-template name="apply-templates-copy-lang"/&gt;</PRE>
<P>instead of</P><PRE>&lt;xsl:apply-templates/&gt;</PRE>
<P>when it wants to copy the <CODE>xml:lang</CODE> attribute.</P>
<H3><A name=section-Computing-Generated-Text></A>7.6 Computing Generated 
Text</H3>
<P>Within a template, the <CODE>xsl:value-of</CODE> element can be used to 
compute generated text, for example by extracting text from the source tree or 
by inserting the value of a variable. The <CODE>xsl:value-of</CODE> element does 
this with an <A href="http://www.w3.org/TR/xslt#dt-expression">expression</A> 
that is specified as the value of the <CODE>select</CODE> attribute. Expressions 
can also be used inside attribute values of literal result elements by enclosing 
the expression in curly braces (<CODE>{}</CODE>).</P>
<H4><A name=value-of></A>7.6.1 Generating Text with 
<CODE>xsl:value-of</CODE></H4>
<P class=element-syntax><A name=element-value-of></A><CODE>&lt;!-- Category: 
instruction --&gt;<BR>&lt;xsl:value-of<BR>&nbsp;&nbsp;<B>select</B> = 
<VAR>string-expression</VAR> <BR>&nbsp;&nbsp;disable-output-escaping = "yes" | 
"no"&nbsp;/&gt;</CODE></P>
<P>The <CODE>xsl:value-of</CODE> element is instantiated to create a text node 
in the result tree. The required <CODE>select</CODE> attribute is an <A 
href="http://www.w3.org/TR/xslt#dt-expression">expression</A>; this expression 
is evaluated and the resulting object is converted to a string as if by a call 
to the <B><A href="http://www.w3.org/TR/xpath#function-string">string</A></B> 
function. The string specifies the string-value of the created text node. If the 
string is empty, no text node will be created. The created text node will be 
merged with any adjacent text nodes.</P>
<P>The <CODE>xsl:copy-of</CODE> element can be used to copy a node-set over to 
the result tree without converting it to a string. See <A 
href="http://www.w3.org/TR/xslt#copy-of">[<B>11.3 Using Values of Variables and 
Parameters with <CODE>xsl:copy-of</CODE></B>]</A>.</P>
<P>For example, the following creates an HTML paragraph from a 
<CODE>person</CODE> element with <CODE>given-name</CODE> and 
<CODE>family-name</CODE> attributes. The paragraph will contain the value of the 
<CODE>given-name</CODE> attribute of the current node followed by a space and 
the value of the <CODE>family-name</CODE> attribute of the current node.</P><PRE>&lt;xsl:template match="person"&gt;
  &lt;p&gt;
   &lt;xsl:value-of select="@given-name"/&gt;
   &lt;xsl:text&gt; &lt;/xsl:text&gt;
   &lt;xsl:value-of select="@family-name"/&gt;
  &lt;/p&gt;
&lt;/xsl:template&gt;</PRE>
<P>For another example, the following creates an HTML paragraph from a 
<CODE>person</CODE> element with <CODE>given-name</CODE> and 
<CODE>family-name</CODE> children elements. The paragraph will contain the 
string-value of the first <CODE>given-name</CODE> child element of the current 
node followed by a space and the string-value of the first 
<CODE>family-name</CODE> child element of the current node.</P><PRE>&lt;xsl:template match="person"&gt;
  &lt;p&gt;
   &lt;xsl:value-of select="given-name"/&gt;
   &lt;xsl:text&gt; &lt;/xsl:text&gt;
   &lt;xsl:value-of select="family-name"/&gt;
  &lt;/p&gt;
&lt;/xsl:template&gt;</PRE>
<P>The following precedes each <CODE>procedure</CODE> element with a paragraph 
containing the security level of the procedure. It assumes that the security 
level that applies to a procedure is determined by a <CODE>security</CODE> 
attribute on the procedure element or on an ancestor element of the procedure. 
It also assumes that if more than one such element has a <CODE>security</CODE> 
attribute then the security level is determined by the element that is closest 
to the procedure.</P><PRE>&lt;xsl:template match="procedure"&gt;
  &lt;fo:block&gt;
    &lt;xsl:value-of select="ancestor-or-self::*[@security][1]/@security"/&gt;
  &lt;/fo:block&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;</PRE>
<H4><A name=attribute-value-templates></A>7.6.2 Attribute Value Templates</H4>
<P><A name=dt-attribute-value-template></A>In an attribute value that is 
interpreted as an <B>attribute value template</B>, such as an attribute of a 
literal result element, an <A 
href="http://www.w3.org/TR/xslt#dt-expression">expression</A> can be used by 
surrounding the expression with curly braces (<CODE>{}</CODE>). The attribute 
value template is instantiated by replacing the expression together with 
surrounding curly braces by the result of evaluating the expression and 
converting the resulting object to a string as if by a call to the <B><A 
href="http://www.w3.org/TR/xpath#function-string">string</A></B> function. Curly 
braces are not recognized in an attribute value in an XSLT stylesheet unless the 
attribute is specifically stated to be one that is interpreted as an attribute 
value template; in an element syntax summary, the value of such attributes is 
surrounded by curly braces.</P>
<BLOCKQUOTE><B>NOTE:</B>Not all attributes are interpreted as attribute value 
  templates. Attributes whose value is an expression or pattern, attributes of 
  <A href="http://www.w3.org/TR/xslt#dt-top-level">top-level</A> elements and 
  attributes that refer to named XSLT objects are not interpreted as attribute 
  value templates. In addition, <CODE>xmlns</CODE> attributes are not 
  interpreted as attribute value templates; it would not be conformant with the 
  XML Namespaces Recommendation to do this.</BLOCKQUOTE>
<P>The following example creates an <CODE>img</CODE> result element from a 
<CODE>photograph</CODE> element in the source; the value of the <CODE>src</CODE> 
attribute of the <CODE>img</CODE> element is computed from the value of the 
<CODE>image-dir</CODE> variable and the string-value of the <CODE>href</CODE> 
child of the <CODE>photograph</CODE> element; the value of the 
<CODE>width</CODE> attribute of the <CODE>img</CODE> element is computed from 
the value of the <CODE>width</CODE> attribute of the <CODE>size</CODE> child of 
the <CODE>photograph</CODE> element:</P><PRE>&lt;xsl:variable name="image-dir"&gt;/images&lt;/xsl:variable&gt;

&lt;xsl:template match="photograph"&gt;
&lt;img src="{$image-dir}/{href}" width="{size/@width}"/&gt;
&lt;/xsl:template&gt;</PRE>
<P>With this source</P><PRE>&lt;photograph&gt;
  &lt;href&gt;headquarters.jpg&lt;/href&gt;
  &lt;size width="300"/&gt;
&lt;/photograph&gt;</PRE>
<P>the result would be</P><PRE>&lt;img src="/images/headquarters.jpg" width="300"/&gt;</PRE>
<P>When an attribute value template is instantiated, a double left or right 
curly brace outside an expression will be replaced by a single curly brace. It 
is an error if a right curly brace occurs in an attribute value template outside 
an expression without being followed by a second right curly brace. A right 
curly brace inside a <A href="http://www.w3.org/TR/xpath#NT-Literal">Literal</A> 
in an expression is not recognized as terminating the expression.</P>
<P>Curly braces are <I>not</I> recognized recursively inside expressions. For 
example:</P><PRE style="COLOR: red">&lt;a href="#{id({@ref})/title}"&gt;</PRE>
<P>is <I>not</I> allowed. Instead, use simply:</P><PRE>&lt;a href="#{id(@ref)/title}"&gt;</PRE>
<H3><A name=number></A>7.7 Numbering</H3>
<P class=element-syntax><A name=element-number></A><CODE>&lt;!-- Category: 
instruction --&gt;<BR>&lt;xsl:number<BR>&nbsp;&nbsp;level = "single" | 
"multiple" | "any"<BR>&nbsp;&nbsp;count = <VAR>pattern</VAR> 
<BR>&nbsp;&nbsp;from = <VAR>pattern</VAR> <BR>&nbsp;&nbsp;value = 
<VAR>number-expression</VAR> <BR>&nbsp;&nbsp;format = { <VAR>string</VAR> 
}<BR>&nbsp;&nbsp;lang = { <VAR>nmtoken</VAR> }<BR>&nbsp;&nbsp;letter-value = { 
"alphabetic" | "traditional" }<BR>&nbsp;&nbsp;grouping-separator = { 
<VAR>char</VAR> }<BR>&nbsp;&nbsp;grouping-size = { <VAR>number</VAR> 
}&nbsp;/&gt;</CODE></P>
<P>The <CODE>xsl:number</CODE> element is used to insert a formatted number into 
the result tree. The number to be inserted may be specified by an expression. 
The <CODE>value</CODE> attribute contains an <A 
href="http://www.w3.org/TR/xslt#dt-expression">expression</A>. The expression is 
evaluated and the resulting object is converted to a number as if by a call to 
the <B><A href="http://www.w3.org/TR/xpath#function-number">number</A></B> 
function. The number is rounded to an integer and then converted to a string 
using the attributes specified in <A 
href="http://www.w3.org/TR/xslt#convert">[<B>7.7.1 Number to String Conversion 
Attributes</B>]</A>; in this context, the value of each of these attributes is 
interpreted as an <A 
href="http://www.w3.org/TR/xslt#dt-attribute-value-template">attribute value 
template</A>. After conversion, the resulting string is inserted in the result 
tree. For example, the following example numbers a sorted list:</P><PRE>&lt;xsl:template match="items"&gt;
  &lt;xsl:for-each select="item"&gt;
    &lt;xsl:sort select="."/&gt;
    &lt;p&gt;
      &lt;xsl:number value="position()" format="1. "/&gt;
      &lt;xsl:value-of select="."/&gt;
    &lt;/p&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;</PRE>
<P>If no <CODE>value</CODE> attribute is specified, then the 
<CODE>xsl:number</CODE> element inserts a number based on the position of the 
current node in the source tree. The following attributes control how the 
current node is to be numbered:</P>
<UL>
  <LI>
  <P>The <CODE>level</CODE> attribute specifies what levels of the source tree 
  should be considered; it has the values <CODE>single</CODE>, 
  <CODE>multiple</CODE> or <CODE>any</CODE>. The default is 
  <CODE>single</CODE>.</P>
  <LI>
  <P>The <CODE>count</CODE> attribute is a pattern that specifies what nodes 
  should be counted at those levels. If <CODE>count</CODE> attribute is not 
  specified, then it defaults to the pattern that matches any node with the same 
  node type as the current node and, if the current node has an expanded-name, 
  with the same expanded-name as the current node.</P>
  <LI>
  <P>The <CODE>from</CODE> attribute is a pattern that specifies where counting 
  starts.</P></LI></UL>
<P>In addition, the attributes specified in <A 
href="http://www.w3.org/TR/xslt#convert">[<B>7.7.1 Number to String Conversion 
Attributes</B>]</A> are used for number to string conversion, as in the case 
when the <CODE>value</CODE> attribute is specified.</P>
<P>The <CODE>xsl:number</CODE> element first constructs a list of positive 
integers using the <CODE>level</CODE>, <CODE>count</CODE> and <CODE>from</CODE> 
attributes:</P>
<UL>
  <LI>
  <P>When <CODE>level="single"</CODE>, it goes up to the first node in the 
  ancestor-or-self axis that matches the <CODE>count</CODE> pattern, and 
  constructs a list of length one containing one plus the number of preceding 
  siblings of that ancestor that match the <CODE>count</CODE> pattern. If there 
  is no such ancestor, it constructs an empty list. If the <CODE>from</CODE> 
  attribute is specified, then the only ancestors that are searched are those 
  that are descendants of the nearest ancestor that matches the 
  <CODE>from</CODE> pattern. Preceding siblings has the same meaning here as 
  with the <CODE>preceding-sibling</CODE> axis.</P>
  <LI>
  <P>When <CODE>level="multiple"</CODE>, it constructs a list of all ancestors 
  of the current node in document order followed by the element itself; it then 
  selects from the list those nodes that match the <CODE>count</CODE> pattern; 
  it then maps each node in the list to one plus the number of preceding 
  siblings of that node that match the <CODE>count</CODE> pattern. If the 
  <CODE>from</CODE> attribute is specified, then the only ancestors that are 
  searched are those that are descendants of the nearest ancestor that matches 
  the <CODE>from</CODE> pattern. Preceding siblings has the same meaning here as 
  with the <CODE>preceding-sibling</CODE> axis.</P>
  <LI>
  <P>When <CODE>level="any"</CODE>, it constructs a list of length one 
  containing the number of nodes that match the <CODE>count</CODE> pattern and 
  belong to the set containing the current node and all nodes at any level of 
  the document that are before the current node in document order, excluding any 
  namespace and attribute nodes (in other words the union of the members of the 
  <CODE>preceding</CODE> and <CODE>ancestor-or-self</CODE> axes). If the 
  <CODE>from</CODE> attribute is specified, then only nodes after the first node 
  before the current node that match the <CODE>from</CODE> pattern are 
  considered.</P></LI></UL>
<P>The list of numbers is then converted into a string using the attributes 
specified in <A href="http://www.w3.org/TR/xslt#convert">[<B>7.7.1 Number to 
String Conversion Attributes</B>]</A>; in this context, the value of each of 
these attributes is interpreted as an <A 
href="http://www.w3.org/TR/xslt#dt-attribute-value-template">attribute value 
template</A>. After conversion, the resulting string is inserted in the result 
tree.</P>
<P>The following would number the items in an ordered list:</P><PRE>&lt;xsl:template match="ol/item"&gt;
  &lt;fo:block&gt;
    &lt;xsl:number/&gt;&lt;xsl:text&gt;. &lt;/xsl:text&gt;&lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;xsl:template&gt;</PRE>
<P>The following two rules would number <CODE>title</CODE> elements. This is 
intended for a document that contains a sequence of chapters followed by a 
sequence of appendices, where both chapters and appendices contain sections, 
which in turn contain subsections. Chapters are numbered 1, 2, 3; appendices are 
numbered A, B, C; sections in chapters are numbered 1.1, 1.2, 1.3; sections in 
appendices are numbered A.1, A.2, A.3.</P><PRE>&lt;xsl:template match="title"&gt;
  &lt;fo:block&gt;
     &lt;xsl:number level="multiple"
                 count="chapter|section|subsection"
                 format="1.1 "/&gt;
     &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="appendix//title" priority="1"&gt;
  &lt;fo:block&gt;
     &lt;xsl:number level="multiple"
                 count="appendix|section|subsection"
                 format="A.1 "/&gt;
     &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;</PRE>
<P>The following example numbers notes sequentially within a chapter:</P><PRE>&lt;xsl:template match="note"&gt;
  &lt;fo:block&gt;
     &lt;xsl:number level="any" from="chapter" format="(1) "/&gt;
     &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;</PRE>
<P>The following example would number <CODE>H4</CODE> elements in HTML with a 
three-part label:</P><PRE>&lt;xsl:template match="H4"&gt;
 &lt;fo:block&gt;
   &lt;xsl:number level="any" from="H1" count="H2"/&gt;
   &lt;xsl:text&gt;.&lt;/xsl:text&gt;
   &lt;xsl:number level="any" from="H2" count="H3"/&gt;
   &lt;xsl:text&gt;.&lt;/xsl:text&gt;
   &lt;xsl:number level="any" from="H3" count="H4"/&gt;
   &lt;xsl:text&gt; &lt;/xsl:text&gt;
   &lt;xsl:apply-templates/&gt;
 &lt;/fo:block&gt;
&lt;/xsl:template&gt;</PRE>
<H4><A name=convert></A>7.7.1 Number to String Conversion Attributes</H4>
<P>The following attributes are used to control conversion of a list of numbers 
into a string. The numbers are integers greater than 0. The attributes are all 
optional.</P>
<P>The main attribute is <CODE>format</CODE>. The default value for the 
<CODE>format</CODE> attribute is <CODE>1</CODE>. The <CODE>format</CODE> 
attribute is split into a sequence of tokens where each token is a maximal 
sequence of alphanumeric characters or a maximal sequence of non-alphanumeric 
characters. Alphanumeric means any character that has a Unicode category of Nd, 
Nl, No, Lu, Ll, Lt, Lm or Lo. The alphanumeric tokens (format tokens) specify 
the format to be used for each number in the list. If the first token is a 
non-alphanumeric token, then the constructed string will start with that token; 
if the last token is non-alphanumeric token, then the constructed string will 
end with that token. Non-alphanumeric tokens that occur between two format 
tokens are separator tokens that are used to join numbers in the list. The 
<VAR>n</VAR>th format token will be used to format the <VAR>n</VAR>th number in 
the list. If there are more numbers than format tokens, then the last format 
token will be used to format remaining numbers. If there are no format tokens, 
then a format token of <CODE>1</CODE> is used to format all numbers. The format 
token specifies the string to be used to represent the number 1. Each number 
after the first will be separated from the preceding number by the separator 
token preceding the format token used to format that number, or, if there are no 
separator tokens, then by <CODE>.</CODE> (a period character).</P>
<P>Format tokens are a superset of the allowed values for the <CODE>type</CODE> 
attribute for the <CODE>OL</CODE> element in HTML 4.0 and are interpreted as 
follows:</P>
<UL>
  <LI>
  <P>Any token where the last character has a decimal digit value of 1 (as 
  specified in the Unicode character property database), and the Unicode value 
  of preceding characters is one less than the Unicode value of the last 
  character generates a decimal representation of the number where each number 
  is at least as long as the format token. Thus, a format token <CODE>1</CODE> 
  generates the sequence <CODE>1 2 ... 10 11 12 ...</CODE>, and a format token 
  <CODE>01</CODE> generates the sequence <CODE>01 02 ... 09 10 11 12 ... 99 100 
  101</CODE>.</P>
  <LI>
  <P>A format token <CODE>A</CODE> generates the sequence <CODE>A B C ... Z AA 
  AB AC...</CODE>.</P>
  <LI>
  <P>A format token <CODE>a</CODE> generates the sequence <CODE>a b c ... z aa 
  ab ac...</CODE>.</P>
  <LI>
  <P>A format token <CODE>i</CODE> generates the sequence <CODE>i ii iii iv v vi 
  vii viii ix x ...</CODE>.</P>
  <LI>
  <P>A format token <CODE>I</CODE> generates the sequence <CODE>I II III IV V VI 
  VII VIII IX X ...</CODE>.</P>
  <LI>
  <P>Any other format token indicates a numbering sequence that starts with that 
  token. If an implementation does not support a numbering sequence that starts 
  with that token, it must use a format token of <CODE>1</CODE>.</P></LI></UL>
<P>When numbering with an alphabetic sequence, the <CODE>lang</CODE> attribute 
specifies which language's alphabet is to be used; it has the same range of 
values as <CODE>xml:lang</CODE> <A 
href="http://www.w3.org/TR/xslt#XML">[XML]</A>; if no <CODE>lang</CODE> value is 
specified, the language should be determined from the system environment. 
Implementers should document for which languages they support numbering.</P>
<BLOCKQUOTE><B>NOTE:</B>Implementers should not make any assumptions about how 
  numbering works in particular languages and should properly research the 
  languages that they wish to support. The numbering conventions of many 
  languages are very different from English.</BLOCKQUOTE>
<P>The <CODE>letter-value</CODE> attribute disambiguates between numbering 
sequences that use letters. In many languages there are two commonly used 
numbering sequences that use letters. One numbering sequence assigns numeric 
values to letters in alphabetic sequence, and the other assigns numeric values 
to each letter in some other manner traditional in that language. In English, 
these would correspond to the numbering sequences specified by the format tokens 
<CODE>a</CODE> and <CODE>i</CODE>. In some languages, the first member of each 
sequence is the same, and so the format token alone would be ambiguous. A value 
of <CODE>alphabetic</CODE> specifies the alphabetic sequence; a value of 
<CODE>traditional</CODE> specifies the other sequence. If the 
<CODE>letter-value</CODE> attribute is not specified, then it is 
implementation-dependent how any ambiguity is resolved.</P>
<BLOCKQUOTE><B>NOTE:</B>It is possible for two conforming XSLT processors not 
  to convert a number to exactly the same string. Some XSLT processors may not 
  support some languages. Furthermore, there may be variations possible in the 
  way conversions are performed for any particular language that are not 
  specifiable by the attributes on <CODE>xsl:number</CODE>. Future versions of 
  XSLT may provide additional attributes to provide control over these 
  variations. Implementations may also use implementation-specific namespaced 
  attributes on <CODE>xsl:number</CODE> for this.</BLOCKQUOTE>
<P>The <CODE>grouping-separator</CODE> attribute gives the separator used as a 
grouping (e.g. thousands) separator in decimal numbering sequences, and the 
optional <CODE>grouping-size</CODE> specifies the size (normally 3) of the 
grouping. For example, <CODE>grouping-separator=","</CODE> and 
<CODE>grouping-size="3"</CODE> would produce numbers of the form 
<CODE>1,000,000</CODE>. If only one of the <CODE>grouping-separator</CODE> and 
<CODE>grouping-size</CODE> attributes is specified, then it is ignored.</P>
<P>Here are some examples of conversion specifications:</P>
<UL>
  <LI>
  <P><CODE>format="&amp;#x30A2;"</CODE> specifies Katakana numbering</P>
  <LI>
  <P><CODE>format="&amp;#x30A4;"</CODE> specifies Katakana numbering in the 
  "iroha" order</P>
  <LI>
  <P><CODE>format="&amp;#x0E51;"</CODE> specifies numbering with Thai digits</P>
  <LI>
  <P><CODE>format="&amp;#x05D0;" letter-value="traditional"</CODE> specifies 
  "traditional" Hebrew numbering</P>
  <LI>
  <P><CODE>format="&amp;#x10D0;" letter-value="traditional"</CODE> specifies 
  Georgian numbering</P>
  <LI>
  <P><CODE>format="&amp;#x03B1;" letter-value="traditional"</CODE> specifies 
  "classical" Greek numbering</P>
  <LI>
  <P><CODE>format="&amp;#x0430;" letter-value="traditional"</CODE> specifies Old 
  Slavic numbering</P></LI></UL>
<H2><A name=for-each></A>8 Repetition</H2>
<P class=element-syntax><A name=element-for-each></A><CODE>&lt;!-- Category: 
instruction --&gt;<BR>&lt;xsl:for-each<BR>&nbsp;&nbsp;<B>select</B> = 
<VAR>node-set-expression</VAR>&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: (<A 
href="http://www.w3.org/TR/xslt#element-sort">xsl:sort</A>*, 
<VAR>template</VAR>) --&gt;<BR>&lt;/xsl:for-each&gt;</CODE></P>
<P>When the result has a known regular structure, it is useful to be able to 
specify directly the template for selected nodes. The <CODE>xsl:for-each</CODE> 
instruction contains a template, which is instantiated for each node selected by 
the <A href="http://www.w3.org/TR/xslt#dt-expression">expression</A> specified 
by the <CODE>select</CODE> attribute. The <CODE>select</CODE> attribute is 
required. The expression must evaluate to a node-set. The template is 
instantiated with the selected node as the <A 
href="http://www.w3.org/TR/xslt#dt-current-node">current node</A>, and with a 
list of all of the selected nodes as the <A 
href="http://www.w3.org/TR/xslt#dt-current-node-list">current node list</A>. The 
nodes are processed in document order, unless a sorting specification is present 
(see <A href="http://www.w3.org/TR/xslt#sorting">[<B>10 Sorting</B>]</A>).</P>
<P>For example, given an XML document with this structure</P><PRE>&lt;customers&gt;
  &lt;customer&gt;
    &lt;name&gt;...&lt;/name&gt;
    &lt;order&gt;...&lt;/order&gt;
    &lt;order&gt;...&lt;/order&gt;
  &lt;/customer&gt;
  &lt;customer&gt;
    &lt;name&gt;...&lt;/name&gt;
    &lt;order&gt;...&lt;/order&gt;
    &lt;order&gt;...&lt;/order&gt;
  &lt;/customer&gt;
&lt;/customers&gt;</PRE>
<P>the following would create an HTML document containing a table with a row for 
each <CODE>customer</CODE> element</P><PRE>&lt;xsl:template match="/"&gt;
  &lt;html&gt;
    &lt;head&gt;
      &lt;title&gt;Customers&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
      &lt;table&gt;
        &lt;tbody&gt;
          &lt;xsl:for-each select="customers/customer"&gt;
            &lt;tr&gt;
              &lt;th&gt;
                &lt;xsl:apply-templates select="name"/&gt;
              &lt;/th&gt;
              &lt;xsl:for-each select="order"&gt;
                &lt;td&gt;
                  &lt;xsl:apply-templates/&gt;
                &lt;/td&gt;
              &lt;/xsl:for-each&gt;
            &lt;/tr&gt;
          &lt;/xsl:for-each&gt;
        &lt;/tbody&gt;
      &lt;/table&gt;
    &lt;/body&gt;
  &lt;/html&gt;
&lt;/xsl:template&gt;</PRE>
<H2><A name=section-Conditional-Processing></A>9 Conditional Processing</H2>
<P>There are two instructions in XSLT that support conditional processing in a 
template: <CODE>xsl:if</CODE> and <CODE>xsl:choose</CODE>. The 
<CODE>xsl:if</CODE> instruction provides simple if-then conditionality; the 
<CODE>xsl:choose</CODE> instruction supports selection of one choice when there 
are several possibilities.</P>
<H3><A name=section-Conditional-Processing-with-xsl:if></A>9.1 Conditional 
Processing with <CODE>xsl:if</CODE></H3>
<P class=element-syntax><A name=element-if></A><CODE>&lt;!-- Category: 
instruction --&gt;<BR>&lt;xsl:if<BR>&nbsp;&nbsp;<B>test</B> = 
<VAR>boolean-expression</VAR>&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: 
<VAR>template</VAR> --&gt;<BR>&lt;/xsl:if&gt;</CODE></P>
<P>The <CODE>xsl:if</CODE> element has a <CODE>test</CODE> attribute, which 
specifies an <A href="http://www.w3.org/TR/xslt#dt-expression">expression</A>. 
The content is a template. The expression is evaluated and the resulting object 
is converted to a boolean as if by a call to the <B><A 
href="http://www.w3.org/TR/xpath#function-boolean">boolean</A></B> function. If 
the result is true, then the content template is instantiated; otherwise, 
nothing is created. In the following example, the names in a group of names are 
formatted as a comma separated list:</P><PRE>&lt;xsl:template match="namelist/name"&gt;
  &lt;xsl:apply-templates/&gt;
  &lt;xsl:if test="not(position()=last())"&gt;, &lt;/xsl:if&gt;
&lt;/xsl:template&gt;</PRE>
<P>The following colors every other table row yellow:</P><PRE>&lt;xsl:template match="item"&gt;
  &lt;tr&gt;
    &lt;xsl:if test="position() mod 2 = 0"&gt;
       &lt;xsl:attribute name="bgcolor"&gt;yellow&lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/tr&gt;
&lt;/xsl:template&gt;</PRE>
<H3><A name=section-Conditional-Processing-with-xsl:choose></A>9.2 Conditional 
Processing with <CODE>xsl:choose</CODE></H3>
<P class=element-syntax><A name=element-choose></A><CODE>&lt;!-- Category: 
instruction --&gt;<BR>&lt;xsl:choose&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: (<A 
href="http://www.w3.org/TR/xslt#element-when">xsl:when</A>+, <A 
href="http://www.w3.org/TR/xslt#element-otherwise">xsl:otherwise</A>?) 
--&gt;<BR>&lt;/xsl:choose&gt;</CODE></P>
<P class=element-syntax><A 
name=element-when></A><CODE>&lt;xsl:when<BR>&nbsp;&nbsp;<B>test</B> = 
<VAR>boolean-expression</VAR>&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: 
<VAR>template</VAR> --&gt;<BR>&lt;/xsl:when&gt;</CODE></P>
<P class=element-syntax><A 
name=element-otherwise></A><CODE>&lt;xsl:otherwise&gt;<BR>&nbsp;&nbsp;&lt;!-- 
Content: <VAR>template</VAR> --&gt;<BR>&lt;/xsl:otherwise&gt;</CODE></P>
<P>The <CODE>xsl:choose</CODE> element selects one among a number of possible 
alternatives. It consists of a sequence of <CODE>xsl:when</CODE> elements 
followed by an optional <CODE>xsl:otherwise</CODE> element. Each 
<CODE>xsl:when</CODE> element has a single attribute, <CODE>test</CODE>, which 
specifies an <A href="http://www.w3.org/TR/xslt#dt-expression">expression</A>. 
The content of the <CODE>xsl:when</CODE> and <CODE>xsl:otherwise</CODE> elements 
is a template. When an <CODE>xsl:choose</CODE> element is processed, each of the 
<CODE>xsl:when</CODE> elements is tested in turn, by evaluating the expression 
and converting the resulting object to a boolean as if by a call to the <B><A 
href="http://www.w3.org/TR/xpath#function-boolean">boolean</A></B> function. The 
content of the first, and only the first, <CODE>xsl:when</CODE> element whose 
test is true is instantiated. If no <CODE>xsl:when</CODE> is true, the content 
of the <CODE>xsl:otherwise</CODE> element is instantiated. If no 
<CODE>xsl:when</CODE> element is true, and no <CODE>xsl:otherwise</CODE> element 
is present, nothing is created.</P>
<P>The following example enumerates items in an ordered list using arabic 
numerals, letters, or roman numerals depending on the depth to which the ordered 
lists are nested.</P><PRE>&lt;xsl:template match="orderedlist/listitem"&gt;
  &lt;fo:list-item indent-start='2pi'&gt;
    &lt;fo:list-item-label&gt;
      &lt;xsl:variable name="level"
                    select="count(ancestor::orderedlist) mod 3"/&gt;
      &lt;xsl:choose&gt;
        &lt;xsl:when test='$level=1'&gt;
          &lt;xsl:number format="i"/&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:when test='$level=2'&gt;
          &lt;xsl:number format="a"/&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:otherwise&gt;
          &lt;xsl:number format="1"/&gt;
        &lt;/xsl:otherwise&gt;
      &lt;/xsl:choose&gt;
      &lt;xsl:text&gt;. &lt;/xsl:text&gt;
    &lt;/fo:list-item-label&gt;
    &lt;fo:list-item-body&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/fo:list-item-body&gt;
  &lt;/fo:list-item&gt;
&lt;/xsl:template&gt;</PRE>
<H2><A name=sorting></A>10 Sorting</H2>
<P class=element-syntax><A 
name=element-sort></A><CODE>&lt;xsl:sort<BR>&nbsp;&nbsp;select = 
<VAR>string-expression</VAR> <BR>&nbsp;&nbsp;lang = { <VAR>nmtoken</VAR> 
}<BR>&nbsp;&nbsp;data-type = { "text" | "number" | 
<VAR>qname-but-not-ncname</VAR> }<BR>&nbsp;&nbsp;order = { "ascending" | 
"descending" }<BR>&nbsp;&nbsp;case-order = { "upper-first" | "lower-first" 
}&nbsp;/&gt;</CODE></P>
<P>Sorting is specified by adding <CODE>xsl:sort</CODE> elements as children of 
an <CODE>xsl:apply-templates</CODE> or <CODE>xsl:for-each</CODE> element. The 
first <CODE>xsl:sort</CODE> child specifies the primary sort key, the second 
<CODE>xsl:sort</CODE> child specifies the secondary sort key and so on. When an 
<CODE>xsl:apply-templates</CODE> or <CODE>xsl:for-each</CODE> element has one or 
more <CODE>xsl:sort</CODE> children, then instead of processing the selected 
nodes in document order, it sorts the nodes according to the specified sort keys 
and then processes them in sorted order. When used in <CODE>xsl:for-each</CODE>, 
<CODE>xsl:sort</CODE> elements must occur first. When a template is instantiated 
by <CODE>xsl:apply-templates</CODE> and <CODE>xsl:for-each</CODE>, the <A 
href="http://www.w3.org/TR/xslt#dt-current-node-list">current node list</A> list 
consists of the complete list of nodes being processed in sorted order.</P>
<P><CODE>xsl:sort</CODE> has a <CODE>select</CODE> attribute whose value is an 
<A href="http://www.w3.org/TR/xslt#dt-expression">expression</A>. For each node 
to be processed, the expression is evaluated with that node as the current node 
and with the complete list of nodes being processed in unsorted order as the 
current node list. The resulting object is converted to a string as if by a call 
to the <B><A href="http://www.w3.org/TR/xpath#function-string">string</A></B> 
function; this string is used as the sort key for that node. The default value 
of the <CODE>select</CODE> attribute is <CODE>.</CODE>, which will cause the 
string-value of the current node to be used as the sort key.</P>
<P>This string serves as a sort key for the node. The following optional 
attributes on <CODE>xsl:sort</CODE> control how the list of sort keys are 
sorted; the values of all of these attributes are interpreted as <A 
href="http://www.w3.org/TR/xslt#dt-attribute-value-template">attribute value 
templates</A>.</P>
<UL>
  <LI>
  <P><CODE>order</CODE> specifies whether the strings should be sorted in 
  ascending or descending order; <CODE>ascending</CODE> specifies ascending 
  order; <CODE>descending</CODE> specifies descending order; the default is 
  <CODE>ascending</CODE></P>
  <LI>
  <P><CODE>lang</CODE> specifies the language of the sort keys; it has the same 
  range of values as <CODE>xml:lang</CODE> <A 
  href="http://www.w3.org/TR/xslt#XML">[XML]</A>; if no <CODE>lang</CODE> value 
  is specified, the language should be determined from the system 
environment</P>
  <LI>
  <P><CODE>data-type</CODE> specifies the data type of the strings; the 
  following values are allowed:</P>
  <UL>
    <LI>
    <P><CODE>text</CODE> specifies that the sort keys should be sorted 
    lexicographically in the culturally correct manner for the language 
    specified by <CODE>lang</CODE></P>
    <LI>
    <P><CODE>number</CODE> specifies that the sort keys should be converted to 
    numbers and then sorted according to the numeric value; the sort key is 
    converted to a number as if by a call to the <B><A 
    href="http://www.w3.org/TR/xpath#function-number">number</A></B> function; 
    the <CODE>lang</CODE> attribute is ignored</P>
    <LI>
    <P>a <A href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</A> with a 
    prefix is expanded into an <A 
    href="http://www.w3.org/TR/xpath#dt-expanded-name">expanded-name</A> as 
    described in <A href="http://www.w3.org/TR/xslt#qname">[<B>2.4 Qualified 
    Names</B>]</A>; the expanded-name identifies the data-type; the behavior in 
    this case is not specified by this document</P></LI></UL>
  <P>The default value is <CODE>text</CODE>.</P>
  <BLOCKQUOTE><B>NOTE:</B>The XSL Working Group plans that future versions of 
    XSLT will leverage XML Schemas to define further values for this 
  attribute.</BLOCKQUOTE>
  <LI>
  <P><CODE>case-order</CODE> has the value <CODE>upper-first</CODE> or 
  <CODE>lower-first</CODE>; this applies when <CODE>data-type="text"</CODE>, and 
  specifies that upper-case letters should sort before lower-case letters or 
  vice-versa respectively. For example, if <CODE>lang="en"</CODE>, then <CODE>A 
  a B b</CODE> are sorted with <CODE>case-order="upper-first"</CODE> and <CODE>a 
  A b B</CODE> are sorted with <CODE>case-order="lower-first"</CODE>. The 
  default value is language dependent.</P></LI></UL>
<BLOCKQUOTE><B>NOTE:</B>It is possible for two conforming XSLT processors not 
  to sort exactly the same. Some XSLT processors may not support some languages. 
  Furthermore, there may be variations possible in the sorting of any particular 
  language that are not specified by the attributes on <CODE>xsl:sort</CODE>, 
  for example, whether Hiragana or Katakana is sorted first in Japanese. Future 
  versions of XSLT may provide additional attributes to provide control over 
  these variations. Implementations may also use implementation-specific 
  namespaced attributes on <CODE>xsl:sort</CODE> for this.</BLOCKQUOTE>
<BLOCKQUOTE><B>NOTE:</B>It is recommended that implementers consult <A 
  href="http://www.w3.org/TR/xslt#UNICODE-TR10">[UNICODE TR10]</A> for 
  information on internationalized sorting.</BLOCKQUOTE>
<P>The sort must be stable: in the sorted list of nodes, any sub list that has 
sort keys that all compare equal must be in document order.</P>
<P>For example, suppose an employee database has the form</P><PRE>&lt;employees&gt;
  &lt;employee&gt;
    &lt;name&gt;
      &lt;given&gt;James&lt;/given&gt;
      &lt;family&gt;Clark&lt;/family&gt;
    &lt;/name&gt;
    ...
  &lt;/employee&gt;
&lt;/employees&gt;</PRE>
<P>Then a list of employees sorted by name could be generated using:</P><PRE>&lt;xsl:template match="employees"&gt;
  &lt;ul&gt;
    &lt;xsl:apply-templates select="employee"&gt;
      &lt;xsl:sort select="name/family"/&gt;
      &lt;xsl:sort select="name/given"/&gt;
    &lt;/xsl:apply-templates&gt;
  &lt;/ul&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="employee"&gt;
  &lt;li&gt;
    &lt;xsl:value-of select="name/given"/&gt;
    &lt;xsl:text&gt; &lt;/xsl:text&gt;
    &lt;xsl:value-of select="name/family"/&gt;
  &lt;/li&gt;
&lt;/xsl:template&gt;</PRE>
<H2><A name=variables></A>11 Variables and Parameters</H2>
<P class=element-syntax><A name=element-variable></A><CODE>&lt;!-- Category: 
top-level-element --&gt;<BR>&lt;!-- Category: instruction 
--&gt;<BR>&lt;xsl:variable<BR>&nbsp;&nbsp;<B>name</B> = <VAR>qname</VAR> 
<BR>&nbsp;&nbsp;select = <VAR>expression</VAR>&gt;<BR>&nbsp;&nbsp;&lt;!-- 
Content: <VAR>template</VAR> --&gt;<BR>&lt;/xsl:variable&gt;</CODE></P>
<P class=element-syntax><A name=element-param></A><CODE>&lt;!-- Category: 
top-level-element --&gt;<BR>&lt;xsl:param<BR>&nbsp;&nbsp;<B>name</B> = 
<VAR>qname</VAR> <BR>&nbsp;&nbsp;select = 
<VAR>expression</VAR>&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: <VAR>template</VAR> 
--&gt;<BR>&lt;/xsl:param&gt;</CODE></P>
<P>A variable is a name that may be bound to a value. The value to which a 
variable is bound (the <B>value</B> of the variable) can be an object of any of 
the types that can be returned by expressions. There are two elements that can 
be used to bind variables: <CODE>xsl:variable</CODE> and <CODE>xsl:param</CODE>. 
The difference is that the value specified on the <CODE>xsl:param</CODE> 
variable is only a default value for the binding; when the template or 
stylesheet within which the <CODE>xsl:param</CODE> element occurs is invoked, 
parameters may be passed that are used in place of the default values.</P>
<P>Both <CODE>xsl:variable</CODE> and <CODE>xsl:param</CODE> have a required 
<CODE>name</CODE> attribute, which specifies the name of the variable. The value 
of the <CODE>name</CODE> attribute is a <A 
href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</A>, which is expanded 
as described in <A href="http://www.w3.org/TR/xslt#qname">[<B>2.4 Qualified 
Names</B>]</A>.</P>
<P>For any use of these variable-binding elements, there is a region of the 
stylesheet tree within which the binding is visible; within this region, any 
binding of the variable that was visible on the variable-binding element itself 
is hidden. Thus, only the innermost binding of a variable is visible. The set of 
variable bindings in scope for an expression consists of those bindings that are 
visible at the point in the stylesheet where the expression occurs.</P>
<H3><A name=section-Result-Tree-Fragments></A>11.1 Result Tree Fragments</H3>
<P>Variables introduce an additional data-type into the expression language. <A 
name=dt-result-tree-fragment></A>This additional data type is called <B>result 
tree fragment</B>. A variable may be bound to a result tree fragment instead of 
one of the four basic XPath data-types (string, number, boolean, node-set). A 
result tree fragment represents a fragment of the result tree. A result tree 
fragment is treated equivalently to a node-set that contains just a single root 
node. However, the operations permitted on a result tree fragment are a subset 
of those permitted on a node-set. An operation is permitted on a result tree 
fragment only if that operation would be permitted on a string (the operation on 
the string may involve first converting the string to a number or boolean). In 
particular, it is not permitted to use the <CODE>/</CODE>, <CODE>//</CODE>, and 
<CODE>[]</CODE> operators on result tree fragments. When a permitted operation 
is performed on a result tree fragment, it is performed exactly as it would be 
on the equivalent node-set.</P>
<P>When a result tree fragment is copied into the result tree (see <A 
href="http://www.w3.org/TR/xslt#copy-of">[<B>11.3 Using Values of Variables and 
Parameters with <CODE>xsl:copy-of</CODE></B>]</A>), then all the nodes that are 
children of the root node in the equivalent node-set are added in sequence to 
the result tree.</P>
<P>Expressions can only return values of type result tree fragment by 
referencing variables of type result tree fragment or calling extension 
functions that return a result tree fragment or getting a system property whose 
value is a result tree fragment.</P>
<H3><A name=variable-values></A>11.2 Values of Variables and Parameters</H3>
<P>A variable-binding element can specify the value of the variable in three 
alternative ways.</P>
<UL>
  <LI>
  <P>If the variable-binding element has a <CODE>select</CODE> attribute, then 
  the value of the attribute must be an <A 
  href="http://www.w3.org/TR/xslt#dt-expression">expression</A> and the value of 
  the variable is the object that results from evaluating the expression. In 
  this case, the content must be empty.</P>
  <LI>
  <P>If the variable-binding element does not have a <CODE>select</CODE> 
  attribute and has non-empty content (i.e. the variable-binding element has one 
  or more child nodes), then the content of the variable-binding element 
  specifies the value. The content of the variable-binding element is a 
  template, which is instantiated to give the value of the variable. The value 
  is a result tree fragment equivalent to a node-set containing just a single 
  root node having as children the sequence of nodes produced by instantiating 
  the template. The base URI of the nodes in the result tree fragment is the 
  base URI of the variable-binding element.</P>
  <P>It is an error if a member of the sequence of nodes created by 
  instantiating the template is an attribute node or a namespace node, since a 
  root node cannot have an attribute node or a namespace node as a child. An 
  XSLT processor may signal the error; if it does not signal the error, it must 
  recover by not adding the attribute node or namespace node.</P>
  <LI>
  <P>If the variable-binding element has empty content and does not have a 
  <CODE>select</CODE> attribute, then the value of the variable is an empty 
  string. Thus</P><PRE>&lt;xsl:variable name="x"/&gt;</PRE>
  <P>is equivalent to</P><PRE>&lt;xsl:variable name="x" select="''"/&gt;</PRE></LI></UL>
<BLOCKQUOTE><B>NOTE:</B>When a variable is used to select nodes by position, 
  be careful not to do: <PRE>&lt;xsl:variable name="n"&gt;2&lt;/xsl:variable&gt;
...
&lt;xsl:value-of select="item[$n]"/&gt;</PRE>This will output the value of the 
  first item element, because the variable <CODE>n</CODE> will be bound to a 
  result tree fragment, not a number. Instead, do either <PRE>&lt;xsl:variable name="n" select="2"/&gt;
...
&lt;xsl:value-of select="item[$n]"/&gt;</PRE>or <PRE>&lt;xsl:variable name="n"&gt;2&lt;/xsl:variable&gt;
...
&lt;xsl:value-of select="item[position()=$n]"/&gt;</PRE></BLOCKQUOTE>
<BLOCKQUOTE><B>NOTE:</B>One convenient way to specify the empty node-set as 
  the default value of a parameter is: <PRE>&lt;xsl:param name="x" select="/.."/&gt;</PRE></BLOCKQUOTE>
<H3><A name=copy-of></A>11.3 Using Values of Variables and Parameters with 
<CODE>xsl:copy-of</CODE></H3>
<P class=element-syntax><A name=element-copy-of></A><CODE>&lt;!-- Category: 
instruction --&gt;<BR>&lt;xsl:copy-of<BR>&nbsp;&nbsp;<B>select</B> = 
<VAR>expression</VAR>&nbsp;/&gt;</CODE></P>
<P>The <CODE>xsl:copy-of</CODE> element can be used to insert a result tree 
fragment into the result tree, without first converting it to a string as 
<CODE>xsl:value-of</CODE> does (see <A 
href="http://www.w3.org/TR/xslt#value-of">[<B>7.6.1 Generating Text with 
<CODE>xsl:value-of</CODE></B>]</A>). The required <CODE>select</CODE> attribute 
contains an <A href="http://www.w3.org/TR/xslt#dt-expression">expression</A>. 
When the result of evaluating the expression is a result tree fragment, the 
complete fragment is copied into the result tree. When the result is a node-set, 
all the nodes in the set are copied in document order into the result tree; 
copying an element node copies the attribute nodes, namespace nodes and children 
of the element node as well as the element node itself; a root node is copied by 
copying its children. When the result is neither a node-set nor a result tree 
fragment, the result is converted to a string and then inserted into the result 
tree, as with <CODE>xsl:value-of</CODE>.</P>
<H3><A name=top-level-variables></A>11.4 Top-level Variables and Parameters</H3>
<P>Both <CODE>xsl:variable</CODE> and <CODE>xsl:param</CODE> are allowed as <A 
href="http://www.w3.org/TR/xslt#dt-top-level">top-level</A> elements. A 
top-level variable-binding element declares a global variable that is visible 
everywhere. A top-level <CODE>xsl:param</CODE> element declares a parameter to 
the stylesheet; XSLT does not define the mechanism by which parameters are 
passed to the stylesheet. It is an error if a stylesheet contains more than one 
binding of a top-level variable with the same name and same <A 
href="http://www.w3.org/TR/xslt#dt-import-precedence">import precedence</A>. At 
the top-level, the expression or template specifying the variable value is 
evaluated with the same context as that used to process the root node of the 
source document: the current node is the root node of the source document and 
the current node list is a list containing just the root node of the source 
document. If the template or expression specifying the value of a global 
variable <VAR>x</VAR> references a global variable <VAR>y</VAR>, then the value 
for <VAR>y</VAR> must be computed before the value of <VAR>x</VAR>. It is an 
error if it is impossible to do this for all global variable definitions; in 
other words, it is an error if the definitions are circular.</P>
<P>This example declares a global variable <CODE>para-font-size</CODE>, which it 
references in an attribute value template.</P><PRE>&lt;xsl:variable name="para-font-size"&gt;12pt&lt;/xsl:variable&gt;

&lt;xsl:template match="para"&gt;
 &lt;fo:block font-size="{$para-font-size}"&gt;
   &lt;xsl:apply-templates/&gt;
 &lt;/fo:block&gt;
&lt;/xsl:template&gt;</PRE>
<H3><A name=local-variables></A>11.5 Variables and Parameters within 
Templates</H3>
<P>As well as being allowed at the top-level, both <CODE>xsl:variable</CODE> and 
<CODE>xsl:param</CODE> are also allowed in templates. <CODE>xsl:variable</CODE> 
is allowed anywhere within a template that an instruction is allowed. In this 
case, the binding is visible for all following siblings and their descendants. 
Note that the binding is not visible for the <CODE>xsl:variable</CODE> element 
itself. <CODE>xsl:param</CODE> is allowed as a child at the beginning of an 
<CODE>xsl:template</CODE> element. In this context, the binding is visible for 
all following siblings and their descendants. Note that the binding is not 
visible for the <CODE>xsl:param</CODE> element itself.</P>
<P><A name=dt-shadows></A>A binding <B>shadows</B> another binding if the 
binding occurs at a point where the other binding is visible, and the bindings 
have the same name. It is an error if a binding established by an 
<CODE>xsl:variable</CODE> or <CODE>xsl:param</CODE> element within a template <A 
href="http://www.w3.org/TR/xslt#dt-shadows">shadows</A> another binding 
established by an <CODE>xsl:variable</CODE> or <CODE>xsl:param</CODE> element 
also within the template. It is not an error if a binding established by an 
<CODE>xsl:variable</CODE> or <CODE>xsl:param</CODE> element in a template <A 
href="http://www.w3.org/TR/xslt#dt-shadows">shadows</A> another binding 
established by an <CODE>xsl:variable</CODE> or <CODE>xsl:param</CODE> <A 
href="http://www.w3.org/TR/xslt#dt-top-level">top-level</A> element. Thus, the 
following is an error:</P><PRE style="COLOR: red">&lt;xsl:template name="foo"&gt;
&lt;xsl:param name="x" select="1"/&gt;
&lt;xsl:variable name="x" select="2"/&gt;
&lt;/xsl:template&gt;</PRE>
<P>However, the following is allowed:</P><PRE>&lt;xsl:param name="x" select="1"/&gt;
&lt;xsl:template name="foo"&gt;
&lt;xsl:variable name="x" select="2"/&gt;
&lt;/xsl:template&gt;</PRE>
<BLOCKQUOTE><B>NOTE:</B>The nearest equivalent in Java to an 
  <CODE>xsl:variable</CODE> element in a template is a final local variable 
  declaration with an initializer. For example, <PRE>&lt;xsl:variable name="x" select="'value'"/&gt;</PRE>has similar 
  semantics to <PRE>final Object x = "value";</PRE>XSLT does not provide an equivalent to the 
  Java assignment operator <PRE>x = "value";</PRE>because this would make it harder to create an 
  implementation that processes a document other than in a batch-like way, 
  starting at the beginning and continuing through to the end.</BLOCKQUOTE>
<H3><A name=section-Passing-Parameters-to-Templates></A>11.6 Passing Parameters 
to Templates</H3>
<P class=element-syntax><A 
name=element-with-param></A><CODE>&lt;xsl:with-param<BR>&nbsp;&nbsp;<B>name</B> 
= <VAR>qname</VAR> <BR>&nbsp;&nbsp;select = 
<VAR>expression</VAR>&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: <VAR>template</VAR> 
--&gt;<BR>&lt;/xsl:with-param&gt;</CODE></P>
<P>Parameters are passed to templates using the <CODE>xsl:with-param</CODE> 
element. The required <CODE>name</CODE> attribute specifies the name of the 
parameter (the variable the value of whose binding is to be replaced). The value 
of the <CODE>name</CODE> attribute is a <A 
href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</A>, which is expanded 
as described in <A href="http://www.w3.org/TR/xslt#qname">[<B>2.4 Qualified 
Names</B>]</A>. <CODE>xsl:with-param</CODE> is allowed within both 
<CODE>xsl:call-template</CODE> and <CODE>xsl:apply-templates</CODE>. The value 
of the parameter is specified in the same way as for <CODE>xsl:variable</CODE> 
and <CODE>xsl:param</CODE>. The current node and current node list used for 
computing the value specified by <CODE>xsl:with-param</CODE> element is the same 
as that used for the <CODE>xsl:apply-templates</CODE> or 
<CODE>xsl:call-template</CODE> element within which it occurs. It is not an 
error to pass a parameter <VAR>x</VAR> to a template that does not have an 
<CODE>xsl:param</CODE> element for <VAR>x</VAR>; the parameter is simply 
ignored.</P>
<P>This example defines a named template for a <CODE>numbered-block</CODE> with 
an argument to control the format of the number.</P><PRE>&lt;xsl:template name="numbered-block"&gt;
  &lt;xsl:param name="format"&gt;1. &lt;/xsl:param&gt;
  &lt;fo:block&gt;
    &lt;xsl:number format="{$format}"/&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="ol//ol/li"&gt;
  &lt;xsl:call-template name="numbered-block"&gt;
    &lt;xsl:with-param name="format"&gt;a. &lt;/xsl:with-param&gt;
  &lt;/xsl:call-template&gt;
&lt;/xsl:template&gt;</PRE>
<H2><A name=add-func></A>12 Additional Functions</H2>
<P>This section describes XSLT-specific additions to the core XPath function 
library. Some of these additional functions also make use of information 
specified by <A href="http://www.w3.org/TR/xslt#dt-top-level">top-level</A> 
elements in the stylesheet; this section also describes these elements.</P>
<H3><A name=document></A>12.1 Multiple Source Documents</H3>
<P><A name=function-document><B>Function: </B><I>node-set</I> 
<B>document</B>(<I>object</I>, <I>node-set</I>?)</A></P>
<P>The <B><A href="http://www.w3.org/TR/xslt#function-document">document</A></B> 
function allows access to XML documents other than the main source document.</P>
<P>When the <B><A 
href="http://www.w3.org/TR/xslt#function-document">document</A></B> function has 
exactly one argument and the argument is a node-set, then the result is the 
union, for each node in the argument node-set, of the result of calling the 
<B><A href="http://www.w3.org/TR/xslt#function-document">document</A></B> 
function with the first argument being the <A 
href="http://www.w3.org/TR/xpath#dt-string-value">string-value</A> of the node, 
and the second argument being a node-set with the node as its only member. When 
the <B><A href="http://www.w3.org/TR/xslt#function-document">document</A></B> 
function has two arguments and the first argument is a node-set, then the result 
is the union, for each node in the argument node-set, of the result of calling 
the <B><A href="http://www.w3.org/TR/xslt#function-document">document</A></B> 
function with the first argument being the <A 
href="http://www.w3.org/TR/xpath#dt-string-value">string-value</A> of the node, 
and with the second argument being the second argument passed to the <B><A 
href="http://www.w3.org/TR/xslt#function-document">document</A></B> 
function.</P>
<P>When the first argument to the <B><A 
href="http://www.w3.org/TR/xslt#function-document">document</A></B> function is 
not a node-set, the first argument is converted to a string as if by a call to 
the <B><A href="http://www.w3.org/TR/xpath#function-string">string</A></B> 
function. This string is treated as a URI reference; the resource identified by 
the URI is retrieved. The data resulting from the retrieval action is parsed as 
an XML document and a tree is constructed in accordance with the data model (see 
<A href="http://www.w3.org/TR/xslt#data-model">[<B>3 Data Model</B>]</A>). If 
there is an error retrieving the resource, then the XSLT processor may signal an 
error; if it does not signal an error, it must recover by returning an empty 
node-set. One possible kind of retrieval error is that the XSLT processor does 
not support the URI scheme used by the URI. An XSLT processor is not required to 
support any particular URI schemes. The documentation for an XSLT processor 
should specify which URI schemes the XSLT processor supports.</P>
<P>If the URI reference does not contain a fragment identifier, then a node-set 
containing just the root node of the document is returned. If the URI reference 
does contain a fragment identifier, the function returns a node-set containing 
the nodes in the tree identified by the fragment identifier of the URI 
reference. The semantics of the fragment identifier is dependent on the media 
type of the result of retrieving the URI. If there is an error in processing the 
fragment identifier, the XSLT processor may signal the error; if it does not 
signal the error, it must recover by returning an empty node-set. Possible 
errors include:</P>
<UL>
  <LI>
  <P>The fragment identifier identifies something that cannot be represented by 
  an XSLT node-set (such as a range of characters within a text node).</P>
  <LI>
  <P>The XSLT processor does not support fragment identifiers for the media-type 
  of the retrieval result. An XSLT processor is not required to support any 
  particular media types. The documentation for an XSLT processor should specify 
  for which media types the XSLT processor supports fragment 
  identifiers.</P></LI></UL>
<P>The data resulting from the retrieval action is parsed as an XML document 
regardless of the media type of the retrieval result; if the top-level media 
type is <CODE>text</CODE>, then it is parsed in the same way as if the media 
type were <CODE>text/xml</CODE>; otherwise, it is parsed in the same way as if 
the media type were <CODE>application/xml</CODE>.</P>
<BLOCKQUOTE><B>NOTE:</B>Since there is no top-level <CODE>xml</CODE> media 
  type, data with a media type other than <CODE>text/xml</CODE> or 
  <CODE>application/xml</CODE> may in fact be XML.</BLOCKQUOTE>
<P>The URI reference may be relative. The base URI (see <A 
href="http://www.w3.org/TR/xslt#base-uri">[<B>3.2 Base URI</B>]</A>) of the node 
in the second argument node-set that is first in document order is used as the 
base URI for resolving the relative URI into an absolute URI. If the second 
argument is omitted, then it defaults to the node in the stylesheet that 
contains the expression that includes the call to the <B><A 
href="http://www.w3.org/TR/xslt#function-document">document</A></B> function. 
Note that a zero-length URI reference is a reference to the document relative to 
which the URI reference is being resolved; thus <CODE>document("")</CODE> refers 
to the root node of the stylesheet; the tree representation of the stylesheet is 
exactly the same as if the XML document containing the stylesheet was the 
initial source document.</P>
<P>Two documents are treated as the same document if they are identified by the 
same URI. The URI used for the comparison is the absolute URI into which any 
relative URI was resolved and does not include any fragment identifier. One root 
node is treated as the same node as another root node if the two nodes are from 
the same document. Thus, the following expression will always be true:</P><PRE>generate-id(document("foo.xml"))=generate-id(document("foo.xml"))</PRE>
<P>The <B><A href="http://www.w3.org/TR/xslt#function-document">document</A></B> 
function gives rise to the possibility that a node-set may contain nodes from 
more than one document. With such a node-set, the relative document order of two 
nodes in the same document is the normal <A 
href="http://www.w3.org/TR/xpath#dt-document-order">document order</A> defined 
by XPath <A href="http://www.w3.org/TR/xslt#XPATH">[XPath]</A>. The relative 
document order of two nodes in different documents is determined by an 
implementation-dependent ordering of the documents containing the two nodes. 
There are no constraints on how the implementation orders documents other than 
that it must do so consistently: an implementation must always use the same 
order for the same set of documents.</P>
<H3><A name=key></A>12.2 Keys</H3>
<P>Keys provide a way to work with documents that contain an implicit 
cross-reference structure. The <CODE>ID</CODE>, <CODE>IDREF</CODE> and 
<CODE>IDREFS</CODE> attribute types in XML provide a mechanism to allow XML 
documents to make their cross-reference explicit. XSLT supports this through the 
XPath <B><A href="http://www.w3.org/TR/xpath#function-id">id</A></B> function. 
However, this mechanism has a number of limitations:</P>
<UL>
  <LI>
  <P>ID attributes must be declared as such in the DTD. If an ID attribute is 
  declared as an ID attribute only in the external DTD subset, then it will be 
  recognized as an ID attribute only if the XML processor reads the external DTD 
  subset. However, XML does not require XML processors to read the external DTD, 
  and they may well choose not to do so, especially if the document is declared 
  <CODE>standalone="yes"</CODE>.</P>
  <LI>
  <P>A document can contain only a single set of unique IDs. There cannot be 
  separate independent sets of unique IDs.</P>
  <LI>
  <P>The ID of an element can only be specified in an attribute; it cannot be 
  specified by the content of the element, or by a child element.</P>
  <LI>
  <P>An ID is constrained to be an XML name. For example, it cannot contain 
  spaces.</P>
  <LI>
  <P>An element can have at most one ID.</P>
  <LI>
  <P>At most one element can have a particular ID.</P></LI></UL>
<P>Because of these limitations XML documents sometimes contain a 
cross-reference structure that is not explicitly declared by ID/IDREF/IDREFS 
attributes.</P>
<P>A key is a triple containing:</P>
<OL>
  <LI>
  <P>the node which has the key</P>
  <LI>
  <P>the name of the key (an <A 
  href="http://www.w3.org/TR/xpath#dt-expanded-name">expanded-name</A>)</P>
  <LI>
  <P>the value of the key (a string)</P></LI></OL>
<P>A stylesheet declares a set of keys for each document using the 
<CODE>xsl:key</CODE> element. When this set of keys contains a member with node 
<VAR>x</VAR>, name <VAR>y</VAR> and value <VAR>z</VAR>, we say that node 
<VAR>x</VAR> has a key with name <VAR>y</VAR> and value <VAR>z</VAR>.</P>
<P>Thus, a key is a kind of generalized ID, which is not subject to the same 
limitations as an XML ID:</P>
<UL>
  <LI>
  <P>Keys are declared in the stylesheet using <CODE>xsl:key</CODE> 
elements.</P>
  <LI>
  <P>A key has a name as well as a value; each key name may be thought of as 
  distinguishing a separate, independent space of identifiers.</P>
  <LI>
  <P>The value of a named key for an element may be specified in any convenient 
  place; for example, in an attribute, in a child element or in content. An 
  XPath expression is used to specify where to find the value for a particular 
  named key.</P>
  <LI>
  <P>The value of a key can be an arbitrary string; it is not constrained to be 
  a name.</P>
  <LI>
  <P>There can be multiple keys in a document with the same node, same key name, 
  but different key values.</P>
  <LI>
  <P>There can be multiple keys in a document with the same key name, same key 
  value, but different nodes.</P></LI></UL>
<P class=element-syntax><A name=element-key></A><CODE>&lt;!-- Category: 
top-level-element --&gt;<BR>&lt;xsl:key<BR>&nbsp;&nbsp;<B>name</B> = 
<VAR>qname</VAR> <BR>&nbsp;&nbsp;<B>match</B> = <VAR>pattern</VAR> 
<BR>&nbsp;&nbsp;<B>use</B> = <VAR>expression</VAR>&nbsp;/&gt;</CODE></P>
<P>The <CODE>xsl:key</CODE> element is used to declare keys. The 
<CODE>name</CODE> attribute specifies the name of the key. The value of the 
<CODE>name</CODE> attribute is a <A 
href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</A>, which is expanded 
as described in <A href="http://www.w3.org/TR/xslt#qname">[<B>2.4 Qualified 
Names</B>]</A>. The <CODE>match</CODE> attribute is a <A 
href="http://www.w3.org/TR/xslt#NT-Pattern">Pattern</A>; an <CODE>xsl:key</CODE> 
element gives information about the keys of any node that matches the pattern 
specified in the match attribute. The <CODE>use</CODE> attribute is an <A 
href="http://www.w3.org/TR/xslt#dt-expression">expression</A> specifying the 
values of the key; the expression is evaluated once for each node that matches 
the pattern. If the result is a node-set, then for each node in the node-set, 
the node that matches the pattern has a key of the specified name whose value is 
the string-value of the node in the node-set; otherwise, the result is converted 
to a string, and the node that matches the pattern has a key of the specified 
name with value equal to that string. Thus, a node <VAR>x</VAR> has a key with 
name <VAR>y</VAR> and value <VAR>z</VAR> if and only if there is an 
<CODE>xsl:key</CODE> element such that:</P>
<UL>
  <LI>
  <P><VAR>x</VAR> matches the pattern specified in the <CODE>match</CODE> 
  attribute of the <CODE>xsl:key</CODE> element;</P>
  <LI>
  <P>the value of the <CODE>name</CODE> attribute of the <CODE>xsl:key</CODE> 
  element is equal to <VAR>y</VAR>; and</P>
  <LI>
  <P>when the expression specified in the <CODE>use</CODE> attribute of the 
  <CODE>xsl:key</CODE> element is evaluated with <VAR>x</VAR> as the current 
  node and with a node list containing just <VAR>x</VAR> as the current node 
  list resulting in an object <VAR>u</VAR>, then either <VAR>z</VAR> is equal to 
  the result of converting <VAR>u</VAR> to a string as if by a call to the <B><A 
  href="http://www.w3.org/TR/xpath#function-string">string</A></B> function, or 
  <VAR>u</VAR> is a node-set and <VAR>z</VAR> is equal to the string-value of 
  one or more of the nodes in <VAR>u</VAR>.</P></LI></UL>
<P>Note also that there may be more than one <CODE>xsl:key</CODE> element that 
matches a given node; all of the matching <CODE>xsl:key</CODE> elements are 
used, even if they do not have the same <A 
href="http://www.w3.org/TR/xslt#dt-import-precedence">import precedence</A>.</P>
<P>It is an error for the value of either the <CODE>use</CODE> attribute or the 
<CODE>match</CODE> attribute to contain a <A 
href="http://www.w3.org/TR/xpath#NT-VariableReference">VariableReference</A>.</P>
<P><A name=function-key><B>Function: </B><I>node-set</I> 
<B>key</B>(<I>string</I>, <I>object</I>)</A></P>
<P>The <B><A href="http://www.w3.org/TR/xslt#function-key">key</A></B> function 
does for keys what the <B><A 
href="http://www.w3.org/TR/xpath#function-id">id</A></B> function does for IDs. 
The first argument specifies the name of the key. The value of the argument must 
be a <A href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</A>, which is 
expanded as described in <A href="http://www.w3.org/TR/xslt#qname">[<B>2.4 
Qualified Names</B>]</A>. When the second argument to the <B><A 
href="http://www.w3.org/TR/xslt#function-key">key</A></B> function is of type 
node-set, then the result is the union of the result of applying the <B><A 
href="http://www.w3.org/TR/xslt#function-key">key</A></B> function to the string 
<A href="http://www.w3.org/TR/xpath#dt-value">value</A> of each of the nodes in 
the argument node-set. When the second argument to <B><A 
href="http://www.w3.org/TR/xslt#function-key">key</A></B> is of any other type, 
the argument is converted to a string as if by a call to the <B><A 
href="http://www.w3.org/TR/xpath#function-string">string</A></B> function; it 
returns a node-set containing the nodes in the same document as the context node 
that have a value for the named key equal to this string.</P>
<P>For example, given a declaration</P><PRE>&lt;xsl:key name="idkey" match="div" use="@id"/&gt;</PRE>
<P>an expression <CODE>key("idkey",@ref)</CODE> will return the same node-set as 
<CODE>id(@ref)</CODE>, assuming that the only ID attribute declared in the XML 
source document is:</P><PRE>&lt;!ATTLIST div id ID #IMPLIED&gt;</PRE>
<P>and that the <CODE>ref</CODE> attribute of the current node contains no 
whitespace.</P>
<P>Suppose a document describing a function library uses a 
<CODE>prototype</CODE> element to define functions</P><PRE>&lt;prototype name="key" return-type="node-set"&gt;
&lt;arg type="string"/&gt;
&lt;arg type="object"/&gt;
&lt;/prototype&gt;</PRE>
<P>and a <CODE>function</CODE> element to refer to function names</P><PRE>&lt;function&gt;key&lt;/function&gt;</PRE>
<P>Then the stylesheet could generate hyperlinks between the references and 
definitions as follows:</P><PRE>&lt;xsl:key name="func" match="prototype" use="@name"/&gt;

&lt;xsl:template match="function"&gt;
&lt;b&gt;
  &lt;a href="#{generate-id(key('func',.))}"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/a&gt;
&lt;/b&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="prototype"&gt;
&lt;p&gt;&lt;a name="{generate-id()}"&gt;
&lt;b&gt;Function: &lt;/b&gt;
...
&lt;/a&gt;&lt;/p&gt;
&lt;/xsl:template&gt;</PRE>
<P>The <B><A href="http://www.w3.org/TR/xslt#function-key">key</A></B> can be 
used to retrieve a key from a document other than the document containing the 
context node. For example, suppose a document contains bibliographic references 
in the form <CODE>&lt;bibref&gt;XSLT&lt;/bibref&gt;</CODE>, and there is a 
separate XML document <CODE>bib.xml</CODE> containing a bibliographic database 
with entries in the form:</P><PRE>&lt;entry name="XSLT"&gt;...&lt;/entry&gt;</PRE>
<P>Then the stylesheet could use the following to transform the 
<CODE>bibref</CODE> elements:</P><PRE>&lt;xsl:key name="bib" match="entry" use="@name"/&gt;

&lt;xsl:template match="bibref"&gt;
  &lt;xsl:variable name="name" select="."/&gt;
  &lt;xsl:for-each select="document('bib.xml')"&gt;
    &lt;xsl:apply-templates select="key('bib',$name)"/&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;</PRE>
<H3><A name=format-number></A>12.3 Number Formatting</H3>
<P><A name=function-format-number><B>Function: </B><I>string</I> 
<B>format-number</B>(<I>number</I>, <I>string</I>, <I>string</I>?)</A></P>
<P>The <B><A 
href="http://www.w3.org/TR/xslt#function-format-number">format-number</A></B> 
function converts its first argument to a string using the format pattern string 
specified by the second argument and the decimal-format named by the third 
argument, or the default decimal-format, if there is no third argument. The 
format pattern string is in the syntax specified by the JDK 1.1 <A 
href="http://java.sun.com/products/jdk/1.1/docs/api/java.text.DecimalFormat.html">DecimalFormat</A> 
class. The format pattern string is in a localized notation: the decimal-format 
determines what characters have a special meaning in the pattern (with the 
exception of the quote character, which is not localized). The format pattern 
must not contain the currency sign (#x00A4); support for this feature was added 
after the initial release of JDK 1.1. The decimal-format name must be a <A 
href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</A>, which is expanded 
as described in <A href="http://www.w3.org/TR/xslt#qname">[<B>2.4 Qualified 
Names</B>]</A>. It is an error if the stylesheet does not contain a declaration 
of the decimal-format with the specified <A 
href="http://www.w3.org/TR/xpath#dt-expanded-name">expanded-name</A>.</P>
<BLOCKQUOTE><B>NOTE:</B>Implementations are not required to use the JDK 1.1 
  implementation, nor are implementations required to be implemented in 
Java.</BLOCKQUOTE>
<BLOCKQUOTE><B>NOTE:</B>Stylesheets can use other facilities in XPath to 
  control rounding.</BLOCKQUOTE>
<P class=element-syntax><A name=element-decimal-format></A><CODE>&lt;!-- 
Category: top-level-element --&gt;<BR>&lt;xsl:decimal-format<BR>&nbsp;&nbsp;name 
= <VAR>qname</VAR> <BR>&nbsp;&nbsp;decimal-separator = <VAR>char</VAR> 
<BR>&nbsp;&nbsp;grouping-separator = <VAR>char</VAR> <BR>&nbsp;&nbsp;infinity = 
<VAR>string</VAR> <BR>&nbsp;&nbsp;minus-sign = <VAR>char</VAR> 
<BR>&nbsp;&nbsp;NaN = <VAR>string</VAR> <BR>&nbsp;&nbsp;percent = 
<VAR>char</VAR> <BR>&nbsp;&nbsp;per-mille = <VAR>char</VAR> 
<BR>&nbsp;&nbsp;zero-digit = <VAR>char</VAR> <BR>&nbsp;&nbsp;digit = 
<VAR>char</VAR> <BR>&nbsp;&nbsp;pattern-separator = 
<VAR>char</VAR>&nbsp;/&gt;</CODE></P>
<P>The <CODE>xsl:decimal-format</CODE> element declares a decimal-format, which 
controls the interpretation of a format pattern used by the <B><A 
href="http://www.w3.org/TR/xslt#function-format-number">format-number</A></B> 
function. If there is a <CODE>name</CODE> attribute, then the element declares a 
named decimal-format; otherwise, it declares the default decimal-format. The 
value of the <CODE>name</CODE> attribute is a <A 
href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</A>, which is expanded 
as described in <A href="http://www.w3.org/TR/xslt#qname">[<B>2.4 Qualified 
Names</B>]</A>. It is an error to declare either the default decimal-format or a 
decimal-format with a given name more than once (even with different <A 
href="http://www.w3.org/TR/xslt#dt-import-precedence">import precedence</A>), 
unless it is declared every time with the same value for all attributes (taking 
into account any default values).</P>
<P>The other attributes on <CODE>xsl:decimal-format</CODE> correspond to the 
methods on the JDK 1.1 <A 
href="http://java.sun.com/products/jdk/1.1/docs/api/java.text.DecimalFormatSymbols.html">DecimalFormatSymbols</A> 
class. For each <CODE>get</CODE>/<CODE>set</CODE> method pair there is an 
attribute defined for the <CODE>xsl:decimal-format</CODE> element.</P>
<P>The following attributes both control the interpretation of characters in the 
format pattern and specify characters that may appear in the result of 
formatting the number:</P>
<UL>
  <LI>
  <P><CODE>decimal-separator</CODE> specifies the character used for the decimal 
  sign; the default value is the period character (<CODE>.</CODE>)</P>
  <LI>
  <P><CODE>grouping-separator</CODE> specifies the character used as a grouping 
  (e.g. thousands) separator; the default value is the comma character 
  (<CODE>,</CODE>)</P>
  <LI>
  <P><CODE>percent</CODE> specifies the character used as a percent sign; the 
  default value is the percent character (<CODE>%</CODE>)</P>
  <LI>
  <P><CODE>per-mille</CODE> specifies the character used as a per mille sign; 
  the default value is the Unicode per-mille character (#x2030)</P>
  <LI>
  <P><CODE>zero-digit</CODE> specifies the character used as the digit zero; the 
  default value is the digit zero (<CODE>0</CODE>)</P></LI></UL>
<P>The following attributes control the interpretation of characters in the 
format pattern:</P>
<UL>
  <LI>
  <P><CODE>digit</CODE> specifies the character used for a digit in the format 
  pattern; the default value is the number sign character (<CODE>#</CODE>)</P>
  <LI>
  <P><CODE>pattern-separator</CODE> specifies the character used to separate 
  positive and negative sub patterns in a pattern; the default value is the 
  semi-colon character (<CODE>;</CODE>)</P></LI></UL>
<P>The following attributes specify characters or strings that may appear in the 
result of formatting the number:</P>
<UL>
  <LI>
  <P><CODE>infinity</CODE> specifies the string used to represent infinity; the 
  default value is the string <CODE>Infinity</CODE></P>
  <LI>
  <P><CODE>NaN</CODE> specifies the string used to represent the NaN value; the 
  default value is the string <CODE>NaN</CODE></P>
  <LI>
  <P><CODE>minus-sign</CODE> specifies the character used as the default minus 
  sign; the default value is the hyphen-minus character (<CODE>-</CODE>, 
  #x2D)</P></LI></UL>
<H3><A name=misc-func></A>12.4 Miscellaneous Additional Functions</H3>
<P><A name=function-current><B>Function: </B><I>node-set</I> 
<B>current</B>()</A></P>
<P>The <B><A href="http://www.w3.org/TR/xslt#function-current">current</A></B> 
function returns a node-set that has the <A 
href="http://www.w3.org/TR/xslt#dt-current-node">current node</A> as its only 
member. For an outermost expression (an expression not occurring within another 
expression), the current node is always the same as the context node. Thus,</P><PRE>&lt;xsl:value-of select="current()"/&gt;</PRE>
<P>means the same as</P><PRE>&lt;xsl:value-of select="."/&gt;</PRE>
<P>However, within square brackets the current node is usually different from 
the context node. For example,</P><PRE>&lt;xsl:apply-templates select="//glossary/item[@name=current()/@ref]"/&gt;</PRE>
<P>will process all <CODE>item</CODE> elements that have a <CODE>glossary</CODE> 
parent element and that have a <CODE>name</CODE> attribute with value equal to 
the value of the current node's <CODE>ref</CODE> attribute. This is different 
from</P><PRE>&lt;xsl:apply-templates select="//glossary/item[@name=./@ref]"/&gt;</PRE>
<P>which means the same as</P><PRE>&lt;xsl:apply-templates select="//glossary/item[@name=@ref]"/&gt;</PRE>
<P>and so would process all <CODE>item</CODE> elements that have a 
<CODE>glossary</CODE> parent element and that have a <CODE>name</CODE> attribute 
and a <CODE>ref</CODE> attribute with the same value.</P>
<P>It is an error to use the <B><A 
href="http://www.w3.org/TR/xslt#function-current">current</A></B> function in a 
<A href="http://www.w3.org/TR/xslt#dt-pattern">pattern</A>.</P>
<P><A name=function-unparsed-entity-uri><B>Function: </B><I>string</I> 
<B>unparsed-entity-uri</B>(<I>string</I>)</A></P>
<P>The <B><A 
href="http://www.w3.org/TR/xslt#function-unparsed-entity-uri">unparsed-entity-uri</A></B> 
returns the URI of the unparsed entity with the specified name in the same 
document as the context node (see <A 
href="http://www.w3.org/TR/xslt#unparsed-entities">[<B>3.3 Unparsed 
Entities</B>]</A>). It returns the empty string if there is no such entity.</P>
<P><A name=function-generate-id><B>Function: </B><I>string</I> 
<B>generate-id</B>(<I>node-set</I>?)</A></P>
<P>The <B><A 
href="http://www.w3.org/TR/xslt#function-generate-id">generate-id</A></B> 
function returns a string that uniquely identifies the node in the argument 
node-set that is first in document order. The unique identifier must consist of 
ASCII alphanumeric characters and must start with an alphabetic character. Thus, 
the string is syntactically an XML name. An implementation is free to generate 
an identifier in any convenient way provided that it always generates the same 
identifier for the same node and that different identifiers are always generated 
from different nodes. An implementation is under no obligation to generate the 
same identifiers each time a document is transformed. There is no guarantee that 
a generated unique identifier will be distinct from any unique IDs specified in 
the source document. If the argument node-set is empty, the empty string is 
returned. If the argument is omitted, it defaults to the context node.</P>
<P><A name=function-system-property><B>Function: </B><I>object</I> 
<B>system-property</B>(<I>string</I>)</A></P>
<P>The argument must evaluate to a string that is a <A 
href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</A>. The <A 
href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</A> is expanded into a 
name using the namespace declarations in scope for the expression. The <B><A 
href="http://www.w3.org/TR/xslt#function-system-property">system-property</A></B> 
function returns an object representing the value of the system property 
identified by the name. If there is no such system property, the empty string 
should be returned.</P>
<P>Implementations must provide the following system properties, which are all 
in the XSLT namespace:</P>
<UL>
  <LI><CODE>xsl:version</CODE>, a number giving the version of XSLT implemented 
  by the processor; for XSLT processors implementing the version of XSLT 
  specified by this document, this is the number 1.0 
  <LI><CODE>xsl:vendor</CODE>, a string identifying the vendor of the XSLT 
  processor 
  <LI><CODE>xsl:vendor-url</CODE>, a string containing a URL identifying the 
  vendor of the XSLT processor; typically this is the host page (home page) of 
  the vendor's Web site. </LI></UL>
<H2><A name=message></A>13 Messages</H2>
<P class=element-syntax><A name=element-message></A><CODE>&lt;!-- Category: 
instruction --&gt;<BR>&lt;xsl:message<BR>&nbsp;&nbsp;terminate = "yes" | 
"no"&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: <VAR>template</VAR> 
--&gt;<BR>&lt;/xsl:message&gt;</CODE></P>
<P>The <CODE>xsl:message</CODE> instruction sends a message in a way that is 
dependent on the XSLT processor. The content of the <CODE>xsl:message</CODE> 
instruction is a template. The <CODE>xsl:message</CODE> is instantiated by 
instantiating the content to create an XML fragment. This XML fragment is the 
content of the message.</P>
<BLOCKQUOTE><B>NOTE:</B>An XSLT processor might implement 
  <CODE>xsl:message</CODE> by popping up an alert box or by writing to a log 
  file.</BLOCKQUOTE>
<P>If the <CODE>terminate</CODE> attribute has the value <CODE>yes</CODE>, then 
the XSLT processor should terminate processing after sending the message. The 
default value is <CODE>no</CODE>.</P>
<P>One convenient way to do localization is to put the localized information 
(message text, etc.) in an XML document, which becomes an additional input file 
to the stylesheet. For example, suppose messages for a language 
<CODE><VAR>L</VAR></CODE> are stored in an XML file 
<CODE>resources/<VAR>L</VAR>.xml</CODE> in the form:</P><PRE>&lt;messages&gt;
  &lt;message name="problem"&gt;A problem was detected.&lt;/message&gt;
  &lt;message name="error"&gt;An error was detected.&lt;/message&gt;
&lt;/messages&gt;</PRE>
<P>Then a stylesheet could use the following approach to localize messages:</P><PRE>&lt;xsl:param name="lang" select="en"/&gt;
&lt;xsl:variable name="messages"
  select="document(concat('resources/', $lang, '.xml'))/messages"/&gt;

&lt;xsl:template name="localized-message"&gt;
  &lt;xsl:param name="name"/&gt;
  &lt;xsl:message&gt;
    &lt;xsl:value-of select="$messages/message[@name=$name]"/&gt;
  &lt;/xsl:message&gt;
&lt;/xsl:template&gt;

&lt;xsl:template name="problem"&gt;
  &lt;xsl:call-template name="localized-message"/&gt;
    &lt;xsl:with-param name="name"&gt;problem&lt;/xsl:with-param&gt;
  &lt;/xsl:call-template&gt;
&lt;/xsl:template&gt;</PRE>
<H2><A name=extension></A>14 Extensions</H2>
<P>XSLT allows two kinds of extension, extension elements and extension 
functions.</P>
<P>This version of XSLT does not provide a mechanism for defining 
implementations of extensions. Therefore, an XSLT stylesheet that must be 
portable between XSLT implementations cannot rely on particular extensions being 
available. XSLT provides mechanisms that allow an XSLT stylesheet to determine 
whether the XSLT processor by which it is being processed has implementations of 
particular extensions available, and to specify what should happen if those 
extensions are not available. If an XSLT stylesheet is careful to make use of 
these mechanisms, it is possible for it to take advantage of extensions and 
still work with any XSLT implementation.</P>
<H3><A name=extension-element></A>14.1 Extension Elements</H3>
<P><A name=dt-extension-namespace></A>The element extension mechanism allows 
namespaces to be designated as <B>extension namespace</B>s. When a namespace is 
designated as an extension namespace and an element with a name from that 
namespace occurs in a template, then the element is treated as an instruction 
rather than as a literal result element. The namespace determines the semantics 
of the instruction.</P>
<BLOCKQUOTE><B>NOTE:</B>Since an element that is a child of an 
  <CODE>xsl:stylesheet</CODE> element is not occurring <I>in a template</I>, 
  non-XSLT <A href="http://www.w3.org/TR/xslt#dt-top-level">top-level</A> 
  elements are not extension elements as defined here, and nothing in this 
  section applies to them.</BLOCKQUOTE>
<P>A namespace is designated as an extension namespace by using an 
<CODE>extension-element-prefixes</CODE> attribute on an 
<CODE>xsl:stylesheet</CODE> element or an 
<CODE>xsl:extension-element-prefixes</CODE> attribute on a literal result 
element or extension element. The value of both these attributes is a 
whitespace-separated list of namespace prefixes. The namespace bound to each of 
the prefixes is designated as an extension namespace. It is an error if there is 
no namespace bound to the prefix on the element bearing the 
<CODE>extension-element-prefixes</CODE> or 
<CODE>xsl:extension-element-prefixes</CODE> attribute. The default namespace (as 
declared by <CODE>xmlns</CODE>) may be designated as an extension namespace by 
including <CODE>#default</CODE> in the list of namespace prefixes. The 
designation of a namespace as an extension namespace is effective within the 
subtree of the stylesheet rooted at the element bearing the 
<CODE>extension-element-prefixes</CODE> or 
<CODE>xsl:extension-element-prefixes</CODE> attribute; a subtree rooted at an 
<CODE>xsl:stylesheet</CODE> element does not include any stylesheets imported or 
included by children of that <CODE>xsl:stylesheet</CODE> element.</P>
<P>If the XSLT processor does not have an implementation of a particular 
extension element available, then the <B><A 
href="http://www.w3.org/TR/xslt#function-element-available">element-available</A></B> 
function must return false for the name of the element. When such an extension 
element is instantiated, then the XSLT processor must perform fallback for the 
element as specified in <A href="http://www.w3.org/TR/xslt#fallback">[<B>15 
Fallback</B>]</A>. An XSLT processor must not signal an error merely because a 
template contains an extension element for which no implementation is 
available.</P>
<P>If the XSLT processor has an implementation of a particular extension element 
available, then the <B><A 
href="http://www.w3.org/TR/xslt#function-element-available">element-available</A></B> 
function must return true for the name of the element.</P>
<H3><A name=section-Extension-Functions></A>14.2 Extension Functions</H3>
<P>If a <A href="http://www.w3.org/TR/xpath#NT-FunctionName">FunctionName</A> in 
a <A href="http://www.w3.org/TR/xpath#NT-FunctionCall">FunctionCall</A> 
expression is not an <A 
href="http://www.w3.org/TR/REC-xml-names#NT-NCName">NCName</A> (i.e. if it 
contains a colon), then it is treated as a call to an extension function. The <A 
href="http://www.w3.org/TR/xpath#NT-FunctionName">FunctionName</A> is expanded 
to a name using the namespace declarations from the evaluation context.</P>
<P>If the XSLT processor does not have an implementation of an extension 
function of a particular name available, then the <B><A 
href="http://www.w3.org/TR/xslt#function-function-available">function-available</A></B> 
function must return false for that name. If such an extension function occurs 
in an expression and the extension function is actually called, the XSLT 
processor must signal an error. An XSLT processor must not signal an error 
merely because an expression contains an extension function for which no 
implementation is available.</P>
<P>If the XSLT processor has an implementation of an extension function of a 
particular name available, then the <B><A 
href="http://www.w3.org/TR/xslt#function-function-available">function-available</A></B> 
function must return true for that name. If such an extension is called, then 
the XSLT processor must call the implementation passing it the function call 
arguments; the result returned by the implementation is returned as the result 
of the function call.</P>
<H2><A name=fallback></A>15 Fallback</H2>
<P class=element-syntax><A name=element-fallback></A><CODE>&lt;!-- Category: 
instruction --&gt;<BR>&lt;xsl:fallback&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: 
<VAR>template</VAR> --&gt;<BR>&lt;/xsl:fallback&gt;</CODE></P>
<P>Normally, instantiating an <CODE>xsl:fallback</CODE> element does nothing. 
However, when an XSLT processor performs fallback for an instruction element, if 
the instruction element has one or more <CODE>xsl:fallback</CODE> children, then 
the content of each of the <CODE>xsl:fallback</CODE> children must be 
instantiated in sequence; otherwise, an error must be signaled. The content of 
an <CODE>xsl:fallback</CODE> element is a template.</P>
<P>The following functions can be used with the <CODE>xsl:choose</CODE> and 
<CODE>xsl:if</CODE> instructions to explicitly control how a stylesheet should 
behave if particular elements or functions are not available.</P>
<P><A name=function-element-available><B>Function: </B><I>boolean</I> 
<B>element-available</B>(<I>string</I>)</A></P>
<P>The argument must evaluate to a string that is a <A 
href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</A>. The <A 
href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</A> is expanded into an 
<A href="http://www.w3.org/TR/xpath#dt-expanded-name">expanded-name</A> using 
the namespace declarations in scope for the expression. The <B><A 
href="http://www.w3.org/TR/xslt#function-element-available">element-available</A></B> 
function returns true if and only if the expanded-name is the name of an 
instruction. If the expanded-name has a namespace URI equal to the XSLT 
namespace URI, then it refers to an element defined by XSLT. Otherwise, it 
refers to an extension element. If the expanded-name has a null namespace URI, 
the <B><A 
href="http://www.w3.org/TR/xslt#function-element-available">element-available</A></B> 
function will return false.</P>
<P><A name=function-function-available><B>Function: </B><I>boolean</I> 
<B>function-available</B>(<I>string</I>)</A></P>
<P>The argument must evaluate to a string that is a <A 
href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</A>. The <A 
href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</A> is expanded into an 
<A href="http://www.w3.org/TR/xpath#dt-expanded-name">expanded-name</A> using 
the namespace declarations in scope for the expression. The <B><A 
href="http://www.w3.org/TR/xslt#function-function-available">function-available</A></B> 
function returns true if and only if the expanded-name is the name of a function 
in the function library. If the expanded-name has a non-null namespace URI, then 
it refers to an extension function; otherwise, it refers to a function defined 
by XPath or XSLT.</P>
<H2><A name=output></A>16 Output</H2>
<P class=element-syntax><A name=element-output></A><CODE>&lt;!-- Category: 
top-level-element --&gt;<BR>&lt;xsl:output<BR>&nbsp;&nbsp;method = "xml" | 
"html" | "text" | <VAR>qname-but-not-ncname</VAR> <BR>&nbsp;&nbsp;version = 
<VAR>nmtoken</VAR> <BR>&nbsp;&nbsp;encoding = <VAR>string</VAR> 
<BR>&nbsp;&nbsp;omit-xml-declaration = "yes" | "no"<BR>&nbsp;&nbsp;standalone = 
"yes" | "no"<BR>&nbsp;&nbsp;doctype-public = <VAR>string</VAR> 
<BR>&nbsp;&nbsp;doctype-system = <VAR>string</VAR> 
<BR>&nbsp;&nbsp;cdata-section-elements = <VAR>qnames</VAR> 
<BR>&nbsp;&nbsp;indent = "yes" | "no"<BR>&nbsp;&nbsp;media-type = 
<VAR>string</VAR>&nbsp;/&gt;</CODE></P>
<P>An XSLT processor may output the result tree as a sequence of bytes, although 
it is not required to be able to do so (see <A 
href="http://www.w3.org/TR/xslt#conformance">[<B>17 Conformance</B>]</A>). The 
<CODE>xsl:output</CODE> element allows stylesheet authors to specify how they 
wish the result tree to be output. If an XSLT processor outputs the result tree, 
it should do so as specified by the <CODE>xsl:output</CODE> element; however, it 
is not required to do so.</P>
<P>The <CODE>xsl:output</CODE> element is only allowed as a <A 
href="http://www.w3.org/TR/xslt#dt-top-level">top-level</A> element.</P>
<P>The <CODE>method</CODE> attribute on <CODE>xsl:output</CODE> identifies the 
overall method that should be used for outputting the result tree. The value 
must be a <A href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</A>. If 
the <A href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</A> does not 
have a prefix, then it identifies a method specified in this document and must 
be one of <CODE>xml</CODE>, <CODE>html</CODE> or <CODE>text</CODE>. If the <A 
href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</A> has a prefix, then 
the <A href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</A> is expanded 
into an <A href="http://www.w3.org/TR/xpath#dt-expanded-name">expanded-name</A> 
as described in <A href="http://www.w3.org/TR/xslt#qname">[<B>2.4 Qualified 
Names</B>]</A>; the expanded-name identifies the output method; the behavior in 
this case is not specified by this document.</P>
<P>The default for the <CODE>method</CODE> attribute is chosen as follows. 
If</P>
<UL>
  <LI>
  <P>the root node of the result tree has an element child,</P>
  <LI>
  <P>the expanded-name of the first element child of the root node (i.e. the 
  document element) of the result tree has local part <CODE>html</CODE> (in any 
  combination of upper and lower case) and a null namespace URI, and</P>
  <LI>
  <P>any text nodes preceding the first element child of the root node of the 
  result tree contain only whitespace characters,</P></LI></UL>
<P>then the default output method is <CODE>html</CODE>; otherwise, the default 
output method is <CODE>xml</CODE>. The default output method should be used if 
there are no <CODE>xsl:output</CODE> elements or if none of the 
<CODE>xsl:output</CODE> elements specifies a value for the <CODE>method</CODE> 
attribute.</P>
<P>The other attributes on <CODE>xsl:output</CODE> provide parameters for the 
output method. The following attributes are allowed:</P>
<UL>
  <LI>
  <P><CODE>version</CODE> specifies the version of the output method</P>
  <LI>
  <P><CODE>indent</CODE> specifies whether the XSLT processor may add additional 
  whitespace when outputting the result tree; the value must be <CODE>yes</CODE> 
  or <CODE>no</CODE></P>
  <LI>
  <P><CODE>encoding</CODE> specifies the preferred character encoding that the 
  XSLT processor should use to encode sequences of characters as sequences of 
  bytes; the value of the attribute should be treated case-insensitively; the 
  value must contain only characters in the range #x21 to #x7E (i.e. printable 
  ASCII characters); the value should either be a <CODE>charset</CODE> 
  registered with the Internet Assigned Numbers Authority <A 
  href="http://www.w3.org/TR/xslt#IANA">[IANA]</A>, <A 
  href="http://www.w3.org/TR/xslt#RFC2278">[RFC2278]</A> or start with 
  <CODE>X-</CODE></P>
  <LI>
  <P><CODE>media-type</CODE> specifies the media type (MIME content type) of the 
  data that results from outputting the result tree; the <CODE>charset</CODE> 
  parameter should not be specified explicitly; instead, when the top-level 
  media type is <CODE>text</CODE>, a <CODE>charset</CODE> parameter should be 
  added according to the character encoding actually used by the output 
  method</P>
  <LI>
  <P><CODE>doctype-system</CODE> specifies the system identifier to be used in 
  the document type declaration</P>
  <LI>
  <P><CODE>doctype-public</CODE> specifies the public identifier to be used in 
  the document type declaration</P>
  <LI>
  <P><CODE>omit-xml-declaration</CODE> specifies whether the XSLT processor 
  should output an XML declaration; the value must be <CODE>yes</CODE> or 
  <CODE>no</CODE></P>
  <LI>
  <P><CODE>standalone</CODE> specifies whether the XSLT processor should output 
  a standalone document declaration; the value must be <CODE>yes</CODE> or 
  <CODE>no</CODE></P>
  <LI>
  <P><CODE>cdata-section-elements</CODE> specifies a list of the names of 
  elements whose text node children should be output using CDATA 
  sections</P></LI></UL>
<P>The detailed semantics of each attribute will be described separately for 
each output method for which it is applicable. If the semantics of an attribute 
are not described for an output method, then it is not applicable to that output 
method.</P>
<P>A stylesheet may contain multiple <CODE>xsl:output</CODE> elements and may 
include or import stylesheets that also contain <CODE>xsl:output</CODE> 
elements. All the <CODE>xsl:output</CODE> elements occurring in a stylesheet are 
merged into a single effective <CODE>xsl:output</CODE> element. For the 
<CODE>cdata-section-elements</CODE> attribute, the effective value is the union 
of the specified values. For other attributes, the effective value is the 
specified value with the highest <A 
href="http://www.w3.org/TR/xslt#dt-import-precedence">import precedence</A>. It 
is an error if there is more than one such value for an attribute. An XSLT 
processor may signal the error; if it does not signal the error, if should 
recover by using the value that occurs last in the stylesheet. The values of 
attributes are defaulted after the <CODE>xsl:output</CODE> elements have been 
merged; different output methods may have different default values for an 
attribute.</P>
<H3><A name=section-XML-Output-Method></A>16.1 XML Output Method</H3>
<P>The <CODE>xml</CODE> output method outputs the result tree as a well-formed 
XML external general parsed entity. If the root node of the result tree has a 
single element node child and no text node children, then the entity should also 
be a well-formed XML document entity. When the entity is referenced within a 
trivial XML document wrapper like this</P><PRE>&lt;!DOCTYPE doc [
&lt;!ENTITY e SYSTEM "<VAR>entity-URI</VAR>"&gt;
]&gt;
&lt;doc&gt;&amp;e;&lt;/doc&gt;</PRE>
<P>where <CODE><VAR>entity-URI</VAR></CODE> is a URI for the entity, then the 
wrapper document as a whole should be a well-formed XML document conforming to 
the XML Namespaces Recommendation <A 
href="http://www.w3.org/TR/xslt#XMLNAMES">[XML Names]</A>. In addition, the 
output should be such that if a new tree was constructed by parsing the wrapper 
as an XML document as specified in <A 
href="http://www.w3.org/TR/xslt#data-model">[<B>3 Data Model</B>]</A>, and then 
removing the document element, making its children instead be children of the 
root node, then the new tree would be the same as the result tree, with the 
following possible exceptions:</P>
<UL>
  <LI>
  <P>The order of attributes in the two trees may be different.</P>
  <LI>
  <P>The new tree may contain namespace nodes that were not present in the 
  result tree.</P>
  <BLOCKQUOTE><B>NOTE:</B>An XSLT processor may need to add namespace 
    declarations in the course of outputting the result tree as 
  XML.</BLOCKQUOTE></LI></UL>
<P>If the XSLT processor generated a document type declaration because of the 
<CODE>doctype-system</CODE> attribute, then the above requirements apply to the 
entity with the generated document type declaration removed.</P>
<P>The <CODE>version</CODE> attribute specifies the version of XML to be used 
for outputting the result tree. If the XSLT processor does not support this 
version of XML, it should use a version of XML that it does support. The version 
output in the XML declaration (if an XML declaration is output) should 
correspond to the version of XML that the processor used for outputting the 
result tree. The value of the <CODE>version</CODE> attribute should match the <A 
href="http://www.w3.org/TR/REC-xml#NT-VersionNum">VersionNum</A> production of 
the XML Recommendation <A href="http://www.w3.org/TR/xslt#XML">[XML]</A>. The 
default value is <CODE>1.0</CODE>.</P>
<P>The <CODE>encoding</CODE> attribute specifies the preferred encoding to use 
for outputting the result tree. XSLT processors are required to respect values 
of <CODE>UTF-8</CODE> and <CODE>UTF-16</CODE>. For other values, if the XSLT 
processor does not support the specified encoding it may signal an error; if it 
does not signal an error it should use <CODE>UTF-8</CODE> or <CODE>UTF-16</CODE> 
instead. The XSLT processor must not use an encoding whose name does not match 
the <A href="http://www.w3.org/TR/REC-xml#NT-EncName">EncName</A> production of 
the XML Recommendation <A href="http://www.w3.org/TR/xslt#XML">[XML]</A>. If no 
<CODE>encoding</CODE> attribute is specified, then the XSLT processor should use 
either <CODE>UTF-8</CODE> or <CODE>UTF-16</CODE>. It is possible that the result 
tree will contain a character that cannot be represented in the encoding that 
the XSLT processor is using for output. In this case, if the character occurs in 
a context where XML recognizes character references (i.e. in the value of an 
attribute node or text node), then the character should be output as a character 
reference; otherwise (for example if the character occurs in the name of an 
element) the XSLT processor should signal an error.</P>
<P>If the <CODE>indent</CODE> attribute has the value <CODE>yes</CODE>, then the 
<CODE>xml</CODE> output method may output whitespace in addition to the 
whitespace in the result tree (possibly based on whitespace stripped from either 
the source document or the stylesheet) in order to indent the result nicely; if 
the <CODE>indent</CODE> attribute has the value <CODE>no</CODE>, it should not 
output any additional whitespace. The default value is <CODE>no</CODE>. The 
<CODE>xml</CODE> output method should use an algorithm to output additional 
whitespace that ensures that the result if whitespace were to be stripped from 
the output using the process described in <A 
href="http://www.w3.org/TR/xslt#strip">[<B>3.4 Whitespace Stripping</B>]</A> 
with the set of whitespace-preserving elements consisting of just 
<CODE>xsl:text</CODE> would be the same when additional whitespace is output as 
when additional whitespace is not output.</P>
<BLOCKQUOTE><B>NOTE:</B>It is usually not safe to use 
  <CODE>indent="yes"</CODE> with document types that include element types with 
  mixed content.</BLOCKQUOTE>
<P>The <CODE>cdata-section-elements</CODE> attribute contains a 
whitespace-separated list of <A 
href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</A>s. Each <A 
href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</A> is expanded into an 
expanded-name using the namespace declarations in effect on the 
<CODE>xsl:output</CODE> element in which the <A 
href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</A> occurs; if there is 
a default namespace, it is used for <A 
href="http://www.w3.org/TR/REC-xml-names#NT-QName">QName</A>s that do not have a 
prefix. The expansion is performed before the merging of multiple 
<CODE>xsl:output</CODE> elements into a single effective <CODE>xsl:output</CODE> 
element. If the expanded-name of the parent of a text node is a member of the 
list, then the text node should be output as a CDATA section. For example,</P><PRE>&lt;xsl:output cdata-section-elements="example"/&gt;</PRE>
<P>would cause a literal result element written in the stylesheet as</P><PRE>&lt;example&gt;&amp;lt;foo&gt;&lt;/example&gt;</PRE>
<P>or as</P><PRE>&lt;example&gt;&lt;![CDATA[&lt;foo&gt;]]&gt;&lt;/example&gt;</PRE>
<P>to be output as</P><PRE>&lt;example&gt;&lt;![CDATA[&lt;foo&gt;]]&gt;&lt;/example&gt;</PRE>
<P>If the text node contains the sequence of characters <CODE>]]&gt;</CODE>, 
then the currently open CDATA section should be closed following the 
<CODE>]]</CODE> and a new CDATA section opened before the <CODE>&gt;</CODE>. For 
example, a literal result element written in the stylesheet as</P><PRE>&lt;example&gt;]]&amp;gt;&lt;/example&gt;</PRE>
<P>would be output as</P><PRE>&lt;example&gt;&lt;![CDATA[]]]]&gt;&lt;![CDATA[&gt;]]&gt;&lt;/example&gt;</PRE>
<P>If the text node contains a character that is not representable in the 
character encoding being used to output the result tree, then the currently open 
CDATA section should be closed before the character, the character should be 
output using a character reference or entity reference, and a new CDATA section 
should be opened for any further characters in the text node.</P>
<P>CDATA sections should not be used except for text nodes that the 
<CODE>cdata-section-elements</CODE> attribute explicitly specifies should be 
output using CDATA sections.</P>
<P>The <CODE>xml</CODE> output method should output an XML declaration unless 
the <CODE>omit-xml-declaration</CODE> attribute has the value <CODE>yes</CODE>. 
The XML declaration should include both version information and an encoding 
declaration. If the <CODE>standalone</CODE> attribute is specified, it should 
include a standalone document declaration with the same value as the value as 
the value of the <CODE>standalone</CODE> attribute. Otherwise, it should not 
include a standalone document declaration; this ensures that it is both a XML 
declaration (allowed at the beginning of a document entity) and a text 
declaration (allowed at the beginning of an external general parsed entity).</P>
<P>If the <CODE>doctype-system</CODE> attribute is specified, the 
<CODE>xml</CODE> output method should output a document type declaration 
immediately before the first element. The name following 
<CODE>&lt;!DOCTYPE</CODE> should be the name of the first element. If 
<CODE>doctype-public</CODE> attribute is also specified, then the 
<CODE>xml</CODE> output method should output <CODE>PUBLIC</CODE> followed by the 
public identifier and then the system identifier; otherwise, it should output 
<CODE>SYSTEM</CODE> followed by the system identifier. The internal subset 
should be empty. The <CODE>doctype-public</CODE> attribute should be ignored 
unless the <CODE>doctype-system</CODE> attribute is specified.</P>
<P>The <CODE>media-type</CODE> attribute is applicable for the <CODE>xml</CODE> 
output method. The default value for the <CODE>media-type</CODE> attribute is 
<CODE>text/xml</CODE>.</P>
<H3><A name=section-HTML-Output-Method></A>16.2 HTML Output Method</H3>
<P>The <CODE>html</CODE> output method outputs the result tree as HTML; for 
example,</P><PRE>&lt;xsl:stylesheet version="1.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:output method="html"/&gt;

&lt;xsl:template match="/"&gt;
  &lt;html&gt;
   &lt;xsl:apply-templates/&gt;
  &lt;/html&gt;
&lt;/xsl:template&gt;

...

&lt;/xsl:stylesheet&gt;</PRE>
<P>The <CODE>version</CODE> attribute indicates the version of the HTML. The 
default value is <CODE>4.0</CODE>, which specifies that the result should be 
output as HTML conforming to the HTML 4.0 Recommendation <A 
href="http://www.w3.org/TR/xslt#HTML">[HTML]</A>.</P>
<P>The <CODE>html</CODE> output method should not output an element differently 
from the <CODE>xml</CODE> output method unless the expanded-name of the element 
has a null namespace URI; an element whose expanded-name has a non-null 
namespace URI should be output as XML. If the expanded-name of the element has a 
null namespace URI, but the local part of the expanded-name is not recognized as 
the name of an HTML element, the element should output in the same way as a 
non-empty, inline element such as <CODE>span</CODE>.</P>
<P>The <CODE>html</CODE> output method should not output an end-tag for empty 
elements. For HTML 4.0, the empty elements are <CODE>area</CODE>, 
<CODE>base</CODE>, <CODE>basefont</CODE>, <CODE>br</CODE>, <CODE>col</CODE>, 
<CODE>frame</CODE>, <CODE>hr</CODE>, <CODE>img</CODE>, <CODE>input</CODE>, 
<CODE>isindex</CODE>, <CODE>link</CODE>, <CODE>meta</CODE> and 
<CODE>param</CODE>. For example, an element written as <CODE>&lt;br/&gt;</CODE> 
or <CODE>&lt;br&gt;&lt;/br&gt;</CODE> in the stylesheet should be output as 
<CODE>&lt;br&gt;</CODE>.</P>
<P>The <CODE>html</CODE> output method should recognize the names of HTML 
elements regardless of case. For example, elements named <CODE>br</CODE>, 
<CODE>BR</CODE> or <CODE>Br</CODE> should all be recognized as the HTML 
<CODE>br</CODE> element and output without an end-tag.</P>
<P>The <CODE>html</CODE> output method should not perform escaping for the 
content of the <CODE>script</CODE> and <CODE>style</CODE> elements. For example, 
a literal result element written in the stylesheet as</P><PRE>&lt;script&gt;if (a &amp;lt; b) foo()&lt;/script&gt;</PRE>
<P>or</P><PRE>&lt;script&gt;&lt;![CDATA[if (a &lt; b) foo()]]&gt;&lt;/script&gt;</PRE>
<P>should be output as</P><PRE>&lt;script&gt;if (a &lt; b) foo()&lt;/script&gt;</PRE>
<P>The <CODE>html</CODE> output method should not escape <CODE>&lt;</CODE> 
characters occurring in attribute values.</P>
<P>If the <CODE>indent</CODE> attribute has the value <CODE>yes</CODE>, then the 
<CODE>html</CODE> output method may add or remove whitespace as it outputs the 
result tree, so long as it does not change how an HTML user agent would render 
the output. The default value is <CODE>yes</CODE>.</P>
<P>The <CODE>html</CODE> output method should escape non-ASCII characters in URI 
attribute values using the method recommended in <A 
href="http://www.w3.org/TR/REC-html40/appendix/notes.html#h-B.2.1">Section 
B.2.1</A> of the HTML 4.0 Recommendation.</P>
<P>The <CODE>html</CODE> output method may output a character using a character 
entity reference, if one is defined for it in the version of HTML that the 
output method is using.</P>
<P>The <CODE>html</CODE> output method should terminate processing instructions 
with <CODE>&gt;</CODE> rather than <CODE>?&gt;</CODE>.</P>
<P>The <CODE>html</CODE> output method should output boolean attributes (that is 
attributes with only a single allowed value that is equal to the name of the 
attribute) in minimized form. For example, a start-tag written in the stylesheet 
as</P><PRE>&lt;OPTION selected="selected"&gt;</PRE>
<P>should be output as</P><PRE>&lt;OPTION selected&gt;</PRE>
<P>The <CODE>html</CODE> output method should not escape a <CODE>&amp;</CODE> 
character occurring in an attribute value immediately followed by a 
<CODE>{</CODE> character (see <A 
href="http://www.w3.org/TR/REC-html40/appendix/notes.html#h-B.7.1.1">Section 
B.7.1</A> of the HTML 4.0 Recommendation). For example, a start-tag written in 
the stylesheet as</P><PRE>&lt;BODY bgcolor='&amp;amp;{{randomrbg}};'&gt;</PRE>
<P>should be output as</P><PRE>&lt;BODY bgcolor='&amp;{randomrbg};'&gt;</PRE>
<P>The <CODE>encoding</CODE> attribute specifies the preferred encoding to be 
used. If there is a <CODE>HEAD</CODE> element, then the <CODE>html</CODE> output 
method should add a <CODE>META</CODE> element immediately after the start-tag of 
the <CODE>HEAD</CODE> element specifying the character encoding actually used. 
For example,</P><PRE>&lt;HEAD&gt;
&lt;META http-equiv="Content-Type" content="text/html; charset=EUC-JP"&gt;
...</PRE>
<P>It is possible that the result tree will contain a character that cannot be 
represented in the encoding that the XSLT processor is using for output. In this 
case, if the character occurs in a context where HTML recognizes character 
references, then the character should be output as a character entity reference 
or decimal numeric character reference; otherwise (for example, in a 
<CODE>script</CODE> or <CODE>style</CODE> element or in a comment), the XSLT 
processor should signal an error.</P>
<P>If the <CODE>doctype-public</CODE> or <CODE>doctype-system</CODE> attributes 
are specified, then the <CODE>html</CODE> output method should output a document 
type declaration immediately before the first element. The name following 
<CODE>&lt;!DOCTYPE</CODE> should be <CODE>HTML</CODE> or <CODE>html</CODE>. If 
the <CODE>doctype-public</CODE> attribute is specified, then the output method 
should output <CODE>PUBLIC</CODE> followed by the specified public identifier; 
if the <CODE>doctype-system</CODE> attribute is also specified, it should also 
output the specified system identifier following the public identifier. If the 
<CODE>doctype-system</CODE> attribute is specified but the 
<CODE>doctype-public</CODE> attribute is not specified, then the output method 
should output <CODE>SYSTEM</CODE> followed by the specified system 
identifier.</P>
<P>The <CODE>media-type</CODE> attribute is applicable for the <CODE>html</CODE> 
output method. The default value is <CODE>text/html</CODE>.</P>
<H3><A name=section-Text-Output-Method></A>16.3 Text Output Method</H3>
<P>The <CODE>text</CODE> output method outputs the result tree by outputting the 
string-value of every text node in the result tree in document order without any 
escaping.</P>
<P>The <CODE>media-type</CODE> attribute is applicable for the <CODE>text</CODE> 
output method. The default value for the <CODE>media-type</CODE> attribute is 
<CODE>text/plain</CODE>.</P>
<P>The <CODE>encoding</CODE> attribute identifies the encoding that the 
<CODE>text</CODE> output method should use to convert sequences of characters to 
sequences of bytes. The default is system-dependent. If the result tree contains 
a character that cannot be represented in the encoding that the XSLT processor 
is using for output, the XSLT processor should signal an error.</P>
<H3><A name=disable-output-escaping></A>16.4 Disabling Output Escaping</H3>
<P>Normally, the <CODE>xml</CODE> output method escapes &amp; and &lt; (and 
possibly other characters) when outputting text nodes. This ensures that the 
output is well-formed XML. However, it is sometimes convenient to be able to 
produce output that is almost, but not quite well-formed XML; for example, the 
output may include ill-formed sections which are intended to be transformed into 
well-formed XML by a subsequent non-XML aware process. For this reason, XSLT 
provides a mechanism for disabling output escaping. An <CODE>xsl:value-of</CODE> 
or <CODE>xsl:text</CODE> element may have a <CODE>disable-output-escaping</CODE> 
attribute; the allowed values are <CODE>yes</CODE> or <CODE>no</CODE>; the 
default is <CODE>no</CODE>; if the value is <CODE>yes</CODE>, then a text node 
generated by instantiating the <CODE>xsl:value-of</CODE> or 
<CODE>xsl:text</CODE> element should be output without any escaping. For 
example,</P><PRE>&lt;xsl:text disable-output-escaping="yes"&gt;&amp;lt;&lt;/xsl:text&gt;</PRE>
<P>should generate the single character <CODE>&lt;</CODE>.</P>
<P>It is an error for output escaping to be disabled for a text node that is 
used for something other than a text node in the result tree. Thus, it is an 
error to disable output escaping for an <CODE>xsl:value-of</CODE> or 
<CODE>xsl:text</CODE> element that is used to generate the string-value of a 
comment, processing instruction or attribute node; it is also an error to 
convert a <A href="http://www.w3.org/TR/xslt#dt-result-tree-fragment">result 
tree fragment</A> to a number or a string if the result tree fragment contains a 
text node for which escaping was disabled. In both cases, an XSLT processor may 
signal the error; if it does not signal the error, it must recover by ignoring 
the <CODE>disable-output-escaping</CODE> attribute.</P>
<P>The <CODE>disable-output-escaping</CODE> attribute may be used with the 
<CODE>html</CODE> output method as well as with the <CODE>xml</CODE> output 
method. The <CODE>text</CODE> output method ignores the 
<CODE>disable-output-escaping</CODE> attribute, since it does not perform any 
output escaping.</P>
<P>An XSLT processor will only be able to disable output escaping if it controls 
how the result tree is output. This may not always be the case. For example, the 
result tree may be used as the source tree for another XSLT transformation 
instead of being output. An XSLT processor is not required to support disabling 
output escaping. If an <CODE>xsl:value-of</CODE> or <CODE>xsl:text</CODE> 
specifies that output escaping should be disabled and the XSLT processor does 
not support this, the XSLT processor may signal an error; if it does not signal 
an error, it must recover by not disabling output escaping.</P>
<P>If output escaping is disabled for a character that is not representable in 
the encoding that the XSLT processor is using for output, then the XSLT 
processor may signal an error; if it does not signal an error, it must recover 
by not disabling output escaping.</P>
<P>Since disabling output escaping may not work with all XSLT processors and can 
result in XML that is not well-formed, it should be used only when there is no 
alternative.</P>
<H2><A name=conformance></A>17 Conformance</H2>
<P>A conforming XSLT processor must be able to use a stylesheet to transform a 
source tree into a result tree as specified in this document. A conforming XSLT 
processor need not be able to output the result in XML or in any other form.</P>
<BLOCKQUOTE><B>NOTE:</B>Vendors of XSLT processors are strongly encouraged to 
  provide a way to verify that their processor is behaving conformingly by 
  allowing the result tree to be output as XML or by providing access to the 
  result tree through a standard API such as the DOM or SAX.</BLOCKQUOTE>
<P>A conforming XSLT processor must signal any errors except for those that this 
document specifically allows an XSLT processor not to signal. A conforming XSLT 
processor may but need not recover from any errors that it signals.</P>
<P>A conforming XSLT processor may impose limits on the processing resources 
consumed by the processing of a stylesheet.</P>
<H2><A name=notation></A>18 Notation</H2>
<P>The specification of each XSLT-defined element type is preceded by a summary 
of its syntax in the form of a model for elements of that element type. The 
meaning of syntax summary notation is as follows:</P>
<UL>
  <LI>
  <P>An attribute is required if and only if its name is in bold.</P>
  <LI>
  <P>The string that occurs in the place of an attribute value specifies the 
  allowed values of the attribute. If this is surrounded by curly braces, then 
  the attribute value is treated as an <A 
  href="http://www.w3.org/TR/xslt#dt-attribute-value-template">attribute value 
  template</A>, and the string occurring within curly braces specifies the 
  allowed values of the result of instantiating the attribute value template. 
  Alternative allowed values are separated by <CODE>|</CODE>. A quoted string 
  indicates a value equal to that specific string. An unquoted, italicized name 
  specifies a particular type of value.</P>
  <LI>
  <P>If the element is allowed not to be empty, then the element contains a 
  comment specifying the allowed content. The allowed content is specified in a 
  similar way to an element type declaration in XML; <I>template</I> means that 
  any mixture of text nodes, literal result elements, extension elements, and 
  XSLT elements from the <CODE>instruction</CODE> category is allowed; 
  <I>top-level-elements</I> means that any mixture of XSLT elements from the 
  <CODE>top-level-element</CODE> category is allowed.</P>
  <LI>
  <P>The element is prefaced by comments indicating if it belongs to the 
  <CODE>instruction</CODE> category or <CODE>top-level-element</CODE> category 
  or both. The category of an element just affects whether it is allowed in the 
  content of elements that allow a <I>template</I> or 
  <I>top-level-elements</I>.</P></LI></UL>
<HR title="Separator from footer">

<H2><A name=section-References></A>A References</H2>
<H3><A name=section-Normative-References></A>A.1 Normative References</H3>
<DL>
  <DT><A name=XML>XML</A> 
  <DD>World Wide Web Consortium. <I>Extensible Markup Language (XML) 1.0.</I> 
  W3C Recommendation. See <A 
  href="http://www.w3.org/TR/1998/REC-xml-19980210">http://www.w3.org/TR/1998/REC-xml-19980210</A> 

  <DT><A name=XMLNAMES>XML Names</A> 
  <DD>World Wide Web Consortium. <I>Namespaces in XML.</I> W3C Recommendation. 
  See <A 
  href="http://www.w3.org/TR/REC-xml-names">http://www.w3.org/TR/REC-xml-names</A> 

  <DT><A name=XPATH>XPath</A> 
  <DD>World Wide Web Consortium. <I>XML Path Language.</I> W3C Recommendation. 
  See <A href="http://www.w3.org/TR/xpath">http://www.w3.org/TR/xpath</A> 
</DD></DL>
<H3><A name=section-Other-References></A>A.2 Other References</H3>
<DL>
  <DT><A name=CSS2>CSS2</A> 
  <DD>World Wide Web Consortium. <I>Cascading Style Sheets, level 2 (CSS2)</I>. 
  W3C Recommendation. See <A 
  href="http://www.w3.org/TR/1998/REC-CSS2-19980512">http://www.w3.org/TR/1998/REC-CSS2-19980512</A> 

  <DT><A name=DSSSL>DSSSL</A> 
  <DD>International Organization for Standardization, International 
  Electrotechnical Commission. <I>ISO/IEC 10179:1996. Document Style Semantics 
  and Specification Language (DSSSL)</I>. International Standard. 
  <DT><A name=HTML>HTML</A> 
  <DD>World Wide Web Consortium. <I>HTML 4.0 specification</I>. W3C 
  Recommendation. See <A 
  href="http://www.w3.org/TR/REC-html40">http://www.w3.org/TR/REC-html40</A> 
  <DT><A name=IANA>IANA</A> 
  <DD>Internet Assigned Numbers Authority. <I>Character Sets</I>. See <A 
  href="ftp://ftp.isi.edu/in-notes/iana/assignments/character-sets">ftp://ftp.isi.edu/in-notes/iana/assignments/character-sets</A>. 

  <DT><A name=RFC2278>RFC2278</A> 
  <DD>N. Freed, J. Postel. <I>IANA Charset Registration Procedures</I>. IETF RFC 
  2278. See <A 
  href="http://www.ietf.org/rfc/rfc2278.txt">http://www.ietf.org/rfc/rfc2278.txt</A>. 

  <DT><A name=RFC2376>RFC2376</A> 
  <DD>E. Whitehead, M. Murata. <I>XML Media Types</I>. IETF RFC 2376. See <A 
  href="http://www.ietf.org/rfc/rfc2376.txt">http://www.ietf.org/rfc/rfc2376.txt</A>. 

  <DT><A name=RFC2396>RFC2396</A> 
  <DD>T. Berners-Lee, R. Fielding, and L. Masinter. <I>Uniform Resource 
  Identifiers (URI): Generic Syntax</I>. IETF RFC 2396. See <A 
  href="http://www.ietf.org/rfc/rfc2396.txt">http://www.ietf.org/rfc/rfc2396.txt</A>. 

  <DT><A name=UNICODE-TR10>UNICODE TR10</A> 
  <DD>Unicode Consortium. <I>Unicode Technical Report #10. Unicode Collation 
  Algorithm</I>. Unicode Technical Report. See <A 
  href="http://www.unicode.org/unicode/reports/tr10/index.html">http://www.unicode.org/unicode/reports/tr10/index.html</A>. 

  <DT><A name=XHTML>XHTML</A> 
  <DD>World Wide Web Consortium. <I>XHTML 1.0: The Extensible HyperText Markup 
  Language.</I> W3C Proposed Recommendation. See <A 
  href="http://www.w3.org/TR/xhtml1">http://www.w3.org/TR/xhtml1</A> 
  <DT><A name=XPTR>XPointer</A> 
  <DD>World Wide Web Consortium. <I>XML Pointer Language (XPointer).</I> W3C 
  Working Draft. See <A 
  href="http://www.w3.org/TR/xptr">http://www.w3.org/TR/xptr</A> 
  <DT><A name=XMLSTYLE>XML Stylesheet</A> 
  <DD>World Wide Web Consortium. <I>Associating stylesheets with XML 
  documents.</I> W3C Recommendation. See <A 
  href="http://www.w3.org/TR/xml-stylesheet">http://www.w3.org/TR/xml-stylesheet</A> 

  <DT><A name=XSL>XSL</A> 
  <DD>World Wide Web Consortium. <I>Extensible Stylesheet Language (XSL).</I> 
  W3C Working Draft. See <A 
  href="http://www.w3.org/TR/WD-xsl">http://www.w3.org/TR/WD-xsl</A> </DD></DL>
<H2><A name=element-syntax-summary></A>B Element Syntax Summary</H2>
<P class=element-syntax-summary><CODE>&lt;!-- Category: instruction 
--&gt;<BR>&lt;<A 
href="http://www.w3.org/TR/xslt#element-apply-imports">xsl:apply-imports</A>&nbsp;/&gt;</CODE></P>
<P class=element-syntax-summary><CODE>&lt;!-- Category: instruction 
--&gt;<BR>&lt;<A 
href="http://www.w3.org/TR/xslt#element-apply-templates">xsl:apply-templates</A> 
<BR>&nbsp;&nbsp;select = <VAR>node-set-expression</VAR> <BR>&nbsp;&nbsp;mode = 
<VAR>qname</VAR>&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: (<A 
href="http://www.w3.org/TR/xslt#element-sort">xsl:sort</A> | <A 
href="http://www.w3.org/TR/xslt#element-with-param">xsl:with-param</A>)* 
--&gt;<BR>&lt;/xsl:apply-templates&gt;</CODE></P>
<P class=element-syntax-summary><CODE>&lt;!-- Category: instruction 
--&gt;<BR>&lt;<A 
href="http://www.w3.org/TR/xslt#element-attribute">xsl:attribute</A> 
<BR>&nbsp;&nbsp;<B>name</B> = { <VAR>qname</VAR> }<BR>&nbsp;&nbsp;namespace = { 
<VAR>uri-reference</VAR> }&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: 
<VAR>template</VAR> --&gt;<BR>&lt;/xsl:attribute&gt;</CODE></P>
<P class=element-syntax-summary><CODE>&lt;!-- Category: top-level-element 
--&gt;<BR>&lt;<A 
href="http://www.w3.org/TR/xslt#element-attribute-set">xsl:attribute-set</A> 
<BR>&nbsp;&nbsp;<B>name</B> = <VAR>qname</VAR> 
<BR>&nbsp;&nbsp;use-attribute-sets = 
<VAR>qnames</VAR>&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: <A 
href="http://www.w3.org/TR/xslt#element-attribute">xsl:attribute</A>* 
--&gt;<BR>&lt;/xsl:attribute-set&gt;</CODE></P>
<P class=element-syntax-summary><CODE>&lt;!-- Category: instruction 
--&gt;<BR>&lt;<A 
href="http://www.w3.org/TR/xslt#element-call-template">xsl:call-template</A> 
<BR>&nbsp;&nbsp;<B>name</B> = <VAR>qname</VAR>&gt;<BR>&nbsp;&nbsp;&lt;!-- 
Content: <A 
href="http://www.w3.org/TR/xslt#element-with-param">xsl:with-param</A>* 
--&gt;<BR>&lt;/xsl:call-template&gt;</CODE></P>
<P class=element-syntax-summary><CODE>&lt;!-- Category: instruction 
--&gt;<BR>&lt;<A 
href="http://www.w3.org/TR/xslt#element-choose">xsl:choose</A>&gt;<BR>&nbsp;&nbsp;&lt;!-- 
Content: (<A href="http://www.w3.org/TR/xslt#element-when">xsl:when</A>+, <A 
href="http://www.w3.org/TR/xslt#element-otherwise">xsl:otherwise</A>?) 
--&gt;<BR>&lt;/xsl:choose&gt;</CODE></P>
<P class=element-syntax-summary><CODE>&lt;!-- Category: instruction 
--&gt;<BR>&lt;<A 
href="http://www.w3.org/TR/xslt#element-comment">xsl:comment</A>&gt;<BR>&nbsp;&nbsp;&lt;!-- 
Content: <VAR>template</VAR> --&gt;<BR>&lt;/xsl:comment&gt;</CODE></P>
<P class=element-syntax-summary><CODE>&lt;!-- Category: instruction 
--&gt;<BR>&lt;<A href="http://www.w3.org/TR/xslt#element-copy">xsl:copy</A> 
<BR>&nbsp;&nbsp;use-attribute-sets = 
<VAR>qnames</VAR>&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: <VAR>template</VAR> 
--&gt;<BR>&lt;/xsl:copy&gt;</CODE></P>
<P class=element-syntax-summary><CODE>&lt;!-- Category: instruction 
--&gt;<BR>&lt;<A 
href="http://www.w3.org/TR/xslt#element-copy-of">xsl:copy-of</A> 
<BR>&nbsp;&nbsp;<B>select</B> = <VAR>expression</VAR>&nbsp;/&gt;</CODE></P>
<P class=element-syntax-summary><CODE>&lt;!-- Category: top-level-element 
--&gt;<BR>&lt;<A 
href="http://www.w3.org/TR/xslt#element-decimal-format">xsl:decimal-format</A> 
<BR>&nbsp;&nbsp;name = <VAR>qname</VAR> <BR>&nbsp;&nbsp;decimal-separator = 
<VAR>char</VAR> <BR>&nbsp;&nbsp;grouping-separator = <VAR>char</VAR> 
<BR>&nbsp;&nbsp;infinity = <VAR>string</VAR> <BR>&nbsp;&nbsp;minus-sign = 
<VAR>char</VAR> <BR>&nbsp;&nbsp;NaN = <VAR>string</VAR> <BR>&nbsp;&nbsp;percent 
= <VAR>char</VAR> <BR>&nbsp;&nbsp;per-mille = <VAR>char</VAR> 
<BR>&nbsp;&nbsp;zero-digit = <VAR>char</VAR> <BR>&nbsp;&nbsp;digit = 
<VAR>char</VAR> <BR>&nbsp;&nbsp;pattern-separator = 
<VAR>char</VAR>&nbsp;/&gt;</CODE></P>
<P class=element-syntax-summary><CODE>&lt;!-- Category: instruction 
--&gt;<BR>&lt;<A 
href="http://www.w3.org/TR/xslt#element-element">xsl:element</A> 
<BR>&nbsp;&nbsp;<B>name</B> = { <VAR>qname</VAR> }<BR>&nbsp;&nbsp;namespace = { 
<VAR>uri-reference</VAR> }<BR>&nbsp;&nbsp;use-attribute-sets = 
<VAR>qnames</VAR>&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: <VAR>template</VAR> 
--&gt;<BR>&lt;/xsl:element&gt;</CODE></P>
<P class=element-syntax-summary><CODE>&lt;!-- Category: instruction 
--&gt;<BR>&lt;<A 
href="http://www.w3.org/TR/xslt#element-fallback">xsl:fallback</A>&gt;<BR>&nbsp;&nbsp;&lt;!-- 
Content: <VAR>template</VAR> --&gt;<BR>&lt;/xsl:fallback&gt;</CODE></P>
<P class=element-syntax-summary><CODE>&lt;!-- Category: instruction 
--&gt;<BR>&lt;<A 
href="http://www.w3.org/TR/xslt#element-for-each">xsl:for-each</A> 
<BR>&nbsp;&nbsp;<B>select</B> = 
<VAR>node-set-expression</VAR>&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: (<A 
href="http://www.w3.org/TR/xslt#element-sort">xsl:sort</A>*, 
<VAR>template</VAR>) --&gt;<BR>&lt;/xsl:for-each&gt;</CODE></P>
<P class=element-syntax-summary><CODE>&lt;!-- Category: instruction 
--&gt;<BR>&lt;<A href="http://www.w3.org/TR/xslt#element-if">xsl:if</A> 
<BR>&nbsp;&nbsp;<B>test</B> = 
<VAR>boolean-expression</VAR>&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: 
<VAR>template</VAR> --&gt;<BR>&lt;/xsl:if&gt;</CODE></P>
<P class=element-syntax-summary><CODE>&lt;<A 
href="http://www.w3.org/TR/xslt#element-import">xsl:import</A> 
<BR>&nbsp;&nbsp;<B>href</B> = <VAR>uri-reference</VAR>&nbsp;/&gt;</CODE></P>
<P class=element-syntax-summary><CODE>&lt;!-- Category: top-level-element 
--&gt;<BR>&lt;<A 
href="http://www.w3.org/TR/xslt#element-include">xsl:include</A> 
<BR>&nbsp;&nbsp;<B>href</B> = <VAR>uri-reference</VAR>&nbsp;/&gt;</CODE></P>
<P class=element-syntax-summary><CODE>&lt;!-- Category: top-level-element 
--&gt;<BR>&lt;<A href="http://www.w3.org/TR/xslt#element-key">xsl:key</A> 
<BR>&nbsp;&nbsp;<B>name</B> = <VAR>qname</VAR> <BR>&nbsp;&nbsp;<B>match</B> = 
<VAR>pattern</VAR> <BR>&nbsp;&nbsp;<B>use</B> = 
<VAR>expression</VAR>&nbsp;/&gt;</CODE></P>
<P class=element-syntax-summary><CODE>&lt;!-- Category: instruction 
--&gt;<BR>&lt;<A 
href="http://www.w3.org/TR/xslt#element-message">xsl:message</A> 
<BR>&nbsp;&nbsp;terminate = "yes" | "no"&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: 
<VAR>template</VAR> --&gt;<BR>&lt;/xsl:message&gt;</CODE></P>
<P class=element-syntax-summary><CODE>&lt;!-- Category: top-level-element 
--&gt;<BR>&lt;<A 
href="http://www.w3.org/TR/xslt#element-namespace-alias">xsl:namespace-alias</A> 
<BR>&nbsp;&nbsp;<B>stylesheet-prefix</B> = <VAR>prefix</VAR> | 
"#default"<BR>&nbsp;&nbsp;<B>result-prefix</B> = <VAR>prefix</VAR> | 
"#default"&nbsp;/&gt;</CODE></P>
<P class=element-syntax-summary><CODE>&lt;!-- Category: instruction 
--&gt;<BR>&lt;<A href="http://www.w3.org/TR/xslt#element-number">xsl:number</A> 
<BR>&nbsp;&nbsp;level = "single" | "multiple" | "any"<BR>&nbsp;&nbsp;count = 
<VAR>pattern</VAR> <BR>&nbsp;&nbsp;from = <VAR>pattern</VAR> 
<BR>&nbsp;&nbsp;value = <VAR>number-expression</VAR> <BR>&nbsp;&nbsp;format = { 
<VAR>string</VAR> }<BR>&nbsp;&nbsp;lang = { <VAR>nmtoken</VAR> 
}<BR>&nbsp;&nbsp;letter-value = { "alphabetic" | "traditional" 
}<BR>&nbsp;&nbsp;grouping-separator = { <VAR>char</VAR> 
}<BR>&nbsp;&nbsp;grouping-size = { <VAR>number</VAR> }&nbsp;/&gt;</CODE></P>
<P class=element-syntax-summary><CODE>&lt;<A 
href="http://www.w3.org/TR/xslt#element-otherwise">xsl:otherwise</A>&gt;<BR>&nbsp;&nbsp;&lt;!-- 
Content: <VAR>template</VAR> --&gt;<BR>&lt;/xsl:otherwise&gt;</CODE></P>
<P class=element-syntax-summary><CODE>&lt;!-- Category: top-level-element 
--&gt;<BR>&lt;<A href="http://www.w3.org/TR/xslt#element-output">xsl:output</A> 
<BR>&nbsp;&nbsp;method = "xml" | "html" | "text" | 
<VAR>qname-but-not-ncname</VAR> <BR>&nbsp;&nbsp;version = <VAR>nmtoken</VAR> 
<BR>&nbsp;&nbsp;encoding = <VAR>string</VAR> 
<BR>&nbsp;&nbsp;omit-xml-declaration = "yes" | "no"<BR>&nbsp;&nbsp;standalone = 
"yes" | "no"<BR>&nbsp;&nbsp;doctype-public = <VAR>string</VAR> 
<BR>&nbsp;&nbsp;doctype-system = <VAR>string</VAR> 
<BR>&nbsp;&nbsp;cdata-section-elements = <VAR>qnames</VAR> 
<BR>&nbsp;&nbsp;indent = "yes" | "no"<BR>&nbsp;&nbsp;media-type = 
<VAR>string</VAR>&nbsp;/&gt;</CODE></P>
<P class=element-syntax-summary><CODE>&lt;!-- Category: top-level-element 
--&gt;<BR>&lt;<A href="http://www.w3.org/TR/xslt#element-param">xsl:param</A> 
<BR>&nbsp;&nbsp;<B>name</B> = <VAR>qname</VAR> <BR>&nbsp;&nbsp;select = 
<VAR>expression</VAR>&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: <VAR>template</VAR> 
--&gt;<BR>&lt;/xsl:param&gt;</CODE></P>
<P class=element-syntax-summary><CODE>&lt;!-- Category: top-level-element 
--&gt;<BR>&lt;<A 
href="http://www.w3.org/TR/xslt#element-preserve-space">xsl:preserve-space</A> 
<BR>&nbsp;&nbsp;<B>elements</B> = <VAR>tokens</VAR>&nbsp;/&gt;</CODE></P>
<P class=element-syntax-summary><CODE>&lt;!-- Category: instruction 
--&gt;<BR>&lt;<A 
href="http://www.w3.org/TR/xslt#element-processing-instruction">xsl:processing-instruction</A> 
<BR>&nbsp;&nbsp;<B>name</B> = { <VAR>ncname</VAR> }&gt;<BR>&nbsp;&nbsp;&lt;!-- 
Content: <VAR>template</VAR> 
--&gt;<BR>&lt;/xsl:processing-instruction&gt;</CODE></P>
<P class=element-syntax-summary><CODE>&lt;<A 
href="http://www.w3.org/TR/xslt#element-sort">xsl:sort</A> 
<BR>&nbsp;&nbsp;select = <VAR>string-expression</VAR> <BR>&nbsp;&nbsp;lang = { 
<VAR>nmtoken</VAR> }<BR>&nbsp;&nbsp;data-type = { "text" | "number" | 
<VAR>qname-but-not-ncname</VAR> }<BR>&nbsp;&nbsp;order = { "ascending" | 
"descending" }<BR>&nbsp;&nbsp;case-order = { "upper-first" | "lower-first" 
}&nbsp;/&gt;</CODE></P>
<P class=element-syntax-summary><CODE>&lt;!-- Category: top-level-element 
--&gt;<BR>&lt;<A 
href="http://www.w3.org/TR/xslt#element-strip-space">xsl:strip-space</A> 
<BR>&nbsp;&nbsp;<B>elements</B> = <VAR>tokens</VAR>&nbsp;/&gt;</CODE></P>
<P class=element-syntax-summary><CODE>&lt;<A 
href="http://www.w3.org/TR/xslt#element-stylesheet">xsl:stylesheet</A> 
<BR>&nbsp;&nbsp;id = <VAR>id</VAR> <BR>&nbsp;&nbsp;extension-element-prefixes = 
<VAR>tokens</VAR> <BR>&nbsp;&nbsp;exclude-result-prefixes = <VAR>tokens</VAR> 
<BR>&nbsp;&nbsp;<B>version</B> = <VAR>number</VAR>&gt;<BR>&nbsp;&nbsp;&lt;!-- 
Content: (<A href="http://www.w3.org/TR/xslt#element-import">xsl:import</A>*, 
<VAR>top-level-elements</VAR>) --&gt;<BR>&lt;/xsl:stylesheet&gt;</CODE></P>
<P class=element-syntax-summary><CODE>&lt;!-- Category: top-level-element 
--&gt;<BR>&lt;<A 
href="http://www.w3.org/TR/xslt#element-template">xsl:template</A> 
<BR>&nbsp;&nbsp;match = <VAR>pattern</VAR> <BR>&nbsp;&nbsp;name = 
<VAR>qname</VAR> <BR>&nbsp;&nbsp;priority = <VAR>number</VAR> 
<BR>&nbsp;&nbsp;mode = <VAR>qname</VAR>&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: (<A 
href="http://www.w3.org/TR/xslt#element-param">xsl:param</A>*, 
<VAR>template</VAR>) --&gt;<BR>&lt;/xsl:template&gt;</CODE></P>
<P class=element-syntax-summary><CODE>&lt;!-- Category: instruction 
--&gt;<BR>&lt;<A href="http://www.w3.org/TR/xslt#element-text">xsl:text</A> 
<BR>&nbsp;&nbsp;disable-output-escaping = "yes" | 
"no"&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: #PCDATA 
--&gt;<BR>&lt;/xsl:text&gt;</CODE></P>
<P class=element-syntax-summary><CODE>&lt;<A 
href="http://www.w3.org/TR/xslt#element-transform">xsl:transform</A> 
<BR>&nbsp;&nbsp;id = <VAR>id</VAR> <BR>&nbsp;&nbsp;extension-element-prefixes = 
<VAR>tokens</VAR> <BR>&nbsp;&nbsp;exclude-result-prefixes = <VAR>tokens</VAR> 
<BR>&nbsp;&nbsp;<B>version</B> = <VAR>number</VAR>&gt;<BR>&nbsp;&nbsp;&lt;!-- 
Content: (<A href="http://www.w3.org/TR/xslt#element-import">xsl:import</A>*, 
<VAR>top-level-elements</VAR>) --&gt;<BR>&lt;/xsl:transform&gt;</CODE></P>
<P class=element-syntax-summary><CODE>&lt;!-- Category: instruction 
--&gt;<BR>&lt;<A 
href="http://www.w3.org/TR/xslt#element-value-of">xsl:value-of</A> 
<BR>&nbsp;&nbsp;<B>select</B> = <VAR>string-expression</VAR> 
<BR>&nbsp;&nbsp;disable-output-escaping = "yes" | "no"&nbsp;/&gt;</CODE></P>
<P class=element-syntax-summary><CODE>&lt;!-- Category: top-level-element 
--&gt;<BR>&lt;!-- Category: instruction --&gt;<BR>&lt;<A 
href="http://www.w3.org/TR/xslt#element-variable">xsl:variable</A> 
<BR>&nbsp;&nbsp;<B>name</B> = <VAR>qname</VAR> <BR>&nbsp;&nbsp;select = 
<VAR>expression</VAR>&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: <VAR>template</VAR> 
--&gt;<BR>&lt;/xsl:variable&gt;</CODE></P>
<P class=element-syntax-summary><CODE>&lt;<A 
href="http://www.w3.org/TR/xslt#element-when">xsl:when</A> 
<BR>&nbsp;&nbsp;<B>test</B> = 
<VAR>boolean-expression</VAR>&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: 
<VAR>template</VAR> --&gt;<BR>&lt;/xsl:when&gt;</CODE></P>
<P class=element-syntax-summary><CODE>&lt;<A 
href="http://www.w3.org/TR/xslt#element-with-param">xsl:with-param</A> 
<BR>&nbsp;&nbsp;<B>name</B> = <VAR>qname</VAR> <BR>&nbsp;&nbsp;select = 
<VAR>expression</VAR>&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: <VAR>template</VAR> 
--&gt;<BR>&lt;/xsl:with-param&gt;</CODE></P>
<H2><A name=dtd></A>C DTD Fragment for XSLT Stylesheets (Non-Normative)</H2>
<BLOCKQUOTE><B>NOTE:</B>This DTD Fragment is not normative because XML 1.0 
  DTDs do not support XML Namespaces and thus cannot correctly describe the 
  allowed structure of an XSLT stylesheet.</BLOCKQUOTE>
<P>The following entity can be used to construct a DTD for XSLT stylesheets that 
create instances of a particular result DTD. Before referencing the entity, the 
stylesheet DTD must define a <CODE>result-elements</CODE> parameter entity 
listing the allowed result element types. For example:</P><PRE>&lt;!ENTITY % result-elements "
  | fo:inline-sequence
  | fo:block
"&gt;</PRE>
<P>Such result elements should be declared to have 
<CODE>xsl:use-attribute-sets</CODE> and 
<CODE>xsl:extension-element-prefixes</CODE> attributes. The following entity 
declares the <CODE>result-element-atts</CODE> parameter for this purpose. The 
content that XSLT allows for result elements is the same as it allows for the 
XSLT elements that are declared in the following entity with a content model of 
<CODE>%template;</CODE>. The DTD may use a more restrictive content model than 
<CODE>%template;</CODE> to reflect the constraints of the result DTD.</P>
<P>The DTD may define the <CODE>non-xsl-top-level</CODE> parameter entity to 
allow additional top-level elements from namespaces other than the XSLT 
namespace.</P>
<P>The use of the <CODE>xsl:</CODE> prefix in this DTD does not imply that XSLT 
stylesheets are required to use this prefix. Any of the elements declared in 
this DTD may have attributes whose name starts with <CODE>xmlns:</CODE> or is 
equal to <CODE>xmlns</CODE> in addition to the attributes declared in this 
DTD.</P><PRE>&lt;!ENTITY % char-instructions "
  | xsl:apply-templates
  | xsl:call-template
  | xsl:apply-imports
  | xsl:for-each
  | xsl:value-of
  | xsl:copy-of
  | xsl:number
  | xsl:choose
  | xsl:if
  | xsl:text
  | xsl:copy
  | xsl:variable
  | xsl:message
  | xsl:fallback
"&gt;

&lt;!ENTITY % instructions "
  %char-instructions;
  | xsl:processing-instruction
  | xsl:comment
  | xsl:element
  | xsl:attribute
"&gt;

&lt;!ENTITY % char-template "
 (#PCDATA
  %char-instructions;)*
"&gt;

&lt;!ENTITY % template "
 (#PCDATA
  %instructions;
  %result-elements;)*
"&gt;

&lt;!-- Used for the type of an attribute value that is a URI reference.--&gt;
&lt;!ENTITY % URI "CDATA"&gt;

&lt;!-- Used for the type of an attribute value that is a pattern.--&gt;
&lt;!ENTITY % pattern "CDATA"&gt;

&lt;!-- Used for the type of an attribute value that is an
     attribute value template.--&gt;
&lt;!ENTITY % avt "CDATA"&gt;

&lt;!-- Used for the type of an attribute value that is a QName; the prefix
     gets expanded by the XSLT processor. --&gt;
&lt;!ENTITY % qname "NMTOKEN"&gt;

&lt;!-- Like qname but a whitespace-separated list of QNames. --&gt;
&lt;!ENTITY % qnames "NMTOKENS"&gt;

&lt;!-- Used for the type of an attribute value that is an expression.--&gt;
&lt;!ENTITY % expr "CDATA"&gt;

&lt;!-- Used for the type of an attribute value that consists
     of a single character.--&gt;
&lt;!ENTITY % char "CDATA"&gt;

&lt;!-- Used for the type of an attribute value that is a priority. --&gt;
&lt;!ENTITY % priority "NMTOKEN"&gt;

&lt;!ENTITY % space-att "xml:space (default|preserve) #IMPLIED"&gt;

&lt;!-- This may be overridden to customize the set of elements allowed
at the top-level. --&gt;

&lt;!ENTITY % non-xsl-top-level ""&gt;

&lt;!ENTITY % top-level "
 (xsl:import*,
  (xsl:include
  | xsl:strip-space
  | xsl:preserve-space
  | xsl:output
  | xsl:key
  | xsl:decimal-format
  | xsl:attribute-set
  | xsl:variable
  | xsl:param
  | xsl:template
  | xsl:namespace-alias
  %non-xsl-top-level;)*)
"&gt;

&lt;!ENTITY % top-level-atts '
  extension-element-prefixes CDATA #IMPLIED
  exclude-result-prefixes CDATA #IMPLIED
  id ID #IMPLIED
  version NMTOKEN #REQUIRED
  xmlns:xsl CDATA #FIXED "http://www.w3.org/1999/XSL/Transform"
  %space-att;
'&gt;

&lt;!-- This entity is defined for use in the ATTLIST declaration
for result elements. --&gt;

&lt;!ENTITY % result-element-atts '
  xsl:extension-element-prefixes CDATA #IMPLIED
  xsl:exclude-result-prefixes CDATA #IMPLIED
  xsl:use-attribute-sets %qnames; #IMPLIED
  xsl:version NMTOKEN #IMPLIED
'&gt;

&lt;!ELEMENT xsl:stylesheet %top-level;&gt;
&lt;!ATTLIST xsl:stylesheet %top-level-atts;&gt;

&lt;!ELEMENT xsl:transform %top-level;&gt;
&lt;!ATTLIST xsl:transform %top-level-atts;&gt;

&lt;!ELEMENT xsl:import EMPTY&gt;
&lt;!ATTLIST xsl:import href %URI; #REQUIRED&gt;

&lt;!ELEMENT xsl:include EMPTY&gt;
&lt;!ATTLIST xsl:include href %URI; #REQUIRED&gt;

&lt;!ELEMENT xsl:strip-space EMPTY&gt;
&lt;!ATTLIST xsl:strip-space elements CDATA #REQUIRED&gt;

&lt;!ELEMENT xsl:preserve-space EMPTY&gt;
&lt;!ATTLIST xsl:preserve-space elements CDATA #REQUIRED&gt;

&lt;!ELEMENT xsl:output EMPTY&gt;
&lt;!ATTLIST xsl:output
  method %qname; #IMPLIED
  version NMTOKEN #IMPLIED
  encoding CDATA #IMPLIED
  omit-xml-declaration (yes|no) #IMPLIED
  standalone (yes|no) #IMPLIED
  doctype-public CDATA #IMPLIED
  doctype-system CDATA #IMPLIED
  cdata-section-elements %qnames; #IMPLIED
  indent (yes|no) #IMPLIED
  media-type CDATA #IMPLIED
&gt;

&lt;!ELEMENT xsl:key EMPTY&gt;
&lt;!ATTLIST xsl:key
  name %qname; #REQUIRED
  match %pattern; #REQUIRED
  use %expr; #REQUIRED
&gt;

&lt;!ELEMENT xsl:decimal-format EMPTY&gt;
&lt;!ATTLIST xsl:decimal-format
  name %qname; #IMPLIED
  decimal-separator %char; "."
  grouping-separator %char; ","
  infinity CDATA "Infinity"
  minus-sign %char; "-"
  NaN CDATA "NaN"
  percent %char; "%"
  per-mille %char; "&amp;#x2030;"
  zero-digit %char; "0"
  digit %char; "#"
  pattern-separator %char; ";"
&gt;

&lt;!ELEMENT xsl:namespace-alias EMPTY&gt;
&lt;!ATTLIST xsl:namespace-alias
  stylesheet-prefix CDATA #REQUIRED
  result-prefix CDATA #REQUIRED
&gt;

&lt;!ELEMENT xsl:template
 (#PCDATA
  %instructions;
  %result-elements;
  | xsl:param)*
&gt;

&lt;!ATTLIST xsl:template
  match %pattern; #IMPLIED
  name %qname; #IMPLIED
  priority %priority; #IMPLIED
  mode %qname; #IMPLIED
  %space-att;
&gt;

&lt;!ELEMENT xsl:value-of EMPTY&gt;
&lt;!ATTLIST xsl:value-of
  select %expr; #REQUIRED
  disable-output-escaping (yes|no) "no"
&gt;

&lt;!ELEMENT xsl:copy-of EMPTY&gt;
&lt;!ATTLIST xsl:copy-of select %expr; #REQUIRED&gt;

&lt;!ELEMENT xsl:number EMPTY&gt;
&lt;!ATTLIST xsl:number
   level (single|multiple|any) "single"
   count %pattern; #IMPLIED
   from %pattern; #IMPLIED
   value %expr; #IMPLIED
   format %avt; '1'
   lang %avt; #IMPLIED
   letter-value %avt; #IMPLIED
   grouping-separator %avt; #IMPLIED
   grouping-size %avt; #IMPLIED
&gt;

&lt;!ELEMENT xsl:apply-templates (xsl:sort|xsl:with-param)*&gt;
&lt;!ATTLIST xsl:apply-templates
  select %expr; "node()"
  mode %qname; #IMPLIED
&gt;

&lt;!ELEMENT xsl:apply-imports EMPTY&gt;

&lt;!-- xsl:sort cannot occur after any other elements or
any non-whitespace character --&gt;

&lt;!ELEMENT xsl:for-each
 (#PCDATA
  %instructions;
  %result-elements;
  | xsl:sort)*
&gt;

&lt;!ATTLIST xsl:for-each
  select %expr; #REQUIRED
  %space-att;
&gt;

&lt;!ELEMENT xsl:sort EMPTY&gt;
&lt;!ATTLIST xsl:sort
  select %expr; "."
  lang %avt; #IMPLIED
  data-type %avt; "text"
  order %avt; "ascending"
  case-order %avt; #IMPLIED
&gt;

&lt;!ELEMENT xsl:if %template;&gt;
&lt;!ATTLIST xsl:if
  test %expr; #REQUIRED
  %space-att;
&gt;

&lt;!ELEMENT xsl:choose (xsl:when+, xsl:otherwise?)&gt;
&lt;!ATTLIST xsl:choose %space-att;&gt;

&lt;!ELEMENT xsl:when %template;&gt;
&lt;!ATTLIST xsl:when
  test %expr; #REQUIRED
  %space-att;
&gt;

&lt;!ELEMENT xsl:otherwise %template;&gt;
&lt;!ATTLIST xsl:otherwise %space-att;&gt;

&lt;!ELEMENT xsl:attribute-set (xsl:attribute)*&gt;
&lt;!ATTLIST xsl:attribute-set
  name %qname; #REQUIRED
  use-attribute-sets %qnames; #IMPLIED
&gt;

&lt;!ELEMENT xsl:call-template (xsl:with-param)*&gt;
&lt;!ATTLIST xsl:call-template
  name %qname; #REQUIRED
&gt;

&lt;!ELEMENT xsl:with-param %template;&gt;
&lt;!ATTLIST xsl:with-param
  name %qname; #REQUIRED
  select %expr; #IMPLIED
&gt;

&lt;!ELEMENT xsl:variable %template;&gt;
&lt;!ATTLIST xsl:variable 
  name %qname; #REQUIRED
  select %expr; #IMPLIED
&gt;

&lt;!ELEMENT xsl:param %template;&gt;
&lt;!ATTLIST xsl:param 
  name %qname; #REQUIRED
  select %expr; #IMPLIED
&gt;

&lt;!ELEMENT xsl:text (#PCDATA)&gt;
&lt;!ATTLIST xsl:text
  disable-output-escaping (yes|no) "no"
&gt;

&lt;!ELEMENT xsl:processing-instruction %char-template;&gt;
&lt;!ATTLIST xsl:processing-instruction 
  name %avt; #REQUIRED
  %space-att;
&gt;

&lt;!ELEMENT xsl:element %template;&gt;
&lt;!ATTLIST xsl:element 
  name %avt; #REQUIRED
  namespace %avt; #IMPLIED
  use-attribute-sets %qnames; #IMPLIED
  %space-att;
&gt;

&lt;!ELEMENT xsl:attribute %char-template;&gt;
&lt;!ATTLIST xsl:attribute 
  name %avt; #REQUIRED
  namespace %avt; #IMPLIED
  %space-att;
&gt;

&lt;!ELEMENT xsl:comment %char-template;&gt;
&lt;!ATTLIST xsl:comment %space-att;&gt;

&lt;!ELEMENT xsl:copy %template;&gt;
&lt;!ATTLIST xsl:copy
  %space-att;
  use-attribute-sets %qnames; #IMPLIED
&gt;

&lt;!ELEMENT xsl:message %template;&gt;
&lt;!ATTLIST xsl:message
  %space-att;
  terminate (yes|no) "no"
&gt;

&lt;!ELEMENT xsl:fallback %template;&gt;
&lt;!ATTLIST xsl:fallback %space-att;&gt;</PRE>
<H2><A name=section-Examples></A>D Examples (Non-Normative)</H2>
<H3><A name=section-Document-Example></A>D.1 Document Example</H3>
<P>This example is a stylesheet for transforming documents that conform to a 
simple DTD into XHTML <A href="http://www.w3.org/TR/xslt#XHTML">[XHTML]</A>. The 
DTD is:</P><PRE>&lt;!ELEMENT doc (title, chapter*)&gt;
&lt;!ELEMENT chapter (title, (para|note)*, section*)&gt;
&lt;!ELEMENT section (title, (para|note)*)&gt;
&lt;!ELEMENT title (#PCDATA|emph)*&gt;
&lt;!ELEMENT para (#PCDATA|emph)*&gt;
&lt;!ELEMENT note (#PCDATA|emph)*&gt;
&lt;!ELEMENT emph (#PCDATA|emph)*&gt;</PRE>
<P>The stylesheet is:</P><PRE>&lt;xsl:stylesheet version="1.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns="http://www.w3.org/TR/xhtml1/strict"&gt;

&lt;xsl:strip-space elements="doc chapter section"/&gt;
&lt;xsl:output
   method="xml"
   indent="yes"
   encoding="iso-8859-1"
/&gt;

&lt;xsl:template match="doc"&gt;
 &lt;html&gt;
   &lt;head&gt;
     &lt;title&gt;
       &lt;xsl:value-of select="title"/&gt;
     &lt;/title&gt;
   &lt;/head&gt;
   &lt;body&gt;
     &lt;xsl:apply-templates/&gt;
   &lt;/body&gt;
 &lt;/html&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="doc/title"&gt;
  &lt;h1&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/h1&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="chapter/title"&gt;
  &lt;h2&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/h2&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="section/title"&gt;
  &lt;h3&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/h3&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="para"&gt;
  &lt;p&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/p&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="note"&gt;
  &lt;p class="note"&gt;
    &lt;b&gt;NOTE: &lt;/b&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/p&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="emph"&gt;
  &lt;em&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/em&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</PRE>
<P>With the following input document</P><PRE>&lt;!DOCTYPE doc SYSTEM "doc.dtd"&gt;
&lt;doc&gt;
&lt;title&gt;Document Title&lt;/title&gt;
&lt;chapter&gt;
&lt;title&gt;Chapter Title&lt;/title&gt;
&lt;section&gt;
&lt;title&gt;Section Title&lt;/title&gt;
&lt;para&gt;This is a test.&lt;/para&gt;
&lt;note&gt;This is a note.&lt;/note&gt;
&lt;/section&gt;
&lt;section&gt;
&lt;title&gt;Another Section Title&lt;/title&gt;
&lt;para&gt;This is &lt;emph&gt;another&lt;/emph&gt; test.&lt;/para&gt;
&lt;note&gt;This is another note.&lt;/note&gt;
&lt;/section&gt;
&lt;/chapter&gt;
&lt;/doc&gt;</PRE>
<P>it would produce the following result</P><PRE>&lt;?xml version="1.0" encoding="iso-8859-1"?&gt;
&lt;html xmlns="http://www.w3.org/TR/xhtml1/strict"&gt;
&lt;head&gt;
&lt;title&gt;Document Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Document Title&lt;/h1&gt;
&lt;h2&gt;Chapter Title&lt;/h2&gt;
&lt;h3&gt;Section Title&lt;/h3&gt;
&lt;p&gt;This is a test.&lt;/p&gt;
&lt;p class="note"&gt;
&lt;b&gt;NOTE: &lt;/b&gt;This is a note.&lt;/p&gt;
&lt;h3&gt;Another Section Title&lt;/h3&gt;
&lt;p&gt;This is &lt;em&gt;another&lt;/em&gt; test.&lt;/p&gt;
&lt;p class="note"&gt;
&lt;b&gt;NOTE: &lt;/b&gt;This is another note.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</PRE>
<H3><A name=data-example></A>D.2 Data Example</H3>
<P>This is an example of transforming some data represented in XML using three 
different XSLT stylesheets to produce three different representations of the 
data, HTML, SVG and VRML.</P>
<P>The input data is:</P><PRE>&lt;sales&gt;

        &lt;division id="North"&gt;
                &lt;revenue&gt;10&lt;/revenue&gt;
                &lt;growth&gt;9&lt;/growth&gt;
                &lt;bonus&gt;7&lt;/bonus&gt;
        &lt;/division&gt;

        &lt;division id="South"&gt;
                &lt;revenue&gt;4&lt;/revenue&gt;
                &lt;growth&gt;3&lt;/growth&gt;
                &lt;bonus&gt;4&lt;/bonus&gt;
        &lt;/division&gt;

        &lt;division id="West"&gt;
                &lt;revenue&gt;6&lt;/revenue&gt;
                &lt;growth&gt;-1.5&lt;/growth&gt;
                &lt;bonus&gt;2&lt;/bonus&gt;
        &lt;/division&gt;

&lt;/sales&gt;</PRE>
<P>The following stylesheet, which uses the simplified syntax described in <A 
href="http://www.w3.org/TR/xslt#result-element-stylesheet">[<B>2.3 Literal 
Result Element as Stylesheet</B>]</A>, transforms the data into HTML:</P><PRE>&lt;html xsl:version="1.0"
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
      lang="en"&gt;
    &lt;head&gt;
        &lt;title&gt;Sales Results By Division&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;table border="1"&gt;
            &lt;tr&gt;
                &lt;th&gt;Division&lt;/th&gt;
                &lt;th&gt;Revenue&lt;/th&gt;
                &lt;th&gt;Growth&lt;/th&gt;
                &lt;th&gt;Bonus&lt;/th&gt;
            &lt;/tr&gt;
            &lt;xsl:for-each select="sales/division"&gt;
                &lt;!-- order the result by revenue --&gt;
                &lt;xsl:sort select="revenue"
                          data-type="number"
                          order="descending"/&gt;
                &lt;tr&gt;
                    &lt;td&gt;
                        &lt;em&gt;&lt;xsl:value-of select="@id"/&gt;&lt;/em&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                        &lt;xsl:value-of select="revenue"/&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                        &lt;!-- highlight negative growth in red --&gt;
                        &lt;xsl:if test="growth &amp;lt; 0"&gt;
                             &lt;xsl:attribute name="style"&gt;
                                 &lt;xsl:text&gt;color:red&lt;/xsl:text&gt;
                             &lt;/xsl:attribute&gt;
                        &lt;/xsl:if&gt;
                        &lt;xsl:value-of select="growth"/&gt;
                    &lt;/td&gt;
                    &lt;td&gt;
                        &lt;xsl:value-of select="bonus"/&gt;
                    &lt;/td&gt;
                &lt;/tr&gt;
            &lt;/xsl:for-each&gt;
        &lt;/table&gt;
    &lt;/body&gt;
&lt;/html&gt;</PRE>
<P>The HTML output is:</P><PRE>&lt;html lang="en"&gt;
&lt;head&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"&gt;
&lt;title&gt;Sales Results By Division&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;table border="1"&gt;
&lt;tr&gt;
&lt;th&gt;Division&lt;/th&gt;&lt;th&gt;Revenue&lt;/th&gt;&lt;th&gt;Growth&lt;/th&gt;&lt;th&gt;Bonus&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;em&gt;North&lt;/em&gt;&lt;/td&gt;&lt;td&gt;10&lt;/td&gt;&lt;td&gt;9&lt;/td&gt;&lt;td&gt;7&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;em&gt;West&lt;/em&gt;&lt;/td&gt;&lt;td&gt;6&lt;/td&gt;&lt;td style="color:red"&gt;-1.5&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;em&gt;South&lt;/em&gt;&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;</PRE>
<P>The following stylesheet transforms the data into SVG:</P><PRE>&lt;xsl:stylesheet version="1.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns="http://www.w3.org/Graphics/SVG/SVG-19990812.dtd"&gt;

&lt;xsl:output method="xml" indent="yes" media-type="image/svg"/&gt;

&lt;xsl:template match="/"&gt;

&lt;svg width = "3in" height="3in"&gt;
    &lt;g style = "stroke: #000000"&gt; 
        &lt;!-- draw the axes --&gt;
        &lt;line x1="0" x2="150" y1="150" y2="150"/&gt;
        &lt;line x1="0" x2="0" y1="0" y2="150"/&gt;
        &lt;text x="0" y="10"&gt;Revenue&lt;/text&gt;
        &lt;text x="150" y="165"&gt;Division&lt;/text&gt;
        &lt;xsl:for-each select="sales/division"&gt;
            &lt;!-- define some useful variables --&gt;

            &lt;!-- the bar's x position --&gt;
            &lt;xsl:variable name="pos"
                          select="(position()*40)-30"/&gt;

            &lt;!-- the bar's height --&gt;
            &lt;xsl:variable name="height"
                          select="revenue*10"/&gt;

            &lt;!-- the rectangle --&gt;
            &lt;rect x="{$pos}" y="{150-$height}"
                  width="20" height="{$height}"/&gt;

            &lt;!-- the text label --&gt;
            &lt;text x="{$pos}" y="165"&gt;
                &lt;xsl:value-of select="@id"/&gt;
            &lt;/text&gt; 

            &lt;!-- the bar value --&gt;
            &lt;text x="{$pos}" y="{145-$height}"&gt;
                &lt;xsl:value-of select="revenue"/&gt;
            &lt;/text&gt;
        &lt;/xsl:for-each&gt;
    &lt;/g&gt;
&lt;/svg&gt;

&lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</PRE>
<P>The SVG output is:</P><PRE>&lt;svg width="3in" height="3in"
     xmlns="http://www.w3.org/Graphics/SVG/svg-19990412.dtd"&gt;
    &lt;g style="stroke: #000000"&gt;
        &lt;line x1="0" x2="150" y1="150" y2="150"/&gt;
        &lt;line x1="0" x2="0" y1="0" y2="150"/&gt;
        &lt;text x="0" y="10"&gt;Revenue&lt;/text&gt;
        &lt;text x="150" y="165"&gt;Division&lt;/text&gt;
        &lt;rect x="10" y="50" width="20" height="100"/&gt;
        &lt;text x="10" y="165"&gt;North&lt;/text&gt;
        &lt;text x="10" y="45"&gt;10&lt;/text&gt;
        &lt;rect x="50" y="110" width="20" height="40"/&gt;
        &lt;text x="50" y="165"&gt;South&lt;/text&gt;
        &lt;text x="50" y="105"&gt;4&lt;/text&gt;
        &lt;rect x="90" y="90" width="20" height="60"/&gt;
        &lt;text x="90" y="165"&gt;West&lt;/text&gt;
        &lt;text x="90" y="85"&gt;6&lt;/text&gt;
    &lt;/g&gt;
&lt;/svg&gt;</PRE>
<P>The following stylesheet transforms the data into VRML:</P><PRE>&lt;xsl:stylesheet version="1.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;!-- generate text output as mime type model/vrml, using default charset --&gt;
&lt;xsl:output method="text" encoding="UTF-8" media-type="model/vrml"/&gt;  

        &lt;xsl:template match="/"&gt;#VRML V2.0 utf8 
 
# externproto definition of a single bar element 
EXTERNPROTO bar [ 
  field SFInt32 x  
  field SFInt32 y  
  field SFInt32 z  
  field SFString name  
  ] 
  "http://www.vrml.org/WorkingGroups/dbwork/barProto.wrl" 
 
# inline containing the graph axes 
Inline {  
        url "http://www.vrml.org/WorkingGroups/dbwork/barAxes.wrl" 
        } 
        
                &lt;xsl:for-each select="sales/division"&gt;
bar {
        x &lt;xsl:value-of select="revenue"/&gt;
        y &lt;xsl:value-of select="growth"/&gt;
        z &lt;xsl:value-of select="bonus"/&gt;
        name "&lt;xsl:value-of select="@id"/&gt;" 
        }
                &lt;/xsl:for-each&gt;
        
        &lt;/xsl:template&gt; 
 
&lt;/xsl:stylesheet&gt;</PRE>
<P>The VRML output is:</P><PRE>#VRML V2.0 utf8 
 
# externproto definition of a single bar element 
EXTERNPROTO bar [ 
  field SFInt32 x  
  field SFInt32 y  
  field SFInt32 z  
  field SFString name  
  ] 
  "http://www.vrml.org/WorkingGroups/dbwork/barProto.wrl" 
 
# inline containing the graph axes 
Inline {  
        url "http://www.vrml.org/WorkingGroups/dbwork/barAxes.wrl" 
        } 
        
                
bar {
        x 10
        y 9
        z 7
        name "North" 
        }
                
bar {
        x 4
        y 3
        z 4
        name "South" 
        }
                
bar {
        x 6
        y -1.5
        z 2
        name "West" 
        }</PRE>
<H2><A name=section-Acknowledgements></A>E Acknowledgements (Non-Normative)</H2>
<P>The following have contributed to authoring this draft:</P>
<UL>
  <LI>Daniel Lipkin, Saba 
  <LI>Jonathan Marsh, Microsoft 
  <LI>Henry Thompson, University of Edinburgh 
  <LI>Norman Walsh, Arbortext 
  <LI>Steve Zilles, Adobe </LI></UL>
<P>This specification was developed and approved for publication by the W3C XSL 
Working Group (WG). WG approval of this specification does not necessarily imply 
that all WG members voted for its approval. The current members of the XSL WG 
are:</P>Sharon Adler, IBM (Co-Chair); Anders Berglund, IBM; Perin Blanchard, 
Novell; Scott Boag, Lotus; Larry Cable, Sun; Jeff Caruso, Bitstream; James 
Clark; Peter Danielsen, Bell Labs; Don Day, IBM; Stephen Deach, Adobe; Dwayne 
Dicks, SoftQuad; Andrew Greene, Bitstream; Paul Grosso, Arbortext; Eduardo 
Gutentag, Sun; Juliane Harbarth, Software AG; Mickey Kimchi, Enigma; Chris 
Lilley, W3C; Chris Maden, Exemplary Technologies; Jonathan Marsh, Microsoft; 
Alex Milowski, Lexica; Steve Muench, Oracle; Scott Parnell, Xerox; Vincent 
Quint, W3C; Dan Rapp, Novell; Gregg Reynolds, Datalogics; Jonathan Robie, 
Software AG; Mark Scardina, Oracle; Henry Thompson, University of Edinburgh; 
Philip Wadler, Bell Labs; Norman Walsh, Arbortext; Sanjiva Weerawarana, IBM; 
Steve Zilles, Adobe (Co-Chair) 
<H2><A name=section-Changes-from-Proposed-Recommendation></A>F Changes from 
Proposed Recommendation (Non-Normative)</H2>
<P>The following are the changes since the Proposed Recommendation:</P>
<UL>
  <LI>
  <P>The <CODE>xsl:version</CODE> attribute is required on a literal result 
  element used as a stylesheet (see <A 
  href="http://www.w3.org/TR/xslt#result-element-stylesheet">[<B>2.3 Literal 
  Result Element as Stylesheet</B>]</A>).</P>
  <LI>
  <P>The <CODE>data-type</CODE> attribute on <CODE>xsl:sort</CODE> can use a 
  prefixed name to specify a data-type not defined by XSLT (see <A 
  href="http://www.w3.org/TR/xslt#sorting">[<B>10 Sorting</B>]</A>).</P></LI></UL>
<H2><A 
name=section-Features-under-Consideration-for-Future-Versions-of-XSLT></A>G 
Features under Consideration for Future Versions of XSLT (Non-Normative)</H2>
<P>The following features are under consideration for versions of XSLT after 
XSLT 1.0:</P>
<UL>
  <LI>
  <P>a conditional expression;</P>
  <LI>
  <P>support for XML Schema datatypes and archetypes;</P>
  <LI>
  <P>support for something like style rules in the original XSL submission;</P>
  <LI>
  <P>an attribute to control the default namespace for names occurring in XSLT 
  attributes;</P>
  <LI>
  <P>support for entity references;</P>
  <LI>
  <P>support for DTDs in the data model;</P>
  <LI>
  <P>support for notations in the data model;</P>
  <LI>
  <P>a way to get back from an element to the elements that reference it (e.g. 
  by IDREF attributes);</P>
  <LI>
  <P>an easier way to get an ID or key in another document;</P>
  <LI>
  <P>support for regular expressions for matching against any or all of text 
  nodes, attribute values, attribute names, element type names;</P>
  <LI>
  <P>case-insensitive comparisons;</P>
  <LI>
  <P>normalization of strings before comparison, for example for compatibility 
  characters;</P>
  <LI>
  <P>a function <CODE>string resolve(node-set)</CODE> function that treats the 
  value of the argument as a relative URI and turns it into an absolute URI 
  using the base URI of the node;</P>
  <LI>
  <P>multiple result documents;</P>
  <LI>
  <P>defaulting the <CODE>select</CODE> attribute on <CODE>xsl:value-of</CODE> 
  to the current node;</P>
  <LI>
  <P>an attribute on <CODE>xsl:attribute</CODE> to control how the attribute 
  value is normalized;</P>
  <LI>
  <P>additional attributes on <CODE>xsl:sort</CODE> to provide further control 
  over sorting, such as relative order of scripts;</P>
  <LI>
  <P>a way to put the text of a resource identified by a URI into the result 
  tree;</P>
  <LI>
  <P>allow unions in steps (e.g. <CODE>foo/(bar|baz)</CODE>);</P>
  <LI>
  <P>allow for result tree fragments all operations that are allowed for 
  node-sets;</P>
  <LI>
  <P>a way to group together consecutive nodes having duplicate subelements or 
  attributes;</P>
  <LI>
  <P>features to make handling of the HTML <CODE>style</CODE> attribute more 
  convenient.</P></LI></UL></BODY></HTML>
