<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0046)http://www.w3.org/TR/2007/REC-xslt20-20070123/ -->
<?xml version="1.0" encoding="utf-8"?><HTML lang=EN xml:lang="EN" 
xmlns="http://www.w3.org/1999/xhtml"><HEAD><TITLE>XSL Transformations (XSLT) Version 2.0</TITLE>
<META http-equiv=Content-Type content="text/html; charset=utf-8">
<META content="MSHTML 6.00.2900.3020" name=GENERATOR>
<STYLE type=text/css>CODE {
	FONT-FAMILY: monospace
}
DIV.constraint {
	MARGIN-LEFT: 2em
}
DIV.issue {
	MARGIN-LEFT: 2em
}
DIV.note {
	MARGIN-LEFT: 2em
}
DIV.notice {
	MARGIN-LEFT: 2em
}
DIV.issue P.title {
	MARGIN-LEFT: -2em
}
OL.enumar {
	LIST-STYLE-TYPE: decimal
}
OL.enumla {
	LIST-STYLE-TYPE: lower-alpha
}
OL.enumlr {
	LIST-STYLE-TYPE: lower-roman
}
OL.enumua {
	LIST-STYLE-TYPE: upper-alpha
}
OL.enumur {
	LIST-STYLE-TYPE: upper-roman
}
LI P {
	MARGIN-TOP: 0.3em; MARGIN-BOTTOM: 0.3em
}
SUP SMALL {
	COLOR: #8f8f8f; FONT-STYLE: italic
}
DIV.exampleInner PRE {
	MARGIN-TOP: 0em; MARGIN-BOTTOM: 0em; MARGIN-LEFT: 1em
}
DIV.exampleOuter {
	BORDER-RIGHT: gray 4px double; PADDING-RIGHT: 0em; BORDER-TOP: gray 4px double; PADDING-LEFT: 0em; PADDING-BOTTOM: 0em; MARGIN: 0em; BORDER-LEFT: gray 4px double; PADDING-TOP: 0em; BORDER-BOTTOM: gray 4px double
}
DIV.exampleInner {
	PADDING-RIGHT: 4px; BORDER-TOP: #d3d3d3 4px double; PADDING-LEFT: 4px; PADDING-BOTTOM: 4px; MARGIN: 0em; PADDING-TOP: 4px; BORDER-BOTTOM: #d3d3d3 4px double; BACKGROUND-COLOR: #d5dee3
}
DIV.exampleWrapper {
	MARGIN: 4px
}
DIV.exampleHeader {
	FONT-WEIGHT: bold; MARGIN: 4px
}
DIV.issue {
	MARGIN-BOTTOM: 20pt; BORDER-BOTTOM: black 1pt solid
}
TH.issue-toc-head {
	BORDER-BOTTOM: black 1pt solid
}
DD.indent {
	MARGIN-LEFT: 2em
}
P.element-syntax {
	BORDER-RIGHT: thin solid; BORDER-TOP: thin solid; BORDER-LEFT: thin solid; BORDER-BOTTOM: thin solid; BACKGROUND-COLOR: #ffccff
}
DIV.proto {
	BORDER-RIGHT: thin solid; BORDER-TOP: thin solid; BORDER-LEFT: thin solid; BORDER-BOTTOM: thin solid; BACKGROUND-COLOR: #ffccff
}
DIV.example {
	BORDER-RIGHT: thin solid; PADDING-RIGHT: 1em; BORDER-TOP: thin solid; PADDING-LEFT: 1em; PADDING-BOTTOM: 1em; BORDER-LEFT: thin solid; PADDING-TOP: 1em; BORDER-BOTTOM: thin solid; BACKGROUND-COLOR: #40e0d0
}
SPAN.verb {
	FONT: small-caps 100% sans-serif
}
SPAN.error {
	FONT-SIZE: small
}
SPAN.definition {
	FONT: small-caps 100% sans-serif
}
SPAN.grayed {
	COLOR: gray
}
</STYLE>
<LINK href="REC-xslt20-20070123_files/W3C-REC.css" type=text/css 
rel=stylesheet></HEAD>
<BODY>
<DIV class=head>
<P><A href="http://www.w3.org/"><IMG height=48 alt=W3C 
src="REC-xslt20-20070123_files/w3c_home.png" width=72></A></P>
<H1><A id=title name=title></A>XSL Transformations (XSLT) Version 2.0</H1>
<H2><A id=w3c-doctype name=w3c-doctype></A>W3C Recommendation 23 January 
2007</H2>
<DL>
  <DT>This version: 
  <DD><A 
  href="http://www.w3.org/TR/2007/REC-xslt20-20070123/">http://www.w3.org/TR/2007/REC-xslt20-20070123/</A> 

  <DT>Latest version: 
  <DD><A 
href="http://www.w3.org/TR/xslt20/">http://www.w3.org/TR/xslt20/</A><BR>
  <DT>Previous version: 
  <DD><A 
  href="http://www.w3.org/TR/2006/PR-xslt20-20061121/">http://www.w3.org/TR/2006/PR-xslt20-20061121/</A><BR>
  <DT>Editor: 
  <DD>Michael Kay, Saxonica <A 
  href="http://www.saxonica.com/">&lt;http://www.saxonica.com/&gt;</A> </DD></DL>
<P>Please refer to the <A 
href="http://www.w3.org/XML/2007/qt-errata/xslt-errata.html"><STRONG>errata</STRONG></A> 
for this document, which may include some normative corrections.</P>
<P>See also <A 
href="http://www.w3.org/2003/03/Translations/byTechnology?technology=xslt20"><STRONG>translations</STRONG></A>.</P>
<P class=copyright><A 
href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</A>&nbsp;©&nbsp;2007&nbsp;<A 
href="http://www.w3.org/"> <ACRONYM 
title="World Wide Web Consortium">W3C</ACRONYM></A><SUP>®</SUP> (<A 
href="http://www.csail.mit.edu/"><ACRONYM 
title="Massachusetts Institute of Technology">MIT</ACRONYM></A>, <A 
href="http://www.ercim.org/"><ACRONYM 
title="European Research Consortium for Informatics and Mathematics">ERCIM</ACRONYM></A>, 
<A href="http://www.keio.ac.jp/">Keio</A>), All Rights Reserved. W3C <A 
href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</A>, 
<A 
href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</A> 
and <A href="http://www.w3.org/Consortium/Legal/copyright-documents">document 
use</A> rules apply.</P></DIV>
<HR>

<DIV>
<H2><A id=abstract name=abstract></A>Abstract</H2>
<P>This specification defines the syntax and semantics of XSLT 2.0, a language 
for transforming XML documents into other XML documents.</P>
<P>XSLT 2.0 is a revised version of the XSLT 1.0 Recommendation <A 
href="http://www.w3.org/TR/2007/REC-xslt20-20070123/#xslt">[XSLT 1.0]</A> 
published on 16 November 1999.</P>
<P>XSLT 2.0 is designed to be used in conjunction with XPath 2.0, which is 
defined in <A 
href="http://www.w3.org/TR/2007/REC-xslt20-20070123/#xpath20">[XPath 2.0]</A>. 
XSLT shares the same data model as XPath 2.0, which is defined in <A 
href="http://www.w3.org/TR/2007/REC-xslt20-20070123/#xpath-datamodel">[Data 
Model]</A>, and it uses the library of functions and operators defined in <A 
href="http://www.w3.org/TR/2007/REC-xslt20-20070123/#xpath-functions">[Functions 
and Operators]</A>.</P>
<P>XSLT 2.0 also includes optional facilities to serialize the results of a 
transformation, by means of an interface to the serialization component 
described in <A 
href="http://www.w3.org/TR/2007/REC-xslt20-20070123/#xslt-xquery-serialization">[XSLT 
and XQuery Serialization]</A>.</P>
<P><EM>This document contains hyperlinks to specific sections or definitions 
within other documents in this family of specifications. These links are 
indicated visually by a superscript identifying the target specification: for 
example XP for XPath, DM for the XDM data model, FO for Functions and 
Operators.</EM></P></DIV>
<DIV>
<H2><A id=status name=status></A>Status of this Document</H2>
<P><EM>This section describes the status of this document at the time of its 
publication. Other documents may supersede this document. A list of current W3C 
publications and the latest revision of this technical report can be found in 
the <A href="http://www.w3.org/TR/">W3C technical reports index</A> at 
http://www.w3.org/TR/.</EM></P>
<P>This <A 
href="http://www.w3.org/2004/02/Process-20040205/tr.html#RecsW3C">Recommendation</A> 
builds on the success of <A 
href="http://www.w3.org/TR/2007/REC-xslt20-20070123/#xslt">[XSLT 1.0]</A>, which 
was published on 16 November 1999. Many new features have been added to the 
language (see <A 
href="http://www.w3.org/TR/2007/REC-xslt20-20070123/#changes-since-1.0"><I>J.2 
New Functionality</I></A>) while retaining a high level of backwards 
compatibility (see <A 
href="http://www.w3.org/TR/2007/REC-xslt20-20070123/#incompatibilities"><I>J.1 
Incompatible Changes</I></A>). The changes have been designed to meet the 
requirements for XSLT 2.0 described in <A 
href="http://www.w3.org/TR/2007/REC-xslt20-20070123/#xslt20req">[XSLT 2.0 
Requirements]</A>. The way in which each requirement has been addressed is 
outlined in <A 
href="http://www.w3.org/TR/2007/REC-xslt20-20070123/#requirements-checklist"><I>I 
Checklist of Requirements</I></A>.</P>
<P>XSLT 2.0 depends on a number of other specifications that have progressed to 
Recommendation status at the same time: see <A 
href="http://www.w3.org/TR/2007/REC-xslt20-20070123/#xpath20">[XPath 2.0]</A>, 
<A href="http://www.w3.org/TR/2007/REC-xslt20-20070123/#xpath-datamodel">[Data 
Model]</A>, <A 
href="http://www.w3.org/TR/2007/REC-xslt20-20070123/#xpath-functions">[Functions 
and Operators]</A>, and <A 
href="http://www.w3.org/TR/2007/REC-xslt20-20070123/#xslt-xquery-serialization">[XSLT 
and XQuery Serialization]</A>. These subsidiary documents are also referenced in 
the specification of XQuery 1.0.</P>
<P>This document has been produced by the <A 
href="http://www.w3.org/Style/XSL/">XSL Working Group</A>, which is part of the 
<A href="http://www.w3.org/XML/Activity">XML Activity</A>. The document has been 
reviewed by W3C Members and other interested parties, and is endorsed by the 
Director. It is a stable document and may be used as reference material or cited 
as a normative reference from another document. W3C's role in making the 
Recommendation is to draw attention to the specification and to promote its 
widespread deployment. This enhances the functionality and interoperability of 
the Web.</P>
<P>A small number of editorial corrections and clarifications have been made to 
the document since it <A 
href="http://www.w3.org/TR/2006/PR-xslt20-20061121/">was published</A> as a <A 
href="http://www.w3.org/2004/02/Process-20040205/tr.html#RecsPR">Proposed 
Recommendation</A> on 21 November 2006. These changes are listed at <A 
href="http://www.w3.org/TR/2007/REC-xslt20-20070123/#changes-2007-01"><I>J.2.4 
Changes since Proposed Recommendation</I></A>.</P>
<P>Please record any comments about this document in W3C's <A 
href="http://www.w3.org/Bugs/Public/">public Bugzilla system</A> (instructions 
can be found at <A 
href="http://www.w3.org/XML/2005/04/qt-bugzilla">http://www.w3.org/XML/2005/04/qt-bugzilla</A>). 
If access to that system is not feasible, you may send your comments to the W3C 
XSLT/XPath/XQuery public comments mailing list, <A 
href="mailto:public-qt-comments@w3.org">public-qt-comments@w3.org</A>. It is 
helpful to include the string [XSLT] in the subject line of your comment, 
whether made in Bugzilla or in email. Each Bugzilla entry and email message 
should contain only one comment. Archives of the comments and responses are 
available at <A 
href="http://lists.w3.org/Archives/Public/public-qt-comments/">http://lists.w3.org/Archives/Public/public-qt-comments/</A>.</P>
<P>General public discussion of XSLT takes place on the <A 
href="http://www.mulberrytech.com/xsl/xsl-list/index.html">XSL-List</A> 
forum.</P>
<P>This document was produced by a group operating under the <A 
href="http://www.w3.org/Consortium/Patent-Policy-20040205/">5 February 2004 W3C 
Patent Policy</A>. W3C maintains a <A 
href="http://www.w3.org/2004/01/pp-impl/19552/status#disclosures">public list of 
any patent disclosures</A> made in connection with the deliverables of the 
group; that page also includes instructions for disclosing a patent. An 
individual who has actual knowledge of a patent which the individual believes 
contains <A 
href="http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">Essential 
Claim(s)</A> must disclose the information in accordance with <A 
href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">section 
6 of the W3C Patent Policy</A>.</P></DIV>
<DIV class=toc>
<H2><A id=contents name=contents></A>Table of Contents</H2>
<P class=toc>1 <A 
href="REC-xslt20-20070123.htm#introduction">Introduction</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;1.1 
<A href="REC-xslt20-20070123.htm#what-is-xslt">What is 
XSLT?</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;1.2 <A 
href="REC-xslt20-20070123.htm#whats-new-in-xslt2">What's 
New in XSLT 2.0?</A><BR>2 <A 
href="REC-xslt20-20070123.htm#concepts">Concepts</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;2.1 
<A 
href="REC-xslt20-20070123.htm#terminology">Terminology</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;2.2 
<A 
href="REC-xslt20-20070123.htm#notation">Notation</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;2.3 
<A href="REC-xslt20-20070123.htm#initiating">Initiating a 
Transformation</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;2.4 <A 
href="REC-xslt20-20070123.htm#executing-a-transformation">Executing 
a Transformation</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;2.5 <A 
href="REC-xslt20-20070123.htm#context">The Evaluation 
Context</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;2.6 <A 
href="REC-xslt20-20070123.htm#parsing-and-serialization">Parsing 
and Serialization</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;2.7 <A 
href="REC-xslt20-20070123.htm#extensibility">Extensibility</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;2.8 
<A 
href="REC-xslt20-20070123.htm#stylesheets-and-schemas">Stylesheets 
and XML Schemas</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;2.9 <A 
href="REC-xslt20-20070123.htm#errors">Error 
Handling</A><BR>3 <A 
href="REC-xslt20-20070123.htm#stylesheet-structure">Stylesheet 
Structure</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;3.1 <A 
href="REC-xslt20-20070123.htm#xslt-namespace">XSLT 
Namespace</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;3.2 <A 
href="REC-xslt20-20070123.htm#reserved-namespaces">Reserved 
Namespaces</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;3.3 <A 
href="REC-xslt20-20070123.htm#extension-attributes">Extension 
Attributes</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;3.4 <A 
href="REC-xslt20-20070123.htm#xslt-media-type">XSLT Media 
Type</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;3.5 <A 
href="REC-xslt20-20070123.htm#standard-attributes">Standard 
Attributes</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;3.6 <A 
href="REC-xslt20-20070123.htm#stylesheet-element">Stylesheet 
Element</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.6.1 <A 
href="REC-xslt20-20070123.htm#default-collation-attribute">The 
default-collation 
attribute</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.6.2 <A 
href="REC-xslt20-20070123.htm#user-defined-top-level">User-defined 
Data Elements</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;3.7 <A 
href="REC-xslt20-20070123.htm#simplified-stylesheet">Simplified 
Stylesheet Modules</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;3.8 <A 
href="REC-xslt20-20070123.htm#backwards">Backwards-Compatible 
Processing</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;3.9 <A 
href="REC-xslt20-20070123.htm#forwards">Forwards-Compatible 
Processing</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;3.10 <A 
href="REC-xslt20-20070123.htm#combining-modules">Combining 
Stylesheet Modules</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.10.1 
<A 
href="REC-xslt20-20070123.htm#locating-modules">Locating 
Stylesheet Modules</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.10.2 
<A href="REC-xslt20-20070123.htm#include">Stylesheet 
Inclusion</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.10.3 <A 
href="REC-xslt20-20070123.htm#import">Stylesheet 
Import</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;3.11 <A 
href="REC-xslt20-20070123.htm#embedded">Embedded 
Stylesheet Modules</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;3.12 <A 
href="REC-xslt20-20070123.htm#conditional-inclusion">Conditional 
Element Inclusion</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;3.13 <A 
href="REC-xslt20-20070123.htm#built-in-types">Built-in 
Types</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;3.14 <A 
href="REC-xslt20-20070123.htm#import-schema">Importing 
Schema Components</A><BR>4 <A 
href="REC-xslt20-20070123.htm#data-model">Data 
Model</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;4.1 <A 
href="REC-xslt20-20070123.htm#xml-versions">XML 
Versions</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;4.2 <A 
href="REC-xslt20-20070123.htm#stylesheet-stripping">Stripping 
Whitespace from the Stylesheet</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;4.3 <A 
href="REC-xslt20-20070123.htm#stripping-annotations">Stripping 
Type Annotations from a Source Tree</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;4.4 <A 
href="REC-xslt20-20070123.htm#strip">Stripping Whitespace 
from a Source Tree</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;4.5 <A 
href="REC-xslt20-20070123.htm#id-in-data-model">Attribute 
Types and DTD Validation</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;4.6 <A 
href="REC-xslt20-20070123.htm#limits">Limits</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;4.7 
<A 
href="REC-xslt20-20070123.htm#d-o-e-in-data-model">Disable 
Output Escaping</A><BR>5 <A 
href="REC-xslt20-20070123.htm#constructs">Features of the 
XSLT Language</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;5.1 <A 
href="REC-xslt20-20070123.htm#qname">Qualified 
Names</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;5.2 <A 
href="REC-xslt20-20070123.htm#unprefixed-qnames">Unprefixed 
QNames in Expressions and Patterns</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;5.3 <A 
href="REC-xslt20-20070123.htm#expressions">Expressions</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;5.4 
<A 
href="REC-xslt20-20070123.htm#static-and-dynamic-context">The 
Static and Dynamic 
Context</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.4.1 <A 
href="REC-xslt20-20070123.htm#static-context">Initializing 
the Static Context</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.4.2 
<A 
href="REC-xslt20-20070123.htm#additional-static-context">Additional 
Static Context Components used by 
XSLT</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.4.3 <A 
href="REC-xslt20-20070123.htm#xpath-dynamic-context">Initializing 
the Dynamic 
Context</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.4.3.1 
<A href="REC-xslt20-20070123.htm#focus">Maintaining 
Position: the 
Focus</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.4.3.2 
<A 
href="REC-xslt20-20070123.htm#evaluation-context">Other 
components of the XPath Dynamic 
Context</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.4.4 <A 
href="REC-xslt20-20070123.htm#additional-dynamic-context">Additional 
Dynamic Context Components used by XSLT</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;5.5 <A 
href="REC-xslt20-20070123.htm#patterns">Patterns</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.5.1 
<A 
href="REC-xslt20-20070123.htm#pattern-examples">Examples 
of Patterns</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.5.2 <A 
href="REC-xslt20-20070123.htm#pattern-syntax">Syntax of 
Patterns</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.5.3 <A 
href="REC-xslt20-20070123.htm#pattern-semantics">The 
Meaning of a 
Pattern</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.5.4 <A 
href="REC-xslt20-20070123.htm#pattern-errors">Errors in 
Patterns</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;5.6 <A 
href="REC-xslt20-20070123.htm#attribute-value-templates">Attribute 
Value Templates</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;5.7 <A 
href="REC-xslt20-20070123.htm#sequence-constructors">Sequence 
Constructors</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.7.1 <A 
href="REC-xslt20-20070123.htm#constructing-complex-content">Constructing 
Complex Content</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.7.2 <A 
href="REC-xslt20-20070123.htm#constructing-simple-content">Constructing 
Simple Content</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.7.3 <A 
href="REC-xslt20-20070123.htm#namespace-fixup">Namespace 
Fixup</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;5.8 <A 
href="REC-xslt20-20070123.htm#uri-references">URI 
References</A><BR>6 <A 
href="REC-xslt20-20070123.htm#rules">Template 
Rules</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;6.1 <A 
href="REC-xslt20-20070123.htm#defining-templates">Defining 
Templates</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;6.2 <A 
href="REC-xslt20-20070123.htm#defining-template-rules">Defining 
Template Rules</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;6.3 <A 
href="REC-xslt20-20070123.htm#applying-templates">Applying 
Template Rules</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;6.4 <A 
href="REC-xslt20-20070123.htm#conflict">Conflict 
Resolution for Template Rules</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;6.5 <A 
href="REC-xslt20-20070123.htm#modes">Modes</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;6.6 
<A href="REC-xslt20-20070123.htm#built-in-rule">Built-in 
Template Rules</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;6.7 <A 
href="REC-xslt20-20070123.htm#apply-imports">Overriding 
Template Rules</A><BR>7 <A 
href="REC-xslt20-20070123.htm#for-each">Repetition</A><BR>8 
<A 
href="REC-xslt20-20070123.htm#conditionals">Conditional 
Processing</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;8.1 <A 
href="REC-xslt20-20070123.htm#xsl-if">Conditional 
Processing with xsl:if</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;8.2 <A 
href="REC-xslt20-20070123.htm#xsl-choose">Conditional 
Processing with xsl:choose</A><BR>9 <A 
href="REC-xslt20-20070123.htm#variables-and-parameters">Variables 
and Parameters</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;9.1 <A 
href="REC-xslt20-20070123.htm#variables">Variables</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;9.2 
<A 
href="REC-xslt20-20070123.htm#parameters">Parameters</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;9.3 
<A href="REC-xslt20-20070123.htm#variable-values">Values 
of Variables and Parameters</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;9.4 <A 
href="REC-xslt20-20070123.htm#temporary-trees">Creating 
implicit document nodes</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;9.5 <A 
href="REC-xslt20-20070123.htm#global-variables">Global 
Variables and Parameters</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;9.6 <A 
href="REC-xslt20-20070123.htm#local-variables">Local 
Variables and Parameters</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;9.7 <A 
href="REC-xslt20-20070123.htm#scope-of-variables">Scope 
of Variables</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;9.8 <A 
href="REC-xslt20-20070123.htm#circularity">Circular 
Definitions</A><BR>10 <A 
href="REC-xslt20-20070123.htm#callable-components">Callable 
Components</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;10.1 <A 
href="REC-xslt20-20070123.htm#named-templates">Named 
Templates</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.1.1 <A 
href="REC-xslt20-20070123.htm#with-param">Passing 
Parameters to 
Templates</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.1.2 <A 
href="REC-xslt20-20070123.htm#tunnel-params">Tunnel 
Parameters</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;10.2 <A 
href="REC-xslt20-20070123.htm#attribute-sets">Named 
Attribute Sets</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;10.3 <A 
href="REC-xslt20-20070123.htm#stylesheet-functions">Stylesheet 
Functions</A><BR>11 <A 
href="REC-xslt20-20070123.htm#creating-new-nodes">Creating 
Nodes and Sequences</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;11.1 <A 
href="REC-xslt20-20070123.htm#literal-result-element">Literal 
Result Elements</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11.1.1 <A 
href="REC-xslt20-20070123.htm#setting-annotation-for-lre">Setting 
the Type Annotation for Literal Result 
Elements</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11.1.2 <A 
href="REC-xslt20-20070123.htm#attributes-for-lres">Attribute 
Nodes for Literal Result 
Elements</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11.1.3 <A 
href="REC-xslt20-20070123.htm#lre-namespaces">Namespace 
Nodes for Literal Result 
Elements</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11.1.4 <A 
href="REC-xslt20-20070123.htm#namespace-aliasing">Namespace 
Aliasing</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;11.2 <A 
href="REC-xslt20-20070123.htm#xsl-element">Creating 
Element Nodes Using 
xsl:element</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11.2.1 <A 
href="REC-xslt20-20070123.htm#annotation-for-constructed-element">Setting 
the Type Annotation for a Constructed Element 
Node</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;11.3 <A 
href="REC-xslt20-20070123.htm#creating-attributes">Creating 
Attribute Nodes Using 
xsl:attribute</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11.3.1 <A 
href="REC-xslt20-20070123.htm#annotation-for-constructed-attribute">Setting 
the Type Annotation for a Constructed Attribute 
Node</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;11.4 <A 
href="REC-xslt20-20070123.htm#creating-text-nodes">Creating 
Text Nodes</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11.4.1 <A 
href="REC-xslt20-20070123.htm#literal-text-nodes">Literal 
Text Nodes</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11.4.2 <A 
href="REC-xslt20-20070123.htm#xsl-text">Creating Text 
Nodes Using 
xsl:text</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11.4.3 <A 
href="REC-xslt20-20070123.htm#value-of">Generating Text 
with xsl:value-of</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;11.5 <A 
href="REC-xslt20-20070123.htm#creating-document-nodes">Creating 
Document Nodes</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;11.6 <A 
href="REC-xslt20-20070123.htm#creating-processing-instructions">Creating 
Processing Instructions</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;11.7 <A 
href="REC-xslt20-20070123.htm#creating-namespace-nodes">Creating 
Namespace Nodes</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;11.8 <A 
href="REC-xslt20-20070123.htm#creating-comments">Creating 
Comments</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;11.9 <A 
href="REC-xslt20-20070123.htm#copying">Copying 
Nodes</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11.9.1 <A 
href="REC-xslt20-20070123.htm#shallow-copy">Shallow 
Copy</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11.9.2 <A 
href="REC-xslt20-20070123.htm#copy-of">Deep 
Copy</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;11.10 <A 
href="REC-xslt20-20070123.htm#constructing-sequences">Constructing 
Sequences</A><BR>12 <A 
href="REC-xslt20-20070123.htm#number">Numbering</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;12.1 
<A 
href="REC-xslt20-20070123.htm#formatting-supplied-number">Formatting 
a Supplied Number</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;12.2 <A 
href="REC-xslt20-20070123.htm#numbering-based-on-position">Numbering 
based on Position in a Document</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;12.3 <A 
href="REC-xslt20-20070123.htm#convert">Number to String 
Conversion Attributes</A><BR>13 <A 
href="REC-xslt20-20070123.htm#sorting">Sorting</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;13.1 
<A href="REC-xslt20-20070123.htm#xsl-sort">The xsl:sort 
Element</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;13.1.1 <A 
href="REC-xslt20-20070123.htm#sorting-process">The 
Sorting Process</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;13.1.2 <A 
href="REC-xslt20-20070123.htm#comparing-sort-keys">Comparing 
Sort Key Values</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;13.1.3 <A 
href="REC-xslt20-20070123.htm#collating-sequences">Sorting 
Using Collations</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;13.2 <A 
href="REC-xslt20-20070123.htm#creating-sorted-sequence">Creating 
a Sorted Sequence</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;13.3 <A 
href="REC-xslt20-20070123.htm#sorted-iteration">Processing 
a Sequence in Sorted Order</A><BR>14 <A 
href="REC-xslt20-20070123.htm#grouping">Grouping</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;14.1 
<A href="REC-xslt20-20070123.htm#current-group">The 
Current Group</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;14.2 <A 
href="REC-xslt20-20070123.htm#current-grouping-key">The 
Current Grouping Key</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;14.3 <A 
href="REC-xslt20-20070123.htm#xsl-for-each-group">The 
xsl:for-each-group Element</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;14.4 <A 
href="REC-xslt20-20070123.htm#grouping-examples">Examples 
of Grouping</A><BR>15 <A 
href="REC-xslt20-20070123.htm#regular-expressions">Regular 
Expressions</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;15.1 <A 
href="REC-xslt20-20070123.htm#analyze-string">The 
xsl:analyze-string instruction</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;15.2 <A 
href="REC-xslt20-20070123.htm#regex-group">Captured 
Substrings</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;15.3 <A 
href="REC-xslt20-20070123.htm#regex-examples">Examples of 
Regular Expression Matching</A><BR>16 <A 
href="REC-xslt20-20070123.htm#add-func">Additional 
Functions</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;16.1 <A 
href="REC-xslt20-20070123.htm#document">Multiple Source 
Documents</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;16.2 <A 
href="REC-xslt20-20070123.htm#unparsed-text">Reading Text 
Files</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;16.3 <A 
href="REC-xslt20-20070123.htm#key">Keys</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16.3.1 
<A href="REC-xslt20-20070123.htm#xsl-key">The xsl:key 
Declaration</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16.3.2 <A 
href="REC-xslt20-20070123.htm#keys">The key 
Function</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;16.4 <A 
href="REC-xslt20-20070123.htm#format-number">Number 
Formatting</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16.4.1 <A 
href="REC-xslt20-20070123.htm#defining-decimal-format">Defining 
a Decimal Format</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16.4.2 
<A 
href="REC-xslt20-20070123.htm#processing-picture-string">Processing 
the Picture String</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16.4.3 
<A 
href="REC-xslt20-20070123.htm#analysing-picture-string">Analysing 
the Picture String</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16.4.4 
<A 
href="REC-xslt20-20070123.htm#formatting-the-number">Formatting 
the Number</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;16.5 <A 
href="REC-xslt20-20070123.htm#format-date">Formatting 
Dates and Times</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16.5.1 <A 
href="REC-xslt20-20070123.htm#date-picture-string">The 
Picture String</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16.5.2 <A 
href="REC-xslt20-20070123.htm#lang-cal-country">The 
Language, Calendar, and Country 
Arguments</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16.5.3 <A 
href="REC-xslt20-20070123.htm#date-time-examples">Examples 
of Date and Time Formatting</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;16.6 <A 
href="REC-xslt20-20070123.htm#misc-func">Miscellaneous 
Additional 
Functions</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16.6.1 <A 
href="REC-xslt20-20070123.htm#current-function">current</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16.6.2 
<A 
href="REC-xslt20-20070123.htm#unparsed-entity-uri">unparsed-entity-uri</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16.6.3 
<A 
href="REC-xslt20-20070123.htm#unparsed-entity-public-id">unparsed-entity-public-id</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16.6.4 
<A 
href="REC-xslt20-20070123.htm#generate-id">generate-id</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16.6.5 
<A 
href="REC-xslt20-20070123.htm#system-property">system-property</A><BR>17 
<A 
href="REC-xslt20-20070123.htm#message">Messages</A><BR>18 
<A href="REC-xslt20-20070123.htm#extension">Extensibility 
and Fallback</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;18.1 <A 
href="REC-xslt20-20070123.htm#extension-functions">Extension 
Functions</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.1.1 <A 
href="REC-xslt20-20070123.htm#testing-function-availability">Testing 
Availability of 
Functions</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.1.2 <A 
href="REC-xslt20-20070123.htm#calling-extension-functions">Calling 
Extension 
Functions</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.1.3 <A 
href="REC-xslt20-20070123.htm#external-objects">External 
Objects</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.1.4 <A 
href="REC-xslt20-20070123.htm#testing-type-availability">Testing 
Availability of Types</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;18.2 <A 
href="REC-xslt20-20070123.htm#extension-instruction">Extension 
Instructions</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.2.1 <A 
href="REC-xslt20-20070123.htm#designating-extension-namespace">Designating 
an Extension 
Namespace</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.2.2 <A 
href="REC-xslt20-20070123.htm#testing-instruction-available">Testing 
Availability of 
Instructions</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.2.3 <A 
href="REC-xslt20-20070123.htm#fallback">Fallback</A><BR>19 
<A href="REC-xslt20-20070123.htm#result-trees">Final 
Result Trees</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;19.1 <A 
href="REC-xslt20-20070123.htm#creating-result-trees">Creating 
Final Result Trees</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;19.2 <A 
href="REC-xslt20-20070123.htm#validation">Validation</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;19.2.1 
<A 
href="REC-xslt20-20070123.htm#validating-constructed-nodes">Validating 
Constructed Elements and 
Attributes</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;19.2.1.1 
<A 
href="REC-xslt20-20070123.htm#validating-using-validation-attribute">Validation 
using the [xsl:]validation 
Attribute</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;19.2.1.2 
<A 
href="REC-xslt20-20070123.htm#validation-xsl-type">Validation 
using the [xsl:]type 
Attribute</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;19.2.1.3 
<A href="REC-xslt20-20070123.htm#validation-process">The 
Validation Process</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;19.2.2 
<A 
href="REC-xslt20-20070123.htm#validating-document-nodes">Validating 
Document Nodes</A><BR>20 <A 
href="REC-xslt20-20070123.htm#serialization">Serialization</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;20.1 
<A 
href="REC-xslt20-20070123.htm#character-maps">Character 
Maps</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;20.2 <A 
href="REC-xslt20-20070123.htm#disable-output-escaping">Disabling 
Output Escaping</A><BR>21 <A 
href="REC-xslt20-20070123.htm#conformance">Conformance</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;21.1 
<A href="REC-xslt20-20070123.htm#basic-conformance">Basic 
XSLT Processor</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;21.2 <A 
href="REC-xslt20-20070123.htm#schema-aware-conformance">Schema-Aware 
XSLT Processor</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;21.3 <A 
href="REC-xslt20-20070123.htm#serialization-feature">Serialization 
Feature</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;21.4 <A 
href="REC-xslt20-20070123.htm#backwards-compatibility-feature">Backwards 
Compatibility Feature</A><BR></P>
<H3><A id=appendices name=appendices></A>Appendices</H3>
<P class=toc>A <A 
href="REC-xslt20-20070123.htm#references">References</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;A.1 
<A 
href="REC-xslt20-20070123.htm#normative-references">Normative 
References</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;A.2 <A 
href="REC-xslt20-20070123.htm#other-references">Other 
References</A><BR>B <A 
href="REC-xslt20-20070123.htm#xslt-mime-definition">The 
XSLT Media Type</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;B.1 <A 
href="REC-xslt20-20070123.htm#media-type-registration">Registration 
of MIME Media Type application/xslt+xml</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;B.2 <A 
href="REC-xslt20-20070123.htm#media-type-fragid">Fragment 
Identifiers</A><BR>C <A 
href="REC-xslt20-20070123.htm#glossary">Glossary</A> 
(Non-Normative)<BR>D <A 
href="REC-xslt20-20070123.htm#element-syntax-summary">Element 
Syntax Summary</A> (Non-Normative)<BR>E <A 
href="REC-xslt20-20070123.htm#error-summary">Summary of 
Error Conditions</A> (Non-Normative)<BR>F <A 
href="REC-xslt20-20070123.htm#implementation-defined-features">Checklist 
of Implementation-Defined Features</A> (Non-Normative)<BR>G <A 
href="REC-xslt20-20070123.htm#schema-for-xslt">Schema for 
XSLT Stylesheets</A> (Non-Normative)<BR>H <A 
href="REC-xslt20-20070123.htm#acknowledgements">Acknowledgements</A> 
(Non-Normative)<BR>I <A 
href="REC-xslt20-20070123.htm#requirements-checklist">Checklist 
of Requirements</A> (Non-Normative)<BR>J <A 
href="REC-xslt20-20070123.htm#changes">Changes from XSLT 
1.0</A> (Non-Normative)<BR>&nbsp;&nbsp;&nbsp;&nbsp;J.1 <A 
href="REC-xslt20-20070123.htm#incompatibilities">Incompatible 
Changes</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;J.1.1 <A 
href="REC-xslt20-20070123.htm#incompatibility-stripping">Tree 
construction: whitespace 
stripping</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;J.1.2 <A 
href="REC-xslt20-20070123.htm#incompatibility-serialization">Changes 
in Serialization 
Behavior</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;J.1.3 <A 
href="REC-xslt20-20070123.htm#backwards-compatibility-behavior">Backwards 
Compatibility 
Behavior</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;J.1.4 <A 
href="REC-xslt20-20070123.htm#incompatibility-without-schema">Incompatibility 
in the Absence of a 
Schema</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;J.1.5 <A 
href="REC-xslt20-20070123.htm#compatibility-with-schema">Compatibility 
in the Presence of a 
Schema</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;J.1.6 <A 
href="REC-xslt20-20070123.htm#xpath-compatibility">XPath 
2.0 Backwards Compatibility</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;J.2 <A 
href="REC-xslt20-20070123.htm#changes-since-1.0">New 
Functionality</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;J.2.1 <A 
href="REC-xslt20-20070123.htm#pervasive-changes">Pervasive 
changes</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;J.2.2 <A 
href="REC-xslt20-20070123.htm#major-features">Major 
Features</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;J.2.3 <A 
href="REC-xslt20-20070123.htm#minor-changes">Minor 
Changes</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;J.2.4 <A 
href="REC-xslt20-20070123.htm#changes-2007-01">Changes 
since Proposed Recommendation</A><BR></P></DIV>
<HR>

<DIV class=body>
<DIV class=div1>
<H2><A id=introduction name=introduction></A>1 Introduction</H2>
<DIV class=div2>
<H3><A id=what-is-xslt name=what-is-xslt></A>1.1 What is XSLT?</H3>
<P>This specification defines the syntax and semantics of the XSLT 2.0 
language.</P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-stylesheet 
title=stylesheet name=dt-stylesheet></A>A transformation in the XSLT language is 
expressed in the form of a <B>stylesheet</B>, whose syntax is well-formed XML <A 
href="REC-xslt20-20070123.htm#REC-xml">[XML 1.0]</A> 
conforming to the Namespaces in XML Recommendation <A 
href="REC-xslt20-20070123.htm#REC-xml-names">[Namespaces 
in XML 1.0]</A>.<SPAN class=definition>]</SPAN></P>
<P>A stylesheet generally includes elements that are defined by XSLT as well as 
elements that are not defined by XSLT. XSLT-defined elements are distinguished 
by use of the namespace <CODE>http://www.w3.org/1999/XSL/Transform</CODE> (see 
<A href="REC-xslt20-20070123.htm#xslt-namespace"><I>3.1 
XSLT Namespace</I></A>), which is referred to in this specification as the <A 
title="XSLT namespace" 
href="REC-xslt20-20070123.htm#dt-xslt-namespace">XSLT 
namespace</A>. Thus this specification is a definition of the syntax and 
semantics of the XSLT namespace.</P>
<P>The term <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
reflects the fact that one of the important roles of XSLT is to add styling 
information to an XML source document, by transforming it into a document 
consisting of XSL formatting objects (see <A 
href="REC-xslt20-20070123.htm#xsl">[Extensible Stylesheet 
Language (XSL)]</A>), or into another presentation-oriented format such as HTML, 
XHTML, or SVG. However, XSLT is used for a wide range of transformation tasks, 
not exclusively for formatting and presentation applications.</P>
<P>A transformation expressed in XSLT describes rules for transforming zero or 
more source trees into one or more result trees. The structure of these trees is 
described in <A 
href="REC-xslt20-20070123.htm#xpath-datamodel">[Data 
Model]</A>. The transformation is achieved by a set of <A title="template rule" 
href="REC-xslt20-20070123.htm#dt-template-rule">template 
rules</A>. A template rule associates a <A title=pattern 
href="REC-xslt20-20070123.htm#dt-pattern">pattern</A>, 
which matches nodes in the source document, with a <A 
title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A>. In many cases, evaluating the sequence constructor will cause 
new nodes to be constructed, which can be used to produce part of a result tree. 
The structure of the result trees can be completely different from the structure 
of the source trees. In constructing a result tree, nodes from the source trees 
can be filtered and reordered, and arbitrary structure can be added. This 
mechanism allows a <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
to be applicable to a wide class of documents that have similar source tree 
structures.</P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A 
id=dt-principal-stylesheet-module title="principal stylesheet module" 
name=dt-principal-stylesheet-module></A>A <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
may consist of several <A title="stylesheet module" 
href="REC-xslt20-20070123.htm#dt-stylesheet-module">stylesheet 
modules</A>, contained in different XML documents. For a given transformation, 
one of these functions as the <B>principal stylesheet module</B>. The complete 
<A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
is assembled by finding the <A title="stylesheet module" 
href="REC-xslt20-20070123.htm#dt-stylesheet-module">stylesheet 
modules</A> referenced directly or indirectly from the principal stylesheet 
module using <A 
href="REC-xslt20-20070123.htm#element-include"><CODE>xsl:include</CODE></A> 
and <A 
href="REC-xslt20-20070123.htm#element-import"><CODE>xsl:import</CODE></A> 
elements: see <A 
href="REC-xslt20-20070123.htm#include"><I>3.10.2 
Stylesheet Inclusion</I></A> and <A 
href="REC-xslt20-20070123.htm#import"><I>3.10.3 
Stylesheet Import</I></A>.<SPAN class=definition>]</SPAN></P></DIV>
<DIV class=div2>
<H3><A id=whats-new-in-xslt2 name=whats-new-in-xslt2></A>1.2 What's New in XSLT 
2.0?</H3>
<P>XSLT 1.0 was published in November 1999, and version 2.0 represents a 
significant increase in the capability of the language. A detailed list of 
changes is included in <A 
href="REC-xslt20-20070123.htm#changes"><I>J Changes from 
XSLT 1.0</I></A>. XSLT 2.0 has been developed in parallel with XPath 2.0 (see <A 
href="REC-xslt20-20070123.htm#xpath20">[XPath 2.0]</A>), 
so the changes to XPath must be considered alongside the changes to 
XSLT.</P></DIV></DIV>
<DIV class=div1>
<H2><A id=concepts name=concepts></A>2 Concepts</H2>
<DIV class=div2>
<H3><A id=terminology name=terminology></A>2.1 Terminology</H3>
<P>For a full glossary of terms, see <A 
href="REC-xslt20-20070123.htm#glossary"><I>C 
Glossary</I></A>.</P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-processor 
title=processor name=dt-processor></A>The software responsible for transforming 
source trees into result trees using an XSLT stylesheet is referred to as the 
<B>processor</B>. This is sometimes expanded to <EM>XSLT processor</EM> to avoid 
any confusion with other processors, for example an XML processor.<SPAN 
class=definition>]</SPAN></P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-implementation 
title=implementation name=dt-implementation></A>A specific product that performs 
the functions of an <A title=processor 
href="REC-xslt20-20070123.htm#dt-processor">XSLT 
processor</A> is referred to as an <B>implementation</B> <SPAN 
class=definition>]</SPAN>.</P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-result-tree 
title="result tree" name=dt-result-tree></A>The term <B>result tree</B> is used 
to refer to any tree constructed by <A title=instruction 
href="REC-xslt20-20070123.htm#dt-instruction">instructions</A> 
in the stylesheet. A result tree is either a <A title="final result tree" 
href="REC-xslt20-20070123.htm#dt-final-result-tree">final 
result tree</A> or a <A title="temporary tree" 
href="REC-xslt20-20070123.htm#dt-temporary-tree">temporary 
tree</A>.<SPAN class=definition>]</SPAN></P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-final-result-tree 
title="final result tree" name=dt-final-result-tree></A>A <B>final result 
tree</B> is a <A title="result tree" 
href="REC-xslt20-20070123.htm#dt-result-tree">result 
tree</A> that forms part of the final output of a transformation. Once created, 
the contents of a final result tree are not accessible within the stylesheet 
itself.<SPAN class=definition>]</SPAN> The <A 
href="REC-xslt20-20070123.htm#element-result-document"><CODE>xsl:result-document</CODE></A> 
instruction always creates a final result tree, and a final result tree may also 
be created implicitly by the <A title="initial template" 
href="REC-xslt20-20070123.htm#dt-initial-template">initial 
template</A>. The conditions under which this happens are described in <A 
href="REC-xslt20-20070123.htm#executing-a-transformation"><I>2.4 
Executing a Transformation</I></A>. A final result tree <SPAN 
class=verb>may</SPAN> be serialized as described in <A 
href="REC-xslt20-20070123.htm#serialization"><I>20 
Serialization</I></A>.</P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-source-tree 
title="source tree" name=dt-source-tree></A>The term <B>source tree</B> means 
any tree provided as input to the transformation. This includes the document 
containing the <A title="initial context node" 
href="REC-xslt20-20070123.htm#dt-initial-context-node">initial 
context node</A> if any, documents containing nodes supplied as the values of <A 
title="stylesheet parameter" 
href="REC-xslt20-20070123.htm#dt-stylesheet-parameter">stylesheet 
parameters</A>, documents obtained from the results of functions such as <A 
href="REC-xslt20-20070123.htm#function-document"><CODE>document</CODE></A>, 
<A 
href="http://www.w3.org/TR/xpath-functions/#func-doc"><CODE>doc</CODE></A><SUP> 
<SMALL>FO</SMALL></SUP>, and <A 
href="http://www.w3.org/TR/xpath-functions/#func-collection"><CODE>collection</CODE></A><SUP><SMALL>FO</SMALL></SUP>, 
and documents returned by extension functions or extension instructions. In the 
context of a particular XSLT instruction, the term <B>source tree</B> means any 
tree provided as input to that instruction; this may be a source tree of the 
transformation as a whole, or it may be a <A title="temporary tree" 
href="REC-xslt20-20070123.htm#dt-temporary-tree">temporary 
tree</A> produced during the course of the transformation.<SPAN 
class=definition>]</SPAN></P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-temporary-tree 
title="temporary tree" name=dt-temporary-tree></A>The term <B>temporary tree</B> 
means any tree that is neither a <A title="source tree" 
href="REC-xslt20-20070123.htm#dt-source-tree">source 
tree</A> nor a <A title="final result tree" 
href="REC-xslt20-20070123.htm#dt-final-result-tree">final 
result tree</A>.<SPAN class=definition>]</SPAN> Temporary trees are used to hold 
intermediate results during the execution of the transformation.</P>
<P>In this specification the phrases <SPAN class=verb>must</SPAN>, <SPAN 
class=verb>must not</SPAN>, <SPAN class=verb>should</SPAN>, <SPAN 
class=verb>should not</SPAN>, <SPAN class=verb>may</SPAN>, <SPAN 
class=verb>required</SPAN>, and <SPAN class=verb>recommended</SPAN> are to be 
interpreted as described in <A 
href="REC-xslt20-20070123.htm#RFC2119">[RFC2119]</A>.</P>
<P>Where the phrase <SPAN class=verb>must</SPAN>, <SPAN class=verb>must 
not</SPAN>, or <SPAN class=verb>required</SPAN> relates to the behavior of the 
XSLT processor, then an implementation is not conformant unless it behaves as 
specified, subject to the more detailed rules in <A 
href="REC-xslt20-20070123.htm#conformance"><I>21 
Conformance</I></A>.</P>
<P>Where the phrase <SPAN class=verb>must</SPAN>, <SPAN class=verb>must 
not</SPAN>, or <SPAN class=verb>required</SPAN> relates to a stylesheet, then 
the processor <SPAN class=verb>must</SPAN> enforce this constraint on 
stylesheets by reporting an error if the constraint is not satisfied.</P>
<P>Where the phrase <SPAN class=verb>should</SPAN>, <SPAN class=verb>should 
not</SPAN>, or <SPAN class=verb>recommended</SPAN> relates to a stylesheet, then 
a processor <SPAN class=verb>may</SPAN> produce warning messages if the 
constraint is not satisfied, but <SPAN class=verb>must not</SPAN> treat this as 
an error.</P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A 
id=dt-implementation-defined title=implementation-defined 
name=dt-implementation-defined></A>In this specification, the term 
<B>implementation-defined</B> refers to a feature where the implementation is 
allowed some flexibility, and where the choices made by the implementation <SPAN 
class=verb>must</SPAN> be described in documentation that accompanies any 
conformance claim.<SPAN class=definition>]</SPAN></P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A 
id=dt-implementation-dependent title=implementation-dependent 
name=dt-implementation-dependent></A>The term <B>implementation-dependent</B> 
refers to a feature where the behavior <SPAN class=verb>may</SPAN> vary from one 
implementation to another, and where the vendor is not expected to provide a 
full specification of the behavior.<SPAN class=definition>]</SPAN> (This might 
apply, for example, to limits on the size of source documents that can be 
transformed.)</P>
<P>In all cases where this specification leaves the behavior 
implementation-defined or implementation-dependent, the implementation has the 
option of providing mechanisms that allow the user to influence the 
behavior.</P>
<P>A paragraph labeled as a <B>Note</B> or described as an <B>example</B> is 
non-normative.</P>
<P>Many terms used in this document are defined in the XPath specification <A 
href="REC-xslt20-20070123.htm#xpath20">[XPath 2.0]</A> or 
the XDM specification <A 
href="REC-xslt20-20070123.htm#xpath-datamodel">[Data 
Model]</A>. Particular attention is drawn to the following:</P>
<UL>
  <LI>
  <P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-atomization 
  title=atomize name=dt-atomization></A>The term <B>atomization</B> is defined 
  in <A href="http://www.w3.org/TR/xpath20/#id-atomization">Section 2.4.2 
  Atomization</A><SUP><SMALL>XP</SMALL></SUP>. It is a process that takes as 
  input a sequence of nodes and atomic values, and returns a sequence of atomic 
  values, in which the nodes are replaced by their typed values as defined in <A 
  href="REC-xslt20-20070123.htm#xpath-datamodel">[Data 
  Model]</A>.<SPAN class=definition>]</SPAN> For some nodes (for example, 
  elements with element-only content), atomization generates a <A 
  title="dynamic error" 
  href="REC-xslt20-20070123.htm#dt-dynamic-error">dynamic 
  error</A>.</P>
  <LI>
  <P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-typed-value 
  title="typed value" name=dt-typed-value></A>The term <B>typed value</B> is 
  defined in <A 
  href="http://www.w3.org/TR/xpath-datamodel/#dm-typed-value">Section 5.15 
  typed-value Accessor</A><SUP><SMALL>DM</SMALL></SUP>. Every node except an 
  element defined in the schema with element-only content has a <A 
  title="string value" 
  href="REC-xslt20-20070123.htm#dt-string-value">typed 
  value</A>. For example, the <A title="typed value" 
  href="REC-xslt20-20070123.htm#dt-typed-value">typed 
  value</A> of an attribute of type <CODE>xs:IDREFS</CODE> is a sequence of zero 
  or more <CODE>xs:IDREF</CODE> values.<SPAN class=definition>]</SPAN></P>
  <LI>
  <P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-string-value 
  title="string value" name=dt-string-value></A>The term <B>string value</B> is 
  defined in <A 
  href="http://www.w3.org/TR/xpath-datamodel/#dm-string-value">Section 5.13 
  string-value Accessor</A><SUP><SMALL>DM</SMALL></SUP>. Every node has a <A 
  title="string value" 
  href="REC-xslt20-20070123.htm#dt-string-value">string 
  value</A>. For example, the <A title="string value" 
  href="REC-xslt20-20070123.htm#dt-string-value">string 
  value</A> of an element is the concatenation of the <A title="string value" 
  href="REC-xslt20-20070123.htm#dt-string-value">string 
  values</A> of all its descendant text nodes.<SPAN 
class=definition>]</SPAN></P>
  <LI>
  <P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-compatibility-mode 
  title="XPath 1.0 compatibility mode" name=dt-compatibility-mode></A>The term 
  <B>XPath 1.0 compatibility mode</B> is defined in <A 
  href="http://www.w3.org/TR/xpath20/#static_context">Section 2.1.1 Static 
  Context</A><SUP><SMALL>XP</SMALL></SUP>. This is a setting in the static 
  context of an XPath expression; it has two values, <CODE>true</CODE> and 
  <CODE>false</CODE>. When the value is set to true, the semantics of function 
  calls and certain other operations are adjusted to give a greater degree of 
  backwards compatibility between XPath 2.0 and XPath 1.0.<SPAN 
  class=definition>]</SPAN></P></LI></UL>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-core-function 
title="core function" name=dt-core-function></A>The term <B>core function</B> 
means a function that is specified in <A 
href="REC-xslt20-20070123.htm#xpath-functions">[Functions 
and Operators]</A> and that is in the <A title="standard function namespace" 
href="REC-xslt20-20070123.htm#dt-standard-function-namespace">standard 
function namespace</A>.<SPAN class=definition>]</SPAN></P></DIV>
<DIV class=div2>
<H3><A id=notation name=notation></A>2.2 Notation</H3>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-xslt-element 
title="XSLT element" name=dt-xslt-element></A>An <B>XSLT element</B> is an 
element in the <A title="XSLT namespace" 
href="REC-xslt20-20070123.htm#dt-xslt-namespace">XSLT 
namespace</A> whose syntax and semantics are defined in this specification.<SPAN 
class=definition>]</SPAN> For a non-normative list of XSLT elements, see <A 
href="REC-xslt20-20070123.htm#element-syntax-summary"><I>D 
Element Syntax Summary</I></A>.</P>
<P>In this document the specification of each <A title="XSLT element" 
href="REC-xslt20-20070123.htm#dt-xslt-element">XSLT 
element</A> is preceded by a summary of its syntax in the form of a model for 
elements of that element type. A full list of all these specifications can be 
found in <A 
href="REC-xslt20-20070123.htm#element-syntax-summary"><I>D 
Element Syntax Summary</I></A>. The meaning of syntax summary notation is as 
follows:</P>
<UL>
  <LI>
  <P>An attribute that is <SPAN class=verb>required</SPAN> is shown with its 
  name in bold. An attribute that may be omitted is shown with a question mark 
  following its name.</P>
  <LI>
  <P>An attribute that is <A title=deprecated 
  href="REC-xslt20-20070123.htm#dt-deprecated">deprecated</A> 
  is shown in a grayed font within square brackets.</P>
  <LI>
  <P>The string that occurs in the place of an attribute value specifies the 
  allowed values of the attribute. If this is surrounded by curly brackets 
  (<CODE>{...}</CODE>), then the attribute value is treated as an <A 
  title="attribute value template" 
  href="REC-xslt20-20070123.htm#dt-attribute-value-template">attribute 
  value template</A>, and the string occurring within curly brackets specifies 
  the allowed values of the result of evaluating the attribute value template. 
  Alternative allowed values are separated by <CODE>|</CODE>. A quoted string 
  indicates a value equal to that specific string. An unquoted, italicized name 
  specifies a particular type of value.</P>
  <P>In all cases where this specification states that the value of an attribute 
  <SPAN class=verb>must</SPAN> be one of a limited set of values, leading and 
  trailing whitespace in the attribute value is ignored. In the case of an <A 
  title="attribute value template" 
  href="REC-xslt20-20070123.htm#dt-attribute-value-template">attribute 
  value template</A>, this applies to the <A title="effective value" 
  href="REC-xslt20-20070123.htm#dt-effective-value">effective 
  value</A> obtained when the attribute value template is expanded.</P>
  <LI>
  <P>Unless the element is <SPAN class=verb>required</SPAN> to be empty, the 
  model element contains a comment specifying the allowed content. The allowed 
  content is specified in a similar way to an element type declaration in XML; 
  <EM>sequence constructor</EM> means that any mixture of text nodes, <A 
  title="literal result element" 
  href="REC-xslt20-20070123.htm#dt-literal-result-element">literal 
  result elements</A>, <A title="extension instruction" 
  href="REC-xslt20-20070123.htm#dt-extension-instruction">extension 
  instructions</A>, and <A title="XSLT element" 
  href="REC-xslt20-20070123.htm#dt-xslt-element">XSLT 
  elements</A> from the <A title=instruction 
  href="REC-xslt20-20070123.htm#dt-instruction">instruction</A> 
  category is allowed; <EM>other-declarations</EM> means that any mixture of 
  XSLT elements from the <A title=declaration 
  href="REC-xslt20-20070123.htm#dt-declaration">declaration</A> 
  category, other than <A 
  href="REC-xslt20-20070123.htm#element-import"><CODE>xsl:import</CODE></A>, 
  is allowed, together with <A title="user-defined data element" 
  href="REC-xslt20-20070123.htm#dt-data-element">user-defined 
  data elements</A>.</P>
  <LI>
  <P>The element is prefaced by comments indicating if it belongs to the 
  <CODE>instruction</CODE> category or <CODE>declaration</CODE> category or 
  both. The category of an element only affects whether it is allowed in the 
  content of elements that allow a <A title="sequence constructor" 
  href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
  constructor</A> or <EM>other-declarations</EM>.</P></LI></UL>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e659 name=d5e659></A>Example: Syntax Notation 
</DIV>
<P>This example illustrates the notation used to describe <A 
title="XSLT element" 
href="REC-xslt20-20070123.htm#dt-xslt-element">XSLT 
elements</A>.</P>
<P class=element-syntax><A id=element-example-element 
name=element-example-element></A><CODE>&lt;!-- Category: instruction 
--&gt;<BR>&lt;xsl:example-element<BR>&nbsp;&nbsp;<B>select</B> = 
<VAR>expression</VAR><BR>&nbsp;&nbsp;debug? = { "yes" | "no" 
}&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: ((<A 
href="REC-xslt20-20070123.htm#element-variable">xsl:variable</A> 
| <A 
href="REC-xslt20-20070123.htm#element-param">xsl:param</A>)*, 
<A 
href="REC-xslt20-20070123.htm#element-sequence">xsl:sequence</A>) 
--&gt;<BR>&lt;/xsl:example-element&gt;</CODE></P>
<P>This example defines a (non-existent) element 
<CODE>xsl:example-element</CODE>. The element is classified as an instruction. 
It takes a mandatory <CODE>select</CODE> attribute, whose value is an XPath <A 
title=expression 
href="REC-xslt20-20070123.htm#dt-expression">expression</A>, 
and an optional <CODE>debug</CODE> attribute, whose value <SPAN 
class=verb>must</SPAN> be either <CODE>yes</CODE> or <CODE>no</CODE>; the curly 
brackets indicate that the value can be defined as an <A 
title="attribute value template" 
href="REC-xslt20-20070123.htm#dt-attribute-value-template">attribute 
value template</A>, allowing a value such as <CODE>debug="{$debug}"</CODE>, 
where the <A title=variable 
href="REC-xslt20-20070123.htm#dt-variable">variable</A> 
<CODE>debug</CODE> is evaluated to yield <CODE>"yes"</CODE> or <CODE>"no"</CODE> 
at run-time.</P>
<P>The content of an <CODE>xsl:example-element</CODE> instruction is defined to 
be a sequence of zero or more <A 
href="REC-xslt20-20070123.htm#element-variable"><CODE>xsl:variable</CODE></A> 
and <A 
href="REC-xslt20-20070123.htm#element-param"><CODE>xsl:param</CODE></A> 
elements, followed by an <A 
href="REC-xslt20-20070123.htm#element-sequence"><CODE>xsl:sequence</CODE></A> 
element.</P></DIV>
<P><A id=err-XTSE0010 name=err-XTSE0010><SPAN class=error>[ERR 
XTSE0010]</SPAN></A> A <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A> is signaled if an XSLT-defined element is used in a context where it 
is not permitted, if a <SPAN class=verb>required</SPAN> attribute is omitted, or 
if the content of the element does not correspond to the content that is allowed 
for the element.</P>
<P>Attributes are validated as follows. These rules apply to the value of the 
attribute after removing leading and trailing whitespace.</P>
<UL>
  <LI>
  <P><A id=err-XTSE0020 name=err-XTSE0020><SPAN class=error>[ERR 
  XTSE0020]</SPAN></A> It is a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A> if an attribute (other than an attribute written using curly 
  brackets in a position where an <A title="attribute value template" 
  href="REC-xslt20-20070123.htm#dt-attribute-value-template">attribute 
  value template</A> is permitted) contains a value that is not one of the 
  permitted values for that attribute.</P>
  <LI>
  <P><A id=err-XTDE0030 name=err-XTDE0030><SPAN class=error>[ERR 
  XTDE0030]</SPAN></A> It is a <A title="non-recoverable dynamic error" 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A> if the <A title="effective value" 
  href="REC-xslt20-20070123.htm#dt-effective-value">effective 
  value</A> of an attribute written using curly brackets, in a position where an 
  <A title="attribute value template" 
  href="REC-xslt20-20070123.htm#dt-attribute-value-template">attribute 
  value template</A> is permitted, is a value that is not one of the permitted 
  values for that attribute. If the processor is able to detect the error 
  statically (for example, when any XPath expressions within the curly brackets 
  can be evaluated statically), then the processor may optionally signal this as 
  a static error.</P></LI></UL>
<P>Special rules apply if the construct appears in part of the <A 
title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
that is processed with <A title="forwards-compatible behavior" 
href="REC-xslt20-20070123.htm#dt-forwards-compatible-behavior">forwards-compatible 
behavior</A>: see <A 
href="REC-xslt20-20070123.htm#forwards"><I>3.9 
Forwards-Compatible Processing</I></A>.</P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-deprecated 
title=deprecated name=dt-deprecated></A>Some constructs defined in this 
specification are described as being <B>deprecated</B>. The use of this term 
implies that stylesheet authors <SPAN class=verb>should not</SPAN> use the 
construct, and that the construct may be removed in a later version of this 
specification.<SPAN class=definition>]</SPAN> All constructs that are <A 
title=deprecated 
href="REC-xslt20-20070123.htm#dt-deprecated">deprecated</A> 
in this specification are also (as it happens) optional features that <A 
title=implementation 
href="REC-xslt20-20070123.htm#dt-implementation">implementations</A> 
are <SPAN class=verb>not required</SPAN> to provide.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>This working draft includes a non-normative XML Schema for XSLT <A 
title="stylesheet module" 
href="REC-xslt20-20070123.htm#dt-stylesheet-module">stylesheet 
modules</A> (see <A 
href="REC-xslt20-20070123.htm#schema-for-xslt"><I>G 
Schema for XSLT Stylesheets</I></A>). The syntax summaries described in this 
section are normative.</P></DIV>
<P>XSLT defines a set of standard functions which are additional to those 
defined in <A 
href="REC-xslt20-20070123.htm#xpath-functions">[Functions 
and Operators]</A>. The signatures of these functions are described using the 
same notation as used in <A 
href="REC-xslt20-20070123.htm#xpath-functions">[Functions 
and Operators]</A>. The names of these functions are all in the <A 
title="standard function namespace" 
href="REC-xslt20-20070123.htm#dt-standard-function-namespace">standard 
function namespace</A>.</P></DIV>
<DIV class=div2>
<H3><A id=initiating name=initiating></A>2.3 Initiating a Transformation</H3>
<P>This document does not specify any application programming interfaces or 
other interfaces for initiating a transformation. This section, however, 
describes the information that is supplied when a transformation is initiated. 
Except where otherwise indicated, the information is <SPAN 
class=verb>required</SPAN>.</P>
<P>Implementations <SPAN class=verb>may</SPAN> allow a transformation to run as 
two or more phases, for example parsing, compilation and execution. Such a 
distinction is outside the scope of this specification, which treats 
transformation as a single process controlled using a set of <A 
title="stylesheet module" 
href="REC-xslt20-20070123.htm#dt-stylesheet-module">stylesheet 
modules</A>, supplied in the form of XML documents.</P>
<P>The following information is supplied to execute a transformation:</P>
<UL>
  <LI>
  <P>The <A title="stylesheet module" 
  href="REC-xslt20-20070123.htm#dt-stylesheet-module">stylesheet 
  module</A> that is to act as the <A title="principal stylesheet module" 
  href="REC-xslt20-20070123.htm#dt-principal-stylesheet-module">principal 
  stylesheet module</A> for the transformation. The complete <A title=stylesheet 
  href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
  is assembled by recursively expanding the <A 
  href="REC-xslt20-20070123.htm#element-import"><CODE>xsl:import</CODE></A> 
  and <A 
  href="REC-xslt20-20070123.htm#element-include"><CODE>xsl:include</CODE></A> 
  declarations in the principal stylesheet module, as described in <A 
  href="REC-xslt20-20070123.htm#include"><I>3.10.2 
  Stylesheet Inclusion</I></A> and <A 
  href="REC-xslt20-20070123.htm#import"><I>3.10.3 
  Stylesheet Import</I></A>.</P>
  <LI>
  <P>A set (possibly empty) of values for <A title="stylesheet parameter" 
  href="REC-xslt20-20070123.htm#dt-stylesheet-parameter">stylesheet 
  parameters</A> (see <A 
  href="REC-xslt20-20070123.htm#global-variables"><I>9.5 
  Global Variables and Parameters</I></A>). These values are available for use 
  within <A title=expression 
  href="REC-xslt20-20070123.htm#dt-expression">expressions</A> 
  in the <A title=stylesheet 
  href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A>.</P>
  <LI>
  <P><SPAN class=definition>[Definition:&nbsp;</SPAN><A 
  id=dt-initial-context-node title="initial context node" 
  name=dt-initial-context-node></A>A node that acts as the <B>initial context 
  node</B> for the transformation. This node is accessible within the <A 
  title=stylesheet 
  href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
  as the initial value of the XPath <A title=expression 
  href="REC-xslt20-20070123.htm#dt-expression">expressions</A> 
  <CODE>.</CODE> (dot) and <CODE>self::node()</CODE>, as described in <A 
  href="REC-xslt20-20070123.htm#focus"><I>5.4.3.1 
  Maintaining Position: the Focus</I></A><SPAN class=definition>]</SPAN>.</P>
  <P>If no initial context node is supplied, then the <A title="context item" 
  href="REC-xslt20-20070123.htm#dt-context-item">context 
  item</A>, <A title="context position" 
  href="REC-xslt20-20070123.htm#dt-context-position">context 
  position</A>, and <A title="context size" 
  href="REC-xslt20-20070123.htm#dt-context-size">context 
  size</A> will initially be undefined, and the evaluation of any expression 
  that references these values will result in a dynamic error. (Note that the 
  initial context size and context position will always be 1 (one) when an 
  initial context node is supplied, and will be undefined if no initial context 
  node is supplied).</P>
  <LI>
  <P>Optionally, the name of a <A title="named template" 
  href="REC-xslt20-20070123.htm#dt-named-template">named 
  template</A> which is to be executed as the entry point to the transformation. 
  This template <SPAN class=verb>must</SPAN> exist within the <A 
  title=stylesheet 
  href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A>. 
  If no named template is supplied, then the transformation starts with the <A 
  title="template rule" 
  href="REC-xslt20-20070123.htm#dt-template-rule">template 
  rule</A> that best matches the <A title="initial context node" 
  href="REC-xslt20-20070123.htm#dt-initial-context-node">initial 
  context node</A>, according to the rules defined in <A 
  href="REC-xslt20-20070123.htm#conflict"><I>6.4 Conflict 
  Resolution for Template Rules</I></A>. Either a named template, or an initial 
  context node, or both, <SPAN class=verb>must</SPAN> be supplied.</P>
  <LI>
  <P>Optionally, an initial <A title=mode 
  href="REC-xslt20-20070123.htm#dt-mode">mode</A>. 
  <SPAN>This <SPAN class=verb>must</SPAN> either be the default mode, or a mode 
  that is explicitly named in the <CODE>mode</CODE> attribute of an <A 
  href="REC-xslt20-20070123.htm#element-template"><CODE>xsl:template</CODE></A> 
  declaration within the stylesheet</SPAN>. If an initial mode is supplied, then 
  in searching for the <A title="template rule" 
  href="REC-xslt20-20070123.htm#dt-template-rule">template 
  rule</A> that best matches the <A title="initial context node" 
  href="REC-xslt20-20070123.htm#dt-initial-context-node">initial 
  context node</A>, the processor considers only those rules that apply to the 
  initial mode. If no initial mode is supplied, the <A title="default mode" 
  href="REC-xslt20-20070123.htm#dt-default-mode">default 
  mode</A> is used.</P>
  <LI>
  <P>A base output URI. <SPAN class=definition>[Definition:&nbsp;</SPAN><A 
  id=dt-base-output-uri title="base output URI" name=dt-base-output-uri></A> The 
  <B>base output URI</B> is a URI to be used as the base URI when resolving a 
  relative URI allocated to a <A title="final result tree" 
  href="REC-xslt20-20070123.htm#dt-final-result-tree">final 
  result tree</A>. If the transformation generates more than one final result 
  tree, then typically each one will be allocated a URI relative to this base 
  URI. <SPAN class=definition>]</SPAN> <SPAN>The way in which a base output URI 
  is established is <A title=implementation-defined 
  href="REC-xslt20-20070123.htm#dt-implementation-defined">implementation-defined</A>.</SPAN></P>
  <LI>
  <P>A mechanism for obtaining a document node and a media type, given an 
  absolute URI. The total set of available documents (modeled as a mapping from 
  URIs to document nodes) forms part of the context for evaluating XPath 
  expressions, specifically the <A 
  href="http://www.w3.org/TR/xpath-functions/#func-doc"><CODE>doc</CODE></A><SUP> 
  <SMALL>FO</SMALL></SUP> function. The XSLT <A 
  href="REC-xslt20-20070123.htm#function-document"><CODE>document</CODE></A> 
  function additionally requires the media type of the resource representation, 
  for use in interpreting any fragment identifier present within a URI 
  Reference.</P>
  <DIV class=note>
  <P class=prefix><B>Note:</B></P>
  <P>The set of documents that are available to the stylesheet is <A 
  title=implementation-dependent 
  href="REC-xslt20-20070123.htm#dt-implementation-dependent">implementation-dependent</A>, 
  as is the processing that is carried out to construct a tree representing the 
  resource retrieved using a given URI. Some possible ways of constructing a 
  document (specifically, rules for constructing a document from an Infoset or 
  from a PSVI) are described in <A 
  href="REC-xslt20-20070123.htm#xpath-datamodel">[Data 
  Model]</A>.</P></DIV></LI></UL>
<P><A id=err-XTDE0040 name=err-XTDE0040><SPAN class=error>[ERR 
XTDE0040]</SPAN></A> It is a <A title="non-recoverable dynamic error" 
href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
dynamic error</A> if the invocation of the <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
specifies a template name that does not match the <A title=expanded-QName 
href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded-QName</A> 
of a named template defined in the <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A>.</P>
<P><A id=err-XTDE0045 name=err-XTDE0045><SPAN class=error>[ERR 
XTDE0045]</SPAN></A> It is a <A title="non-recoverable dynamic error" 
href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
dynamic error</A> if the invocation of the <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
specifies an initial <A title=mode 
href="REC-xslt20-20070123.htm#dt-mode">mode</A> (other 
than the default mode) that does not match the <A title=expanded-QName 
href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded-QName</A> 
in the <CODE>mode</CODE> attribute of any template defined in the <A 
title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A>.</P>
<P><A id=err-XTDE0047 name=err-XTDE0047><SPAN class=error>[ERR 
XTDE0047]</SPAN></A> It is a <A title="non-recoverable dynamic error" 
href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
dynamic error</A> if the invocation of the <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
specifies both an initial <A title=mode 
href="REC-xslt20-20070123.htm#dt-mode">mode</A> and an 
initial template.</P>
<P><A id=err-XTDE0050 name=err-XTDE0050><SPAN class=error>[ERR 
XTDE0050]</SPAN></A> It is a <A title="non-recoverable dynamic error" 
href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
dynamic error</A> if the stylesheet that is invoked declares a visible <A 
title="stylesheet parameter" 
href="REC-xslt20-20070123.htm#dt-stylesheet-parameter">stylesheet 
parameter</A> with <CODE>required="yes"</CODE> and no value for this parameter 
is supplied during the invocation of the stylesheet. A stylesheet parameter is 
visible if it is not masked by another global variable or parameter with the 
same name and higher <A title="import precedence" 
href="REC-xslt20-20070123.htm#dt-import-precedence">import 
precedence</A>.</P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-initial-template 
title="initial template" name=dt-initial-template></A>The transformation is 
performed by evaluating an <B>initial template</B>. If a <A 
title="named template" 
href="REC-xslt20-20070123.htm#dt-named-template">named 
template</A> is supplied when the transformation is initiated, then this is the 
initial template; <SPAN>otherwise, the initial template is the <A 
title="template rule" 
href="REC-xslt20-20070123.htm#dt-template-rule">template 
rule</A> selected according to the rules of the <A 
href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A> 
instruction for processing the <A title="initial context node" 
href="REC-xslt20-20070123.htm#dt-initial-context-node">initial 
context node</A> in the initial <A title=mode 
href="REC-xslt20-20070123.htm#dt-mode">mode</A>.</SPAN><SPAN 
class=definition>]</SPAN></P>
<P>Parameters passed to the transformation by the client application are matched 
against <A title="stylesheet parameter" 
href="REC-xslt20-20070123.htm#dt-stylesheet-parameter">stylesheet 
parameters</A> (see <A 
href="REC-xslt20-20070123.htm#global-variables"><I>9.5 
Global Variables and Parameters</I></A>), not against the <A 
title="template parameter" 
href="REC-xslt20-20070123.htm#dt-template-parameter">template 
parameters</A> declared within the <A title="initial template" 
href="REC-xslt20-20070123.htm#dt-initial-template">initial 
template</A>. All <A title="template parameter" 
href="REC-xslt20-20070123.htm#dt-template-parameter">template 
parameters</A> within the initial template to be executed will take their 
default values.</P>
<P><A id=err-XTDE0060 name=err-XTDE0060><SPAN class=error>[ERR 
XTDE0060]</SPAN></A> It is a <A title="non-recoverable dynamic error" 
href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
dynamic error</A> if the <A title="initial template" 
href="REC-xslt20-20070123.htm#dt-initial-template">initial 
template</A> defines a <A title="template parameter" 
href="REC-xslt20-20070123.htm#dt-template-parameter">template 
parameter</A> that specifies <CODE>required="yes"</CODE>.</P>
<P>A <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
can process further source documents in addition to those supplied when the 
transformation is invoked. These additional documents can be loaded using the 
functions <A 
href="REC-xslt20-20070123.htm#function-document"><CODE>document</CODE></A> 
(see <A href="REC-xslt20-20070123.htm#document"><I>16.1 
Multiple Source Documents</I></A>) or <A 
href="http://www.w3.org/TR/xpath-functions/#func-doc"><CODE>doc</CODE></A><SUP> 
<SMALL>FO</SMALL></SUP> or <A 
href="http://www.w3.org/TR/xpath-functions/#func-collection"><CODE>collection</CODE></A><SUP><SMALL>FO</SMALL></SUP> 
(see <A 
href="REC-xslt20-20070123.htm#xpath-functions">[Functions 
and Operators]</A>), or they can be supplied as <A title="stylesheet parameter" 
href="REC-xslt20-20070123.htm#dt-stylesheet-parameter">stylesheet 
parameters</A> (see <A 
href="REC-xslt20-20070123.htm#global-variables"><I>9.5 
Global Variables and Parameters</I></A>), or as the result of an <A 
title="extension function" 
href="REC-xslt20-20070123.htm#dt-extension-function">extension 
function</A> (see <A 
href="REC-xslt20-20070123.htm#extension-functions"><I>18.1 
Extension Functions</I></A>).</P></DIV>
<DIV class=div2>
<H3><A id=executing-a-transformation name=executing-a-transformation></A>2.4 
Executing a Transformation</H3>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-template-rule 
title="template rule" name=dt-template-rule></A>A stylesheet contains a set of 
<B>template rules</B> (see <A 
href="REC-xslt20-20070123.htm#rules"><I>6 Template 
Rules</I></A>). A template rule has three parts: a <A title=pattern 
href="REC-xslt20-20070123.htm#dt-pattern">pattern</A> 
that is matched against nodes, a (possibly empty) set of <A 
title="template parameter" 
href="REC-xslt20-20070123.htm#dt-template-parameter">template 
parameters</A>, and a <A title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A> that is evaluated to produce a sequence of items.<SPAN 
class=definition>]</SPAN> In many cases these items are newly constructed nodes, 
which are then written to a <A title="result tree" 
href="REC-xslt20-20070123.htm#dt-result-tree">result 
tree</A>.</P>
<P>A transformation as a whole is executed by evaluating the <A 
title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A> of the <A title="initial template" 
href="REC-xslt20-20070123.htm#dt-initial-template">initial 
template</A> as described in <A 
href="REC-xslt20-20070123.htm#sequence-constructors"><I>5.7 
Sequence Constructors</I></A>.</P>
<P>If the initial template has an <CODE>as</CODE> attribute, then the result 
sequence of the initial template is checked against the required type in the 
same way as for any other template. If this result sequence is non-empty, then 
it is used to construct an implicit <A title="final result tree" 
href="REC-xslt20-20070123.htm#dt-final-result-tree">final 
result tree</A>, following the rules described in <A 
href="REC-xslt20-20070123.htm#constructing-complex-content"><I>5.7.1 
Constructing Complex Content</I></A>: the effect is as if the initial template 
<VAR>T</VAR> were called by an implicit template of the form:</P>
<DIV class=exampleInner><PRE>&lt;xsl:template name="IMPLICIT"&gt;
  &lt;xsl:result-document href=""&gt;
    &lt;xsl:call-template name="T"/&gt;
  &lt;/xsl:result-document&gt;
&lt;/xsl:template&gt;
</PRE></DIV>
<P>An implicit result tree is also created when the result sequence is empty, 
provided that no <A 
href="REC-xslt20-20070123.htm#element-result-document"><CODE>xsl:result-document</CODE></A> 
instruction has been evaluated during the course of the transformation. In this 
situation the implicit result tree will consist of a document node with no 
children.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>This means that there is always at least one result tree. It also means that 
if the content of the initial template is a single <A 
href="REC-xslt20-20070123.htm#element-result-document"><CODE>xsl:result-document</CODE></A> 
instruction, as in the example above, then only one result tree is produced, not 
two. It is useful to make the result document explicit as this is the only way 
of invoking document-level validation.</P>
<P>If the result of the initial template is non-empty, and an explicit <A 
href="REC-xslt20-20070123.htm#element-result-document"><CODE>xsl:result-document</CODE></A> 
instruction has been evaluated with the empty attribute <CODE>href=""</CODE>, 
then an error will occur <SPAN class=error>[see <A 
href="REC-xslt20-20070123.htm#err-XTDE1490">ERR 
XTDE1490</A>]</SPAN>, since it is not possible to create two final result trees 
with the same URI.</P></DIV>
<P>A <A title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A> is a sequence of sibling nodes in the stylesheet, each of which 
is either an <A title="XSLT instruction" 
href="REC-xslt20-20070123.htm#dt-xslt-instruction">XSLT 
instruction</A>, a <A title="literal result element" 
href="REC-xslt20-20070123.htm#dt-literal-result-element">literal 
result element</A>, a text node, or an <A title="extension instruction" 
href="REC-xslt20-20070123.htm#dt-extension-instruction">extension 
instruction</A>.</P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-instruction 
title=instruction name=dt-instruction></A>An <B>instruction</B> is either an <A 
title="XSLT instruction" 
href="REC-xslt20-20070123.htm#dt-xslt-instruction">XSLT 
instruction</A> or an <A title="extension instruction" 
href="REC-xslt20-20070123.htm#dt-extension-instruction">extension 
instruction</A>.<SPAN class=definition>]</SPAN></P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-xslt-instruction 
title="XSLT instruction" name=dt-xslt-instruction></A>An <B>XSLT instruction</B> 
is an <A title="XSLT element" 
href="REC-xslt20-20070123.htm#dt-xslt-element">XSLT 
element</A> whose syntax summary in this specification contains the annotation 
<CODE>&lt;!-- category: instruction --&gt;</CODE>.<SPAN 
class=definition>]</SPAN></P>
<P><A title="extension instruction" 
href="REC-xslt20-20070123.htm#dt-extension-instruction">Extension 
instructions</A> are described in <A 
href="REC-xslt20-20070123.htm#extension-instruction"><I>18.2 
Extension Instructions</I></A>.</P>
<P>The main categories of <A title="XSLT instruction" 
href="REC-xslt20-20070123.htm#dt-xslt-instruction">XSLT 
instruction</A> are as follows:</P>
<UL>
  <LI>
  <P>instructions that create new nodes: <SPAN><A 
  href="REC-xslt20-20070123.htm#element-document"><CODE>xsl:document</CODE></A></SPAN>, 
  <A 
  href="REC-xslt20-20070123.htm#element-element"><CODE>xsl:element</CODE></A>, 
  <A 
  href="REC-xslt20-20070123.htm#element-attribute"><CODE>xsl:attribute</CODE></A>, 
  <A 
  href="REC-xslt20-20070123.htm#element-processing-instruction"><CODE>xsl:processing-instruction</CODE></A>, 
  <A 
  href="REC-xslt20-20070123.htm#element-comment"><CODE>xsl:comment</CODE></A>, 
  <A 
  href="REC-xslt20-20070123.htm#element-value-of"><CODE>xsl:value-of</CODE></A>, 
  <A 
  href="REC-xslt20-20070123.htm#element-text"><CODE>xsl:text</CODE></A>, 
  <A 
  href="REC-xslt20-20070123.htm#element-namespace"><CODE>xsl:namespace</CODE></A>;</P>
  <LI>
  <P>an instruction that returns an arbitrary sequence by evaluating an XPath 
  expression: <A 
  href="REC-xslt20-20070123.htm#element-sequence"><CODE>xsl:sequence</CODE></A>;</P>
  <LI>
  <P>instructions that cause conditional or repeated evaluation of nested 
  instructions: <A 
  href="REC-xslt20-20070123.htm#element-if"><CODE>xsl:if</CODE></A>, 
  <A 
  href="REC-xslt20-20070123.htm#element-choose"><CODE>xsl:choose</CODE></A>, 
  <A 
  href="REC-xslt20-20070123.htm#element-for-each"><CODE>xsl:for-each</CODE></A>, 
  <A 
  href="REC-xslt20-20070123.htm#element-for-each-group"><CODE>xsl:for-each-group</CODE></A>;</P>
  <LI>
  <P>instructions that invoke templates: <A 
  href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A>, 
  <A 
  href="REC-xslt20-20070123.htm#element-apply-imports"><CODE>xsl:apply-imports</CODE></A>, 
  <A 
  href="REC-xslt20-20070123.htm#element-call-template"><CODE>xsl:call-template</CODE></A>, 
  <A 
  href="REC-xslt20-20070123.htm#element-next-match"><CODE>xsl:next-match</CODE></A>;</P>
  <LI>
  <P>Instructions that declare variables: <A 
  href="REC-xslt20-20070123.htm#element-variable"><CODE>xsl:variable</CODE></A>, 
  <A 
  href="REC-xslt20-20070123.htm#element-param"><CODE>xsl:param</CODE></A>;</P>
  <LI>
  <P>other specialized instructions: <A 
  href="REC-xslt20-20070123.htm#element-number"><CODE>xsl:number</CODE></A>, 
  <A 
  href="REC-xslt20-20070123.htm#element-analyze-string"><CODE>xsl:analyze-string</CODE></A>, 
  <A 
  href="REC-xslt20-20070123.htm#element-message"><CODE>xsl:message</CODE></A>, 
  <A 
  href="REC-xslt20-20070123.htm#element-result-document"><CODE>xsl:result-document</CODE></A>.</P></LI></UL>
<P>Often, a <A title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A> will include an <A 
href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A> 
instruction, which selects a sequence of nodes to be processed. Each of the 
selected nodes is processed by searching the stylesheet for a matching <A 
title="template rule" 
href="REC-xslt20-20070123.htm#dt-template-rule">template 
rule</A> and evaluating the <A title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A> of that template rule. The resulting sequences of items are 
concatenated, in order, to give the result of the <A 
href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A> 
instruction, as described in <A 
href="REC-xslt20-20070123.htm#applying-templates"><I>6.3 
Applying Template Rules</I></A>; this sequence is often added to a <A 
title="result tree" 
href="REC-xslt20-20070123.htm#dt-result-tree">result 
tree</A>. Since the <A title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructors</A> of the selected <A title="template rule" 
href="REC-xslt20-20070123.htm#dt-template-rule">template 
rules</A> may themselves contain <A 
href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A> 
instructions, this results in a cycle of selecting nodes, identifying <A 
title="template rule" 
href="REC-xslt20-20070123.htm#dt-template-rule">template 
rules</A>, constructing sequences, and constructing <A title="result tree" 
href="REC-xslt20-20070123.htm#dt-result-tree">result 
trees</A>, that recurses through a <A title="source tree" 
href="REC-xslt20-20070123.htm#dt-source-tree">source 
tree</A>.</P></DIV>
<DIV class=div2>
<H3><A id=context name=context></A>2.5 The Evaluation Context</H3>
<P>The results of some expressions and instructions in a stylesheet may depend 
on information provided contextually. This context information is divided into 
two categories: the static context, which is known during static analysis of the 
stylesheet, and the dynamic context, which is not known until the stylesheet is 
evaluated. Although information in the static context is known at analysis time, 
it is sometimes used during stylesheet evaluation.</P>
<P>Some context information can be set by means of declarations within the 
stylesheet itself. For example, the namespace bindings used for any XPath 
expression are determined by the namespace declarations present in containing 
elements in the stylesheet. Other information may be supplied externally or 
implicitly: an example is the current date and time.</P>
<P>The context information used in processing an XSLT stylesheet includes as a 
subset all the context information required when evaluating XPath expressions. 
The XPath 2.0 specification defines a static and dynamic context that the host 
language (in this case, XSLT) may initialize, which affects the results of XPath 
expressions used in that context. XSLT augments the context with additional 
information: this additional information is used firstly by XSLT constructs 
outside the scope of XPath (for example, the <A 
href="REC-xslt20-20070123.htm#element-sort"><CODE>xsl:sort</CODE></A> 
element), and secondly, by functions that are defined in the XSLT specification 
(such as <A 
href="REC-xslt20-20070123.htm#function-key"><CODE>key</CODE></A> 
and <A 
href="REC-xslt20-20070123.htm#function-format-number"><CODE>format-number</CODE></A>) 
that are available for use in XPath expressions appearing within a 
stylesheet.</P>
<P>The static context for an expression or other construct in a stylesheet is 
determined by the place in which it appears lexically. The details vary for 
different components of the static context, but in general, elements within a 
stylesheet module affect the static context for their descendant elements within 
the same stylesheet module.</P>
<P>The dynamic context is maintained as a stack. When an instruction or 
expression is evaluated, it may add dynamic context information to the stack; 
when evaluation is complete, the dynamic context reverts to its previous state. 
An expression that accesses information from the dynamic context always uses the 
value at the top of the stack.</P>
<P>The most commonly used component of the dynamic context is the <A 
title="context item" 
href="REC-xslt20-20070123.htm#dt-context-item">context 
item</A>. This is an implicit variable whose value is the item (it may be a node 
or an atomic value) currently being processed. The value of the context item can 
be referenced within an XPath expression using the expression <CODE>.</CODE> 
(dot).</P>
<P>Full details of the static and dynamic context are provided in <A 
href="REC-xslt20-20070123.htm#static-and-dynamic-context"><I>5.4 
The Static and Dynamic Context</I></A>.</P></DIV>
<DIV class=div2>
<H3><A id=parsing-and-serialization name=parsing-and-serialization></A>2.6 
Parsing and Serialization</H3>
<P>An XSLT <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
describes a process that constructs a set of <A title="final result tree" 
href="REC-xslt20-20070123.htm#dt-final-result-tree">final 
result trees</A> from a set of <A title="source tree" 
href="REC-xslt20-20070123.htm#dt-source-tree">source 
trees</A>.</P>
<P>The <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
does not describe how a <A title="source tree" 
href="REC-xslt20-20070123.htm#dt-source-tree">source 
tree</A> is constructed. <SPAN>Some possible ways of constructing source trees 
are described in <A 
href="REC-xslt20-20070123.htm#xpath-datamodel">[Data 
Model]</A>.</SPAN> Frequently an <A title=implementation 
href="REC-xslt20-20070123.htm#dt-implementation">implementation</A> 
will operate in conjunction with an XML parser (or more strictly, in the 
terminology of <A 
href="REC-xslt20-20070123.htm#REC-xml">[XML 1.0]</A>, an 
<EM>XML processor</EM>), to build a source tree from an input XML document. An 
implementation <SPAN class=verb>may</SPAN> also provide an application 
programming interface allowing the tree to be constructed directly, or allowing 
it to be supplied in the form of a DOM Document object (see <A 
href="REC-xslt20-20070123.htm#DOM-Level-2-Core">[DOM 
Level 2]</A>). This is outside the scope of this specification. Users should be 
aware, however, that since the input to the transformation is a tree conforming 
to the <SPAN>XDM</SPAN> data model as described in <A 
href="REC-xslt20-20070123.htm#xpath-datamodel">[Data 
Model]</A>, constructs that might exist in the original XML document, or in the 
DOM, but which are not within the scope of the data model, cannot be processed 
by the <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
and cannot be guaranteed to remain unchanged in the transformation output. Such 
constructs include CDATA section boundaries, the use of entity references, and 
the DOCTYPE declaration and internal DTD subset.</P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-serialization 
title=serialization name=dt-serialization></A>A frequent requirement is to 
output a <A title="final result tree" 
href="REC-xslt20-20070123.htm#dt-final-result-tree">final 
result tree</A> as an XML document (or in other formats such as HTML). This 
process is referred to as <B>serialization</B>.<SPAN 
class=definition>]</SPAN></P>
<P>Like parsing, serialization is not part of the transformation process, and it 
is not <SPAN class=verb>required</SPAN> that an XSLT processor <SPAN 
class=verb>must</SPAN> be able to perform serialization. However, for pragmatic 
reasons, this specification describes declarations (the <A 
href="REC-xslt20-20070123.htm#element-output"><CODE>xsl:output</CODE></A> 
element and the <A 
href="REC-xslt20-20070123.htm#element-character-map"><CODE>xsl:character-map</CODE></A> 
declarations, see <A 
href="REC-xslt20-20070123.htm#serialization"><I>20 
Serialization</I></A>), and attributes on the <A 
href="REC-xslt20-20070123.htm#element-result-document"><CODE>xsl:result-document</CODE></A> 
instruction, that allow a <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
to specify the desired properties of a serialized output file. <SPAN>When 
serialization is not being performed, either because the implementation does not 
support the serialization option, or because the user is executing the 
transformation in a way that does not invoke serialization, then the content of 
the <A 
href="REC-xslt20-20070123.htm#element-output"><CODE>xsl:output</CODE></A> 
and <A 
href="REC-xslt20-20070123.htm#element-character-map"><CODE>xsl:character-map</CODE></A> 
declarations has no effect. Under these circumstances the processor <SPAN 
class=verb>may</SPAN> report any errors in an <A 
href="REC-xslt20-20070123.htm#element-output"><CODE>xsl:output</CODE></A> 
or <A 
href="REC-xslt20-20070123.htm#element-character-map"><CODE>xsl:character-map</CODE></A> 
declaration, or in the serialization attributes of <A 
href="REC-xslt20-20070123.htm#element-result-document"><CODE>xsl:result-document</CODE></A>,</SPAN> 
but is not <SPAN class=verb>required</SPAN> to do so.</P></DIV>
<DIV class=div2>
<H3><A id=extensibility name=extensibility></A>2.7 Extensibility</H3>
<P>XSLT defines a number of features that allow the language to be extended by 
implementers, or, if implementers choose to provide the capability, by users. 
These features have been designed, so far as possible, so that they can be used 
without sacrificing interoperability. Extensions other than those explicitly 
defined in this specification are not permitted.</P>
<P>These features are all based on XML namespaces; namespaces are used to ensure 
that the extensions provided by one implementer do not clash with those of a 
different implementer.</P>
<P>The most common way of extending the language is by providing additional 
functions, which can be invoked from XPath expressions. These are known as <A 
title="extension function" 
href="REC-xslt20-20070123.htm#dt-extension-function">extension 
functions</A>, and are described in <A 
href="REC-xslt20-20070123.htm#extension-functions"><I>18.1 
Extension Functions</I></A>.</P>
<P>It is also permissible to extend the language by providing new <A 
title=instruction 
href="REC-xslt20-20070123.htm#dt-instruction">instructions</A>. 
These are referred to as <A title="extension instruction" 
href="REC-xslt20-20070123.htm#dt-extension-instruction">extension 
instructions</A>, and are described in <A 
href="REC-xslt20-20070123.htm#extension-instruction"><I>18.2 
Extension Instructions</I></A>. A stylesheet that uses extension instructions 
must declare that it is doing so by using the 
<CODE>[xsl:]extension-element-prefixes</CODE> attribute.</P>
<P>Extension instructions and extension functions defined according to these 
rules <SPAN class=verb>may</SPAN> be provided by the implementer of the XSLT 
processor, and the implementer <SPAN class=verb>may</SPAN> also provide 
facilities to allow users to create further extension instructions and extension 
functions.</P>
<P>This specification defines how extension instructions and extension functions 
are invoked, but the facilities for creating new extension instructions and 
extension functions are <A title=implementation-defined 
href="REC-xslt20-20070123.htm#dt-implementation-defined">implementation-defined</A>. 
For further details, see <A 
href="REC-xslt20-20070123.htm#extension"><I>18 
Extensibility and Fallback</I></A>.</P>
<P>The XSLT language can also be extended by the use of <A 
title="extension attribute" 
href="REC-xslt20-20070123.htm#dt-extension-attribute">extension 
attributes</A> (see <A 
href="REC-xslt20-20070123.htm#extension-attributes"><I>3.3 
Extension Attributes</I></A>), and by means of <A 
title="user-defined data element" 
href="REC-xslt20-20070123.htm#dt-data-element">user-defined 
data elements</A> (see <A 
href="REC-xslt20-20070123.htm#user-defined-top-level"><I>3.6.2 
User-defined Data Elements</I></A>).</P></DIV>
<DIV class=div2>
<H3><A id=stylesheets-and-schemas name=stylesheets-and-schemas></A>2.8 
Stylesheets and <SPAN>XML</SPAN> Schemas</H3>
<P>An XSLT <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
can make use of information from a schema. An XSLT transformation can take place 
in the absence of a schema (and, indeed, in the absence of a DTD), but where the 
source document has undergone schema validity assessment, the XSLT processor has 
access to the type information associated with individual nodes, not merely to 
the untyped text.</P>
<P>Information from a schema can be used both statically (when the <A 
title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
is compiled), and dynamically (during evaluation of the stylesheet to transform 
a source document).</P>
<P>There are places within a <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A>, 
and within XPath <A title=expression 
href="REC-xslt20-20070123.htm#dt-expression">expressions</A> 
and <A title=pattern 
href="REC-xslt20-20070123.htm#dt-pattern">patterns</A> in 
a <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A>, 
where it is possible to refer to named type definitions in a schema, or to 
element and attribute declarations. For example, it is possible to declare the 
types expected for the parameters of a function. This is done using the <A 
href="http://www.w3.org/TR/xpath20/#doc-xpath-SequenceType">SequenceType</A><SUP> 
<SMALL>XP</SMALL></SUP> syntax defined in <A 
href="REC-xslt20-20070123.htm#xpath20">[XPath 
2.0]</A>.</P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-schema-component 
title="schema component" name=dt-schema-component></A>Type definitions and 
element and attribute declarations are referred to collectively as <B>schema 
components</B>.<SPAN class=definition>]</SPAN></P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A 
id=dt-in-scope-schema-component title="in-scope schema component" 
name=dt-in-scope-schema-component></A>The <A title="schema component" 
href="REC-xslt20-20070123.htm#dt-schema-component">schema 
components</A> that may be referenced by name in a <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
are referred to as the <B>in-scope schema components</B>. This set is the same 
throughout all the modules of a stylesheet.<SPAN class=definition>]</SPAN></P>
<P>The conformance rules for XSLT 2.0, defined in <A 
href="REC-xslt20-20070123.htm#conformance"><I>21 
Conformance</I></A>, distinguish between a <A title="basic XSLT processor" 
href="REC-xslt20-20070123.htm#dt-basic-xslt-processor">basic 
XSLT processor</A> and a <A title="schema-aware XSLT processor" 
href="REC-xslt20-20070123.htm#dt-schema-aware-xslt-processor">schema-aware 
XSLT processor</A>. As the names suggest, a basic XSLT processor does not 
support the features of XSLT that require access to schema information, either 
statically or dynamically. A <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
that works with a basic XSLT processor will produce the same results with a 
schema-aware XSLT processor <SPAN>provided that the source documents are untyped 
(that is, they are not validated against a schema). However, if source documents 
are validated against a schema then the results may be different from the case 
where they are not validated. Some constructs that work on untyped data may fail 
with typed data (for example, an attribute of type <CODE>xs:date</CODE> cannot 
be used as an argument of the <A 
href="http://www.w3.org/TR/xpath-functions/#func-substring"><CODE>substring</CODE></A><SUP><SMALL>FO</SMALL></SUP> 
function) and other constructs may produce different results depending on the 
data type (for example, given the element <CODE>&lt;product price="10.00" 
discount="2.00"/&gt;</CODE>, the expression <CODE>@price gt @discount</CODE> 
will return true if the attributes have type <CODE>xs:decimal</CODE>, but will 
return false if they are untyped).</SPAN></P>
<P>There is a standard set of type definitions that are always available as <A 
title="in-scope schema component" 
href="REC-xslt20-20070123.htm#dt-in-scope-schema-component">in-scope 
schema components</A> in every stylesheet. These are defined in <A 
href="REC-xslt20-20070123.htm#built-in-types"><I>3.13 
Built-in Types</I></A>. The set of built-in types varies between a <A 
title="basic XSLT processor" 
href="REC-xslt20-20070123.htm#dt-basic-xslt-processor">basic 
XSLT processor</A> and a <A title="schema-aware XSLT processor" 
href="REC-xslt20-20070123.htm#dt-schema-aware-xslt-processor">schema-aware 
XSLT processor</A>.</P>
<P>The remainder of this section describes facilities that are available only 
with a <A title="schema-aware XSLT processor" 
href="REC-xslt20-20070123.htm#dt-schema-aware-xslt-processor">schema-aware 
XSLT processor</A>.</P>
<P>Additional <A title="schema component" 
href="REC-xslt20-20070123.htm#dt-schema-component">schema 
components</A> (type definitions, element declarations, and attribute 
declarations) may be added to the <A title="in-scope schema component" 
href="REC-xslt20-20070123.htm#dt-in-scope-schema-component">in-scope 
schema components</A> by means of the <A 
href="REC-xslt20-20070123.htm#element-import-schema"><CODE>xsl:import-schema</CODE></A> 
declaration in a stylesheet.</P>
<P>The <A 
href="REC-xslt20-20070123.htm#element-import-schema"><CODE>xsl:import-schema</CODE></A> 
declaration may reference an external schema document by means of a URI, or it 
may contain an inline <CODE>xs:schema</CODE> element.</P>
<P>It is only necessary to import a schema explicitly if <SPAN>one or more of 
its <A title="schema component" 
href="REC-xslt20-20070123.htm#dt-schema-component">schema 
components</A> are referenced explicitly by name</SPAN> in the <A 
title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A>; 
it is not necessary to import a schema merely because the stylesheet is used to 
process a source document that has been assessed against that schema. It is 
possible to make use of the information resulting from schema assessment (for 
example, the fact that a particular attribute holds a date) even if no schema 
has been imported by the stylesheet.</P>
<P>Further, importing a schema does not of itself say anything about the type of 
the source document that the <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
is expected to process. The imported type definitions can be used for temporary 
nodes or for nodes on a <A title="result tree" 
href="REC-xslt20-20070123.htm#dt-result-tree">result 
tree</A> just as much as for nodes <SPAN>in source documents. It is possible to 
make assertions about the type of an input document by means of tests within the 
<A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A>. 
For example:</SPAN></P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e1763 name=d5e1763></A>Example: Asserting the 
Required Type of the Source Document </DIV>
<DIV class=exampleInner><PRE>&lt;xsl:template match="document-node(schema-element(my:invoice))" priority="2"&gt;
. . .
&lt;/xsl:template&gt;

&lt;xsl:template match="document-node()" priority="1"&gt;
  &lt;xsl:message terminate="yes"&gt;Source document is not an invoice&lt;/xsl:message&gt;
&lt;/xsl:template&gt;
</PRE></DIV>
<P>This example will cause the transformation to fail with an error message 
unless the document element of the source document is valid against the 
top-level element declaration <CODE>my:invoice</CODE>, and has been annotated as 
such.</P></DIV>
<P>It is possible that a source document may contain nodes whose <A 
title="type annotation" 
href="REC-xslt20-20070123.htm#dt-annotation">type 
annotation</A> is not one of the types imported by the stylesheet. This creates 
a potential problem because in the case of an expression such as <CODE>data(.) 
instance of xs:integer</CODE> the system needs to know whether the type named in 
the type annotation of the context node is derived by restriction from the type 
<CODE>xs:integer</CODE>. This information is not explicitly available in an 
<SPAN>XDM tree</SPAN>, as defined in <A 
href="REC-xslt20-20070123.htm#xpath-datamodel">[Data 
Model]</A>. The implementation may choose one of several strategies for dealing 
with this situation:</P>
<OL class=enumar>
  <LI>
  <P>The processor may signal a <A title="non-recoverable dynamic error" 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A> if a source document is found to contain a <A 
  title="type annotation" 
  href="REC-xslt20-20070123.htm#dt-annotation">type 
  annotation</A> that is not known to the processor.</P>
  <LI>
  <P>The processor may maintain additional metadata, beyond that described in <A 
  href="REC-xslt20-20070123.htm#xpath-datamodel">[Data 
  Model]</A>, that allows the source document to be processed as if all the 
  necessary schema information had been imported using <A 
  href="REC-xslt20-20070123.htm#element-import-schema"><CODE>xsl:import-schema</CODE></A>. 
  Such metadata might be held in the data structure representing the source 
  document itself, or it might be held in a system catalog or repository.</P>
  <LI>
  <P>The processor may be configured to use a fixed set of schemas, which are 
  automatically used to validate all source documents before they can be 
  supplied as input to a transformation. In this case it is impossible for a 
  source document to have a <A title="type annotation" 
  href="REC-xslt20-20070123.htm#dt-annotation">type 
  annotation</A> that the processor is not aware of.</P>
  <LI>
  <P>The processor may be configured to treat the source document as if no 
  schema processing had been performed, that is, effectively to strip all type 
  annotations from elements and attributes on input, marking them instead as 
  having type <SPAN><CODE>xs:untyped</CODE></SPAN> and 
  <SPAN><CODE>xs:untypedAtomic</CODE></SPAN> respectively.</P></LI></OL>
<P>Where a stylesheet author chooses to make assertions about the types of nodes 
or of <A title=variable 
href="REC-xslt20-20070123.htm#dt-variable">variables</A> 
and <A title=parameter 
href="REC-xslt20-20070123.htm#dt-parameter">parameters</A>, 
it is possible for an XSLT processor to perform static analysis of the <A 
title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
(that is, analysis in the absence of any source document). Such analysis <SPAN 
class=verb>may</SPAN> reveal errors that would otherwise not be discovered until 
the transformation is actually executed. An XSLT processor is not <SPAN 
class=verb>required</SPAN> to perform such static type-checking. <SPAN>Under 
some circumstances (see <A 
href="REC-xslt20-20070123.htm#errors"><I>2.9 Error 
Handling</I></A>) type errors that are detected early <SPAN 
class=verb>may</SPAN> be reported as static errors. In addition an 
implementation <SPAN class=verb>may</SPAN> report any condition found during 
static analysis as a warning, provided that this does not prevent the stylesheet 
being evaluated as described by this specification.</SPAN></P>
<P>A <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
can also control the <A title="type annotation" 
href="REC-xslt20-20070123.htm#dt-annotation">type 
annotations</A> of nodes that it constructs in a <A title="final result tree" 
href="REC-xslt20-20070123.htm#dt-final-result-tree">final 
result tree</A>, or in <A title="temporary tree" 
href="REC-xslt20-20070123.htm#dt-temporary-tree">temporary 
trees</A>. This can be done in a number of ways.</P>
<UL>
  <LI>
  <P>It is possible to request explicit validation of a complete document, that 
  is, a tree rooted at a document node. This applies both to temporary trees 
  constructed using the <A 
  href="REC-xslt20-20070123.htm#element-document"><CODE>xsl:document</CODE></A> 
  (or <A 
  href="REC-xslt20-20070123.htm#element-copy"><CODE>xsl:copy</CODE></A>) 
  instruction and also to <A title="final result tree" 
  href="REC-xslt20-20070123.htm#dt-final-result-tree">final 
  result trees</A> constructed using <A 
  href="REC-xslt20-20070123.htm#element-result-document"><CODE>xsl:result-document</CODE></A>. 
  Validation is either strict or lax, as described in <A 
  href="REC-xslt20-20070123.htm#xmlschema-1">[XML Schema 
  Part 1]</A>. If validation of a <A title="result tree" 
  href="REC-xslt20-20070123.htm#dt-result-tree">result 
  tree</A> fails (strictly speaking, if the outcome of the validity assessment 
  is <CODE>invalid</CODE>), then the transformation fails, but in all other 
  cases, the element and attribute nodes of the tree will be annotated with the 
  names of the types to which these nodes conform. These <A 
  title="type annotation" 
  href="REC-xslt20-20070123.htm#dt-annotation">type 
  annotations</A> will be discarded if the result tree is serialized as an XML 
  document, but they remain available when the result tree is passed to an 
  application (perhaps another <A title=stylesheet 
  href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A>) 
  for further processing.</P>
  <LI>
  <P>It is also possible to validate individual element and attribute nodes as 
  they are constructed. This is done using the <CODE>type</CODE> and 
  <CODE>validation</CODE> attributes of the <A 
  href="REC-xslt20-20070123.htm#element-element"><CODE>xsl:element</CODE></A>, 
  <A 
  href="REC-xslt20-20070123.htm#element-attribute"><CODE>xsl:attribute</CODE></A>, 
  <A 
  href="REC-xslt20-20070123.htm#element-copy"><CODE>xsl:copy</CODE></A>, 
  and <A 
  href="REC-xslt20-20070123.htm#element-copy-of"><CODE>xsl:copy-of</CODE></A> 
  instructions, or the <CODE>xsl:type</CODE> and <CODE>xsl:validation</CODE> 
  attributes of a literal result element.</P>
  <LI>
  <P>When elements, attributes, or document nodes are copied, either explicitly 
  using the <A 
  href="REC-xslt20-20070123.htm#element-copy"><CODE>xsl:copy</CODE></A> 
  or <A 
  href="REC-xslt20-20070123.htm#element-copy-of"><CODE>xsl:copy-of</CODE></A> 
  instructions, or implicitly when nodes in a sequence are attached to a new 
  parent node, the options <CODE>validation="strip"</CODE> and 
  <CODE>validation="preserve"</CODE> are available, to control whether existing 
  <A title="type annotation" 
  href="REC-xslt20-20070123.htm#dt-annotation">type 
  annotations</A> are to be retained or not.</P></LI></UL>
<P>When nodes in a <A title="temporary tree" 
href="REC-xslt20-20070123.htm#dt-temporary-tree">temporary 
tree</A> are validated, type information is available for use by operations 
carried out on the temporary tree, in the same way as for a source document that 
has undergone schema assessment.</P>
<P>For details of how validation of element and attribute nodes works, see <A 
href="REC-xslt20-20070123.htm#validation"><I>19.2 
Validation</I></A>.</P></DIV>
<DIV class=div2>
<H3><A id=errors name=errors></A>2.9 Error Handling</H3>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-static-error 
title="static error" name=dt-static-error></A>An error that is detected by 
examining a <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
before execution starts (that is, before the source document and values of 
stylesheet parameters are available) is referred to as a <B>static 
error</B>.<SPAN class=definition>]</SPAN></P>
<P>Errors classified in this specification as static errors <SPAN 
class=verb>must</SPAN> be signaled by all implementations: that is, the <A 
title=processor 
href="REC-xslt20-20070123.htm#dt-processor">processor</A> 
<SPAN class=verb>must</SPAN> indicate that the error is present. A static error 
<SPAN class=verb>must</SPAN> be signaled even if it occurs in a part of the <A 
title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
that is never evaluated. Static errors are never recoverable. After signaling a 
static error, a processor <SPAN class=verb>may</SPAN> continue for the purpose 
of signaling additional errors, but it <SPAN class=verb>must</SPAN> eventually 
terminate abnormally without producing any <SPAN><A title="final result tree" 
href="REC-xslt20-20070123.htm#dt-final-result-tree">final 
result tree</A></SPAN>.</P>
<P>There is an exception to this rule when the stylesheet specifies <A 
title="forwards-compatible behavior" 
href="REC-xslt20-20070123.htm#dt-forwards-compatible-behavior">forwards-compatible 
behavior</A> (see <A 
href="REC-xslt20-20070123.htm#forwards"><I>3.9 
Forwards-Compatible Processing</I></A>).</P>
<P>Generally, errors in the structure of the <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A>, 
or in the syntax of XPath <A title=expression 
href="REC-xslt20-20070123.htm#dt-expression">expressions</A> 
contained in the stylesheet, are classified as <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
errors</A>. Where this specification states that an element in the stylesheet 
<SPAN class=verb>must</SPAN> or <SPAN class=verb>must not</SPAN> appear in a 
certain position, or that it <SPAN class=verb>must</SPAN> or <SPAN 
class=verb>must not</SPAN> have a particular attribute, or that an attribute 
<SPAN class=verb>must</SPAN> or <SPAN class=verb>must not</SPAN> have a value 
satisfying specified conditions, then any contravention of this rule is a static 
error unless otherwise specified.</P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-dynamic-error 
title="dynamic error" name=dt-dynamic-error></A>An error that is not detected 
until a source document is being transformed is referred to as a <B>dynamic 
error</B>.<SPAN class=definition>]</SPAN></P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-recoverable-error 
title="recoverable error" name=dt-recoverable-error></A>Some dynamic errors are 
classed as <B>recoverable errors</B>. When a recoverable error occurs, this 
specification allows the processor either to signal the error (by reporting the 
error condition and terminating execution) or to take a defined recovery action 
and continue processing.<SPAN class=definition>]</SPAN> It is <A 
title=implementation-defined 
href="REC-xslt20-20070123.htm#dt-implementation-defined">implementation-defined</A> 
whether the error is signaled or the recovery action is taken.</P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A 
id=dt-optional-recovery-action title="optional recovery action" 
name=dt-optional-recovery-action></A>If an implementation chooses to recover 
from a <A title="recoverable error" 
href="REC-xslt20-20070123.htm#dt-recoverable-error">recoverable 
dynamic error</A>, it <SPAN class=verb>must</SPAN> take the <B>optional recovery 
action</B> defined for that error condition in this specification.<SPAN 
class=definition>]</SPAN></P>
<P>When the implementation makes the choice between signaling a dynamic error or 
recovering, it is not restricted in how it makes the choice; for example, it 
<SPAN class=verb>may</SPAN> provide options that can be set by the user. When an 
implementation chooses to recover from a dynamic error, it <SPAN><SPAN 
class=verb>may</SPAN></SPAN> also take other action, such as logging a warning 
message.</P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-nonrec-dynamic-error 
title="non-recoverable dynamic error" name=dt-nonrec-dynamic-error></A>A <A 
title="dynamic error" 
href="REC-xslt20-20070123.htm#dt-dynamic-error">dynamic 
error</A> that is not recoverable is referred to as a <B>non-recoverable dynamic 
error</B>. When a non-recoverable dynamic error occurs, the <A title=processor 
href="REC-xslt20-20070123.htm#dt-processor">processor</A> 
<SPAN class=verb>must</SPAN> signal the error, and the transformation 
fails.<SPAN class=definition>]</SPAN></P>
<P>Because different implementations may optimize execution of the <A 
title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
in different ways, the detection of dynamic errors is to some degree <A 
title=implementation-dependent 
href="REC-xslt20-20070123.htm#dt-implementation-dependent">implementation-dependent</A>. 
In cases where an implementation is able to produce the <A 
title="final result tree" 
href="REC-xslt20-20070123.htm#dt-final-result-tree">final 
result trees</A> without evaluating a particular construct, the implementation 
is never <SPAN class=verb>required</SPAN> to evaluate that construct solely in 
order to determine whether doing so causes a dynamic error. For example, if a <A 
title=variable 
href="REC-xslt20-20070123.htm#dt-variable">variable</A> 
is declared but never referenced, an implementation <SPAN class=verb>may</SPAN> 
choose whether or not to evaluate the variable declaration, which means that if 
evaluating the variable declaration causes a dynamic error, some implementations 
will signal this error and others will not.</P>
<P>There are some cases where this specification requires that a construct <SPAN 
class=verb>must not</SPAN> be evaluated: for example, the content of an <A 
href="REC-xslt20-20070123.htm#element-if"><CODE>xsl:if</CODE></A> 
instruction <SPAN class=verb>must not</SPAN> be evaluated if the test condition 
is false. This means that an implementation <SPAN class=verb>must not</SPAN> 
signal any dynamic errors that would arise if the construct were evaluated.</P>
<P>An implementation <SPAN class=verb>may</SPAN> signal a <A 
title="dynamic error" 
href="REC-xslt20-20070123.htm#dt-dynamic-error">dynamic 
error</A> before any source document is available, but only if it can determine 
that the error would be signaled for every possible source document and every 
possible set of parameter values. For example, some <A title="" 
href="REC-xslt20-20070123.htm#circularity">circularity</A> 
errors fall into this category: see <A 
href="REC-xslt20-20070123.htm#circularity"><I>9.8 
Circular Definitions</I></A>.</P>
<P>The XPath specification states (see <A 
href="http://www.w3.org/TR/xpath20/#id-kinds-of-errors">Section 2.3.1 Kinds of 
Errors</A><SUP><SMALL>XP</SMALL></SUP>) that if any expression (at any level) 
can be evaluated during the analysis phase (because all its explicit operands 
are known and it has no dependencies on the dynamic context), then any error in 
performing this evaluation <SPAN class=verb>may</SPAN> be reported as a static 
error. For XPath expressions used in an XSLT stylesheet, however, any such 
errors <SPAN class=verb>must not</SPAN> be reported as static errors in the 
stylesheet unless they would occur in every possible evaluation of that 
stylesheet; instead, they must be signaled as dynamic errors, and signaled only 
if the XPath expression is actually evaluated.</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e2144 name=d5e2144></A>Example: Errors in 
Constant Subexpressions </DIV>
<P>An XPath processor may report statically that the expression <CODE>1 div 
0</CODE> fails with a "divide by zero" error. But suppose this XPath expression 
occurs in an XSLT construct such as:</P>
<DIV class=exampleInner><PRE>&lt;xsl:choose&gt;
  &lt;xsl:when test="system-property('xsl:version') = '1.0'"&gt;
    &lt;xsl:value-of select="1 div 0"/&gt;
  &lt;/xsl:when&gt;
  &lt;xsl:otherwise&gt;
    &lt;xsl:value-of select="xs:double('INF')"/&gt;
  &lt;/xsl:otherwise&gt;
&lt;/xsl:choose&gt;
</PRE></DIV>
<P>Then the XSLT processor must not report an error, because the relevant XPath 
construct appears in a context where it will never be executed by an XSLT 2.0 
processor. (An XSLT 1.0 processor will execute this code successfully, returning 
positive infinity, because it uses double arithmetic rather than decimal 
arithmetic.)</P></DIV>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-type-error 
title="type errors" name=dt-type-error></A>Certain errors are classified as 
<B>type errors</B>. A type error occurs when the value supplied as input to an 
operation is of the wrong type for that operation, for example when an integer 
is supplied to an operation that expects a node.<SPAN class=definition>]</SPAN> 
If a type error occurs in an instruction that is actually evaluated, then it 
<SPAN class=verb>must</SPAN> be signaled <SPAN>in the same way as a <A 
title="non-recoverable dynamic error" 
href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
dynamic error</A>. Alternatively, an implementation <SPAN class=verb>may</SPAN> 
signal a type error during the analysis phase</SPAN> in the same way as a <A 
title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A>, even if it occurs in part of the stylesheet that is never evaluated, 
provided it can establish that execution of a particular construct would never 
succeed.</P>
<P>It is <A title=implementation-defined 
href="REC-xslt20-20070123.htm#dt-implementation-defined">implementation-defined</A> 
whether type errors are signaled statically.</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e2186 name=d5e2186></A>Example: A Type Error 
</DIV>
<P>The following construct contains a type error, because <CODE>42</CODE> is not 
allowed as an operand of the <A 
href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A> 
instruction. An implementation <SPAN class=verb>may</SPAN> optionally signal 
this as a static error, even though the offending instruction will never be 
evaluated, and the type error would therefore never be signaled as a dynamic 
error.</P>
<DIV class=exampleInner><PRE>&lt;xsl:if test="false()"&gt;
  &lt;xsl:apply-templates select="42"/&gt;
&lt;/xsl:if&gt;
</PRE></DIV>
<P>On the other hand, in the following example it is not possible to determine 
statically whether the operand of <A 
href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A> 
will have a suitable dynamic type. An implementation <SPAN class=verb>may</SPAN> 
produce a warning in such cases, but it <SPAN class=verb>must not</SPAN> treat 
it as an error.</P>
<DIV class=exampleInner><PRE>&lt;xsl:template match="para"&gt;
  &lt;xsl:param name="p" as="item()"/&gt;
  &lt;xsl:apply-templates select="$p"/&gt;
&lt;/xsl:template&gt;
</PRE></DIV></DIV>
<P>If more than one error arises, an implementation is not <SPAN 
class=verb>required</SPAN> to signal any errors other than the first one that it 
detects. It is <A title=implementation-dependent 
href="REC-xslt20-20070123.htm#dt-implementation-dependent">implementation-dependent</A> 
which of the several errors is signaled. This applies both to static errors and 
to dynamic errors. An implementation is allowed to signal more than one error, 
but if any errors have been signaled, it <SPAN class=verb>must not</SPAN> finish 
as if the transformation were successful.</P>
<P>When a transformation signals one or more dynamic errors, the final state of 
any persistent resources updated by the transformation is <A 
title=implementation-dependent 
href="REC-xslt20-20070123.htm#dt-implementation-dependent">implementation-dependent</A>. 
Implementations are not <SPAN class=verb>required</SPAN> to restore such 
resources to their initial state. In particular, where a transformation produces 
multiple result documents, it is possible that one or more serialized result 
documents <SPAN class=verb>may</SPAN> be written successfully before the 
transformation terminates, but the application cannot rely on this behavior.</P>
<P>Everything said above about error handling applies equally to errors in 
evaluating XSLT instructions, and errors in evaluating XPath <A title=expression 
href="REC-xslt20-20070123.htm#dt-expression">expressions</A>. 
Static errors and dynamic errors may occur in both cases.</P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-serialization-error 
title="serialization error" name=dt-serialization-error></A>If a transformation 
has successfully produced a <A title="final result tree" 
href="REC-xslt20-20070123.htm#dt-final-result-tree">final 
result tree</A>, it is still possible that errors may occur in serializing the 
result tree. For example, it may be impossible to serialize the result tree 
using the encoding selected by the user. Such an error is referred to as a 
<B>serialization error</B>.<SPAN class=definition>]</SPAN> <SPAN>If the 
processor performs serialization, then it <SPAN class=verb>must</SPAN> do so as 
specified in <A 
href="REC-xslt20-20070123.htm#serialization"><I>20 
Serialization</I></A>, and in particular it <SPAN class=verb>must</SPAN> signal 
any serialization errors that occur.</SPAN></P>
<P>Errors are identified by a QName. For errors defined in this specification, 
the namespace of the QName is always 
<CODE>http://www.w3.org/2005/xqt-errors</CODE> (and is therefore not given 
explicitly), while the local part is an 8-character code in the form 
<VAR>PPSSNNNN</VAR>. Here <VAR>PP</VAR> is always <CODE>XT</CODE> (meaning 
XSLT), and <VAR>SS</VAR> is one of <CODE>SE</CODE> (static error), 
<CODE>DE</CODE> (dynamic error), <CODE>RE</CODE> (recoverable dynamic error), or 
<CODE>TE</CODE> (type error). Note that the allocation of an error to one of 
these categories is purely for convenience and carries no normative implications 
about the way the error is handled. Many errors, for example, can be reported 
either dynamically or statically.</P>
<P>These error codes are used to label error conditions in this specification, 
and are summarized in <A 
href="REC-xslt20-20070123.htm#error-summary"><I>E Summary 
of Error Conditions</I></A>). They are provided primarily for ease of reference. 
Implementations <SPAN class=verb>may</SPAN> use these codes when signaling 
errors, but they are not <SPAN class=verb>required</SPAN> to do so. An API 
specification, however, <SPAN class=verb>may</SPAN> require the use of error 
codes based on these QNames. Additional errors defined by an implementation (or 
by an application) <SPAN class=verb>may</SPAN> use QNames in an 
implementation-defined (or user-defined) namespace without risk of 
collision.</P>
<P>Errors defined in the <A 
href="REC-xslt20-20070123.htm#xpath20">[XPath 2.0]</A> 
and <A 
href="REC-xslt20-20070123.htm#xpath-functions">[Functions 
and Operators]</A> specifications use QNames with a similar structure, in the 
same namespace. When errors occur in processing XPath expressions, an XSLT 
processor <SPAN class=verb>should</SPAN> use the original error code reported by 
the XPath processor, unless a more specific XSLT error code is 
available.</P></DIV></DIV>
<DIV class=div1>
<H2><A id=stylesheet-structure name=stylesheet-structure></A>3 Stylesheet 
Structure</H2>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-stylesheet-module 
title="stylesheet module" name=dt-stylesheet-module></A>A <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
consists of one or more <B>stylesheet modules</B>, each one forming all or part 
of an XML document.<SPAN class=definition>]</SPAN></P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>A stylesheet module is represented by an <SPAN>XDM element node</SPAN> (see 
<A href="REC-xslt20-20070123.htm#xpath-datamodel">[Data 
Model]</A>). <SPAN>In the case of a standard stylesheet module, this will be an 
<A 
href="REC-xslt20-20070123.htm#element-stylesheet"><CODE>xsl:stylesheet</CODE></A> 
or <A 
href="REC-xslt20-20070123.htm#element-transform"><CODE>xsl:transform</CODE></A> 
element. In the case of a simplified stylesheet module, it can be any element 
(not in the <A title="XSLT namespace" 
href="REC-xslt20-20070123.htm#dt-xslt-namespace">XSLT 
namespace</A>) that has an <CODE>xsl:version</CODE> attribute.</SPAN></P>
<P>Although stylesheet modules will commonly be maintained in the form of 
documents conforming to XML 1.0 or XML 1.1, this specification does not mandate 
such a representation. As with <A title="source tree" 
href="REC-xslt20-20070123.htm#dt-source-tree">source 
trees</A>, the way in which stylesheet modules are constructed, from textual XML 
or otherwise, is outside the scope of this specification.</P></DIV>
<P>A stylesheet module is either a standard stylesheet module or a simplified 
stylesheet module:</P>
<UL>
  <LI>
  <P><SPAN class=definition>[Definition:&nbsp;</SPAN><A 
  id=dt-standard-stylesheet-module title="standard stylesheet module" 
  name=dt-standard-stylesheet-module></A>A <B>standard stylesheet module</B> is 
  a tree, or part of a tree, consisting of an <A 
  href="REC-xslt20-20070123.htm#element-stylesheet"><CODE>xsl:stylesheet</CODE></A> 
  or <A 
  href="REC-xslt20-20070123.htm#element-transform"><CODE>xsl:transform</CODE></A> 
  element (see <A 
  href="REC-xslt20-20070123.htm#stylesheet-element"><I>3.6 
  Stylesheet Element</I></A>) together with its descendant nodes and associated 
  attributes and namespaces.<SPAN class=definition>]</SPAN></P>
  <LI>
  <P><SPAN class=definition>[Definition:&nbsp;</SPAN><A 
  id=dt-simplified-stylesheet-module title="simplified stylesheet module" 
  name=dt-simplified-stylesheet-module></A>A <B>simplified stylesheet module</B> 
  is a tree, or part of a tree, consisting of a <A 
  title="literal result element" 
  href="REC-xslt20-20070123.htm#dt-literal-result-element">literal 
  result element</A> together with its descendant nodes and associated 
  attributes and namespaces. This element is not itself in the XSLT namespace, 
  but it <SPAN class=verb>must</SPAN> have an <CODE>xsl:version</CODE> 
  attribute, which implies that it <SPAN class=verb>must</SPAN> have a namespace 
  node that declares a binding for the XSLT namespace. For further details see 
  <A 
  href="REC-xslt20-20070123.htm#simplified-stylesheet"><I>3.7 
  Simplified Stylesheet Modules</I></A>. <SPAN 
class=definition>]</SPAN></P></LI></UL>
<P>Both forms of stylesheet module (standard and simplified) can exist either as 
an entire XML document, or embedded as part of another XML document, typically 
<SPAN>but not necessarily</SPAN> a source document that is to be processed using 
the stylesheet.</P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A 
id=dt-standalone-stylesheet-module title="standalone stylesheet module" 
name=dt-standalone-stylesheet-module></A>A <B>standalone stylesheet module</B> 
is a stylesheet module that comprises the whole of an XML document.<SPAN 
class=definition>]</SPAN></P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A 
id=dt-embedded-stylesheet-module title="embedded stylesheet module" 
name=dt-embedded-stylesheet-module></A>An <B>embedded stylesheet module</B> is a 
stylesheet module that is embedded within another XML document, typically the 
source document that is being transformed.<SPAN class=definition>]</SPAN> (see 
<A href="REC-xslt20-20070123.htm#embedded"><I>3.11 
Embedded Stylesheet Modules</I></A>).</P>
<P>There are thus four kinds of stylesheet module:</P>
<BLOCKQUOTE>
  <P>standalone standard stylesheet modules<BR>standalone simplified stylesheet 
  modules<BR>embedded standard stylesheet modules<BR>embedded simplified 
  stylesheet modules</P></BLOCKQUOTE>
<DIV class=div2>
<H3><A id=xslt-namespace name=xslt-namespace></A>3.1 XSLT Namespace</H3>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-xslt-namespace 
title="XSLT namespace" name=dt-xslt-namespace></A>The <B>XSLT namespace</B> has 
the URI <CODE>http://www.w3.org/1999/XSL/Transform</CODE>. It is used to 
identify elements, attributes, and other names that have a special meaning 
defined in this specification.<SPAN class=definition>]</SPAN></P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>The <CODE>1999</CODE> in the URI indicates the year in which the URI was 
allocated by the W3C. It does not indicate the version of XSLT being used, which 
is specified by attributes (see <A 
href="REC-xslt20-20070123.htm#stylesheet-element"><I>3.6 
Stylesheet Element</I></A> and <A 
href="REC-xslt20-20070123.htm#simplified-stylesheet"><I>3.7 
Simplified Stylesheet Modules</I></A>).</P></DIV>
<P>XSLT <A title=processor 
href="REC-xslt20-20070123.htm#dt-processor">processors</A> 
<SPAN class=verb>must</SPAN> use the XML namespaces mechanism <A 
href="REC-xslt20-20070123.htm#REC-xml-names">[Namespaces 
in XML 1.0]</A> to recognize elements and attributes from this namespace. 
Elements from the XSLT namespace are recognized only in the <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
and not in the source document. The complete list of XSLT-defined elements is 
specified in <A 
href="REC-xslt20-20070123.htm#element-syntax-summary"><I>D 
Element Syntax Summary</I></A>. <A title=implementation 
href="REC-xslt20-20070123.htm#dt-implementation">Implementations</A> 
<SPAN class=verb>must not</SPAN> extend the XSLT namespace with additional 
elements or attributes. Instead, any extension <SPAN class=verb>must</SPAN> be 
in a separate namespace. Any namespace that is used for additional instruction 
elements <SPAN class=verb>must</SPAN> be identified by means of the <A 
title="extension instruction" 
href="REC-xslt20-20070123.htm#dt-extension-instruction">extension 
instruction</A> mechanism specified in <A 
href="REC-xslt20-20070123.htm#extension-instruction"><I>18.2 
Extension Instructions</I></A>.</P>
<P>This specification uses a prefix of <CODE>xsl:</CODE> for referring to 
elements in the XSLT namespace. However, XSLT stylesheets are free to use any 
prefix, provided that there is a namespace declaration that binds the prefix to 
the URI of the XSLT namespace.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>Throughout this specification, an element or attribute that is in no 
namespace, or an <A title=expanded-QName 
href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded-QName</A> 
whose namespace part is an empty sequence, is referred to as having a <B>null 
namespace URI</B>.</P></DIV>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>The conventions used for the names of <A title="XSLT element" 
href="REC-xslt20-20070123.htm#dt-xslt-element">XSLT 
elements</A>, attributes and functions are that names are all lower-case, use 
hyphens to separate words, and use abbreviations only if they already appear in 
the syntax of a related language such as XML or HTML. Names of types defined in 
XML Schema however, are regarded as single words and are capitalized exactly as 
in XML Schema. This sometimes leads to composite function names such as <A 
href="http://www.w3.org/TR/xpath-functions/#func-current-dateTime"><CODE>current-dateTime</CODE></A><SUP><SMALL>FO</SMALL></SUP>.</P></DIV></DIV>
<DIV class=div2>
<H3><A id=reserved-namespaces name=reserved-namespaces></A>3.2 Reserved 
Namespaces</H3>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-reserved-namespace 
title="reserved namespace" name=dt-reserved-namespace></A>The XSLT namespace, 
together with certain other namespaces recognized by an XSLT processor, are 
classified as <B>reserved namespaces</B> and <SPAN class=verb>must</SPAN> be 
used only as specified in this and related specifications.<SPAN 
class=definition>]</SPAN> The reserved namespaces are those listed below.</P>
<UL>
  <LI>
  <P>The <A title="XSLT namespace" 
  href="REC-xslt20-20070123.htm#dt-xslt-namespace">XSLT 
  namespace</A>, described in <A 
  href="REC-xslt20-20070123.htm#xslt-namespace"><I>3.1 
  XSLT Namespace</I></A>, is reserved.</P>
  <LI>
  <P><SPAN class=definition>[Definition:&nbsp;</SPAN><A 
  id=dt-standard-function-namespace title="standard function namespace" 
  name=dt-standard-function-namespace></A>The <B>standard function namespace</B> 
  <CODE>http://www.w3.org/2005/xpath-functions</CODE> is used for functions in 
  the function library defined in <A 
  href="REC-xslt20-20070123.htm#xpath-functions">[Functions 
  and Operators]</A> and standard functions defined in this specification.<SPAN 
  class=definition>]</SPAN></P>
  <LI>
  <P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=xml-namespace 
  title="XML namespace" name=xml-namespace></A>The <B>XML namespace</B>, 
  <SPAN>defined in <A 
  href="REC-xslt20-20070123.htm#REC-xml-names">[Namespaces 
  in XML 1.0]</A> as <CODE>http://www.w3.org/XML/1998/namespace</CODE></SPAN>, 
  is used for attributes such as <CODE>xml:lang</CODE>, <CODE>xml:space</CODE>, 
  and <CODE>xml:id</CODE>.<SPAN class=definition>]</SPAN></P>
  <LI>
  <P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-schema-namespace 
  title="schema namespace" name=dt-schema-namespace></A>The <B>schema 
  namespace</B> <CODE>http://www.w3.org/2001/XMLSchema</CODE> is used as defined 
  in <A href="REC-xslt20-20070123.htm#xmlschema-1">[XML 
  Schema Part 1]</A> <SPAN class=definition>]</SPAN>. In a <A title=stylesheet 
  href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
  this namespace may be used to refer to built-in schema datatypes and to the 
  constructor functions associated with those datatypes.</P>
  <LI>
  <P><SPAN class=definition>[Definition:&nbsp;</SPAN><A 
  id=dt-schema-instance-namespace title="schema instance namespace" 
  name=dt-schema-instance-namespace></A>The <B>schema instance namespace</B> 
  <CODE>http://www.w3.org/2001/XMLSchema-instance</CODE> is used as defined in 
  <A href="REC-xslt20-20070123.htm#xmlschema-1">[XML 
  Schema Part 1]</A> <SPAN class=definition>]</SPAN>. Attributes in this 
  namespace, if they appear in a <A title=stylesheet 
  href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A>, 
  are treated by the XSLT processor in the same way as any other 
  attributes.</P></LI></UL>
<P>Reserved namespaces may be used without restriction to refer to the names of 
elements and attributes in source documents and result documents. As far as the 
XSLT processor is concerned, reserved namespaces other than the XSLT namespace 
may be used without restriction in the names of <A 
title="literal result element" 
href="REC-xslt20-20070123.htm#dt-literal-result-element">literal 
result elements</A> and <A title="user-defined data element" 
href="REC-xslt20-20070123.htm#dt-data-element">user-defined 
data elements</A>, and in the names of attributes of literal result elements or 
of <A title="XSLT element" 
href="REC-xslt20-20070123.htm#dt-xslt-element">XSLT 
<SPAN>elements</SPAN></A>: but other processors <SPAN class=verb>may</SPAN> 
impose restrictions or attach special meaning to them. Reserved namespaces <SPAN 
class=verb>must not</SPAN> be used, however, in the names of stylesheet-defined 
objects such as <A title=variable 
href="REC-xslt20-20070123.htm#dt-variable">variables</A> 
and <A title="stylesheet function" 
href="REC-xslt20-20070123.htm#dt-stylesheet-function">stylesheet 
functions</A>.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>With the exception of the XML namespace, any of the above namespaces that are 
used in a stylesheet must be explicitly declared with a namespace declaration. 
Although conventional prefixes are used for these namespaces in this 
specification, any prefix may be used in a user stylesheet.</P></DIV>
<P><A id=err-XTSE0080 name=err-XTSE0080><SPAN class=error>[ERR 
XTSE0080]</SPAN></A> It is a <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A> to use a <A title="reserved namespace" 
href="REC-xslt20-20070123.htm#dt-reserved-namespace">reserved 
namespace</A> in the name of a <A title="named template" 
href="REC-xslt20-20070123.htm#dt-named-template">named 
template</A>, a <A title=mode 
href="REC-xslt20-20070123.htm#dt-mode">mode</A>, an <A 
title="attribute set" 
href="REC-xslt20-20070123.htm#dt-attribute-set">attribute 
set</A>, a <A title=key 
href="REC-xslt20-20070123.htm#dt-key">key</A>, a <A 
title="decimal format" 
href="REC-xslt20-20070123.htm#dt-decimal-format">decimal-format</A>, 
a <A title=variable 
href="REC-xslt20-20070123.htm#dt-variable">variable</A> 
or <A title=parameter 
href="REC-xslt20-20070123.htm#dt-parameter">parameter</A>, 
a <A title="stylesheet function" 
href="REC-xslt20-20070123.htm#dt-stylesheet-function">stylesheet 
function</A>, a named <A title="output definition" 
href="REC-xslt20-20070123.htm#dt-output-definition">output 
definition</A>, or a <A title="character map" 
href="REC-xslt20-20070123.htm#dt-character-map">character 
map</A>.</P></DIV>
<DIV class=div2>
<H3><A id=extension-attributes name=extension-attributes></A>3.3 Extension 
Attributes</H3>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-extension-attribute 
title="extension attribute" name=dt-extension-attribute></A>An element from the 
XSLT namespace may have any attribute not from the XSLT namespace, provided that 
the <A title=expanded-QName 
href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded-QName</A> 
(see <A href="REC-xslt20-20070123.htm#xpath20">[XPath 
2.0]</A>) of the attribute has a non-null namespace URI. These attributes are 
referred to as <B>extension attributes</B>.<SPAN class=definition>]</SPAN> The 
presence of an extension attribute <SPAN class=verb>must not</SPAN> cause the <A 
title="final result tree" 
href="REC-xslt20-20070123.htm#dt-final-result-tree">final 
result trees</A> produced by the transformation to be different from the result 
trees that a conformant XSLT 2.0 processor might produce. They <SPAN 
class=verb>must not</SPAN> cause the processor to fail to signal an error that a 
conformant processor is required to signal. This means that an extension 
attribute <SPAN class=verb>must not</SPAN> change the effect of any <A 
title=instruction 
href="REC-xslt20-20070123.htm#dt-instruction">instruction</A> 
except to the extent that the effect is <A title=implementation-defined 
href="REC-xslt20-20070123.htm#dt-implementation-defined">implementation-defined</A> 
or <A title=implementation-dependent 
href="REC-xslt20-20070123.htm#dt-implementation-dependent">implementation-dependent</A>.</P>
<P>Furthermore, if serialization is performed using one of the serialization 
methods <CODE>xml</CODE>, <CODE>xhtml</CODE>, <CODE>html</CODE>, or 
<CODE>text</CODE> described in <A 
href="REC-xslt20-20070123.htm#serialization"><I>20 
Serialization</I></A>, the presence of an extension attribute must not cause the 
serializer to behave in a way that is inconsistent with the mandatory provisions 
of that specification.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P><A title="extension attribute" 
href="REC-xslt20-20070123.htm#dt-extension-attribute">Extension 
attributes</A> may be used to modify the behavior of <A 
title="extension function" 
href="REC-xslt20-20070123.htm#dt-extension-function">extension 
functions</A> and <A title="extension instruction" 
href="REC-xslt20-20070123.htm#dt-extension-instruction">extension 
instructions</A>. They may be used to select processing options in cases where 
the specification leaves the behavior <A title=implementation-defined 
href="REC-xslt20-20070123.htm#dt-implementation-defined">implementation-defined</A> 
or <A title=implementation-dependent 
href="REC-xslt20-20070123.htm#dt-implementation-dependent">implementation-dependent</A>. 
They may also be used for optimization hints, for diagnostics, or for 
documentation.</P>
<P><A title="extension attribute" 
href="REC-xslt20-20070123.htm#dt-extension-attribute">Extension 
attributes</A> <SPAN class=verb>may</SPAN> also be used to influence the 
behavior of the serialization methods <CODE>xml</CODE>, <CODE>xhtml</CODE>, 
<CODE>html</CODE>, or <CODE>text</CODE>, to the extent that the behavior of the 
serialization method is <A title=implementation-defined 
href="REC-xslt20-20070123.htm#dt-implementation-defined">implementation-defined</A> 
or <A title=implementation-dependent 
href="REC-xslt20-20070123.htm#dt-implementation-dependent">implementation-dependent</A>. 
For example, an extension attribute might be used to define the amount of 
indentation to be used when <CODE>indent="yes"</CODE> is specified. If a 
serialization method other than one of these four is requested (using a prefixed 
QName in the method parameter) then extension attributes may influence its 
behavior in arbitrary ways. Extension attributes <SPAN class=verb>must 
not</SPAN> be used to cause the four standard serialization methods to behave in 
a non-conformant way, for example by failing to report serialization errors that 
a serializer is <SPAN class=verb>required</SPAN> to report. An implementation 
that wishes to provide such options must create a new serialization method for 
the purpose.</P>
<P>An implementation that does not recognize the name of an extension attribute, 
or that does not recognize its value, <SPAN class=verb>must</SPAN> perform the 
transformation as if the extension attribute were not present. As always, it is 
permissible to produce warning messages.</P>
<P>The namespace used for an extension attribute will be copied to the <A 
title="result tree" 
href="REC-xslt20-20070123.htm#dt-result-tree">result 
tree</A> in the normal way if it is in scope for a <A 
title="literal result element" 
href="REC-xslt20-20070123.htm#dt-literal-result-element">literal 
result element</A>. This can be prevented using the 
<CODE>[xsl:]exclude-result-prefixes</CODE> attribute.</P></DIV>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e2801 name=d5e2801></A>Example: An Extension 
Attribute for <CODE>xsl:message</CODE> </DIV>
<P>The following code might be used to indicate to a particular implementation 
that the <A 
href="REC-xslt20-20070123.htm#element-message"><CODE>xsl:message</CODE></A> 
instruction is to ask the user for confirmation before continuing with the 
transformation:</P>
<DIV class=exampleInner><PRE>&lt;xsl:message
    abc:pause="yes"
    xmlns:abc="http://vendor.example.com/xslt/extensions"&gt;Phase 1 complete&lt;/xsl:message&gt;
</PRE></DIV>
<P>Implementations that do not recognize the namespace 
<CODE>http://vendor.example.com/xslt/extensions</CODE> will simply ignore the 
extra attribute, and evaluate the <A 
href="REC-xslt20-20070123.htm#element-message"><CODE>xsl:message</CODE></A> 
instruction in the normal way.</P></DIV>
<P><A id=err-XTSE0090 name=err-XTSE0090><SPAN class=error>[ERR 
XTSE0090]</SPAN></A> It is a <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A> for an element from the XSLT namespace to have an attribute whose 
namespace is either null (that is, an attribute with an unprefixed name) or the 
XSLT namespace, other than attributes defined for the element in this 
document.</P></DIV>
<DIV class=div2>
<H3><A id=xslt-media-type name=xslt-media-type></A>3.4 XSLT Media Type</H3>
<P>The media type <CODE>application/xslt+xml</CODE> will be registered for XSLT 
stylesheet modules.</P>
<P>The proposed definition of the media type is at <A 
href="REC-xslt20-20070123.htm#xslt-mime-definition"><I>B 
The XSLT Media Type</I></A></P>
<P>This media type <SPAN class=verb>should</SPAN> be used for an XML document 
containing a <A title="standard stylesheet module" 
href="REC-xslt20-20070123.htm#dt-standard-stylesheet-module">standard 
stylesheet module</A> at its top level, and it <SPAN class=verb>may</SPAN> also 
be used for a <A title="simplified stylesheet module" 
href="REC-xslt20-20070123.htm#dt-simplified-stylesheet-module">simplified 
stylesheet module</A>. It <SPAN class=verb>should not</SPAN> be used for an XML 
document containing an <A title="embedded stylesheet module" 
href="REC-xslt20-20070123.htm#dt-embedded-stylesheet-module">embedded 
stylesheet module</A>.</P></DIV>
<DIV class=div2>
<H3><A id=standard-attributes name=standard-attributes></A>3.5 Standard 
Attributes</H3>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-standard-attributes 
title="standard attributes" name=dt-standard-attributes></A>There are a number 
of <B>standard attributes</B> that may appear on any <A title="XSLT element" 
href="REC-xslt20-20070123.htm#dt-xslt-element">XSLT 
element</A>: specifically <CODE>version</CODE>, 
<CODE>exclude-result-prefixes</CODE>, <CODE>extension-element-prefixes</CODE>, 
<CODE>xpath-default-namespace</CODE><SPAN>, <CODE>default-collation</CODE>, and 
<CODE>use-when</CODE>.</SPAN><SPAN class=definition>]</SPAN></P>
<P>These attributes may also appear on a <A title="literal result element" 
href="REC-xslt20-20070123.htm#dt-literal-result-element">literal 
result element</A>, but in this case, to distinguish them from user-defined 
attributes, the names of the attributes are in the <A title="XSLT namespace" 
href="REC-xslt20-20070123.htm#dt-xslt-namespace">XSLT 
namespace</A>. They are thus typically written as <CODE>xsl:version</CODE>, 
<CODE>xsl:exclude-result-prefixes</CODE>, 
<CODE>xsl:extension-element-prefixes</CODE>, 
<CODE>xsl:xpath-default-namespace</CODE><SPAN>, 
<CODE>xsl:default-collation</CODE>, or <CODE>xsl:use-when</CODE></SPAN>.</P>
<P>It is <SPAN class=verb>recommended</SPAN> that all these attributes should 
also be permitted on <A title="extension instruction" 
href="REC-xslt20-20070123.htm#dt-extension-instruction">extension 
instructions</A>, but this is at the discretion of the implementer of each 
extension instruction. They <SPAN class=verb>may</SPAN> also be permitted on <A 
title="user-defined data element" 
href="REC-xslt20-20070123.htm#dt-data-element">user-defined 
data elements</A>, though they will only have any useful effect in the case of 
data elements that are designed to behave like XSLT declarations or 
instructions.</P>
<P>In the following descriptions, these attributes are referred to generically 
as <CODE>[xsl:]version</CODE>, and so on.</P>
<P>These attributes all affect the element they appear on, <SPAN>together with 
any elements and attributes that have that element as an ancestor</SPAN>. The 
two forms with and without the XSLT namespace have the same effect; the XSLT 
namespace is used for the attribute if and only if its parent element is 
<EM>not</EM> in the XSLT namespace.</P>
<P>In the case of <CODE>[xsl:]version</CODE>, 
<CODE>[xsl:]xpath-default-namespace</CODE>, and 
<CODE>[xsl:]default-collation</CODE>, the value can be overridden by a different 
value for the same attribute appearing on a descendant element. The effective 
value of the attribute for a particular stylesheet element is determined by the 
innermost <SPAN>ancestor-or-self</SPAN> element on which the attribute 
appears.</P>
<P>In an <A title="embedded stylesheet module" 
href="REC-xslt20-20070123.htm#dt-embedded-stylesheet-module">embedded 
stylesheet module</A>, <A title="standard attributes" 
href="REC-xslt20-20070123.htm#dt-standard-attributes">standard 
attributes</A> appearing on ancestors of the outermost element of the stylesheet 
module have no effect.</P>
<P>In the case of <CODE>[xsl:]exclude-result-prefixes</CODE> and 
<CODE>[xsl:]extension-element-prefixes</CODE> the values are cumulative. For 
these attributes, the value is given as a whitespace-separated list of namespace 
prefixes, and the effective value for an element is the combined set of 
namespace URIs designated by the prefixes that appear in this attribute for that 
element and any of its ancestor elements. Again, the two forms with and without 
the XSLT namespace are equivalent.</P>
<P>The effect of the <CODE>[xsl:]use-when</CODE> attribute is described in <A 
href="REC-xslt20-20070123.htm#conditional-inclusion"><I>3.12 
Conditional Element Inclusion</I></A>.</P>
<P>Because these attributes may appear on any <A title="XSLT element" 
href="REC-xslt20-20070123.htm#dt-xslt-element">XSLT 
element</A>, they are not listed in the syntax summary of each individual 
element. Instead they are listed and described in the entry for the <A 
href="REC-xslt20-20070123.htm#element-stylesheet"><CODE>xsl:stylesheet</CODE></A> 
and <A 
href="REC-xslt20-20070123.htm#element-transform"><CODE>xsl:transform</CODE></A> 
elements only. This reflects the fact that these attributes are often used on 
the <A 
href="REC-xslt20-20070123.htm#element-stylesheet"><CODE>xsl:stylesheet</CODE></A> 
element only, in which case they apply to the entire <A 
title="stylesheet module" 
href="REC-xslt20-20070123.htm#dt-stylesheet-module">stylesheet 
module</A>.</P>
<P>Note that the effect of these attributes does <EM>not</EM> extend to <A 
title="stylesheet module" 
href="REC-xslt20-20070123.htm#dt-stylesheet-module">stylesheet 
modules</A> referenced by <A 
href="REC-xslt20-20070123.htm#element-include"><CODE>xsl:include</CODE></A> 
or <A 
href="REC-xslt20-20070123.htm#element-import"><CODE>xsl:import</CODE></A> 
declarations.</P>
<P>For the detailed effect of each attribute, see the following sections:</P>
<DL>
  <DT class=label><CODE>[xsl:]version</CODE> 
  <DD>
  <P>see <A 
  href="REC-xslt20-20070123.htm#backwards"><I>3.8 
  Backwards-Compatible Processing</I></A> and <A 
  href="REC-xslt20-20070123.htm#forwards"><I>3.9 
  Forwards-Compatible Processing</I></A></P>
  <DT class=label><CODE>[xsl:]xpath-default-namespace</CODE> 
  <DD>
  <P>see <A 
  href="REC-xslt20-20070123.htm#unprefixed-qnames"><I>5.2 
  Unprefixed QNames in Expressions and Patterns</I></A></P>
  <DT class=label><CODE>[xsl:]exclude-result-prefixes</CODE> 
  <DD>
  <P>see <A 
  href="REC-xslt20-20070123.htm#lre-namespaces"><I>11.1.3 
  Namespace Nodes for Literal Result Elements</I></A></P>
  <DT class=label><CODE>[xsl:]extension-element-prefixes</CODE> 
  <DD>
  <P>see <A 
  href="REC-xslt20-20070123.htm#extension-instruction"><I>18.2 
  Extension Instructions</I></A></P>
  <DT class=label><CODE>[xsl:]use-when</CODE> 
  <DD>
  <P>see <A 
  href="REC-xslt20-20070123.htm#conditional-inclusion"><I>3.12 
  Conditional Element Inclusion</I></A></P>
  <DT class=label><CODE>[xsl:]default-collation</CODE> 
  <DD>
  <P>see <A 
  href="REC-xslt20-20070123.htm#default-collation-attribute"><I>3.6.1 
  The default-collation attribute</I></A></P></DD></DL></DIV>
<DIV class=div2>
<H3><A id=stylesheet-element name=stylesheet-element></A>3.6 Stylesheet 
Element</H3>
<P class=element-syntax><A id=element-stylesheet 
name=element-stylesheet></A><CODE>&lt;xsl:stylesheet<BR>&nbsp;&nbsp;id? = 
<VAR>id</VAR><BR>&nbsp;&nbsp;extension-element-prefixes? = 
<VAR>tokens</VAR><BR>&nbsp;&nbsp;exclude-result-prefixes? = 
<VAR>tokens</VAR><BR>&nbsp;&nbsp;<B>version</B> = 
<VAR>number</VAR><BR>&nbsp;&nbsp;xpath-default-namespace? = 
<VAR>uri</VAR><BR>&nbsp;&nbsp;default-validation? = "preserve" | 
"strip"<BR>&nbsp;&nbsp;default-collation? = 
<VAR>uri-list</VAR><BR>&nbsp;&nbsp;input-type-annotations? = "preserve" | 
"strip" | "unspecified"&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: (<A 
href="REC-xslt20-20070123.htm#element-import">xsl:import</A>*, 
<VAR>other-declarations</VAR>) --&gt;<BR>&lt;/xsl:stylesheet&gt;</CODE></P>
<P class=element-syntax><A id=element-transform 
name=element-transform></A><CODE>&lt;xsl:transform<BR>&nbsp;&nbsp;id? = 
<VAR>id</VAR><BR>&nbsp;&nbsp;extension-element-prefixes? = 
<VAR>tokens</VAR><BR>&nbsp;&nbsp;exclude-result-prefixes? = 
<VAR>tokens</VAR><BR>&nbsp;&nbsp;<B>version</B> = 
<VAR>number</VAR><BR>&nbsp;&nbsp;xpath-default-namespace? = 
<VAR>uri</VAR><BR>&nbsp;&nbsp;default-validation? = "preserve" | 
"strip"<BR>&nbsp;&nbsp;default-collation? = 
<VAR>uri-list</VAR><BR>&nbsp;&nbsp;input-type-annotations? = "preserve" | 
"strip" | "unspecified"&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: (<A 
href="REC-xslt20-20070123.htm#element-import">xsl:import</A>*, 
<VAR>other-declarations</VAR>) --&gt;<BR>&lt;/xsl:transform&gt;</CODE></P>
<P>A stylesheet module is represented by an <A 
href="REC-xslt20-20070123.htm#element-stylesheet"><CODE>xsl:stylesheet</CODE></A> 
element in an XML document. <A 
href="REC-xslt20-20070123.htm#element-transform"><CODE>xsl:transform</CODE></A> 
is allowed as a synonym for <A 
href="REC-xslt20-20070123.htm#element-stylesheet"><CODE>xsl:stylesheet</CODE></A>; 
everything this specification says about the <A 
href="REC-xslt20-20070123.htm#element-stylesheet"><CODE>xsl:stylesheet</CODE></A> 
element applies equally to <A 
href="REC-xslt20-20070123.htm#element-transform"><CODE>xsl:transform</CODE></A>.</P>
<P>An <A 
href="REC-xslt20-20070123.htm#element-stylesheet"><CODE>xsl:stylesheet</CODE></A> 
element <SPAN class=verb>must</SPAN> have a <CODE>version</CODE> attribute, 
indicating the version of XSLT that the stylesheet <SPAN>module</SPAN> 
requires.</P>
<P><A id=err-XTSE0110 name=err-XTSE0110><SPAN class=error>[ERR 
XTSE0110]</SPAN></A> The value of the <CODE>version</CODE> attribute <SPAN 
class=verb>must</SPAN> be a number: specifically, it <SPAN 
class=verb>must</SPAN> be a <SPAN>a valid instance of the type 
<CODE>xs:decimal</CODE> as defined in <A 
href="REC-xslt20-20070123.htm#xmlschema-2">[XML Schema 
Part 2]</A></SPAN>. For this version of XSLT, the value <SPAN 
class=verb>should</SPAN> normally be <CODE>2.0</CODE>. A value of 
<CODE>1.0</CODE> indicates that the stylesheet module was written with the 
intention that it <SPAN class=verb>should</SPAN> be processed using an XSLT 1.0 
processor.</P>
<P>If a <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
that specifies <CODE>[xsl:]version="1.0"</CODE> in the outermost element of the 
<A title="principal stylesheet module" 
href="REC-xslt20-20070123.htm#dt-principal-stylesheet-module">principal 
stylesheet module</A> (that is, <CODE>version="1.0"</CODE> in the case of a <A 
title="standard stylesheet module" 
href="REC-xslt20-20070123.htm#dt-standard-stylesheet-module">standard 
stylesheet module</A>, or <CODE>xsl:version="1.0"</CODE> in the case of a <A 
title="simplified stylesheet module" 
href="REC-xslt20-20070123.htm#dt-simplified-stylesheet-module">simplified 
stylesheet module</A>) is submitted to an XSLT 2.0 processor, the processor 
<SPAN class=verb>should</SPAN> output a warning advising the user of possible 
incompatibilities, unless the user has requested otherwise. The processor <SPAN 
class=verb>must</SPAN> then process the stylesheet using the rules for <A 
title="backwards compatible behavior" 
href="REC-xslt20-20070123.htm#dt-backwards-compatible-behavior">backwards-compatible 
behavior</A>. These rules require that if the processor does not support <A 
title="backwards compatible behavior" 
href="REC-xslt20-20070123.htm#dt-backwards-compatible-behavior">backwards-compatible 
behavior</A>, it <SPAN class=verb>must</SPAN> signal an error and <SPAN 
class=verb>must not</SPAN> execute the transformation.</P>
<P>When the value of the <CODE>version</CODE> attribute is greater than 2.0, <A 
title="forwards-compatible behavior" 
href="REC-xslt20-20070123.htm#dt-forwards-compatible-behavior">forwards-compatible 
behavior</A> is enabled (see <A 
href="REC-xslt20-20070123.htm#forwards"><I>3.9 
Forwards-Compatible Processing</I></A>).</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>XSLT 1.0 allowed the <CODE>[xsl:]version</CODE> attribute to take any numeric 
value, and specified that if the value was not equal to 1.0, the <A 
title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
would be executed in forwards compatible mode. XSLT 2.0 continues to allow the 
attribute to take any unsigned decimal value. A software product that includes 
both an XSLT 1.0 processor and an XSLT 2.0 processor (or that can execute as 
either) may use the <CODE>[xsl:]version</CODE> attribute to decide which 
processor to invoke; such behavior is outside the scope of this specification. 
When the stylesheet is executed with an XSLT 2.0 processor, the value 
<CODE>1.0</CODE> is taken to indicate that the stylesheet <SPAN>module</SPAN> 
was written with XSLT 1.0 in mind: if this value appears on the outermost 
element of the principal stylesheet module then an XSLT 2.0 processor will 
either reject the stylesheet or execute it in backwards compatible mode, as 
described above. Setting <CODE>version="2.0"</CODE> indicates that the <A 
title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
is to be executed with neither backwards nor forwards compatible behavior 
enabled. Any other value less than <CODE>2.0</CODE> enables backwards compatible 
behavior, while any value greater than <CODE>2.0</CODE> enables forwards 
compatible behavior.</P>
<P>When developing a <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
that is designed to execute under either XSLT 1.0 or XSLT 2.0, the recommended 
practice is to create two alternative <A title="stylesheet module" 
href="REC-xslt20-20070123.htm#dt-stylesheet-module">stylesheet 
modules</A>, one specifying <CODE>version="1.0"</CODE>, and the other specifying 
<CODE>version="2.0"</CODE>; these modules can use <A 
href="REC-xslt20-20070123.htm#element-include"><CODE>xsl:include</CODE></A> 
or <A 
href="REC-xslt20-20070123.htm#element-import"><CODE>xsl:import</CODE></A> 
to incorporate the common code. When running under an XSLT 1.0 processor, the 
<CODE>version="1.0"</CODE> module can be selected as the <A 
title="principal stylesheet module" 
href="REC-xslt20-20070123.htm#dt-principal-stylesheet-module">principal 
stylesheet module</A>; when running under an XSLT 2.0 processor, the 
<CODE>version="2.0"</CODE> module can be selected as the <A 
title="principal stylesheet module" 
href="REC-xslt20-20070123.htm#dt-principal-stylesheet-module">principal 
stylesheet module</A>. Stylesheet modules that are included or imported should 
specify <CODE>version="2.0"</CODE> if they make use of XSLT 2.0 facilities, and 
<CODE>version="1.0"</CODE> otherwise.</P></DIV>
<P>The effect of the <CODE>input-type-annotations</CODE> attribute is described 
in <A 
href="REC-xslt20-20070123.htm#stripping-annotations"><I>4.3 
Stripping Type Annotations from a Source Tree</I></A>.</P>
<P>The <CODE>default-validation</CODE> attribute defines the default value of 
the <CODE>validation</CODE> attribute of all <SPAN><A 
href="REC-xslt20-20070123.htm#element-document"><CODE>xsl:document</CODE></A></SPAN>, 
<A 
href="REC-xslt20-20070123.htm#element-element"><CODE>xsl:element</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-attribute"><CODE>xsl:attribute</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-copy"><CODE>xsl:copy</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-copy-of"><CODE>xsl:copy-of</CODE></A>, 
and <A 
href="REC-xslt20-20070123.htm#element-result-document"><CODE>xsl:result-document</CODE></A> 
instructions, and of the <CODE>xsl:validation</CODE> attribute of all <A 
title="literal result element" 
href="REC-xslt20-20070123.htm#dt-literal-result-element">literal 
result elements</A>. It also determines the validation applied to the implicit 
<A title="final result tree" 
href="REC-xslt20-20070123.htm#dt-final-result-tree">final 
result tree</A> created in the absence of an <A 
href="REC-xslt20-20070123.htm#element-result-document"><CODE>xsl:result-document</CODE></A> 
instruction. This default applies within the <A title="stylesheet module" 
href="REC-xslt20-20070123.htm#dt-stylesheet-module">stylesheet 
module</A>: it does not extend to included or imported stylesheet modules. If 
the attribute is omitted, the default is <CODE>strip</CODE>. <SPAN>The permitted 
values are <CODE>preserve</CODE> and <CODE>strip</CODE>.</SPAN> For details of 
the effect of this attribute, see <A 
href="REC-xslt20-20070123.htm#validation"><I>19.2 
Validation</I></A>.</P>
<P><A id=err-XTSE0120 name=err-XTSE0120><SPAN class=error>[ERR 
XTSE0120]</SPAN></A> An <A 
href="REC-xslt20-20070123.htm#element-stylesheet"><CODE>xsl:stylesheet</CODE></A> 
element <SPAN class=verb>must not</SPAN> have any text node children. (This rule 
applies after stripping of <A title="whitespace text node" 
href="REC-xslt20-20070123.htm#dt-whitespace-text-node">whitespace 
text nodes</A> as described in <A 
href="REC-xslt20-20070123.htm#stylesheet-stripping"><I>4.2 
Stripping Whitespace from the Stylesheet</I></A>.)</P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-top-level 
title=top-level name=dt-top-level></A>An element occurring as a child of an <A 
href="REC-xslt20-20070123.htm#element-stylesheet"><CODE>xsl:stylesheet</CODE></A> 
element is called a <B>top-level</B> element.<SPAN class=definition>]</SPAN></P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-declaration 
title=declaration name=dt-declaration></A>Top-level elements fall into two 
categories: declarations, and user-defined data elements. Top-level elements 
whose names are in the <A title="XSLT namespace" 
href="REC-xslt20-20070123.htm#dt-xslt-namespace">XSLT 
namespace</A> are <B>declarations</B>. Top-level elements in any other namespace 
are <A title="user-defined data element" 
href="REC-xslt20-20070123.htm#dt-data-element">user-defined 
data elements</A> (see <A 
href="REC-xslt20-20070123.htm#user-defined-top-level"><I>3.6.2 
User-defined Data Elements</I></A>)<SPAN class=definition>]</SPAN>.</P>
<P>The <A title=declaration 
href="REC-xslt20-20070123.htm#dt-declaration">declaration</A> 
elements permitted in the <A 
href="REC-xslt20-20070123.htm#element-stylesheet"><CODE>xsl:stylesheet</CODE></A> 
element are:</P>
<BLOCKQUOTE>
  <P><A 
  href="REC-xslt20-20070123.htm#element-import"><CODE>xsl:import</CODE></A><BR><A 
  href="REC-xslt20-20070123.htm#element-include"><CODE>xsl:include</CODE></A><BR><A 
  href="REC-xslt20-20070123.htm#element-attribute-set"><CODE>xsl:attribute-set</CODE></A><BR><A 
  href="REC-xslt20-20070123.htm#element-character-map"><CODE>xsl:character-map</CODE></A><BR><A 
  href="REC-xslt20-20070123.htm#element-decimal-format"><CODE>xsl:decimal-format</CODE></A><BR><A 
  href="REC-xslt20-20070123.htm#element-function"><CODE>xsl:function</CODE></A><BR><A 
  href="REC-xslt20-20070123.htm#element-import-schema"><CODE>xsl:import-schema</CODE></A><BR><A 
  href="REC-xslt20-20070123.htm#element-key"><CODE>xsl:key</CODE></A><BR><A 
  href="REC-xslt20-20070123.htm#element-namespace-alias"><CODE>xsl:namespace-alias</CODE></A><BR><A 
  href="REC-xslt20-20070123.htm#element-output"><CODE>xsl:output</CODE></A><BR><A 
  href="REC-xslt20-20070123.htm#element-param"><CODE>xsl:param</CODE></A><BR><A 
  href="REC-xslt20-20070123.htm#element-preserve-space"><CODE>xsl:preserve-space</CODE></A><BR><A 
  href="REC-xslt20-20070123.htm#element-strip-space"><CODE>xsl:strip-space</CODE></A><BR><A 
  href="REC-xslt20-20070123.htm#element-template"><CODE>xsl:template</CODE></A><BR><A 
  href="REC-xslt20-20070123.htm#element-variable"><CODE>xsl:variable</CODE></A></P></BLOCKQUOTE>
<P>Note that the <A 
href="REC-xslt20-20070123.htm#element-variable"><CODE>xsl:variable</CODE></A> 
and <A 
href="REC-xslt20-20070123.htm#element-param"><CODE>xsl:param</CODE></A> 
elements can act either as <A title=declaration 
href="REC-xslt20-20070123.htm#dt-declaration">declarations</A> 
or as <A title=instruction 
href="REC-xslt20-20070123.htm#dt-instruction">instructions</A>. 
A global variable or parameter is defined using a declaration; a local variable 
or parameter using an instruction.</P>
<P>If there are <A 
href="REC-xslt20-20070123.htm#element-import"><CODE>xsl:import</CODE></A> 
elements, these <SPAN class=verb>must</SPAN> come before any other elements. 
Apart from this, the child elements of the <A 
href="REC-xslt20-20070123.htm#element-stylesheet"><CODE>xsl:stylesheet</CODE></A> 
element may appear in any order. The ordering of these elements does not affect 
the results of the transformation unless there are conflicting declarations (for 
example, two template rules with the same priority that match the same node). In 
general, it is an error for a <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
to contain such conflicting declarations, but in some cases the processor is 
allowed to recover from the error by choosing the declaration that appears last 
in the stylesheet.</P>
<DIV class=div3>
<H4><A id=default-collation-attribute name=default-collation-attribute></A>3.6.1 
The <CODE>default-collation</CODE> attribute</H4>
<P>The <CODE>default-collation</CODE> attribute is a <A 
title="standard attributes" 
href="REC-xslt20-20070123.htm#dt-standard-attributes">standard 
attribute</A> that may appear on any element in the XSLT namespace, or (as 
<CODE>xsl:default-collation</CODE>) on a <A title="literal result element" 
href="REC-xslt20-20070123.htm#dt-literal-result-element">literal 
result element</A>.</P>
<P>The attribute is used to specify the default collation used by all XPath 
expressions appearing in the attributes of this element, or attributes of 
descendant elements, unless overridden by another <CODE>default-collation</CODE> 
attribute on an inner element. It also determines the collation used by certain 
XSLT constructs (such as <A 
href="REC-xslt20-20070123.htm#element-key"><CODE>xsl:key</CODE></A> 
and <A 
href="REC-xslt20-20070123.htm#element-for-each-group"><CODE>xsl:for-each-group</CODE></A>) 
within its scope.</P>
<P>The value of the attribute is a whitespace-separated list of collation URIs. 
<SPAN>If any of these URIs is a relative URI, then it is resolved relative to 
the base URI of the attribute's parent element. If the implementation recognizes 
one or more of the resulting absolute collation URIs</SPAN>, then it uses the 
first one that it recognizes as the default collation.</P>
<P><A id=err-XTSE0125 name=err-XTSE0125><SPAN class=error>[ERR 
XTSE0125]</SPAN></A> It is a <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A> if the value of an <CODE>[xsl:]default-collation</CODE> 
attribute<SPAN>, after resolving against the base URI,</SPAN> contains no URI 
that the implementation recognizes as a collation URI.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>The reason the attribute allows a list of collation URIs is that collation 
URIs will often be meaningful only to one particular XSLT implementation. 
Stylesheets designed to run with several different implementations can therefore 
specify several different collation URIs, one for use with each. To avoid the 
above error condition, it is possible to specify the Unicode Codepoint Collation 
as the last collation URI in the list.</P></DIV>
<P>The <CODE>[xsl:]default-collation</CODE> attribute does not affect the 
collation used by <CODE>xsl:sort</CODE>.</P></DIV>
<DIV class=div3>
<H4><A id=user-defined-top-level name=user-defined-top-level></A>3.6.2 
User-defined Data Elements</H4>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-data-element 
title="user-defined data element" name=dt-data-element></A>In addition to <A 
title=declaration 
href="REC-xslt20-20070123.htm#dt-declaration">declarations</A>, 
the <A 
href="REC-xslt20-20070123.htm#element-stylesheet"><CODE>xsl:stylesheet</CODE></A> 
element may contain any element not from the <A title="XSLT namespace" 
href="REC-xslt20-20070123.htm#dt-xslt-namespace">XSLT 
namespace</A>, provided that the <A title=expanded-QName 
href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded-QName</A> 
of the element has a non-null namespace URI. Such elements are referred to as 
<B>user-defined data elements</B>.<SPAN class=definition>]</SPAN></P>
<P><A id=err-XTSE0130 name=err-XTSE0130><SPAN class=error>[ERR 
XTSE0130]</SPAN></A> It is a <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A> if the <A 
href="REC-xslt20-20070123.htm#element-stylesheet"><CODE>xsl:stylesheet</CODE></A> 
element has a child element whose name has a null namespace URI.</P>
<P>An implementation <SPAN class=verb>may</SPAN> attach <SPAN>an <A 
title=implementation-defined 
href="REC-xslt20-20070123.htm#dt-implementation-defined">implementation-defined</A></SPAN> 
meaning to user-defined data elements that appear in <SPAN>particular 
namespaces</SPAN>. The set of namespaces that are recognized for such data 
elements is <A title=implementation-defined 
href="REC-xslt20-20070123.htm#dt-implementation-defined">implementation-defined</A>. 
The presence of a user-defined data element <SPAN class=verb>must not</SPAN> 
change the behavior of <A title="XSLT element" 
href="REC-xslt20-20070123.htm#dt-xslt-element">XSLT 
elements</A> and functions defined in this document; for example, it is not 
permitted for a user-defined data element to specify that <A 
href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A> 
should use different rules to resolve conflicts. <SPAN>The constraints on what 
user-defined data elements can and cannot do are exactly the same as the 
constraints on <A title="extension attribute" 
href="REC-xslt20-20070123.htm#dt-extension-attribute">extension 
attributes</A>, described in <A 
href="REC-xslt20-20070123.htm#extension-attributes"><I>3.3 
Extension Attributes</I></A>.</SPAN> Thus, an implementation is always free to 
ignore user-defined data elements, and <SPAN class=verb>must</SPAN> ignore such 
data elements without giving an error if it does not recognize the namespace 
URI.</P>
<P>User-defined data elements can provide, for example,</P>
<UL>
  <LI>
  <P>information used by <A title="extension instruction" 
  href="REC-xslt20-20070123.htm#dt-extension-instruction">extension 
  instructions</A> or <A title="extension function" 
  href="REC-xslt20-20070123.htm#dt-extension-function">extension 
  functions</A> (see <A 
  href="REC-xslt20-20070123.htm#extension"><I>18 
  Extensibility and Fallback</I></A>),</P>
  <LI>
  <P>information about what to do with any <A title="final result tree" 
  href="REC-xslt20-20070123.htm#dt-final-result-tree">final 
  result tree</A>,</P>
  <LI>
  <P>information about how to construct <A title="source tree" 
  href="REC-xslt20-20070123.htm#dt-source-tree">source 
  trees</A>,</P>
  <LI>
  <P>optimization hints for the <A title=processor 
  href="REC-xslt20-20070123.htm#dt-processor">processor</A>,</P>
  <LI>
  <P>metadata about the stylesheet,</P>
  <LI>
  <P>structured documentation for the stylesheet.</P></LI></UL>
<P>A <A title="user-defined data element" 
href="REC-xslt20-20070123.htm#dt-data-element">user-defined 
data element</A> <SPAN class=verb>must not</SPAN> precede an <A 
href="REC-xslt20-20070123.htm#element-import"><CODE>xsl:import</CODE></A> 
element within a <A title="stylesheet module" 
href="REC-xslt20-20070123.htm#dt-stylesheet-module">stylesheet 
module</A> <SPAN><SPAN class=error>[see <A 
href="REC-xslt20-20070123.htm#err-XTSE0200">ERR 
XTSE0200</A>]</SPAN></SPAN></P></DIV></DIV>
<DIV class=div2>
<H3><A id=simplified-stylesheet name=simplified-stylesheet></A>3.7 Simplified 
Stylesheet Modules</H3>
<P>A simplified syntax is allowed for a <A title="stylesheet module" 
href="REC-xslt20-20070123.htm#dt-stylesheet-module">stylesheet 
module</A> that defines only a single template rule for the document node. The 
stylesheet module may consist of just a <A title="literal result element" 
href="REC-xslt20-20070123.htm#dt-literal-result-element">literal 
result element</A> (see <A 
href="REC-xslt20-20070123.htm#literal-result-element"><I>11.1 
Literal Result Elements</I></A>) together with its contents. <SPAN>The literal 
result element must have an <CODE>xsl:version</CODE> attribute (and it must 
therefore also declare the XSLT namespace).</SPAN> Such a stylesheet 
<SPAN>module</SPAN> is equivalent to a standard stylesheet module whose <A 
href="REC-xslt20-20070123.htm#element-stylesheet"><CODE>xsl:stylesheet</CODE></A> 
element contains a <A title="template rule" 
href="REC-xslt20-20070123.htm#dt-template-rule">template 
rule</A> containing the literal result element, <SPAN>minus its 
<CODE>xsl:version</CODE> attribute</SPAN>; the template rule has a match <A 
title=pattern 
href="REC-xslt20-20070123.htm#dt-pattern">pattern</A> of 
<CODE>/</CODE>.</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e3741 name=d5e3741></A>Example: A Simplified 
Stylesheet </DIV>
<P>For example:</P>
<DIV class=exampleInner><PRE>&lt;html xsl:version="2.0"
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
      xmlns="http://www.w3.org/1999/xhtml"&gt;
  &lt;head&gt;
    &lt;title&gt;Expense Report Summary&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;Total Amount: &lt;xsl:value-of select="expense-report/total"/&gt;&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</PRE></DIV>
<P>has the same meaning as</P>
<DIV class=exampleInner><PRE>&lt;xsl:stylesheet version="2.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns="http://www.w3.org/1999/xhtml"&gt;
&lt;xsl:template match="/"&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Expense Report Summary&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;Total Amount: &lt;xsl:value-of select="expense-report/total"/&gt;&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
&lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
</PRE></DIV>
<P>Note that it is not possible, using a simplified stylesheet, to request that 
the serialized output contains a <CODE>DOCTYPE</CODE> declaration. This can only 
be done by using a standard stylesheet module, and using the <A 
href="REC-xslt20-20070123.htm#element-output"><CODE>xsl:output</CODE></A> 
element.</P></DIV>
<P>More formally, a simplified stylesheet module is equivalent to the standard 
stylesheet module that would be generated by applying the following 
transformation to the simplified stylesheet module, invoking the transformation 
by calling the <A title="named template" 
href="REC-xslt20-20070123.htm#dt-named-template">named 
template</A> <CODE>expand</CODE>, with the containing literal result element as 
the <A title="context node" 
href="REC-xslt20-20070123.htm#dt-context-node">context 
node</A>:</P>
<DIV class=exampleInner><PRE>&lt;xsl:stylesheet version="2.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:template name="expand"&gt;
  &lt;xsl:element name="xsl:stylesheet"&gt;
    &lt;xsl:attribute name="version" select="@xsl:version"/&gt;
    &lt;xsl:element name="xsl:template"&gt;
      &lt;xsl:attribute name="match"&gt;/&lt;/xsl:attribute&gt;
      &lt;xsl:copy-of select="."/&gt;
    &lt;/xsl:element&gt;
  &lt;/xsl:element&gt;
&lt;/xsl:template&gt;  

&lt;/xsl:stylesheet&gt;
</PRE></DIV>
<P><A id=err-XTSE0150 name=err-XTSE0150><SPAN class=error>[ERR 
XTSE0150]</SPAN></A> A <A title="literal result element" 
href="REC-xslt20-20070123.htm#dt-literal-result-element">literal 
result element</A> that is used as the outermost element of a simplified 
stylesheet module <SPAN class=verb>must</SPAN> have an <CODE>xsl:version</CODE> 
attribute. This indicates the version of XSLT that the stylesheet requires. For 
this version of XSLT, the value will normally be <CODE>2.0</CODE>; the value 
<SPAN class=verb>must</SPAN> be a <SPAN>valid instance of the type 
<CODE>xs:decimal</CODE> as defined in <A 
href="REC-xslt20-20070123.htm#xmlschema-2">[XML Schema 
Part 2]</A></SPAN>.</P>
<P>Other <A title="literal result element" 
href="REC-xslt20-20070123.htm#dt-literal-result-element">literal 
result elements</A> may also have an <CODE>xsl:version</CODE> attribute. When 
the <CODE>xsl:version</CODE> attribute is numerically less than 
<CODE>2.0</CODE>, backwards-compatible processing behavior is enabled (see <A 
href="REC-xslt20-20070123.htm#backwards"><I>3.8 
Backwards-Compatible Processing</I></A>). When the <CODE>xsl:version</CODE> 
attribute is numerically greater than <CODE>2.0</CODE>, <A 
title="forwards-compatible behavior" 
href="REC-xslt20-20070123.htm#dt-forwards-compatible-behavior">forwards-compatible 
behavior</A> is enabled (see <A 
href="REC-xslt20-20070123.htm#forwards"><I>3.9 
Forwards-Compatible Processing</I></A>).</P>
<P>The allowed content of a literal result element when used as a simplified 
stylesheet is the same as when it occurs within a <A 
title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A>. Thus, a literal result element used as the document element of 
a simplified stylesheet cannot contain <A title=declaration 
href="REC-xslt20-20070123.htm#dt-declaration">declarations</A>. 
<SPAN>Simplified stylesheets therefore cannot use <A title="global variable" 
href="REC-xslt20-20070123.htm#dt-global-variable">global 
variables</A>, <A title="stylesheet parameter" 
href="REC-xslt20-20070123.htm#dt-stylesheet-parameter">stylesheet 
parameters</A>, <A title="stylesheet function" 
href="REC-xslt20-20070123.htm#dt-stylesheet-function">stylesheet 
functions</A>, <A title=key 
href="REC-xslt20-20070123.htm#dt-key">keys</A>, <A 
title="attribute set" 
href="REC-xslt20-20070123.htm#dt-attribute-set">attribute-sets</A>, 
or <A title="output definition" 
href="REC-xslt20-20070123.htm#dt-output-definition">output 
definitions</A>. In turn this means that the only useful way to initiate the 
transformation is to supply a document node as the <A 
title="initial context node" 
href="REC-xslt20-20070123.htm#dt-initial-context-node">initial 
context node</A>, to be matched by the implicit <CODE>match="/"</CODE> template 
rule using the <A title="default mode" 
href="REC-xslt20-20070123.htm#dt-default-mode">default 
mode</A>.</SPAN></P></DIV>
<DIV class=div2>
<H3><A id=backwards name=backwards></A>3.8 Backwards-Compatible Processing</H3>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A 
id=dt-backwards-compatible-behavior title="backwards compatible behavior" 
name=dt-backwards-compatible-behavior></A>An element enables 
backwards-compatible behavior for itself, its attributes, its descendants and 
their attributes if it has an <CODE>[xsl:]version</CODE> attribute (see <A 
href="REC-xslt20-20070123.htm#standard-attributes"><I>3.5 
Standard Attributes</I></A>) whose value is less than <CODE>2.0</CODE>.<SPAN 
class=definition>]</SPAN></P>
<P>An element that has an <CODE>[xsl:]version</CODE> attribute whose value is 
greater than or equal to <CODE>2.0</CODE> disables backwards-compatible behavior 
for itself, its attributes, its descendants and their attributes. The 
compatibility behavior established by an element overrides any compatibility 
behavior established by an ancestor element.</P>
<P>If an attribute containing an XPath <A title=expression 
href="REC-xslt20-20070123.htm#dt-expression">expression</A> 
is processed with backwards-compatible behavior, then the expression is 
evaluated with <A title="XPath 1.0 compatibility mode" 
href="REC-xslt20-20070123.htm#dt-compatibility-mode">XPath 
1.0 compatibility mode</A> set to <CODE>true</CODE>. For details of this mode, 
see <A href="http://www.w3.org/TR/xpath20/#static_context">Section 2.1.1 Static 
Context</A><SUP><SMALL>XP</SMALL></SUP>. <SPAN>Furthermore, in such an 
expression any function call for which no implementation is available (unless it 
uses the <A title="standard function namespace" 
href="REC-xslt20-20070123.htm#dt-standard-function-namespace">standard 
function namespace</A>) is bound to a fallback error function whose effect when 
evaluated is to raise a dynamic error <SPAN class=error>[see <A 
href="REC-xslt20-20070123.htm#err-XTDE1425">ERR 
XTDE1425</A>]</SPAN> . The effect is that with backwards-compatible behavior 
enabled, calls on <A title="extension function" 
href="REC-xslt20-20070123.htm#dt-extension-function">extension 
functions</A> that are not available in a particular implementation do not cause 
an error unless the function call is actually evaluated. For further details, 
see <A 
href="REC-xslt20-20070123.htm#extension-functions"><I>18.1 
Extension Functions</I></A>.</SPAN></P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>This might appear to contradict the specification of XPath 2.0, which states 
that a static error [XPST0017] is raised when an expression contains a call to a 
function that is not present (with matching name and arity) in the static 
context. This apparent contradiction is resolved by specifying that the XSLT 
processor constructs a static context for the expression in which every possible 
function name and arity (other than names in the <A 
title="standard function namespace" 
href="REC-xslt20-20070123.htm#dt-standard-function-namespace">standard 
function namespace</A>) is present; when no other implementation of the function 
is available, the function call is bound to a fallback error function whose 
run-time effect is to raise a dynamic error.</P></DIV>
<P>Certain XSLT constructs also produce different results when 
backwards-compatible behavior is enabled. This is described separately for each 
such construct.</P>
<P>These rules do not apply to the <A 
href="REC-xslt20-20070123.htm#element-output"><CODE>xsl:output</CODE></A> 
element, whose <CODE>version</CODE> attribute has an entirely different purpose: 
it is used to define the version of the output method to be used for 
serialization.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P><SPAN>By making use of backwards-compatible behavior, it is possible to write 
the stylesheet in a way that ensures that its results when processed with an 
XSLT 2.0 processor are identical to the effects of processing the same 
stylesheet using an XSLT 1.0 processor.</SPAN> The differences are described 
(non-normatively) in <A 
href="REC-xslt20-20070123.htm#incompatibilities"><I>J.1 
Incompatible Changes</I></A>. To assist with transition, some parts of a 
stylesheet may be processed with backwards compatible behavior enabled, and 
other parts with this behavior disabled. All data values manipulated by an XSLT 
2.0 processor are defined by the <SPAN>XDM</SPAN> data model, whether or not the 
relevant expressions use backwards compatible behavior. Because the same data 
model is used in both cases, expressions are fully composable. The result of 
evaluating instructions or expressions with backwards compatible behavior is 
fully defined in the XSLT 2.0 and XPath 2.0 specifications, it is not defined by 
reference to the XSLT 1.0 and XPath 1.0 specifications.</P></DIV>
<P>It is <A title=implementation-defined 
href="REC-xslt20-20070123.htm#dt-implementation-defined">implementation-defined</A> 
whether a particular XSLT 2.0 implementation supports backwards-compatible 
behavior.</P>
<P><A id=err-XTDE0160 name=err-XTDE0160><SPAN class=error>[ERR 
XTDE0160]</SPAN></A> If an implementation does not support backwards-compatible 
behavior, then it is a <A title="non-recoverable dynamic error" 
href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
dynamic error</A> if any element is evaluated that enables backwards-compatible 
behavior.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>To write a stylesheet that works with both XSLT 1.0 and 2.0 processors, while 
making selective use of XSLT 2.0 facilities, it is necessary to understand both 
the rules for backwards-compatible behavior in XSLT 2.0, and the rules for 
forwards-compatible behavior in XSLT 1.0. If the <A 
href="REC-xslt20-20070123.htm#element-stylesheet"><CODE>xsl:stylesheet</CODE></A> 
element specifies <CODE>version="2.0"</CODE>, then an XSLT 1.0 processor will 
ignore XSLT 2.0 <A title=declaration 
href="REC-xslt20-20070123.htm#dt-declaration">declarations</A> 
that were not defined in XSLT 1.0, for example <A 
href="REC-xslt20-20070123.htm#element-function"><CODE>xsl:function</CODE></A> 
and <A 
href="REC-xslt20-20070123.htm#element-import-schema"><CODE>xsl:import-schema</CODE></A>. 
If any new XSLT 2.0 instructions are used (for example <A 
href="REC-xslt20-20070123.htm#element-analyze-string"><CODE>xsl:analyze-string</CODE></A> 
or <A 
href="REC-xslt20-20070123.htm#element-namespace"><CODE>xsl:namespace</CODE></A>), 
or if new XPath 2.0 features are used (for example, new functions, or syntax 
such as conditional expressions, or calls to a function defined using <A 
href="REC-xslt20-20070123.htm#element-function"><CODE>xsl:function</CODE></A>), 
then the stylesheet must provide fallback behavior that relies on XSLT 1.0 and 
XPath 1.0 facilities only. The fallback behavior can be invoked by using the <A 
href="REC-xslt20-20070123.htm#element-fallback"><CODE>xsl:fallback</CODE></A> 
instruction, or by testing the results of the <A 
href="REC-xslt20-20070123.htm#function-function-available"><CODE>function-available</CODE></A> 
or <A 
href="REC-xslt20-20070123.htm#function-element-available"><CODE>element-available</CODE></A> 
functions, or by testing the value of the <CODE>xsl:version</CODE> property 
returned by the <A 
href="REC-xslt20-20070123.htm#function-system-property"><CODE>system-property</CODE></A> 
function.</P></DIV></DIV>
<DIV class=div2>
<H3><A id=forwards name=forwards></A>3.9 Forwards-Compatible Processing</H3>
<P>The intent of forwards-compatible behavior is to make it possible to write a 
stylesheet that takes advantage of features introduced in some version of XSLT 
subsequent to XSLT 2.0, while retaining the ability to execute the stylesheet 
with an XSLT 2.0 processor using appropriate fallback behavior.</P>
<P>It is always possible to write conditional code to run under different XSLT 
versions by using the <CODE>use-when</CODE> feature described in <A 
href="REC-xslt20-20070123.htm#conditional-inclusion"><I>3.12 
Conditional Element Inclusion</I></A>. The rules for forwards-compatible 
behavior supplement this mechanism in two ways:</P>
<UL>
  <LI>
  <P>certain constructs in the stylesheet that mean nothing to an XSLT 2.0 
  processor are ignored, rather than being treated as errors.</P>
  <LI>
  <P>explicit fallback behavior can be defined for instructions defined in a 
  future XSLT release, using the <A 
  href="REC-xslt20-20070123.htm#element-fallback"><CODE>xsl:fallback</CODE></A> 
  instruction.</P></LI></UL>
<P>The detailed rules follow.</P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A 
id=dt-forwards-compatible-behavior title="forwards-compatible behavior" 
name=dt-forwards-compatible-behavior></A>An element enables 
<B>forwards-compatible behavior</B> for itself, its attributes, its descendants 
and their attributes if it has an <CODE>[xsl:]version</CODE> attribute (see <A 
href="REC-xslt20-20070123.htm#standard-attributes"><I>3.5 
Standard Attributes</I></A>) whose value is greater than <CODE>2.0</CODE>.<SPAN 
class=definition>]</SPAN></P>
<P>An element that has an <CODE>[xsl:]version</CODE> attribute whose value is 
less than or equal to <CODE>2.0</CODE> disables forwards-compatible behavior for 
itself, its attributes, its descendants and their attributes. The compatibility 
behavior established by an element overrides any compatibility behavior 
established by an ancestor element.</P>
<P>These rules do not apply to the <CODE>version</CODE> attribute of the <A 
href="REC-xslt20-20070123.htm#element-output"><CODE>xsl:output</CODE></A> 
element, which has an entirely different purpose: it is used to define the 
version of the output method to be used for serialization.</P>
<P>Within a section of a <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
where forwards-compatible behavior is enabled:</P>
<UL>
  <LI>
  <P>if an element in the XSLT namespace appears as a child of the <A 
  href="REC-xslt20-20070123.htm#element-stylesheet"><CODE>xsl:stylesheet</CODE></A> 
  element, and XSLT 2.0 does not allow such elements to occur as children of the 
  <A 
  href="REC-xslt20-20070123.htm#element-stylesheet"><CODE>xsl:stylesheet</CODE></A> 
  element, then the element and its content <SPAN class=verb>must</SPAN> be 
  ignored.</P>
  <LI>
  <P>if an element has an attribute that XSLT 2.0 does not allow the element to 
  have, then the attribute <SPAN class=verb>must</SPAN> be ignored.</P>
  <LI>
  <P>if an element in the XSLT namespace appears as part of a <A 
  title="sequence constructor" 
  href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
  constructor</A>, and XSLT 2.0 does not allow such elements to appear as part 
  of a sequence constructor, then:</P>
  <OL class=enumar>
    <LI>
    <P>If the element has one or more <A 
    href="REC-xslt20-20070123.htm#element-fallback"><CODE>xsl:fallback</CODE></A> 
    children, then no error is reported either statically or dynamically, and 
    the result of evaluating the instruction is the concatenation of the 
    sequences formed by evaluating the sequence constructors within its <A 
    href="REC-xslt20-20070123.htm#element-fallback"><CODE>xsl:fallback</CODE></A> 
    children, in document order. Siblings of the <A 
    href="REC-xslt20-20070123.htm#element-fallback"><CODE>xsl:fallback</CODE></A> 
    elements are ignored, even if they are valid XSLT 2.0 instructions.</P>
    <LI>
    <P>If the element has no <A 
    href="REC-xslt20-20070123.htm#element-fallback"><CODE>xsl:fallback</CODE></A> 
    children, then a static error is reported in the same way as if 
    forwards-compatible behavior were not enabled.</P></LI></OL></LI></UL>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e4106 name=d5e4106></A>Example: Forwards 
Compatible Behavior </DIV>
<P><SPAN>For example, an XSLT 2.0 <A title=processor 
href="REC-xslt20-20070123.htm#dt-processor">processor</A> 
will</SPAN> process the following stylesheet without error, although the 
stylesheet includes elements from the <A title="XSLT namespace" 
href="REC-xslt20-20070123.htm#dt-xslt-namespace">XSLT 
namespace</A> that are not defined in this specification:</P>
<DIV class=exampleInner><PRE>&lt;xsl:stylesheet version="17.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;xsl:template match="/"&gt;
    &lt;xsl:exciting-new-17.0-feature&gt;
      &lt;xsl:fly-to-the-moon/&gt;
      &lt;xsl:fallback&gt;
        &lt;html&gt;
          &lt;head&gt;
            &lt;title&gt;XSLT 17.0 required&lt;/title&gt;
          &lt;/head&gt;
          &lt;body&gt;
            &lt;p&gt;Sorry, this stylesheet requires XSLT 17.0.&lt;/p&gt;
          &lt;/body&gt;
        &lt;/html&gt;
      &lt;/xsl:fallback&gt;
    &lt;/xsl:exciting-new-17.0-feature&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
</PRE></DIV></DIV>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>If a stylesheet depends crucially on a <A title=declaration 
href="REC-xslt20-20070123.htm#dt-declaration">declaration</A> 
introduced by a version of XSLT after 2.0, then the stylesheet can use an <A 
href="REC-xslt20-20070123.htm#element-message"><CODE>xsl:message</CODE></A> 
element with <CODE>terminate="yes"</CODE> (see <A 
href="REC-xslt20-20070123.htm#message"><I>17 
Messages</I></A>) to ensure that implementations that conform to an earlier 
version of XSLT will not silently ignore the <A title=declaration 
href="REC-xslt20-20070123.htm#dt-declaration">declaration</A>.</P></DIV>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e4139 name=d5e4139></A>Example: Testing the 
XSLT Version </DIV>
<P>For example,</P>
<DIV class=exampleInner><PRE>&lt;xsl:stylesheet version="18.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

  &lt;xsl:important-new-17.0-declaration/&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="number(system-property('xsl:version')) lt 17.0"&gt;
        &lt;xsl:message terminate="yes"&gt;
          &lt;xsl:text&gt;Sorry, this stylesheet requires XSLT 17.0.&lt;/xsl:text&gt;
        &lt;/xsl:message&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        ...
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;
  ...
&lt;/xsl:stylesheet&gt;
</PRE></DIV></DIV></DIV>
<DIV class=div2>
<H3><A id=combining-modules name=combining-modules></A>3.10 Combining Stylesheet 
Modules</H3>
<P>XSLT provides two mechanisms to construct a <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
from multiple <A title="stylesheet module" 
href="REC-xslt20-20070123.htm#dt-stylesheet-module">stylesheet 
modules</A>:</P>
<UL>
  <LI>
  <P>an inclusion mechanism that allows stylesheet modules to be combined 
  without changing the semantics of the modules being combined, and</P>
  <LI>
  <P>an import mechanism that allows stylesheet modules to override each 
  other.</P></LI></UL>
<DIV class=div3>
<H4><A id=locating-modules name=locating-modules></A>3.10.1 Locating Stylesheet 
Modules</H4>
<P>The include and import mechanisms use two declarations, <A 
href="REC-xslt20-20070123.htm#element-include"><CODE>xsl:include</CODE></A> 
and <A 
href="REC-xslt20-20070123.htm#element-import"><CODE>xsl:import</CODE></A>, 
which are defined in the sections that follow.</P>
<P>These declarations use an <CODE>href</CODE> attribute, whose value is a <A 
title="URI Reference" 
href="REC-xslt20-20070123.htm#dt-uri-reference">URI 
reference</A>, to identify the <A title="stylesheet module" 
href="REC-xslt20-20070123.htm#dt-stylesheet-module">stylesheet 
module</A> to be included or imported. If the value of this attribute is a 
relative URI, it is resolved <SPAN>as described in <A 
href="REC-xslt20-20070123.htm#uri-references"><I>5.8 URI 
References</I></A></SPAN>.</P>
<P>After resolving against the base URI, the way in which the URI reference is 
used to locate a <SPAN>representation of a <A title="stylesheet module" 
href="REC-xslt20-20070123.htm#dt-stylesheet-module">stylesheet 
module</A>, and the way in which the stylesheet module is constructed from that 
representation, are</SPAN> <A title=implementation-defined 
href="REC-xslt20-20070123.htm#dt-implementation-defined">implementation-defined</A>. 
In particular, it is implementation-defined which URI schemes are supported, 
whether fragment identifiers are supported, and what media types are supported. 
Conventionally, the URI is a reference to a resource containing the stylesheet 
module as a source XML document, or it may include a fragment identifier that 
selects an embedded stylesheet module within a source XML document; but the 
implementation is free to use other mechanisms to locate the stylesheet module 
identified by the URI reference.</P>
<P>The referenced <A title="stylesheet module" 
href="REC-xslt20-20070123.htm#dt-stylesheet-module">stylesheet 
module</A> may be any of the four kinds of stylesheet module: that is, it may be 
<A title="standalone stylesheet module" 
href="REC-xslt20-20070123.htm#dt-standalone-stylesheet-module">standalone</A> 
or <A title="embedded stylesheet module" 
href="REC-xslt20-20070123.htm#dt-embedded-stylesheet-module">embedded</A>, 
and it may be <A title="standard stylesheet module" 
href="REC-xslt20-20070123.htm#dt-standard-stylesheet-module">standard</A> 
or <A title="simplified stylesheet module" 
href="REC-xslt20-20070123.htm#dt-simplified-stylesheet-module">simplified</A>. 
If it is a <A title="simplified stylesheet module" 
href="REC-xslt20-20070123.htm#dt-simplified-stylesheet-module">simplified 
stylesheet module</A> then it is transformed into the equivalent <A 
title="standard stylesheet module" 
href="REC-xslt20-20070123.htm#dt-standard-stylesheet-module">standard 
stylesheet module</A> by applying the transformation described in <A 
href="REC-xslt20-20070123.htm#simplified-stylesheet"><I>3.7 
Simplified Stylesheet Modules</I></A>.</P>
<P>Implementations <SPAN class=verb>may</SPAN> choose to accept URI references 
containing a fragment identifier defined by reference to the XPointer 
specification (see <A 
href="REC-xslt20-20070123.htm#xptr-framework">[XPointer 
Framework]</A>). Note that if the implementation does not support the use of 
fragment identifiers in the URI reference, then it will not be possible to 
include an <A title="embedded stylesheet module" 
href="REC-xslt20-20070123.htm#dt-embedded-stylesheet-module">embedded 
stylesheet module</A>.</P>
<P><A id=err-XTSE0165 name=err-XTSE0165><SPAN class=error>[ERR 
XTSE0165]</SPAN></A> It is a <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A> if the processor is not able to retrieve the resource identified by 
the URI reference, or if the resource that is retrieved does not contain a 
stylesheet module conforming to this specification.</P></DIV>
<DIV class=div3>
<H4><A id=include name=include></A>3.10.2 Stylesheet Inclusion</H4>
<P class=element-syntax><A id=element-include 
name=element-include></A><CODE>&lt;!-- Category: declaration 
--&gt;<BR>&lt;xsl:include<BR>&nbsp;&nbsp;<B>href</B> = 
<VAR>uri-reference</VAR>&nbsp;/&gt;</CODE></P>
<P>A stylesheet module may include another stylesheet module using an <A 
href="REC-xslt20-20070123.htm#element-include"><CODE>xsl:include</CODE></A> 
declaration.</P>
<P>The <A 
href="REC-xslt20-20070123.htm#element-include"><CODE>xsl:include</CODE></A> 
declaration has a <SPAN class=verb>required</SPAN> <CODE>href</CODE> attribute 
whose value is a URI reference identifying the stylesheet module to be included. 
This attribute is used as described in <A 
href="REC-xslt20-20070123.htm#locating-modules"><I>3.10.1 
Locating Stylesheet Modules</I></A>.</P>
<P><A id=err-XTSE0170 name=err-XTSE0170><SPAN class=error>[ERR 
XTSE0170]</SPAN></A> An <A 
href="REC-xslt20-20070123.htm#element-include"><CODE>xsl:include</CODE></A> 
element <SPAN class=verb>must</SPAN> be a <A title=top-level 
href="REC-xslt20-20070123.htm#dt-top-level">top-level</A> 
element.</P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-stylesheet-level 
title="stylesheet level" name=dt-stylesheet-level></A>A <B>stylesheet level</B> 
is a collection of <A title="stylesheet module" 
href="REC-xslt20-20070123.htm#dt-stylesheet-module">stylesheet 
modules</A> connected using <A 
href="REC-xslt20-20070123.htm#element-include"><CODE>xsl:include</CODE></A> 
declarations: specifically, two stylesheet modules <VAR>A</VAR> and <VAR>B</VAR> 
are part of the same stylesheet level if one of them includes the other by means 
of an <A 
href="REC-xslt20-20070123.htm#element-include"><CODE>xsl:include</CODE></A> 
declaration, or if there is a third stylesheet module <VAR>C</VAR> that is in 
the same stylesheet level as both <VAR>A</VAR> and <VAR>B</VAR>.<SPAN 
class=definition>]</SPAN></P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-declaration-order 
title="declaration order" name=dt-declaration-order></A>The <A title=declaration 
href="REC-xslt20-20070123.htm#dt-declaration">declarations</A> 
within a <A title="stylesheet level" 
href="REC-xslt20-20070123.htm#dt-stylesheet-level">stylesheet 
level</A> have a total ordering known as <B>declaration order</B>. The order of 
declarations within a stylesheet level is the same as the document order that 
would result if each stylesheet module were inserted textually in place of the 
<A 
href="REC-xslt20-20070123.htm#element-include"><CODE>xsl:include</CODE></A> 
element that references it.<SPAN class=definition>]</SPAN> In other respects, 
however, the effect of <A 
href="REC-xslt20-20070123.htm#element-include"><CODE>xsl:include</CODE></A> 
is not equivalent to the effect that would be obtained by textual inclusion.</P>
<P><A id=err-XTSE0180 name=err-XTSE0180><SPAN class=error>[ERR 
XTSE0180]</SPAN></A> It is a <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A> if a stylesheet module directly or indirectly includes itself.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>It is not intrinsically an error for a <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
to include the same module more than once. However, doing so can cause errors 
because of duplicate definitions. Such multiple inclusions are less obvious when 
they are indirect. For example, if stylesheet <VAR>B</VAR> includes stylesheet 
<VAR>A</VAR>, stylesheet <VAR>C</VAR> includes stylesheet <VAR>A</VAR>, and 
stylesheet <VAR>D</VAR> includes both stylesheet <VAR>B</VAR> and stylesheet 
<VAR>C</VAR>, then <VAR>A</VAR> will be included indirectly by <VAR>D</VAR> 
twice. If all of <VAR>B</VAR>, <VAR>C</VAR> and <VAR>D</VAR> are used as 
independent stylesheets, then the error can be avoided by separating everything 
in <VAR>B</VAR> other than the inclusion of <VAR>A</VAR> into a separate 
stylesheet <VAR>B'</VAR> and changing <VAR>B</VAR> to contain just inclusions of 
<VAR>B'</VAR> and <VAR>A</VAR>, similarly for <VAR>C</VAR>, and then changing 
<VAR>D</VAR> to include <VAR>A</VAR>, <VAR>B'</VAR>, 
<VAR>C'</VAR>.</P></DIV></DIV>
<DIV class=div3>
<H4><A id=import name=import></A>3.10.3 Stylesheet Import</H4>
<P class=element-syntax><A id=element-import 
name=element-import></A><CODE>&lt;!-- Category: declaration 
--&gt;<BR>&lt;xsl:import<BR>&nbsp;&nbsp;<B>href</B> = 
<VAR>uri-reference</VAR>&nbsp;/&gt;</CODE></P>
<P>A stylesheet module may import another <A title="stylesheet module" 
href="REC-xslt20-20070123.htm#dt-stylesheet-module">stylesheet 
module</A> using an <A 
href="REC-xslt20-20070123.htm#element-import"><CODE>xsl:import</CODE></A> 
<A title=declaration 
href="REC-xslt20-20070123.htm#dt-declaration">declaration</A>. 
Importing a stylesheet <SPAN>module</SPAN> is the same as including it (see <A 
href="REC-xslt20-20070123.htm#include"><I>3.10.2 
Stylesheet Inclusion</I></A>) except that <A title="template rule" 
href="REC-xslt20-20070123.htm#dt-template-rule">template 
rules</A> and other <A title=declaration 
href="REC-xslt20-20070123.htm#dt-declaration">declarations</A> 
in the importing <SPAN>module</SPAN> take precedence over template rules and 
declarations in the imported <SPAN>module</SPAN>; this is described in more 
detail below.</P>
<P>The <A 
href="REC-xslt20-20070123.htm#element-import"><CODE>xsl:import</CODE></A> 
declaration has a <SPAN class=verb>required</SPAN> <CODE>href</CODE> attribute 
whose value is a URI reference identifying the stylesheet module to be included. 
This attribute is used as described in <A 
href="REC-xslt20-20070123.htm#locating-modules"><I>3.10.1 
Locating Stylesheet Modules</I></A>.</P>
<P><A id=err-XTSE0190 name=err-XTSE0190><SPAN class=error>[ERR 
XTSE0190]</SPAN></A> An <A 
href="REC-xslt20-20070123.htm#element-import"><CODE>xsl:import</CODE></A> 
element <SPAN class=verb>must</SPAN> be a <A title=top-level 
href="REC-xslt20-20070123.htm#dt-top-level">top-level</A> 
element.</P>
<P><A id=err-XTSE0200 name=err-XTSE0200><SPAN class=error>[ERR 
XTSE0200]</SPAN></A> The <A 
href="REC-xslt20-20070123.htm#element-import"><CODE>xsl:import</CODE></A> 
element children <SPAN class=verb>must</SPAN> precede all other element children 
of an <A 
href="REC-xslt20-20070123.htm#element-stylesheet"><CODE>xsl:stylesheet</CODE></A> 
element, including any <A 
href="REC-xslt20-20070123.htm#element-include"><CODE>xsl:include</CODE></A> 
element children and any <A title="user-defined data element" 
href="REC-xslt20-20070123.htm#dt-data-element">user-defined 
data elements</A>.</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e4538 name=d5e4538></A>Example: Using 
<CODE>xsl:import</CODE> </DIV>
<P>For example,</P>
<DIV class=exampleInner><PRE>&lt;xsl:stylesheet version="2.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;xsl:import href="article.xsl"/&gt;
  &lt;xsl:import href="bigfont.xsl"/&gt;
  &lt;xsl:attribute-set name="note-style"&gt;
    &lt;xsl:attribute name="font-style"&gt;italic&lt;/xsl:attribute&gt;
  &lt;/xsl:attribute-set&gt;
&lt;/xsl:stylesheet&gt;
</PRE></DIV></DIV>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-import-tree 
title="import tree" name=dt-import-tree></A>The <A title="stylesheet level" 
href="REC-xslt20-20070123.htm#dt-stylesheet-level">stylesheet 
levels</A> making up a <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
are treated as forming an <B>import tree</B>. In the import tree, each 
stylesheet level has one child for each <A 
href="REC-xslt20-20070123.htm#element-import"><CODE>xsl:import</CODE></A> 
declaration that it contains.<SPAN class=definition>]</SPAN> The ordering of the 
children is the <A title="declaration order" 
href="REC-xslt20-20070123.htm#dt-declaration-order">declaration 
order</A> of the <A 
href="REC-xslt20-20070123.htm#element-import"><CODE>xsl:import</CODE></A> 
declarations within their stylesheet level.</P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-import-precedence 
title="import precedence" name=dt-import-precedence></A>A <A title=declaration 
href="REC-xslt20-20070123.htm#dt-declaration">declaration</A> 
<VAR>D</VAR> in the stylesheet is defined to have lower <B>import precedence</B> 
than another declaration <VAR>E</VAR> if the stylesheet level containing 
<VAR>D</VAR> would be visited before the stylesheet level containing 
<VAR>E</VAR> in a post-order traversal of the import tree (that is, a traversal 
of the import tree in which a stylesheet level is visited after its children). 
Two declarations within the same stylesheet level have the same import 
precedence.<SPAN class=definition>]</SPAN></P>
<P>For example, suppose</P>
<UL>
  <LI>
  <P>stylesheet module <VAR>A</VAR> imports stylesheet modules <VAR>B</VAR> and 
  <VAR>C</VAR> in that order;</P>
  <LI>
  <P>stylesheet module <VAR>B</VAR> imports stylesheet module <VAR>D</VAR>;</P>
  <LI>
  <P>stylesheet module <VAR>C</VAR> imports stylesheet module 
  <VAR>E</VAR>.</P></LI></UL>
<P>Then the import tree has the following structure:</P>
<DIV class=exampleInner><PRE>         A
         |
     +---+---+
     |       |
     B       C
     |       |
     D       E
</PRE></DIV>
<P>The order of import precedence (lowest first) is <VAR>D</VAR>, <VAR>B</VAR>, 
<VAR>E</VAR>, <VAR>C</VAR>, <VAR>A</VAR>.</P>
<P>In general, a <A title=declaration 
href="REC-xslt20-20070123.htm#dt-declaration">declaration</A> 
with higher import precedence takes precedence over a declaration with lower 
import precedence. This is defined in detail for each kind of declaration.</P>
<P><A id=err-XTSE0210 name=err-XTSE0210><SPAN class=error>[ERR 
XTSE0210]</SPAN></A> It is a <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A> if a stylesheet module directly or indirectly imports itself.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>The case where a stylesheet module with a particular URI is imported several 
times is not treated specially. The effect is exactly the same as if several 
stylesheet modules with different URIs but identical content were imported. This 
might or might not cause an error, depending on the content of the stylesheet 
module.</P></DIV></DIV></DIV>
<DIV class=div2>
<H3><A id=embedded name=embedded></A>3.11 Embedded Stylesheet Modules</H3>
<P>An <A title="embedded stylesheet module" 
href="REC-xslt20-20070123.htm#dt-embedded-stylesheet-module">embedded 
stylesheet module</A> is a <A title="stylesheet module" 
href="REC-xslt20-20070123.htm#dt-stylesheet-module">stylesheet 
module</A> whose containing element is not the outermost element of the 
containing XML document. Both <A title="standard stylesheet module" 
href="REC-xslt20-20070123.htm#dt-standard-stylesheet-module">standard 
stylesheet modules</A> and <A title="simplified stylesheet module" 
href="REC-xslt20-20070123.htm#dt-simplified-stylesheet-module">simplified 
stylesheet modules</A> may be embedded in this way.</P>
<P>Two situations where embedded stylesheets may be useful are:</P>
<UL>
  <LI>
  <P>The stylesheet may be embedded in the source document to be 
transformed.</P>
  <LI>
  <P>The stylesheet may be embedded in an XML document that describes a sequence 
  of processing of which the XSLT transformation forms just one 
part.</P></LI></UL>
<P>The <A 
href="REC-xslt20-20070123.htm#element-stylesheet"><CODE>xsl:stylesheet</CODE></A> 
element <SPAN class=verb>may</SPAN> have an <CODE>id</CODE> attribute to 
facilitate reference to the stylesheet module within the containing 
document.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>In order for such an attribute value to be used as a fragment identifier in a 
URI, the <SPAN>XDM attribute node</SPAN> must generally have the 
<CODE>is-id</CODE> property: see <A 
href="http://www.w3.org/TR/xpath-datamodel/#dm-is-id">Section 5.5 is-id 
Accessor</A><SUP><SMALL>DM</SMALL></SUP>. This property will typically be set if 
the attribute is defined in a DTD as being of type <CODE>ID</CODE>, or if is 
defined in a schema as being of type <CODE>xs:ID</CODE>. It is also necessary 
that the media type of the containing document should support the use of ID 
values as fragment identifiers. Such support is widespread in existing products, 
and is expected to be endorsed in respect of the media type 
<CODE>application/xml</CODE> by a future revision of <A 
href="REC-xslt20-20070123.htm#RFC3023">[RFC3023]</A>.</P>
<P>An alternative, if the implementation supports it, is to use an 
<CODE>xml:id</CODE> attribute. XSLT allows this attribute (like other namespaced 
attributes) to appear on any <A title="XSLT element" 
href="REC-xslt20-20070123.htm#dt-xslt-element">XSLT 
element</A>.</P></DIV>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e4734 name=d5e4734></A>Example: The 
<CODE>xml-stylesheet</CODE> Processing Instruction </DIV>
<P>The following example shows how the <CODE>xml-stylesheet</CODE> processing 
instruction (see <A 
href="REC-xslt20-20070123.htm#xml-stylesheet">[XML 
Stylesheet]</A>) can be used to allow a source document to contain its own 
stylesheet. The URI reference uses a relative URI with a fragment identifier to 
locate the <A 
href="REC-xslt20-20070123.htm#element-stylesheet"><CODE>xsl:stylesheet</CODE></A> 
element:</P>
<DIV class=exampleInner><PRE>&lt;?xml-stylesheet type="application/xslt+xml" href="#style1"?&gt;
&lt;!DOCTYPE doc SYSTEM "doc.dtd"&gt;
&lt;doc&gt;
&lt;head&gt;
&lt;xsl:stylesheet id="style1"
                version="2.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns:fo="http://www.w3.org/1999/XSL/Format"&gt;
&lt;xsl:import href="doc.xsl"/&gt;
&lt;xsl:template match="id('foo')"&gt;
  &lt;fo:block font-weight="bold"&gt;&lt;xsl:apply-templates/&gt;&lt;/fo:block&gt;
&lt;/xsl:template&gt;
&lt;xsl:template match="xsl:stylesheet"&gt;
  &lt;!-- ignore --&gt;
&lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;para id="foo"&gt;
...
&lt;/para&gt;
&lt;/body&gt;
&lt;/doc&gt;
</PRE></DIV></DIV>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>A stylesheet module that is embedded in the document to which it is to be 
applied typically needs to contain a <A title="template rule" 
href="REC-xslt20-20070123.htm#dt-template-rule">template 
rule</A> that specifies that <A 
href="REC-xslt20-20070123.htm#element-stylesheet"><CODE>xsl:stylesheet</CODE></A> 
elements are to be ignored.</P></DIV>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>The above example uses the pseudo-attribute 
<CODE>type="application/xslt+xml"</CODE> in the <CODE>xml-stylesheet</CODE> 
processing instruction to denote an XSLT stylesheet. This usage is subject to 
<SPAN>confirmation</SPAN>: see <A 
href="REC-xslt20-20070123.htm#xslt-media-type"><I>3.4 
XSLT Media Type</I></A>. In the absence of a registered media type for XSLT 
stylesheets, some vendors' products have adopted different conventions, notably 
<CODE>type="text/xsl"</CODE>.</P></DIV>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>Support for the <CODE>xml-stylesheet</CODE> processing instruction is not 
required for conformance with this Recommendation. <SPAN>Implementations are not 
constrained in the mechanisms they use to identify a stylesheet when a 
transformation is initiated: see <A 
href="REC-xslt20-20070123.htm#initiating"><I>2.3 
Initiating a Transformation</I></A>.</SPAN></P></DIV></DIV>
<DIV class=div2>
<H3><A id=conditional-inclusion name=conditional-inclusion></A>3.12 Conditional 
Element Inclusion</H3>
<P>Any element in the XSLT namespace may have a <CODE>use-when</CODE> attribute 
whose value is an XPath expression that can be evaluated statically. If the 
attribute is present and the <A 
href="http://www.w3.org/TR/xpath20/#dt-ebv">effective boolean 
value</A><SUP><SMALL>XP</SMALL></SUP> of the expression is false, then the 
element, together with all the nodes having that element as an ancestor, is 
effectively excluded from the <A title="stylesheet module" 
href="REC-xslt20-20070123.htm#dt-stylesheet-module">stylesheet 
module</A>. When a node is effectively excluded from a stylesheet module the 
stylesheet module has the same effect as if the node were not there. Among other 
things this means that no static or dynamic errors will be reported in respect 
of the element and its contents, other than errors in the <CODE>use-when</CODE> 
attribute itself.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>This does not apply to XML parsing or validation errors, which will be 
reported in the usual way. <SPAN>It also does not apply to attributes that are 
necessarily processed before <CODE>[xsl:]use-when</CODE>, examples being 
<CODE>xml:space</CODE> and 
<CODE>[xsl:]xpath-default-namespace</CODE></SPAN>.</P></DIV>
<P>A <A title="literal result element" 
href="REC-xslt20-20070123.htm#dt-literal-result-element">literal 
result element</A>, <SPAN>or any other element within a <A 
title="stylesheet module" 
href="REC-xslt20-20070123.htm#dt-stylesheet-module">stylesheet 
module</A> that is not in the XSLT namespace,</SPAN> may similarly carry an 
<CODE>xsl:use-when</CODE> attribute.</P>
<P>If the <A 
href="REC-xslt20-20070123.htm#element-stylesheet"><CODE>xsl:stylesheet</CODE></A> 
or <A 
href="REC-xslt20-20070123.htm#element-transform"><CODE>xsl:transform</CODE></A> 
element itself is effectively excluded, the effect is to exclude all the 
children of the <A 
href="REC-xslt20-20070123.htm#element-stylesheet"><CODE>xsl:stylesheet</CODE></A> 
or <A 
href="REC-xslt20-20070123.htm#element-transform"><CODE>xsl:transform</CODE></A> 
element, but not the <A 
href="REC-xslt20-20070123.htm#element-stylesheet"><CODE>xsl:stylesheet</CODE></A> 
or <A 
href="REC-xslt20-20070123.htm#element-transform"><CODE>xsl:transform</CODE></A> 
element or its attributes.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>This allows all the declarations that depend on the same condition to be 
included in one stylesheet module, and for their inclusion or exclusion to be 
controlled by a single <CODE>use-when</CODE> attribute at the level of the 
module.</P></DIV>
<P>Conditional element exclusion happens after stripping of whitespace text 
nodes from the stylesheet, as described in <A 
href="REC-xslt20-20070123.htm#stylesheet-stripping"><I>4.2 
Stripping Whitespace from the Stylesheet</I></A>.</P>
<P>There are no syntactic constraints on the XPath expression that can be used 
as the value of the <CODE>use-when</CODE> attribute. However, there are severe 
constraints on the information provided in its evaluation context. These 
constraints are designed to ensure that the expression can be evaluated at the 
earliest possible stage of stylesheet processing, without any dependency on 
information contained in the stylesheet itself or in any source document.</P>
<P>Specifically, the components of the static and dynamic context are defined by 
the following two tables:</P>
<TABLE cellPadding=5 width="100%" border=1>
  <CAPTION>Static Context Components for <CODE>use-when</CODE> Expressions 
  </CAPTION>
  <COLGROUP>
  <COL align=left width="30%">
  <COL align=left>
  <THEAD>
  <TR>
    <TH>Component</TH>
    <TH>Value</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD vAlign=top>XPath 1.0 compatibility mode</TD>
    <TD>false</TD></TR>
  <TR>
    <TD vAlign=top>In scope namespaces</TD>
    <TD>determined by the in-scope namespaces for the containing element in 
      the stylesheet</TD></TR>
  <TR>
    <TD vAlign=top>Default element/type namespace</TD>
    <TD>determined by the <CODE>xpath-default-namespace</CODE> attribute if 
      present (see <A 
      href="REC-xslt20-20070123.htm#unprefixed-qnames"><I>5.2 
      Unprefixed QNames in Expressions and Patterns</I></A>); otherwise the null 
      namespace</TD></TR>
  <TR>
    <TD vAlign=top>Default function namespace</TD>
    <TD>The <A title="standard function namespace" 
      href="REC-xslt20-20070123.htm#dt-standard-function-namespace">standard 
      function namespace</A></TD></TR>
  <TR>
    <TD vAlign=top>In scope type definitions</TD>
    <TD>The type definitions that would be available in the absence of any <A 
      href="REC-xslt20-20070123.htm#element-import-schema"><CODE>xsl:import-schema</CODE></A> 
      declaration</TD></TR>
  <TR>
    <TD vAlign=top>In scope element declarations</TD>
    <TD>None</TD></TR>
  <TR>
    <TD vAlign=top>In scope attribute declarations</TD>
    <TD>None</TD></TR>
  <TR>
    <TD vAlign=top>In scope variables</TD>
    <TD>None</TD></TR>
  <TR>
    <TD vAlign=top>In scope functions</TD>
    <TD>The <A title="core function" 
      href="REC-xslt20-20070123.htm#dt-core-function">core 
      functions</A> defined in <A 
      href="REC-xslt20-20070123.htm#xpath-functions">[Functions 
      and Operators]</A>, together with the functions <A 
      href="REC-xslt20-20070123.htm#function-element-available"><CODE>element-available</CODE></A>, 
      <A 
      href="REC-xslt20-20070123.htm#function-function-available"><CODE>function-available</CODE></A>, 
      <SPAN><A 
      href="REC-xslt20-20070123.htm#function-type-available"><CODE>type-available</CODE></A>,</SPAN> 
      and <A 
      href="REC-xslt20-20070123.htm#function-system-property"><CODE>system-property</CODE></A> 
      defined in this specification, plus <SPAN>the set of extension functions 
      that are present in the static context of every XPath expression (other 
      than a use-when expression) within the content of the element that is the 
      parent of the <CODE>use-when</CODE> attribute</SPAN>. Note that <A 
      title="stylesheet function" 
      href="REC-xslt20-20070123.htm#dt-stylesheet-function">stylesheet 
      functions</A> are <EM>not</EM> included in the context, which means that 
      the function <A 
      href="REC-xslt20-20070123.htm#function-function-available"><CODE>function-available</CODE></A> 
      will return <CODE>false</CODE> in respect of such functions. <SPAN>The 
      effect of this rule is to ensure that <A 
      href="REC-xslt20-20070123.htm#function-function-available"><CODE>function-available</CODE></A> 
      returns true in respect of functions that can be called within the scope 
      of the <CODE>use-when</CODE> attribute. It also has the effect that these 
      extensions functions will be recognized within the <CODE>use-when</CODE> 
      attribute itself; however, the fact that a function is available in this 
      sense gives no guarantee that a call on the function will 
    succeed.</SPAN></TD></TR>
  <TR>
    <TD vAlign=top>In scope collations</TD>
    <TD>Implementation-defined</TD></TR>
  <TR>
    <TD vAlign=top>Default collation</TD>
    <TD>The Unicode Codepoint Collation</TD></TR>
  <TR>
    <TD vAlign=top>Base URI</TD>
    <TD>The base URI of the containing element in the stylesheet</TD></TR>
  <TR>
    <TD vAlign=top>Statically known documents</TD>
    <TD>None</TD></TR>
  <TR>
    <TD vAlign=top>Statically known collections</TD>
    <TD>None</TD></TR></TBODY></TABLE>
<P>&nbsp;</P>
<TABLE cellPadding=5 width="100%" border=1>
  <CAPTION>Dynamic Context Components for <CODE>use-when</CODE> Expressions 
  </CAPTION>
  <COLGROUP>
  <COL align=left width="30%">
  <COL align=left>
  <THEAD>
  <TR>
    <TH>Component</TH>
    <TH>Value</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD vAlign=top>Context item, position, and size</TD>
    <TD>Undefined</TD></TR>
  <TR>
    <TD vAlign=top>Dynamic variables</TD>
    <TD>None</TD></TR>
  <TR>
    <TD vAlign=top>Current date and time</TD>
    <TD>Implementation-defined</TD></TR>
  <TR>
    <TD vAlign=top>Implicit timezone</TD>
    <TD>Implementation-defined</TD></TR>
  <TR>
    <TD vAlign=top>Available documents</TD>
    <TD>None</TD></TR>
  <TR>
    <TD vAlign=top>Available collections</TD>
    <TD>None</TD></TR></TBODY></TABLE>
<P>Within a <A title="stylesheet module" 
href="REC-xslt20-20070123.htm#dt-stylesheet-module">stylesheet 
module</A>, all expressions contained in <CODE>[xsl:]use-when</CODE> attributes 
are evaluated in a single <A 
href="http://www.w3.org/TR/xpath-functions/#execution-scope">execution 
scope</A><SUP><SMALL>FO</SMALL></SUP>. This need not be the same execution scope 
as that used for <CODE>[xsl]:use-when</CODE> expressions in other stylesheet 
modules, or as that used when evaluating XPath expressions appearing elsewhere 
in the stylesheet module. This means that a function such as <A 
href="http://www.w3.org/TR/xpath-functions/#func-current-date"><CODE>current-date</CODE></A><SUP><SMALL>FO</SMALL></SUP> 
will return the same result when called in different <CODE>[xsl:]use-when</CODE> 
expressions within the same stylesheet module, but will not necessarily return 
the same result as the same call in an <CODE>[xsl:]use-when</CODE> expression 
within a different stylesheet module, or as a call on the same function executed 
during the transformation proper.</P>
<P>The use of <CODE>[xsl:]use-when</CODE> is illustrated in the following 
examples.</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e5094 name=d5e5094></A>Example: Using 
Conditional Exclusion to Achieve Portability </DIV>
<P>This example demonstrates the use of the <CODE>use-when</CODE> attribute to 
achieve portability of a stylesheet across schema-aware and non-schema-aware 
processors.</P>
<DIV class=exampleInner><PRE>&lt;xsl:import-schema schema-location="http://example.com/schema"
              use-when="system-property('xsl:is-schema-aware')='yes'"/&gt;

&lt;xsl:template match="/" 
              use-when="system-property('xsl:is-schema-aware')='yes'" 
              priority="2"&gt;
  &lt;xsl:result-document validation="strict"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:result-document&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="/"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;
</PRE></DIV>
<P>The effect of these declarations is that a non-schema-aware processor ignores 
the <A 
href="REC-xslt20-20070123.htm#element-import-schema"><CODE>xsl:import-schema</CODE></A> 
declaration and the first template rule, and therefore generates no errors in 
respect of the schema-related constructs in these declarations.</P></DIV>
<P>&nbsp;</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e5109 name=d5e5109></A>Example: Including 
Variant Stylesheet Modules </DIV>
<P>This example includes different stylesheet modules depending on which XSLT 
processor is in use.</P>
<DIV class=exampleInner><PRE>&lt;xsl:include href="module-A.xsl" 
     use-when="system-property('xsl:vendor')='vendor-A'"/&gt;
&lt;xsl:include href="module-B.xsl" 
     use-when="system-property('xsl:vendor')='vendor-B'"/&gt;
</PRE></DIV></DIV></DIV>
<DIV class=div2>
<H3><A id=built-in-types name=built-in-types></A>3.13 Built-in Types</H3>
<P>Every XSLT 2.0 processor includes the following named type definitions in the 
<A title="in-scope schema component" 
href="REC-xslt20-20070123.htm#dt-in-scope-schema-component">in-scope 
schema components</A>:</P>
<UL>
  <LI>
  <P>All the primitive atomic types defined in <A 
  href="REC-xslt20-20070123.htm#xmlschema-2">[XML Schema 
  Part 2]</A>, with the exception of <CODE>xs:NOTATION</CODE>. That is: 
  <CODE>xs:string</CODE>, <CODE>xs:boolean</CODE>, <CODE>xs:decimal</CODE>, 
  <CODE>xs:double</CODE>, <CODE>xs:float</CODE>, <CODE>xs:date</CODE>, 
  <CODE>xs:time</CODE>, <CODE>xs:dateTime</CODE>, <CODE>xs:duration</CODE>, 
  <CODE>xs:QName</CODE>, <CODE>xs:anyURI</CODE>, <CODE>xs:gDay</CODE>, 
  <CODE>xs:gMonthDay</CODE>, <CODE>xs:gMonth</CODE>, <CODE>xs:gYearMonth</CODE>, 
  <CODE>xs:gYear</CODE>, <CODE>xs:base64Binary</CODE>, and 
  <CODE>xs:hexBinary</CODE>.</P>
  <LI>
  <P>The derived atomic type <CODE>xs:integer</CODE> defined in <A 
  href="REC-xslt20-20070123.htm#xmlschema-2">[XML Schema 
  Part 2]</A>.</P>
  <LI>
  <P>The types <CODE>xs:anyType</CODE> and <CODE>xs:anySimpleType</CODE>.</P>
  <LI>
  <P>The following types defined in <A 
  href="REC-xslt20-20070123.htm#xpath20">[XPath 2.0]</A>: 
  <SPAN><CODE>xs:yearMonthDuration</CODE></SPAN>, 
  <SPAN><CODE>xs:dayTimeDuration</CODE></SPAN>, 
  <SPAN><CODE>xs:anyAtomicType</CODE></SPAN>, 
  <SPAN><CODE>xs:untyped</CODE></SPAN>, and 
  <SPAN><CODE>xs:untypedAtomic</CODE></SPAN>.</P></LI></UL>
<P>A <A title="schema-aware XSLT processor" 
href="REC-xslt20-20070123.htm#dt-schema-aware-xslt-processor">schema-aware 
XSLT processor</A> additionally supports:</P>
<UL>
  <LI>
  <P>All other built-in types defined in <A 
  href="REC-xslt20-20070123.htm#xmlschema-2">[XML Schema 
  Part 2]</A></P>
  <LI>
  <P>User-defined types, and element and attribute declarations, that are 
  imported using an <A 
  href="REC-xslt20-20070123.htm#element-import-schema"><CODE>xsl:import-schema</CODE></A> 
  declaration as described in <A 
  href="REC-xslt20-20070123.htm#import-schema"><I>3.14 
  Importing Schema Components</I></A>. These may include both simple and complex 
  types.</P></LI></UL>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>The names that are imported from the XML Schema namespace do not include all 
the names of top-level types defined in either the Schema for Schemas or the 
Schema for Datatypes. The Schema for Datatypes, as well as defining built-in 
types such as <CODE>xs:integer</CODE> and <CODE>xs:double</CODE>, also defines 
types that are intended for use only within the Schema for DataTypes, such as 
<CODE>xs:derivationControl</CODE>. A <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
that is designed to process XML Schema documents as its input or output may 
import the Schema for Schemas.</P></DIV>
<P>An implementation may define mechanisms that allow additional <A 
title="schema component" 
href="REC-xslt20-20070123.htm#dt-schema-component">schema 
components</A> to be added to the <A title="in-scope schema component" 
href="REC-xslt20-20070123.htm#dt-in-scope-schema-component">in-scope 
schema components</A> for the stylesheet. For example, the mechanisms used to 
define <A title="extension function" 
href="REC-xslt20-20070123.htm#dt-extension-function">extension 
functions</A> (see <A 
href="REC-xslt20-20070123.htm#extension-functions"><I>18.1 
Extension Functions</I></A>) may also be used to import the types used in the 
interface to such functions.</P>
<P>These <A title="schema component" 
href="REC-xslt20-20070123.htm#dt-schema-component">schema 
components</A> are the only ones that may be referenced in XPath expressions 
within the stylesheet, or in the <CODE>[xsl:]type</CODE> and <CODE>as</CODE> 
attributes of those elements that permit these attributes.</P>
<P>For a Basic XSLT Processor, schema built-in types that are not included in 
the static context (for example, <CODE>xs:NCName</CODE>) are "unknown types" in 
the sense of <A 
href="http://www.w3.org/TR/xpath20/#id-sequencetype-matching">Section 2.5.4 
SequenceType Matching</A><SUP><SMALL>XP</SMALL></SUP>. In the language of that 
section, a Basic XSLT Processor <SPAN class=verb>must</SPAN> be able to 
determine whether these unknown types are derived from known schema types such 
as <CODE>xs:string</CODE>. The purpose of this rule is to ensure that system 
functions such as <A 
href="http://www.w3.org/TR/xpath-functions/#func-local-name-from-QName"><CODE>local-name-from-QName</CODE></A><SUP><SMALL>FO</SMALL></SUP>, 
which is defined to return an <CODE>xs:NCName</CODE>, behave correctly. A 
stylesheet that uses a Basic XSLT Processor will not be able to test whether the 
returned value is an <CODE>xs:NCName</CODE>, but it will be able to use it as if 
it were an <CODE>xs:string</CODE>.</P></DIV>
<DIV class=div2>
<H3><A id=import-schema name=import-schema></A>3.14 Importing Schema 
Components</H3>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>The facilities described in this section are not available with a <A 
title="basic XSLT processor" 
href="REC-xslt20-20070123.htm#dt-basic-xslt-processor">basic 
XSLT processor</A>. They require a <A title="schema-aware XSLT processor" 
href="REC-xslt20-20070123.htm#dt-schema-aware-xslt-processor">schema-aware 
XSLT processor</A>, as described in <A 
href="REC-xslt20-20070123.htm#conformance"><I>21 
Conformance</I></A>.</P></DIV>
<P class=element-syntax><A id=element-import-schema 
name=element-import-schema></A><CODE>&lt;!-- Category: declaration 
--&gt;<BR>&lt;xsl:import-schema<BR>&nbsp;&nbsp;namespace? = 
<VAR>uri-reference</VAR><BR>&nbsp;&nbsp;schema-location? = 
<VAR>uri-reference</VAR>&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: xs:schema? 
--&gt;<BR>&lt;/xsl:import-schema&gt;</CODE></P>
<P>The <A 
href="REC-xslt20-20070123.htm#element-import-schema"><CODE>xsl:import-schema</CODE></A> 
declaration is used to identify <A title="schema component" 
href="REC-xslt20-20070123.htm#dt-schema-component">schema 
components</A> (that is, top-level type definitions and top-level element and 
attribute declarations) that need to be available statically, that is, before 
any source document is available. Names of such components used statically 
within the <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
must refer to an <A title="in-scope schema component" 
href="REC-xslt20-20070123.htm#dt-in-scope-schema-component">in-scope 
schema component</A>, which means they must either be built-in types as defined 
in <A 
href="REC-xslt20-20070123.htm#built-in-types"><I>3.13 
Built-in Types</I></A>, or they must be imported using an <A 
href="REC-xslt20-20070123.htm#element-import-schema"><CODE>xsl:import-schema</CODE></A> 
declaration.</P>
<P>The <A 
href="REC-xslt20-20070123.htm#element-import-schema"><CODE>xsl:import-schema</CODE></A> 
declaration identifies a namespace containing the names of the components to be 
imported (or indicates that components whose names are in no namespace are to be 
imported). The effect is that the names of top-level element and attribute 
declarations and type definitions from this namespace (or non-namespace) become 
available for use within XPath expressions in the <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A>, 
and within other stylesheet constructs such as the <CODE>type</CODE> and 
<CODE>as</CODE> attributes of various <A title="XSLT element" 
href="REC-xslt20-20070123.htm#dt-xslt-element">XSLT 
elements</A>.</P>
<P>The same schema components are available in all stylesheet modules; importing 
components in one stylesheet module makes them available throughout the <A 
title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A>.</P>
<P>The <CODE>namespace</CODE> and <CODE>schema-location</CODE> attributes are 
both optional.</P>
<P>If the <A 
href="REC-xslt20-20070123.htm#element-import-schema"><CODE>xsl:import-schema</CODE></A> 
element contains an <CODE>xs:schema</CODE> element, then the 
<CODE>schema-location</CODE> attribute must be absent, and the 
<CODE>namespace</CODE> attribute must either have the same value as the 
<CODE>targetNamespace</CODE> attribute of the <CODE>xs:schema</CODE> element (if 
present), or must be absent, in which case its effective value is that of the 
<CODE>targetNamespace</CODE> attribute of the <CODE>xs:schema</CODE> element if 
present or the zero-length string otherwise.</P>
<P><A id=err-XTSE0215 name=err-XTSE0215><SPAN class=error>[ERR 
XTSE0215]</SPAN></A> It is a <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A> if an <A 
href="REC-xslt20-20070123.htm#element-import-schema"><CODE>xsl:import-schema</CODE></A> 
element that contains an <CODE>xs:schema</CODE> element has a 
<CODE>schema-location</CODE> attribute, or if it has a <CODE>namespace</CODE> 
attribute that conflicts with the target namespace of the contained schema.</P>
<P>If two <A 
href="REC-xslt20-20070123.htm#element-import-schema"><CODE>xsl:import-schema</CODE></A> 
declarations specify the same namespace, or if both specify no namespace, then 
only the one with highest <A title="import precedence" 
href="REC-xslt20-20070123.htm#dt-import-precedence">import 
precedence</A> is used. If this leaves more than one, then all the declarations 
at the highest import precedence are used (which may cause conflicts, as 
described below).</P>
<P>After discarding any <A 
href="REC-xslt20-20070123.htm#element-import-schema"><CODE>xsl:import-schema</CODE></A> 
declarations under the above rule, the effect of the remaining <A 
href="REC-xslt20-20070123.htm#element-import-schema"><CODE>xsl:import-schema</CODE></A> 
declarations is defined in terms of a hypothetical document called the synthetic 
schema document, which is constructed as follows. The synthetic schema document 
defines an arbitrary target namespace that is different from any namespace 
actually used by the application, and it contains <CODE>xs:import</CODE> 
elements corresponding one-for-one with the <A 
href="REC-xslt20-20070123.htm#element-import-schema"><CODE>xsl:import-schema</CODE></A> 
declarations in the <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A>, 
with the following correspondence:</P>
<UL>
  <LI>
  <P>The <CODE>namespace</CODE> attribute of the <CODE>xs:import</CODE> element 
  is copied from the <CODE>namespace</CODE> attribute of the <A 
  href="REC-xslt20-20070123.htm#element-import-schema"><CODE>xsl:import-schema</CODE></A> 
  declaration if it is <SPAN>explicitly present, or is implied by the 
  <CODE>targetNamespace</CODE> attribute of a contained <CODE>xs:schema</CODE> 
  element,</SPAN> and is absent if it is absent.</P>
  <LI>
  <P>The <CODE>schemaLocation</CODE> attribute of the <CODE>xs:import</CODE> 
  element is copied from the <CODE>schema-location</CODE> attribute of the <A 
  href="REC-xslt20-20070123.htm#element-import-schema"><CODE>xsl:import-schema</CODE></A> 
  declaration if present, and is absent if it is absent. <SPAN>If there is a 
  contained <CODE>xs:schema</CODE> element, the effective value of the 
  <CODE>schemaLocation</CODE> attribute is a URI referencing a document 
  containing a copy of the <CODE>xs:schema</CODE> element.</SPAN></P>
  <LI>
  <P>The base URI of the <CODE>xs:import</CODE> element is the same as the base 
  URI of the <A 
  href="REC-xslt20-20070123.htm#element-import-schema"><CODE>xsl:import-schema</CODE></A> 
  declaration.</P></LI></UL>
<P>The schema components included in the <A title="in-scope schema component" 
href="REC-xslt20-20070123.htm#dt-in-scope-schema-component">in-scope 
schema components</A> (that is, the components whose names are available for use 
within the stylesheet) are the top-level element and attribute declarations and 
type definitions that are available for reference within the synthetic schema 
document. See <A 
href="REC-xslt20-20070123.htm#xmlschema-1">[XML Schema 
Part 1]</A> (section 4.2.3, <EM>References to schema components across 
namespaces</EM>).</P>
<P><A id=err-XTSE0220 name=err-XTSE0220><SPAN class=error>[ERR 
XTSE0220]</SPAN></A> It is a <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A> if the synthetic schema document does not satisfy the constraints 
described in <A 
href="REC-xslt20-20070123.htm#xmlschema-1">[XML Schema 
Part 1]</A> (section 5.1, <EM>Errors in Schema Construction and Structure</EM>). 
This includes, without loss of generality, conflicts such as multiple 
definitions of the same name.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>The synthetic schema document does not need to be constructed by a real 
implementation. It is purely a mechanism for defining the semantics of <A 
href="REC-xslt20-20070123.htm#element-import-schema"><CODE>xsl:import-schema</CODE></A> 
in terms of rules that already exist within the XML Schema specification. In 
particular, it implicitly defines the rules that determine whether the set of <A 
href="REC-xslt20-20070123.htm#element-import-schema"><CODE>xsl:import-schema</CODE></A> 
declarations are mutually consistent.</P>
<P>These rules do not cause names to be imported transitively. The fact that a 
name is available for reference within a schema document A does not of itself 
make the name available for reference in a stylesheet that imports the target 
namespace of schema document A. (See <A 
href="REC-xslt20-20070123.htm#xmlschema-1">[XML Schema 
Part 1]</A> section 3.15.3, Constraints on XML Representations of Schemas.) The 
stylesheet must import all the namespaces containing names that it actually 
references.</P>
<P>The <CODE>namespace</CODE> attribute indicates that a schema for the given 
namespace is required by the <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A>. 
This information may be enough on its own to enable an implementation to locate 
the required schema components. The <CODE>namespace</CODE> attribute may be 
omitted to indicate that a schema for names in no namespace is being imported. 
The zero-length string is not a valid namespace URI, and is therefore not a 
valid value for the <CODE>namespace</CODE> attribute.</P>
<P>The <CODE>schema-location</CODE> attribute is a <A title="URI Reference" 
href="REC-xslt20-20070123.htm#dt-uri-reference">URI 
Reference</A> that gives a hint indicating where a schema document or other 
resource containing the required definitions may be found. It is likely that a 
<A title="schema-aware XSLT processor" 
href="REC-xslt20-20070123.htm#dt-schema-aware-xslt-processor">schema-aware 
XSLT processor</A> will be able to process a schema document found at this 
location.</P>
<P>The XML Schema specification gives implementations flexibility in how to 
handle multiple imports for the same namespace. Multiple imports do not cause 
errors if the definitions do not conflict.</P>
<P>A consequence of these rules is that it is not intrinsically an error if no 
schema document can be located for a namespace identified in an <A 
href="REC-xslt20-20070123.htm#element-import-schema"><CODE>xsl:import-schema</CODE></A> 
declaration. This will cause an error only if it results in the stylesheet 
containing references to names that have not been imported.</P>
<P>An inline schema document (using an <CODE>xs:schema</CODE> element as a child 
of the <CODE>xsl:import-schema</CODE> element) has the same status as an 
external schema document, in the sense that it acts as a hint for a source of 
schema components in the relevant namespace. To ensure that the inline schema 
document is always used, it is advisable to use a target namespace that is 
unique to this schema document.</P></DIV>
<P>The use of a namespace in an <A 
href="REC-xslt20-20070123.htm#element-import-schema"><CODE>xsl:import-schema</CODE></A> 
declaration does not by itself associate any namespace prefix with the 
namespace. If names from the namespace are used within the stylesheet module 
then a namespace declaration must be included in the stylesheet module, in the 
usual way.</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e5611 name=d5e5611></A>Example: An Inline 
Schema Document </DIV>
<P>The following example shows an inline schema document. This declares a simple 
type <CODE>local:yes-no</CODE>, which the stylesheet then uses in the 
declaration of a variable.</P>
<P>The example assumes the namespace declaration 
<CODE>xmlns:local="http://localhost/ns/yes-no"</CODE></P>
<DIV class=exampleInner><PRE>&lt;xsl:import-schema&gt;
  &lt;xs:schema targetNamespace="http://localhost/ns/yes-no"
             xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
    &lt;xs:simpleType name="local:yes-no"&gt;
      &lt;xs:restriction base="xs:string"&gt;
        &lt;xs:enumeration value="yes"/&gt;
        &lt;xs:enumeration value="no"/&gt;
      &lt;/xs:restriction&gt;
    &lt;/xs:simpleType&gt;
  &lt;/xs:schema&gt;
&lt;/xsl:import-schema&gt;

&lt;xs:variable name="condition" select="'yes'" as="local:yes-no"/&gt;
</PRE></DIV></DIV></DIV></DIV>
<DIV class=div1>
<H2><A id=data-model name=data-model></A>4 Data Model</H2>
<P>The data model used by XSLT is the XPath 2.0 and XQuery 1.0 data model 
<SPAN>(XDM)</SPAN>, as defined in <A 
href="REC-xslt20-20070123.htm#xpath-datamodel">[Data 
Model]</A>. XSLT operates on source, result and stylesheet documents using the 
same data model.</P>
<P>This section elaborates on some particular features of <SPAN>XDM</SPAN> as it 
is used by XSLT:</P>
<P>The rules in <A 
href="REC-xslt20-20070123.htm#stylesheet-stripping"><I>4.2 
Stripping Whitespace from the Stylesheet</I></A> and <A 
href="REC-xslt20-20070123.htm#strip"><I>4.4 Stripping 
Whitespace from a Source Tree</I></A> make use of the concept of a whitespace 
text node.</P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-whitespace-text-node 
title="whitespace text node" name=dt-whitespace-text-node></A>A <B>whitespace 
text node</B> is a text node whose content consists entirely of whitespace 
characters (that is, #x09, #x0A, #x0D, or #x20).<SPAN 
class=definition>]</SPAN></P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>Features of a source XML document that are not represented in the <SPAN>XDM 
tree</SPAN> will have no effect on the operation of an XSLT stylesheet. Examples 
of such features are entity references, CDATA sections, character references, 
whitespace within element tags, and the choice of single or double quotes around 
attribute values.</P></DIV>
<DIV class=div2>
<H3><A id=xml-versions name=xml-versions></A>4.1 XML Versions</H3>
<P>The <SPAN>XDM</SPAN> data model defined in <A 
href="REC-xslt20-20070123.htm#xpath-datamodel">[Data 
Model]</A> is capable of representing either an XML 1.0 document (conforming to 
<A href="REC-xslt20-20070123.htm#REC-xml">[XML 1.0]</A> 
and <A 
href="REC-xslt20-20070123.htm#REC-xml-names">[Namespaces 
in XML 1.0]</A>) or an XML 1.1 document (conforming to <A 
href="REC-xslt20-20070123.htm#xml11">[XML 1.1]</A> and <A 
href="REC-xslt20-20070123.htm#xml-names11">[Namespaces in 
XML 1.1]</A>), and it makes no distinction between the two. In principle, 
therefore, XSLT 2.0 can be used with either of these XML versions.</P>
<P>Construction of the <SPAN>XDM tree</SPAN> is outside the scope of this 
specification, so XSLT 2.0 places no formal requirements on an XSLT processor to 
accept input from either XML 1.0 documents or XML 1.1 documents or both. This 
specification does define a serialization capability (see <A 
href="REC-xslt20-20070123.htm#serialization"><I>20 
Serialization</I></A>), though from a conformance point of view it is an 
optional feature. Although facilities are described for serializing the 
<SPAN>XDM tree</SPAN> as either XML 1.0 or XML 1.1 (and controlling the choice), 
there is again no formal requirement on an XSLT processor to support either or 
both of these XML versions as serialization targets.</P>
<P>Because the <SPAN>XDM tree</SPAN> is the same whether the original document 
was XML 1.0 or XML 1.1, the semantics of XSLT processing do not depend on the 
version of XML used by the original document. There is no reason in principle 
why all the input and output documents used in a single transformation must 
conform to the same version of XML.</P>
<P>Some of the syntactic constructs in XSLT 2.0 and XPath 2.0, for example the 
productions <A 
href="http://www.w3.org/TR/2000/REC-xml-20001006#NT-Char">Char</A><SUP> 
<SMALL>XML</SMALL></SUP> and <A 
href="http://www.w3.org/TR/REC-xml-names/#NT-NCName">NCName</A><SUP> 
<SMALL>Names</SMALL></SUP>, are defined by reference to the XML and XML 
Namespaces specifications. There are slight variations between the XML 1.0 and 
XML 1.1 versions of these productions. <SPAN>Implementations <SPAN 
class=verb>may</SPAN> support either version; it is <SPAN 
class=verb>recommended</SPAN> that an XSLT 2.0 processor that implements the 1.1 
versions <SPAN class=verb>should</SPAN> also provide a mode that supports the 
1.0 versions. It is thus <A title=implementation-defined 
href="REC-xslt20-20070123.htm#dt-implementation-defined">implementation-defined</A> 
whether the XSLT processor supports XML 1.0 with XML Namespaces 1.0, or XML 1.1 
with XML Namespaces 1.1, or supports both versions at user option.</SPAN></P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>The specification referenced as <A 
href="REC-xslt20-20070123.htm#REC-xml-names">[Namespaces 
in XML 1.0]</A> was actually published without a version number.</P></DIV>
<P>At the time of writing there is no published version of <A 
href="REC-xslt20-20070123.htm#xmlschema-2">[XML Schema 
Part 2]</A> that references the XML 1.1 specifications. This means that data 
types such as <CODE>xs:NCName</CODE> and <CODE>xs:ID</CODE> are constrained by 
the XML 1.0 rules, and do not allow the full range of values permitted by XML 
1.1. This situation will not be resolved until a new version of <A 
href="REC-xslt20-20070123.htm#xmlschema-2">[XML Schema 
Part 2]</A> becomes available; in the meantime, it is <SPAN 
class=verb>recommended</SPAN> that implementers wishing to support XML 1.1 
should consult <A 
href="REC-xslt20-20070123.htm#SCHEMA-AND-XML-1.1">[XML 
Schema 1.0 and XML 1.1]</A> for guidance. An XSLT 2.0 processor that supports 
XML 1.1 <SPAN class=verb>should</SPAN> implement the rules in later versions of 
<A href="REC-xslt20-20070123.htm#xmlschema-2">[XML Schema 
Part 2]</A> as they become available.</P></DIV>
<DIV class=div2>
<H3><A id=stylesheet-stripping name=stylesheet-stripping></A>4.2 Stripping 
Whitespace from the Stylesheet</H3>
<P>The tree representing the stylesheet is preprocessed as follows:</P>
<OL class=enumar>
  <LI>
  <P>All comments and processing instructions are removed.</P>
  <LI>
  <P>Any text nodes that are now adjacent to each other are merged.</P>
  <LI>
  <P>Any <A title="whitespace text node" 
  href="REC-xslt20-20070123.htm#dt-whitespace-text-node">whitespace 
  text node</A> that satisfies both the following conditions is removed from the 
  tree:</P>
  <UL>
    <LI>
    <P>The parent of the text node is not an <A 
    href="REC-xslt20-20070123.htm#element-text"><CODE>xsl:text</CODE></A> 
    element</P>
    <LI>
    <P>The text node does not have an ancestor element that has an 
    <CODE>xml:space</CODE> attribute with a value of <CODE>preserve</CODE>, 
    unless there is a closer ancestor element having an <CODE>xml:space</CODE> 
    attribute with a value of <CODE>default</CODE>.</P></LI></UL>
  <LI>
  <P>Any <A title="whitespace text node" 
  href="REC-xslt20-20070123.htm#dt-whitespace-text-node">whitespace 
  text node</A> whose parent is one of the following elements is removed from 
  the tree, regardless of any <CODE>xml:space</CODE> attributes:</P>
  <BLOCKQUOTE>
    <P><A 
    href="REC-xslt20-20070123.htm#element-analyze-string"><CODE>xsl:analyze-string</CODE></A><BR><A 
    href="REC-xslt20-20070123.htm#element-apply-imports"><CODE>xsl:apply-imports</CODE></A><BR><A 
    href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A><BR><A 
    href="REC-xslt20-20070123.htm#element-attribute-set"><CODE>xsl:attribute-set</CODE></A><BR><A 
    href="REC-xslt20-20070123.htm#element-call-template"><CODE>xsl:call-template</CODE></A><BR><A 
    href="REC-xslt20-20070123.htm#element-character-map"><CODE>xsl:character-map</CODE></A><BR><A 
    href="REC-xslt20-20070123.htm#element-choose"><CODE>xsl:choose</CODE></A><BR><A 
    href="REC-xslt20-20070123.htm#element-next-match"><CODE>xsl:next-match</CODE></A><BR><A 
    href="REC-xslt20-20070123.htm#element-stylesheet"><CODE>xsl:stylesheet</CODE></A><BR><A 
    href="REC-xslt20-20070123.htm#element-transform"><CODE>xsl:transform</CODE></A></P></BLOCKQUOTE>
  <LI>
  <P>Any <A title="whitespace text node" 
  href="REC-xslt20-20070123.htm#dt-whitespace-text-node">whitespace 
  text node</A> whose following-sibling node is an <A 
  href="REC-xslt20-20070123.htm#element-param"><CODE>xsl:param</CODE></A> 
  or <A 
  href="REC-xslt20-20070123.htm#element-sort"><CODE>xsl:sort</CODE></A> 
  element is removed from the tree, regardless of any <CODE>xml:space</CODE> 
  attributes.</P></LI></OL>
<P><A id=err-XTSE0260 name=err-XTSE0260><SPAN class=error>[ERR 
XTSE0260]</SPAN></A> Within an <A title="XSLT element" 
href="REC-xslt20-20070123.htm#dt-xslt-element">XSLT 
element</A> that is <SPAN class=verb>required</SPAN> to be empty, any content 
other than comments or processing instructions, including any <A 
title="whitespace text node" 
href="REC-xslt20-20070123.htm#dt-whitespace-text-node">whitespace 
text node</A> preserved using the <CODE>xml:space="preserve"</CODE> attribute, 
is a <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A>.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>Using <CODE>xml:space="preserve"</CODE> in parts of the stylesheet that 
contain <A title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructors</A> will cause all text nodes in that part of the stylesheet, 
including those that contain whitespace only, to be copied to the result of the 
sequence constructor. When the result of the sequence constructor is used to 
form the content of an element, this can cause errors if such text nodes are 
followed by attribute nodes generated using <A 
href="REC-xslt20-20070123.htm#element-attribute"><CODE>xsl:attribute</CODE></A>.</P></DIV>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>If an <CODE>xml:space</CODE> attribute is specified on a <A 
title="literal result element" 
href="REC-xslt20-20070123.htm#dt-literal-result-element">literal 
result element</A>, it will be copied to the result tree in the same way as any 
other attribute.</P></DIV></DIV>
<DIV class=div2>
<H3><A id=stripping-annotations name=stripping-annotations></A>4.3 Stripping 
Type Annotations from a Source Tree</H3>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-annotation 
title="type annotation" name=dt-annotation></A>The term <B>type annotation</B> 
is used in this specification to refer to the value returned by the 
<CODE>dm:type-name</CODE> accessor of a node: see <A 
href="http://www.w3.org/TR/xpath-datamodel/#dm-type-name">Section 5.14 type-name 
Accessor</A><SUP><SMALL>DM</SMALL></SUP>.<SPAN class=definition>]</SPAN></P>
<P>There is sometimes a requirement to write stylesheets that produce the same 
results whether or not the source documents have been validated against a 
schema. To achieve this, an option is provided to remove any <A 
title="type annotation" 
href="REC-xslt20-20070123.htm#dt-annotation">type 
annotations</A> on element and attribute nodes in a <A title="source tree" 
href="REC-xslt20-20070123.htm#dt-source-tree">source 
tree</A>, replacing them with an annotation of 
<SPAN><CODE>xs:untyped</CODE></SPAN> in the case of element nodes, and 
<SPAN><CODE>xs:untypedAtomic</CODE></SPAN> in the case of attribute nodes.</P>
<P>Such stripping of <A title="type annotation" 
href="REC-xslt20-20070123.htm#dt-annotation">type 
annotations</A> can be requested by specifying 
<CODE>input-type-annotations="strip"</CODE> on the <A 
href="REC-xslt20-20070123.htm#element-stylesheet"><CODE>xsl:stylesheet</CODE></A> 
element. This attribute has three permitted values: <CODE>strip</CODE>, 
<CODE>preserve</CODE>, and <CODE>unspecified</CODE>. The default value is 
<CODE>unspecified</CODE>. Stripping of type annotations takes place if at least 
one <A title="stylesheet module" 
href="REC-xslt20-20070123.htm#dt-stylesheet-module">stylesheet 
module</A> in the <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
specifies <CODE>input-type-annotations="strip"</CODE>.</P>
<P><A id=err-XTSE0265 name=err-XTSE0265><SPAN class=error>[ERR 
XTSE0265]</SPAN></A> It is a <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A> if there is a <A title="stylesheet module" 
href="REC-xslt20-20070123.htm#dt-stylesheet-module">stylesheet 
module</A> in the <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
that specifies <CODE>input-type-annotations="strip"</CODE> and another <A 
title="stylesheet module" 
href="REC-xslt20-20070123.htm#dt-stylesheet-module">stylesheet 
module</A> that specifies <CODE>input-type-annotations="preserve"</CODE>.</P>
<P>The <A title="source tree" 
href="REC-xslt20-20070123.htm#dt-source-tree">source 
trees</A> to which this applies are the same as those affected by <A 
href="REC-xslt20-20070123.htm#element-strip-space"><CODE>xsl:strip-space</CODE></A> 
and <A 
href="REC-xslt20-20070123.htm#element-preserve-space"><CODE>xsl:preserve-space</CODE></A>: 
see <A href="REC-xslt20-20070123.htm#strip"><I>4.4 
Stripping Whitespace from a Source Tree</I></A>.</P>
<P>When type annotations are stripped, the following changes are made to the 
source tree:</P>
<UL>
  <LI>
  <P>The type annotation of every element node is changed to 
  <CODE>xs:untyped</CODE></P>
  <LI>
  <P>The type annotation of every attribute node is changed to 
  <CODE>xs:untypedAtomic</CODE></P>
  <LI>
  <P>The typed value of every element and attribute node is set to be the same 
  as its string value, as an instance of <CODE>xs:untypedAtomic</CODE>.</P>
  <LI>
  <P>The <CODE>is-nilled</CODE> property of every element node is set to 
  <CODE>false</CODE>.</P></LI></UL>
<P>The values of the <CODE>is-id</CODE> and <CODE>is-idrefs</CODE> properties 
are not changed.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>Stripping type annotations does not necessarily return the document to the 
state it would be in had validation not taken place. In particular, any 
defaulted elements and attributes that were added to the tree by the validation 
process will still be present <SPAN>, and elements and attributes validated as 
IDs will still be accessible using the <A 
href="http://www.w3.org/TR/xpath-functions/#func-id"><CODE>id</CODE></A><SUP> 
<SMALL>FO</SMALL></SUP> function</SPAN>.</P></DIV></DIV>
<DIV class=div2>
<H3><A id=strip name=strip></A>4.4 Stripping Whitespace from a Source Tree</H3>
<P>A <A title="source tree" 
href="REC-xslt20-20070123.htm#dt-source-tree">source 
tree</A> supplied as input to the transformation process may contain <A 
title="whitespace text node" 
href="REC-xslt20-20070123.htm#dt-whitespace-text-node">whitespace 
text nodes</A> that are of no interest, and that do not need to be retained by 
the transformation. Conceptually, an XSLT <A title=processor 
href="REC-xslt20-20070123.htm#dt-processor">processor</A> 
makes a copy of the source tree from which unwanted <A 
title="whitespace text node" 
href="REC-xslt20-20070123.htm#dt-whitespace-text-node">whitespace 
text nodes</A> have been removed. This process is referred to as whitespace 
stripping.</P>
<P>For the purposes of this section, the term <B>source tree</B> means the 
document containing the <A title="initial context node" 
href="REC-xslt20-20070123.htm#dt-initial-context-node">initial 
context node</A>, and any document returned by the functions <A 
href="REC-xslt20-20070123.htm#function-document"><CODE>document</CODE></A>, 
<A 
href="http://www.w3.org/TR/xpath-functions/#func-doc"><CODE>doc</CODE></A><SUP> 
<SMALL>FO</SMALL></SUP>, or <A 
href="http://www.w3.org/TR/xpath-functions/#func-collection"><CODE>collection</CODE></A><SUP><SMALL>FO</SMALL></SUP>. 
It does not include documents passed as the values of <A 
title="stylesheet parameter" 
href="REC-xslt20-20070123.htm#dt-stylesheet-parameter">stylesheet 
parameters</A> or returned from <A title="extension function" 
href="REC-xslt20-20070123.htm#dt-extension-function">extension 
functions</A>.</P>
<P>The stripping process takes as input a set of element names whose child <A 
title="whitespace text node" 
href="REC-xslt20-20070123.htm#dt-whitespace-text-node">whitespace 
text nodes</A> are to be preserved. The way in which this set of element names 
is established using the <A 
href="REC-xslt20-20070123.htm#element-strip-space"><CODE>xsl:strip-space</CODE></A> 
and <A 
href="REC-xslt20-20070123.htm#element-preserve-space"><CODE>xsl:preserve-space</CODE></A> 
declarations is described later in this section.</P>
<P>A <A title="whitespace text node" 
href="REC-xslt20-20070123.htm#dt-whitespace-text-node">whitespace 
text node</A> is preserved if either of the following apply:</P>
<UL>
  <LI>
  <P>The element name of the parent of the text node is in the set of 
  whitespace-preserving element names.</P>
  <LI>
  <P>An ancestor element of the text node has an <CODE>xml:space</CODE> 
  attribute with a value of <CODE>preserve</CODE>, and no closer ancestor 
  element has <CODE>xml:space</CODE> with a value of 
  <CODE>default</CODE>.</P></LI></UL>
<P>Otherwise, the <A title="whitespace text node" 
href="REC-xslt20-20070123.htm#dt-whitespace-text-node">whitespace 
text node</A> is stripped.</P>
<P>The <CODE>xml:space</CODE> attributes are not removed from the tree.</P>
<P class=element-syntax><A id=element-strip-space 
name=element-strip-space></A><CODE>&lt;!-- Category: declaration 
--&gt;<BR>&lt;xsl:strip-space<BR>&nbsp;&nbsp;<B>elements</B> = 
<VAR>tokens</VAR>&nbsp;/&gt;</CODE></P>
<P class=element-syntax><A id=element-preserve-space 
name=element-preserve-space></A><CODE>&lt;!-- Category: declaration 
--&gt;<BR>&lt;xsl:preserve-space<BR>&nbsp;&nbsp;<B>elements</B> = 
<VAR>tokens</VAR>&nbsp;/&gt;</CODE></P>
<P>The set of whitespace-preserving element names is specified by <A 
href="REC-xslt20-20070123.htm#element-strip-space"><CODE>xsl:strip-space</CODE></A> 
and <A 
href="REC-xslt20-20070123.htm#element-preserve-space"><CODE>xsl:preserve-space</CODE></A> 
<A title=declaration 
href="REC-xslt20-20070123.htm#dt-declaration">declarations</A>. 
Whether an element name is included in the set of whitespace-preserving names is 
determined by the best match among all the <A 
href="REC-xslt20-20070123.htm#element-strip-space"><CODE>xsl:strip-space</CODE></A> 
or <A 
href="REC-xslt20-20070123.htm#element-preserve-space"><CODE>xsl:preserve-space</CODE></A> 
declarations: it is included if and only if there is no match or the best match 
is an <A 
href="REC-xslt20-20070123.htm#element-preserve-space"><CODE>xsl:preserve-space</CODE></A> 
element. The <A 
href="REC-xslt20-20070123.htm#element-strip-space"><CODE>xsl:strip-space</CODE></A> 
and <A 
href="REC-xslt20-20070123.htm#element-preserve-space"><CODE>xsl:preserve-space</CODE></A> 
elements each have an <CODE>elements</CODE> attribute whose value is a 
whitespace-separated list of <A 
href="http://www.w3.org/TR/xpath20/#doc-xpath-NameTest">NameTests</A><SUP> 
<SMALL>XP</SMALL></SUP>; an element name matches an <A 
href="REC-xslt20-20070123.htm#element-strip-space"><CODE>xsl:strip-space</CODE></A> 
or <A 
href="REC-xslt20-20070123.htm#element-preserve-space"><CODE>xsl:preserve-space</CODE></A> 
element if it matches one of the <A 
href="http://www.w3.org/TR/xpath20/#doc-xpath-NameTest">NameTests</A><SUP> 
<SMALL>XP</SMALL></SUP>. An element matches a <A 
href="http://www.w3.org/TR/xpath20/#doc-xpath-NameTest">NameTest</A><SUP> 
<SMALL>XP</SMALL></SUP> if and only if the <A 
href="http://www.w3.org/TR/xpath20/#doc-xpath-NameTest">NameTest</A><SUP> 
<SMALL>XP</SMALL></SUP> would be true for the element as an XPath node test. 
When more than one <A 
href="REC-xslt20-20070123.htm#element-strip-space"><CODE>xsl:strip-space</CODE></A> 
and <A 
href="REC-xslt20-20070123.htm#element-preserve-space"><CODE>xsl:preserve-space</CODE></A> 
element matches, the best matching element is determined by the best matching <A 
href="http://www.w3.org/TR/xpath20/#doc-xpath-NameTest">NameTest</A><SUP> 
<SMALL>XP</SMALL></SUP>. This is determined in the same way as with <A 
title="template rule" 
href="REC-xslt20-20070123.htm#dt-template-rule">template 
rules</A>:</P>
<UL>
  <LI>
  <P>First, any match with lower <A title="import precedence" 
  href="REC-xslt20-20070123.htm#dt-import-precedence">import 
  precedence</A> than another match is ignored.</P>
  <LI>
  <P>Next, any match that has a lower <A title="default priority" 
  href="REC-xslt20-20070123.htm#dt-default-priority">default 
  priority</A> than the <A title="default priority" 
  href="REC-xslt20-20070123.htm#dt-default-priority">default 
  priority</A> of another match is ignored.</P></LI></UL>
<P><A id=err-XTRE0270 name=err-XTRE0270><SPAN class=error>[ERR 
XTRE0270]</SPAN></A> It is a <A title="recoverable error" 
href="REC-xslt20-20070123.htm#dt-recoverable-error">recoverable 
dynamic error</A> if this leaves more than one match<SPAN>, unless all the 
matched declarations are equivalent (that is, they are all <A 
href="REC-xslt20-20070123.htm#element-strip-space"><CODE>xsl:strip-space</CODE></A> 
or they are all <A 
href="REC-xslt20-20070123.htm#element-preserve-space"><CODE>xsl:preserve-space</CODE></A>)</SPAN>. 
<SPAN>The <A title="optional recovery action" 
href="REC-xslt20-20070123.htm#dt-optional-recovery-action">optional 
recovery action</A> is to select, from the matches that are left, the one that 
occurs last in <A title="declaration order" 
href="REC-xslt20-20070123.htm#dt-declaration-order">declaration 
order</A>.</SPAN></P>
<P>If an element in a source document has a <A title="type annotation" 
href="REC-xslt20-20070123.htm#dt-annotation">type 
annotation</A> that is a simple type or a complex type with simple content, then 
any whitespace text nodes among its children are preserved, regardless of any <A 
href="REC-xslt20-20070123.htm#element-strip-space"><CODE>xsl:strip-space</CODE></A> 
declarations. The reason for this is that stripping a whitespace text node from 
an element with simple content could make the element invalid: for example, it 
could cause the <CODE>minLength</CODE> facet to be violated.</P>
<P>Stripping of <A title="type annotation" 
href="REC-xslt20-20070123.htm#dt-annotation">type 
annotations</A> happens before stripping of whitespace text nodes, so this 
<SPAN>situation</SPAN> will not occur if 
<CODE>input-type-annotations="strip"</CODE> is specified.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>In <A 
href="REC-xslt20-20070123.htm#xpath-datamodel">[Data 
Model]</A>, processes are described for constructing an <SPAN>XDM tree</SPAN> 
from an Infoset or from a PSVI. Those processes deal with whitespace according 
to their own rules, and the provisions in this section apply to the resulting 
tree. In practice this means that elements that are defined in a DTD or a Schema 
to contain element-only content will have <A title="whitespace text node" 
href="REC-xslt20-20070123.htm#dt-whitespace-text-node">whitespace 
text nodes</A> stripped, regardless of the <A 
href="REC-xslt20-20070123.htm#element-strip-space"><CODE>xsl:strip-space</CODE></A> 
and <A 
href="REC-xslt20-20070123.htm#element-preserve-space"><CODE>xsl:preserve-space</CODE></A> 
declarations in the stylesheet.</P>
<P>However, source trees are not necessarily constructed using those processes; 
indeed, they are not necessarily constructed by parsing XML documents. Nothing 
in the XSLT specification constrains how the source tree is constructed, or what 
happens to <A title="whitespace text node" 
href="REC-xslt20-20070123.htm#dt-whitespace-text-node">whitespace 
text nodes</A> during its construction. The provisions in this section relate 
only to whitespace text nodes that are present in the tree supplied as input to 
the XSLT processor. The XSLT processor cannot preserve whitespace text nodes 
unless they were actually present in the supplied tree.</P></DIV></DIV>
<DIV class=div2>
<H3><A id=id-in-data-model name=id-in-data-model></A>4.5 Attribute Types and DTD 
Validation</H3>
<P>The mapping from the Infoset to the <SPAN>XDM</SPAN> data model, described in 
<A href="REC-xslt20-20070123.htm#xpath-datamodel">[Data 
Model]</A>, does not retain attribute types. This means, for example, that an 
attribute described in the DTD as having attribute type <CODE>NMTOKENS</CODE> 
will be annotated in <SPAN>the XDM tree</SPAN> as 
<SPAN><CODE>xs:untypedAtomic</CODE></SPAN> rather than <CODE>xs:NMTOKENS</CODE>, 
and its typed value will consist of a single 
<SPAN><CODE>xs:untypedAtomic</CODE></SPAN> value rather than a sequence of 
<CODE>xs:NMTOKEN</CODE> values.</P>
<P>Attributes with a DTD-derived type of ID, IDREF, or IDREFS will be marked in 
the <SPAN>XDM tree</SPAN> as having the <CODE>is-id</CODE> or 
<CODE>is-idrefs</CODE> properties. It is these properties, rather than any <A 
title="type annotation" 
href="REC-xslt20-20070123.htm#dt-annotation">type 
annotation</A>, that are examined by the functions <A 
href="http://www.w3.org/TR/xpath-functions/#func-id"><CODE>id</CODE></A><SUP> 
<SMALL>FO</SMALL></SUP> and <A 
href="http://www.w3.org/TR/xpath-functions/#func-idref"><CODE>idref</CODE></A><SUP> 
<SMALL>FO</SMALL></SUP> described in <A 
href="REC-xslt20-20070123.htm#xpath-functions">[Functions 
and Operators]</A>.</P></DIV>
<DIV class=div2>
<H3><A id=limits name=limits></A>4.6 Limits</H3>
<P>The XDM data model (see <A 
href="REC-xslt20-20070123.htm#xpath-datamodel">[Data 
Model]</A>) leaves it to the host language to define limits. This section 
describes the limits that apply to XSLT.</P>
<P>Limits on some primitive data types are defined in <A 
href="REC-xslt20-20070123.htm#xmlschema-2">[XML Schema 
Part 2]</A>. Other limits, listed below, are <A title=implementation-defined 
href="REC-xslt20-20070123.htm#dt-implementation-defined">implementation-defined</A>. 
Note that this does not necessarily mean that each limit must be a simple 
constant: it may vary depending on environmental factors such as available 
resources.</P>
<P>The following limits are <A title=implementation-defined 
href="REC-xslt20-20070123.htm#dt-implementation-defined">implementation-defined</A>:</P>
<OL class=enumar>
  <LI>
  <P>For the <CODE>xs:decimal</CODE> type, the maximum number of decimal digits 
  (the <CODE>totalDigits</CODE> facet). This must be at least 18 digits. (Note, 
  however, that support for the full value range of <CODE>xs:unsignedLong</CODE> 
  requires 20 digits.)</P>
  <LI>
  <P>For the types <CODE>xs:date</CODE>, <CODE>xs:time</CODE>, 
  <CODE>xs:dateTime</CODE>, <CODE>xs:gYear</CODE>, and 
  <CODE>xs:gYearMonth</CODE>: the range of values of the year component, which 
  must be at least +0001 to +9999; and the maximum number of fractional second 
  digits, which must be at least 3.</P>
  <LI>
  <P>For the <CODE>xs:duration</CODE> type: the maximum absolute values of the 
  years, months, days, hours, minutes, and seconds components.</P>
  <LI>
  <P>For the <SPAN><CODE>xs:yearMonthDuration</CODE></SPAN> type: the maximum 
  absolute value, expressed as an integer number of months.</P>
  <LI>
  <P>For the <SPAN><CODE>xs:dayTimeDuration</CODE></SPAN> type: the maximum 
  absolute value, expressed as a decimal number of seconds.</P>
  <LI>
  <P>For the types <CODE>xs:string</CODE>, <CODE>xs:hexBinary</CODE>, 
  <CODE>xs:base64Binary</CODE>, <CODE>xs:QName</CODE>, <CODE>xs:anyURI</CODE>, 
  <CODE>xs:NOTATION</CODE>, and types derived from them: the maximum length of 
  the value.</P>
  <LI>
  <P>For sequences, the maximum number of items in a sequence.</P></LI></OL></DIV>
<DIV class=div2>
<H3><A id=d-o-e-in-data-model name=d-o-e-in-data-model></A>4.7 Disable Output 
Escaping</H3>
<P>For backwards compatibility reasons, XSLT 2.0 continues to support the 
<CODE>disable-output-escaping</CODE> feature introduced in XSLT 1.0. This is an 
optional feature and implementations are not <SPAN class=verb>required</SPAN> to 
support it. A new facility, that of named <A title="character map" 
href="REC-xslt20-20070123.htm#dt-character-map">character 
maps</A> (see <A 
href="REC-xslt20-20070123.htm#character-maps"><I>20.1 
Character Maps</I></A>) is introduced in XSLT 2.0. It provides similar 
capabilities to <CODE>disable-output-escaping</CODE>, but without distorting the 
data model.</P>
<P>If an <A title=implementation 
href="REC-xslt20-20070123.htm#dt-implementation">implementation</A> 
supports the <CODE>disable-output-escaping</CODE> attribute of <A 
href="REC-xslt20-20070123.htm#element-text"><CODE>xsl:text</CODE></A> 
and <A 
href="REC-xslt20-20070123.htm#element-value-of"><CODE>xsl:value-of</CODE></A>, 
(see <A 
href="REC-xslt20-20070123.htm#disable-output-escaping"><I>20.2 
Disabling Output Escaping</I></A>), then the data model for trees constructed by 
the <A title=processor 
href="REC-xslt20-20070123.htm#dt-processor">processor</A> 
is augmented with a boolean value representing the value of this property. 
<SPAN>This boolean value, however, can be set only within a <A 
title="final result tree" 
href="REC-xslt20-20070123.htm#dt-final-result-tree">final 
result tree</A> that is being passed to the serializer.</SPAN></P>
<P>Conceptually, each character in a text node on <SPAN>such</SPAN> a result 
tree has a boolean property indicating whether the serializer <SPAN>is to</SPAN> 
disable the normal rules for escaping of special characters (for example, 
outputting of <CODE>&amp;</CODE> as <CODE>&amp;amp;</CODE>) in respect of this 
character or attribute node.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>In practice, the nodes in a <A title="final result tree" 
href="REC-xslt20-20070123.htm#dt-final-result-tree">final 
result tree</A> will often be streamed directly from the XSLT processor to the 
serializer. In such an implementation, <CODE>disable-output-escaping</CODE> can 
be viewed not so much a property stored with nodes in the tree, but rather as 
additional information passed across the interface between the XSLT processor 
and the serializer.</P></DIV></DIV></DIV>
<DIV class=div1>
<H2><A id=constructs name=constructs></A>5 Features of the XSLT Language</H2>
<DIV class=div2>
<H3><A id=qname name=qname></A>5.1 Qualified Names</H3>
<P>The name of a stylesheet-defined object, specifically a <A 
title="named template" 
href="REC-xslt20-20070123.htm#dt-named-template">named 
template</A>, a <A title=mode 
href="REC-xslt20-20070123.htm#dt-mode">mode</A>, an <A 
title="attribute set" 
href="REC-xslt20-20070123.htm#dt-attribute-set">attribute 
set</A>, a <A title=key 
href="REC-xslt20-20070123.htm#dt-key">key</A>, a <A 
title="decimal format" 
href="REC-xslt20-20070123.htm#dt-decimal-format">decimal-format</A>, 
a <A title=variable 
href="REC-xslt20-20070123.htm#dt-variable">variable</A> 
or <A title=parameter 
href="REC-xslt20-20070123.htm#dt-parameter">parameter</A>, 
a <A title="stylesheet function" 
href="REC-xslt20-20070123.htm#dt-stylesheet-function">stylesheet 
function</A>, a named <A title="output definition" 
href="REC-xslt20-20070123.htm#dt-output-definition">output 
definition</A>, <SPAN>or a <A title="character map" 
href="REC-xslt20-20070123.htm#dt-character-map">character 
map</A></SPAN> is specified as a <A title=QName 
href="REC-xslt20-20070123.htm#dt-qname">QName</A> 
<SPAN>using the syntax for <A 
href="http://www.w3.org/TR/REC-xml-names/#NT-QName">QName</A><SUP> 
<SMALL>Names</SMALL></SUP> as defined in <A 
href="REC-xslt20-20070123.htm#REC-xml-names">[Namespaces 
in XML 1.0]</A></SPAN>.</P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-qname title=QName 
name=dt-qname></A>A <B>QName</B> is always written in the form <CODE>(NCName 
":")? NCName</CODE>, that is, a local name optionally preceded by a namespace 
prefix. When two QNames are compared, however, they are considered equal if the 
corresponding <A title=expanded-QName 
href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded-QNames</A> 
are the same, as described below.<SPAN class=definition>]</SPAN></P>
<P>Because an atomic value of type <CODE>xs:QName</CODE> is sometimes referred 
to loosely as a QName, this specification also uses the term <A 
title="lexical QName" 
href="REC-xslt20-20070123.htm#dt-lexical-qname">lexical 
QName</A> to emphasize that it is referring to a <A 
href="http://www.w3.org/TR/REC-xml-names/#NT-QName">QName</A><SUP> 
<SMALL>Names</SMALL></SUP> in its lexical form rather than its expanded form. 
This term is used especially when strings containing lexical QNames are 
manipulated as run-time values.</P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-lexical-qname 
title="lexical QName" name=dt-lexical-qname></A>A <B>lexical QName</B> is a 
string representing a <A title=QName 
href="REC-xslt20-20070123.htm#dt-qname">QName</A> in the 
form <CODE>(NCName ":")? NCName</CODE>, that is, a local name optionally 
preceded by a namespace prefix.<SPAN class=definition>]</SPAN></P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-defining-element 
title="defining element" name=dt-defining-element></A><SPAN>A string in the form 
of a lexical QName</SPAN> may occur as the value of an attribute node in a 
stylesheet module, or within an XPath <A title=expression 
href="REC-xslt20-20070123.htm#dt-expression">expression</A> 
contained in such an attribute node, or as the result of evaluating an XPath 
expression contained in such an attribute node. The element containing this 
attribute node is referred to as the <B>defining element</B> of the QName.<SPAN 
class=definition>]</SPAN></P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-expanded-qname 
title=expanded-QName name=dt-expanded-qname></A>An <B>expanded-QName</B> 
<SPAN>contains a pair of values, namely a local name and an optional namespace 
URI. It may also contain a namespace prefix.</SPAN> Two expanded-QNames are 
equal if the namespace URIs are the same (or both absent) and the local names 
are the same. <SPAN>The prefix plays no part in the comparison, but is used only 
if the expanded-QName needs to be converted back to a string.</SPAN><SPAN 
class=definition>]</SPAN></P>
<P>If the QName has a prefix, then the prefix is expanded into a URI reference 
using the namespace declarations in effect on its <A title="defining element" 
href="REC-xslt20-20070123.htm#dt-defining-element">defining 
element</A>. The <A title=expanded-QName 
href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded-QName</A> 
consisting of the local part of the name and the possibly null URI reference is 
used as the name of the object. The default namespace of the defining element 
(<SPAN>see <A href="http://www.w3.org/TR/xpath-datamodel/#ElementNode">Section 
6.2 Element Nodes</A><SUP><SMALL>DM</SMALL></SUP></SPAN>) is <EM>not</EM> used 
for unprefixed names.</P>
<P>There are <SPAN>three</SPAN> cases where the default namespace <SPAN>of the 
<A title="defining element" 
href="REC-xslt20-20070123.htm#dt-defining-element">defining 
element</A></SPAN> <EM>is</EM> used when expanding an unprefixed QName:</P>
<OL class=enumar>
  <LI>
  <P>Where a QName is used to define the name of an element being constructed. 
  This applies both to cases where the name is known statically (that is, the 
  name of a literal result element) and to cases where it is computed 
  dynamically (the value of the <CODE>name</CODE> attribute of the <A 
  href="REC-xslt20-20070123.htm#element-element"><CODE>xsl:element</CODE></A> 
  instruction).</P>
  <LI>
  <P>The default namespace is used when expanding the first argument of the 
  function <A 
  href="REC-xslt20-20070123.htm#function-element-available"><CODE>element-available</CODE></A>.</P>
  <LI>
  <P>The default namespace applies to any unqualified element names appearing in 
  the <CODE>cdata-section-elements</CODE> attribute of <A 
  href="REC-xslt20-20070123.htm#element-output"><CODE>xsl:output</CODE></A> 
  or <A 
  href="REC-xslt20-20070123.htm#element-result-document"><CODE>xsl:result-document</CODE></A></P></LI></OL>
<P>In the case of an unprefixed QName used as a <CODE>NameTest</CODE> within an 
XPath <A title=expression 
href="REC-xslt20-20070123.htm#dt-expression">expression</A> 
(see <A href="REC-xslt20-20070123.htm#expressions"><I>5.3 
Expressions</I></A>) <SPAN>, and in certain other contexts</SPAN>, the namespace 
to be used in expanding the QName may be specified by means of the 
<CODE>[xsl:]xpath-default-namespace</CODE> attribute, as specified in <A 
href="REC-xslt20-20070123.htm#unprefixed-qnames"><I>5.2 
Unprefixed QNames in Expressions and Patterns</I></A>.</P>
<P><A id=err-XTSE0280 name=err-XTSE0280><SPAN class=error>[ERR 
XTSE0280]</SPAN></A> In the case of a <SPAN>prefixed</SPAN> <A title=QName 
href="REC-xslt20-20070123.htm#dt-qname">QName</A> used as 
the value of an attribute in the <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A>, 
or appearing within an XPath <A title=expression 
href="REC-xslt20-20070123.htm#dt-expression">expression</A> 
in the stylesheet, it is a <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A> if the <A title="defining element" 
href="REC-xslt20-20070123.htm#dt-defining-element">defining 
element</A> has no namespace node whose name matches the prefix of the <A 
title=QName 
href="REC-xslt20-20070123.htm#dt-qname">QName</A>.</P>
<P><A id=err-XTDE0290 name=err-XTDE0290><SPAN class=error>[ERR 
XTDE0290]</SPAN></A> Where the result of evaluating an XPath expression (or an 
attribute value template) is required to be a <A title="lexical QName" 
href="REC-xslt20-20070123.htm#dt-lexical-qname">lexical 
QName</A>, <SPAN>then unless otherwise specified</SPAN> it is a <A 
title="non-recoverable dynamic error" 
href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
dynamic error</A> if the <A title="defining element" 
href="REC-xslt20-20070123.htm#dt-defining-element">defining 
element</A> has no namespace node whose name matches the prefix of the <A 
title="lexical QName" 
href="REC-xslt20-20070123.htm#dt-lexical-qname">lexical 
QName</A>. <SPAN>This error <SPAN class=verb>may</SPAN> be signaled as a <A 
title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A> if the value of the expression can be determined 
statically.</SPAN></P></DIV>
<DIV class=div2>
<H3><A id=unprefixed-qnames name=unprefixed-qnames></A>5.2 Unprefixed QNames in 
Expressions and Patterns</H3>
<P>The attribute <CODE>[xsl:]xpath-default-namespace</CODE> (see <A 
href="REC-xslt20-20070123.htm#standard-attributes"><I>3.5 
Standard Attributes</I></A>) may be used on an element in the <A 
title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
to define the namespace that will be used for an unprefixed element name 
<SPAN>or type name</SPAN> within an XPath expression, and in certain other 
contexts listed below.</P>
<P>The value of the attribute is the namespace URI to be used.</P>
<P>For any element in the <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A>, 
this attribute has an effective value, which is the value of the 
<CODE>[xsl:]xpath-default-namespace</CODE> on that element or on the innermost 
containing element that specifies such an attribute, or the zero-length string 
if no containing element specifies such an attribute.</P>
<P>For any element in the <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A>, 
the effective value of this attribute determines the value of the <EM>default 
namespace for element and type names</EM> in the static context of any XPath 
expression contained in an attribute of that element <SPAN>(including XPath 
expressions in <A title="attribute value template" 
href="REC-xslt20-20070123.htm#dt-attribute-value-template">attribute 
value templates</A>)</SPAN>. The effect of this is specified in <A 
href="REC-xslt20-20070123.htm#xpath20">[XPath 2.0]</A>; 
in summary, it determines the namespace used for any unprefixed type name in the 
SequenceType production, and for any element name appearing in a path expression 
or in the SequenceType production.</P>
<P>The effective value of this attribute similarly applies to <SPAN>any of the 
following constructs appearing within its scope</SPAN>:</P>
<UL>
  <LI>
  <P>any unprefixed element name or type name used in a <A title=pattern 
  href="REC-xslt20-20070123.htm#dt-pattern">pattern</A></P>
  <LI>
  <P>any unprefixed element name used in the <CODE>elements</CODE> attribute of 
  the <A 
  href="REC-xslt20-20070123.htm#element-strip-space"><CODE>xsl:strip-space</CODE></A> 
  or <A 
  href="REC-xslt20-20070123.htm#element-preserve-space"><CODE>xsl:preserve-space</CODE></A> 
  instructions</P>
  <LI>
  <P>any unprefixed element name or type name used in the <CODE>as</CODE> 
  attribute of an <A title="XSLT element" 
  href="REC-xslt20-20070123.htm#dt-xslt-element">XSLT 
  element</A></P>
  <LI>
  <P>any unprefixed type name used in the <CODE>type</CODE> attribute of an <A 
  title="XSLT element" 
  href="REC-xslt20-20070123.htm#dt-xslt-element">XSLT 
  element</A></P>
  <LI>
  <P>any unprefixed type name used in the <CODE>xsl:type</CODE> attribute of a 
  <A title="literal result element" 
  href="REC-xslt20-20070123.htm#dt-literal-result-element">literal 
  result element</A>.</P></LI></UL>
<P>The <CODE>[xsl:]xpath-default-namespace</CODE> attribute <SPAN 
class=verb>must</SPAN> be in the <A title="XSLT namespace" 
href="REC-xslt20-20070123.htm#dt-xslt-namespace">XSLT 
namespace</A> if and only if its parent element is <EM>not</EM> in the XSLT 
namespace.</P>
<P>If the effective value of the attribute is a zero-length string, which will 
be the case if it is explicitly set to a zero-length string or if it is not 
specified at all, then an unprefixed element name or type name refers to a name 
that is in no namespace. The default namespace <SPAN>of the parent element (see 
<A href="http://www.w3.org/TR/xpath-datamodel/#ElementNode">Section 6.2 Element 
Nodes</A><SUP><SMALL>DM</SMALL></SUP>)</SPAN> is <EM>not</EM> used.</P>
<P>The attribute does not affect other names, for example function names, 
variable names, or template names, or strings that are interpreted as <A 
title="lexical QName" 
href="REC-xslt20-20070123.htm#dt-lexical-qname">lexical 
QNames</A> during stylesheet evaluation, such as the <A title="effective value" 
href="REC-xslt20-20070123.htm#dt-effective-value">effective 
value</A> of the <CODE>name</CODE> attribute of <A 
href="REC-xslt20-20070123.htm#element-element"><CODE>xsl:element</CODE></A> 
or the string supplied as the first argument to the <A 
href="REC-xslt20-20070123.htm#function-key"><CODE>key</CODE></A> 
function.</P></DIV>
<DIV class=div2>
<H3><A id=expressions name=expressions></A>5.3 Expressions</H3>
<P>XSLT uses the expression language defined by XPath 2.0 <A 
href="REC-xslt20-20070123.htm#xpath20">[XPath 2.0]</A>. 
Expressions are used in XSLT for a variety of purposes including:</P>
<UL>
  <LI>
  <P>selecting nodes for processing;</P>
  <LI>
  <P>specifying conditions for different ways of processing a node;</P>
  <LI>
  <P>generating text to be inserted in a <A title="result tree" 
  href="REC-xslt20-20070123.htm#dt-result-tree">result 
  tree</A>.</P></LI></UL>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-expression 
title=expression name=dt-expression></A>Within this specification, the term 
<B>XPath expression</B>, or simply <B>expression</B>, means a string that 
matches the production <SPAN><A 
href="http://www.w3.org/TR/xpath20/#doc-xpath-Expr">Expr</A><SUP> 
<SMALL>XP</SMALL></SUP></SPAN> defined in <A 
href="REC-xslt20-20070123.htm#xpath20">[XPath 
2.0]</A>.<SPAN class=definition>]</SPAN></P>
<P>An XPath expression may occur as the value of certain attributes on 
XSLT-defined elements, and also within curly brackets in <A 
title="attribute value template" 
href="REC-xslt20-20070123.htm#dt-attribute-value-template">attribute 
value templates</A>.</P>
<P>Except where <A title="forwards-compatible behavior" 
href="REC-xslt20-20070123.htm#dt-forwards-compatible-behavior">forwards-compatible 
behavior</A> is enabled (see <A 
href="REC-xslt20-20070123.htm#forwards"><I>3.9 
Forwards-Compatible Processing</I></A>), it is a <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A> if the value of such an attribute, or the text between curly brackets 
in an attribute value template, does not match the XPath production <A 
href="http://www.w3.org/TR/xpath20/#doc-xpath-Expr">Expr</A><SUP> 
<SMALL>XP</SMALL></SUP>, or if it fails to satisfy other static constraints 
defined in the XPath specification, for example that all variable references 
<SPAN class=verb>must</SPAN> refer to <A title=variable 
href="REC-xslt20-20070123.htm#dt-variable">variables</A> 
that are in scope. <SPAN>Error codes are defined in <A 
href="REC-xslt20-20070123.htm#xpath20">[XPath 
2.0]</A>.</SPAN></P>
<P>The transformation fails with a <A title="non-recoverable dynamic error" 
href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
dynamic error</A> if any XPath <A title=expression 
href="REC-xslt20-20070123.htm#dt-expression">expression</A> 
is evaluated and raises a dynamic error. <SPAN>Error codes are defined in <A 
href="REC-xslt20-20070123.htm#xpath20">[XPath 
2.0]</A>.</SPAN></P>
<P>The transformation fails with a <A title="type errors" 
href="REC-xslt20-20070123.htm#dt-type-error">type 
error</A> if an XPath <A title=expression 
href="REC-xslt20-20070123.htm#dt-expression">expression</A> 
raises a type error, or if the result of evaluating the XPath <A 
title=expression 
href="REC-xslt20-20070123.htm#dt-expression">expression</A> 
is evaluated and raises a type error, or if the XPath processor signals a type 
error during static analysis of an <A title=expression 
href="REC-xslt20-20070123.htm#dt-expression">expression</A>. 
<SPAN>Error codes are defined in <A 
href="REC-xslt20-20070123.htm#xpath20">[XPath 
2.0]</A>.</SPAN></P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-required-type 
title="required type" name=dt-required-type></A>The context within a <A 
title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
where an XPath <A title=expression 
href="REC-xslt20-20070123.htm#dt-expression">expression</A> 
<SPAN>appears may specify</SPAN> the <B>required type</B> of the expression. The 
required type indicates the type of the value that the expression is expected to 
return.<SPAN class=definition>]</SPAN> If no required type is specified, the 
expression may return any value: in effect, the required type is then 
<CODE>item()*</CODE>.</P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A 
id=dt-function-conversion-rules title="function conversion rules" 
name=dt-function-conversion-rules></A>Except where otherwise indicated, the 
actual value of an <A title=expression 
href="REC-xslt20-20070123.htm#dt-expression">expression</A> 
is converted to the <A title="required type" 
href="REC-xslt20-20070123.htm#dt-required-type">required 
type</A> using the <B>function conversion rules</B>. These are the rules defined 
in <A href="REC-xslt20-20070123.htm#xpath20">[XPath 
2.0]</A> for converting the supplied argument of a function call to the required 
type of that argument, as defined in the function signature. The relevant rules 
are those that apply when <A title="XPath 1.0 compatibility mode" 
href="REC-xslt20-20070123.htm#dt-compatibility-mode">XPath 
1.0 compatibility mode</A> is set to <CODE>false</CODE>.<SPAN 
class=definition>]</SPAN></P>
<P>This specification also invokes the XPath 2.0 <A 
title="function conversion rules" 
href="REC-xslt20-20070123.htm#dt-function-conversion-rules">function 
conversion rules</A> to convert the result of evaluating an XSLT <A 
title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A> to a required type (for example, the sequence constructor 
enclosed in an <A 
href="REC-xslt20-20070123.htm#element-variable"><CODE>xsl:variable</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-template"><CODE>xsl:template</CODE></A>, 
or <A 
href="REC-xslt20-20070123.htm#element-function"><CODE>xsl:function</CODE></A> 
element).</P>
<P>Any <A title="dynamic error" 
href="REC-xslt20-20070123.htm#dt-dynamic-error">dynamic 
error</A> or <A title="type errors" 
href="REC-xslt20-20070123.htm#dt-type-error">type 
error</A> that occurs when applying the <A title="function conversion rules" 
href="REC-xslt20-20070123.htm#dt-function-conversion-rules">function 
conversion rules</A> to convert a value to a required type results in the 
transformation failing, in the same way as if the error had occurred while 
evaluating an expression.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>Note the distinction between the two kinds of error that may occur. 
Attempting to convert an integer to a date is a type error, because such a 
conversion is never possible. Type errors can be reported statically if they can 
be detected statically, whether or not the construct in question is ever 
evaluated. Attempting to convert the string <CODE>2003-02-29</CODE> to a date is 
a dynamic error rather than a type error, because the problem is with this 
particular value, not with its type. Dynamic errors are reported only if the 
instructions or expressions that cause them are actually 
evaluated.</P></DIV></DIV>
<DIV class=div2>
<H3><A id=static-and-dynamic-context name=static-and-dynamic-context></A>5.4 The 
Static and Dynamic Context</H3>
<P>XPath defines the concept of an <A 
href="http://www.w3.org/TR/xpath20/#dt-expression-context">expression 
context</A><SUP><SMALL>XP</SMALL></SUP> which contains all the information that 
can affect the result of evaluating an <A title=expression 
href="REC-xslt20-20070123.htm#dt-expression">expression</A>. 
The expression context has two parts, the <A 
href="http://www.w3.org/TR/xpath20/#dt-static-context">static 
context</A><SUP><SMALL>XP</SMALL></SUP>, and the <A 
href="http://www.w3.org/TR/xpath20/#dt-dynamic-context">dynamic 
context</A><SUP><SMALL>XP</SMALL></SUP>. The components that make up the 
expression context are defined in the XPath specification (see <A 
href="http://www.w3.org/TR/xpath20/#context">Section 2.1 Expression 
Context</A><SUP><SMALL>XP</SMALL></SUP>). This section describes the way in 
which these components are initialized when an XPath expression is contained 
within an XSLT stylesheet.</P>
<P>As well as providing values for the static and dynamic context components 
defined in the XPath specification, XSLT defines additional context components 
of its own. These context components are used by XSLT instructions (for example, 
<A 
href="REC-xslt20-20070123.htm#element-next-match"><CODE>xsl:next-match</CODE></A> 
and <A 
href="REC-xslt20-20070123.htm#element-apply-imports"><CODE>xsl:apply-imports</CODE></A>), 
and also by the functions in the extended function library described in this 
specification.</P>
<P>The following four sections describe:</P>
<BLOCKQUOTE>
  <P><A 
  href="REC-xslt20-20070123.htm#static-context"><I>5.4.1 
  Initializing the Static Context</I></A><BR><A 
  href="REC-xslt20-20070123.htm#additional-static-context"><I>5.4.2 
  Additional Static Context Components used by XSLT</I></A><BR><A 
  href="REC-xslt20-20070123.htm#xpath-dynamic-context"><I>5.4.3 
  Initializing the Dynamic Context</I></A><BR><A 
  href="REC-xslt20-20070123.htm#additional-dynamic-context"><I>5.4.4 
  Additional Dynamic Context Components used by XSLT</I></A></P></BLOCKQUOTE>
<DIV class=div3>
<H4><A id=static-context name=static-context></A>5.4.1 Initializing the Static 
Context</H4>
<P>The <A href="http://www.w3.org/TR/xpath20/#dt-static-context">static 
context</A><SUP><SMALL>XP</SMALL></SUP> of an XPath expression appearing in an 
XSLT stylesheet is initialized as follows. In these rules, the term 
<B>containing element</B> means the element within the stylesheet that is the 
parent of the attribute whose value contains the XPath expression in question, 
and the term <B>enclosing element</B> means the containing element or any of its 
ancestors.</P>
<UL>
  <LI>
  <P><A title="XPath 1.0 compatibility mode" 
  href="REC-xslt20-20070123.htm#dt-compatibility-mode">XPath 
  1.0 compatibility mode</A> is set to true if and only if the containing 
  element occurs in part of the <A title=stylesheet 
  href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
  where <A title="backwards compatible behavior" 
  href="REC-xslt20-20070123.htm#dt-backwards-compatible-behavior">backwards 
  compatible behavior</A> is enabled (see <A 
  href="REC-xslt20-20070123.htm#backwards"><I>3.8 
  Backwards-Compatible Processing</I></A>).</P>
  <LI>
  <P>The <A href="http://www.w3.org/TR/xpath20/#dt-static-namespaces">statically 
  known namespaces</A><SUP><SMALL>XP</SMALL></SUP> are the namespace 
  declarations that are in scope for the containing element.</P>
  <LI>
  <P>The <A href="http://www.w3.org/TR/xpath20/#dt-def-elemtype-ns">default 
  element/type namespace</A><SUP><SMALL>XP</SMALL></SUP> is the namespace 
  defined by the <CODE>[xsl:]xpath-default-namespace</CODE> attribute on the 
  innermost enclosing element that has such an attribute, as described in <A 
  href="REC-xslt20-20070123.htm#unprefixed-qnames"><I>5.2 
  Unprefixed QNames in Expressions and Patterns</I></A>. The value of this 
  attribute is a namespace URI. <SPAN>If there is no 
  <CODE>[xsl:]xpath-default-namespace</CODE> attribute on an enclosing element, 
  the default namespace for element names and type names is the null 
  namespace.</SPAN></P>
  <LI>
  <P>The <A href="http://www.w3.org/TR/xpath20/#dt-def-fn-ns">default function 
  namespace</A><SUP><SMALL>XP</SMALL></SUP> is the <A 
  title="standard function namespace" 
  href="REC-xslt20-20070123.htm#dt-standard-function-namespace">standard 
  function namespace</A>, defined in <A 
  href="REC-xslt20-20070123.htm#xpath-functions">[Functions 
  and Operators]</A>. This means that it is not necessary to declare this 
  namespace in the <A title=stylesheet 
  href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A>, 
  nor is it necessary to use the prefix <CODE>fn</CODE> (or any other prefix) in 
  calls to the <A title="core function" 
  href="REC-xslt20-20070123.htm#dt-core-function">core 
  functions</A>.</P>
  <LI>
  <P>The <A href="http://www.w3.org/TR/xpath20/#dt-issd">in-scope schema 
  definitions</A><SUP><SMALL>XP</SMALL></SUP> for the XPath expression are the 
  same as the <A title="in-scope schema component" 
  href="REC-xslt20-20070123.htm#dt-in-scope-schema-component">in-scope 
  schema components</A> for the <A title=stylesheet 
  href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A>, 
  and are as specified in <A 
  href="REC-xslt20-20070123.htm#built-in-types"><I>3.13 
  Built-in Types</I></A>.</P>
  <LI>
  <P>The <A href="http://www.w3.org/TR/xpath20/#dt-in-scope-variables">in-scope 
  variables</A><SUP><SMALL>XP</SMALL></SUP> are <SPAN>defined by</SPAN> the <A 
  title="variable-binding element" 
  href="REC-xslt20-20070123.htm#dt-variable-binding-element">variable 
  binding elements</A> that are in scope for the containing element (see <A 
  href="REC-xslt20-20070123.htm#variables-and-parameters"><I>9 
  Variables and Parameters</I></A>).</P>
  <LI>
  <P>The <A href="http://www.w3.org/TR/xpath20/#dt-function-signature">function 
  signatures</A><SUP><SMALL>XP</SMALL></SUP> are the <A title="core function" 
  href="REC-xslt20-20070123.htm#dt-core-function">core 
  functions</A> defined in <A 
  href="REC-xslt20-20070123.htm#xpath-functions">[Functions 
  and Operators]</A>, the constructor functions for all the atomic types in the 
  <A href="http://www.w3.org/TR/xpath20/#dt-issd">in-scope schema 
  definitions</A><SUP><SMALL>XP</SMALL></SUP>, the additional functions defined 
  in this specification, the <A title="stylesheet function" 
  href="REC-xslt20-20070123.htm#dt-stylesheet-function">stylesheet 
  functions</A> defined in the stylesheet, plus any <A 
  title="extension function" 
  href="REC-xslt20-20070123.htm#dt-extension-function">extension 
  functions</A> bound using <A title=implementation-defined 
  href="REC-xslt20-20070123.htm#dt-implementation-defined">implementation-defined</A> 
  mechanisms (see <A 
  href="REC-xslt20-20070123.htm#extension"><I>18 
  Extensibility and Fallback</I></A>).</P>
  <DIV class=note>
  <P class=prefix><B>Note:</B></P>
  <P>It follows from the above that a conformant XSLT processor must implement 
  the entire library of <A title="core function" 
  href="REC-xslt20-20070123.htm#dt-core-function">core 
  functions</A> defined in <A 
  href="REC-xslt20-20070123.htm#xpath-functions">[Functions 
  and Operators]</A>.</P></DIV>
  <LI>
  <P>The <A href="http://www.w3.org/TR/xpath20/#dt-static-collations">statically 
  known collations</A><SUP><SMALL>XP</SMALL></SUP> are <A 
  title=implementation-defined 
  href="REC-xslt20-20070123.htm#dt-implementation-defined">implementation-defined</A>. 
  <SPAN>However, the set of in-scope collations <SPAN class=verb>must</SPAN> 
  always include the Unicode codepoint collation, defined in <A 
  href="http://www.w3.org/TR/xpath-functions/#string-compare">Section 7.3 
  Equality and Comparison of Strings</A><SUP><SMALL>FO</SMALL></SUP>.</SPAN></P>
  <LI>
  <P>The <A href="http://www.w3.org/TR/xpath20/#dt-def-collation">default 
  collation</A><SUP><SMALL>XP</SMALL></SUP> is defined by the value of the 
  <CODE>[xsl:]default-collation</CODE> attribute on the innermost enclosing 
  element that has such an attribute. For details, see <A 
  href="REC-xslt20-20070123.htm#default-collation-attribute"><I>3.6.1 
  The default-collation attribute</I></A>.</P>
  <P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-default-collation 
  title="default collation" name=dt-default-collation></A>In this specification 
  the term <B>default collation</B> means the collation that is used by XPath 
  operators such as <CODE>eq</CODE> and <CODE>lt</CODE> appearing in XPath 
  expressions within the stylesheet.<SPAN class=definition>]</SPAN></P>
  <P>This collation is also used by default when comparing strings in the 
  evaluation of the <A 
  href="REC-xslt20-20070123.htm#element-key"><CODE>xsl:key</CODE></A> 
  and <A 
  href="REC-xslt20-20070123.htm#element-for-each-group"><CODE>xsl:for-each-group</CODE></A> 
  elements. This <SPAN class=verb>may</SPAN> also (but need not necessarily) be 
  the same as the default collation used for <A 
  href="REC-xslt20-20070123.htm#element-sort"><CODE>xsl:sort</CODE></A> 
  elements within the stylesheet. Collations used by <A 
  href="REC-xslt20-20070123.htm#element-sort"><CODE>xsl:sort</CODE></A> 
  are described in <A 
  href="REC-xslt20-20070123.htm#collating-sequences"><I>13.1.3 
  Sorting Using Collations</I></A>.</P>
  <LI>
  <P>The <A href="http://www.w3.org/TR/xpath20/#dt-base-uri">base 
  URI</A><SUP><SMALL>XP</SMALL></SUP> is the base URI of the containing element. 
  The concept of the base URI of a node is defined in <A 
  href="http://www.w3.org/TR/xpath-datamodel/#dm-base-uri">Section 5.2 base-uri 
  Accessor</A><SUP><SMALL>DM</SMALL></SUP></P></LI></UL></DIV>
<DIV class=div3>
<H4><A id=additional-static-context name=additional-static-context></A>5.4.2 
Additional Static Context Components used by XSLT</H4>
<P>Some of the components of the XPath static context are used also by <A 
title="XSLT element" 
href="REC-xslt20-20070123.htm#dt-xslt-element">XSLT 
elements</A>. For example, the <A 
href="REC-xslt20-20070123.htm#element-sort"><CODE>xsl:sort</CODE></A> 
element makes use of the collations defined in the static context, and 
attributes such as <CODE>type</CODE> and <CODE>as</CODE> may reference types 
defined in the <A title="in-scope schema component" 
href="REC-xslt20-20070123.htm#dt-in-scope-schema-component">in-scope 
schema components</A>.</P>
<P>Many top-level declarations in a stylesheet, and attributes on the <A 
href="REC-xslt20-20070123.htm#element-stylesheet"><CODE>xsl:stylesheet</CODE></A> 
element, affect the behavior of instructions within the stylesheet. Each of 
these constructs is described in its appropriate place in this 
specification.</P>
<P>A number of these constructs are of particular significance because they are 
used by functions defined in XSLT, which are added to the library of functions 
available for use in XPath expressions within the stylesheet. These are:</P>
<UL>
  <LI>
  <P>The set of named keys, used by the <A 
  href="REC-xslt20-20070123.htm#function-key"><CODE>key</CODE></A> 
  function</P>
  <LI>
  <P>The set of named decimal formats, used by the <A 
  href="REC-xslt20-20070123.htm#function-format-number"><CODE>format-number</CODE></A> 
  function</P>
  <LI>
  <P>The values of system properties, used by the <A 
  href="REC-xslt20-20070123.htm#function-system-property"><CODE>system-property</CODE></A> 
  function</P>
  <LI>
  <P>The set of available instructions, used by the <A 
  href="REC-xslt20-20070123.htm#function-element-available"><CODE>element-available</CODE></A> 
  function</P></LI></UL></DIV>
<DIV class=div3>
<H4><A id=xpath-dynamic-context name=xpath-dynamic-context></A>5.4.3 
Initializing the Dynamic Context</H4>
<P>For convenience, the dynamic context is described in two parts: the <A 
title=focus 
href="REC-xslt20-20070123.htm#dt-focus">focus</A>, which 
represents the place in the source document that is currently being processed, 
and a collection of additional context variables.</P>
<P>A number of functions specified in <A 
href="REC-xslt20-20070123.htm#xpath-functions">[Functions 
and Operators]</A> are defined to be <A 
href="http://www.w3.org/TR/xpath-functions/#stable">stable</A><SUP> 
<SMALL>FO</SMALL></SUP>, meaning that if they are called twice during the same 
<A href="http://www.w3.org/TR/xpath-functions/#execution-scope">execution 
scope</A><SUP><SMALL>FO</SMALL></SUP>, with the same arguments, then they return 
the same results (see <A 
href="http://www.w3.org/TR/xpath-functions/#terminology">Section 1.7 
Terminology</A><SUP><SMALL>FO</SMALL></SUP>). In XSLT, the execution of a 
stylesheet defines the execution scope. This means, for example, that if the 
function <A 
href="http://www.w3.org/TR/xpath-functions/#func-current-dateTime"><CODE>current-dateTime</CODE></A><SUP><SMALL>FO</SMALL></SUP> 
is called repeatedly during a transformation, it produces the same result each 
time. By implication, the components of the dynamic context on which these 
functions depend are also stable for the duration of the transformation. 
Specifically, the following components defined in <A 
href="http://www.w3.org/TR/xpath20/#eval_context">Section 2.1.2 Dynamic 
Context</A><SUP><SMALL>XP</SMALL></SUP> must be stable: <EM>function 
implementations</EM>, <EM>current dateTime</EM>, <EM>implicit timezone</EM>, 
<EM>available documents</EM>, <EM>available collections</EM>, and <EM>default 
collection</EM>. The values of global variables and stylesheet parameters are 
also stable for the duration of a transformation. The focus is <EM>not</EM> 
stable; the additional dynamic context components defined in <A 
href="REC-xslt20-20070123.htm#additional-dynamic-context"><I>5.4.4 
Additional Dynamic Context Components used by XSLT</I></A> are also <EM>not</EM> 
stable.</P>
<P>As specified in <A 
href="REC-xslt20-20070123.htm#xpath-functions">[Functions 
and Operators]</A>, implementations may provide user options that relax the 
requirement for the <A 
href="http://www.w3.org/TR/xpath-functions/#func-doc"><CODE>doc</CODE></A><SUP> 
<SMALL>FO</SMALL></SUP> and <A 
href="http://www.w3.org/TR/xpath-functions/#func-collection"><CODE>collection</CODE></A><SUP><SMALL>FO</SMALL></SUP> 
functions (and therefore, by implication, the <A 
href="REC-xslt20-20070123.htm#function-document"><CODE>document</CODE></A> 
function) to return stable results. By default, however, the functions must be 
stable. The manner in which such user options are provided, if at all, is <A 
title=implementation-defined 
href="REC-xslt20-20070123.htm#dt-implementation-defined">implementation-defined</A>.</P>
<P>XPath expressions contained in <CODE>[xsl:]use-when</CODE> attributes are not 
considered to be evaluated "during the transformation" as defined above. For 
details see <A 
href="REC-xslt20-20070123.htm#conditional-inclusion"><I>3.12 
Conditional Element Inclusion</I></A>.</P>
<DIV class=div4>
<H5><A id=focus name=focus></A>5.4.3.1 Maintaining Position: the Focus</H5>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-focus title=focus 
name=dt-focus></A>When a <A title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A> is evaluated, the <A title=processor 
href="REC-xslt20-20070123.htm#dt-processor">processor</A> 
keeps track of which items are being processed by means of a set of implicit 
variables referred to collectively as the <B>focus</B>.<SPAN 
class=definition>]</SPAN> More specifically, the focus consists of the following 
three values:</P>
<UL>
  <LI>
  <P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-context-item 
  title="context item" name=dt-context-item></A>The <B>context item</B> is the 
  item currently being processed. An item (see <A 
  href="REC-xslt20-20070123.htm#xpath-datamodel">[Data 
  Model]</A>) is either an atomic value (such as an integer, date, or string), 
  or a node. The context item is initially set to the <A 
  title="initial context node" 
  href="REC-xslt20-20070123.htm#dt-initial-context-node">initial 
  context node</A> supplied when the transformation is invoked (see <A 
  href="REC-xslt20-20070123.htm#initiating"><I>2.3 
  Initiating a Transformation</I></A>). It changes whenever instructions such as 
  <A 
  href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A> 
  and <A 
  href="REC-xslt20-20070123.htm#element-for-each"><CODE>xsl:for-each</CODE></A> 
  are used to process a sequence of items; each item in such a sequence becomes 
  the context item while that item is being processed.<SPAN 
  class=definition>]</SPAN> The context item is returned by the XPath <A 
  title=expression 
  href="REC-xslt20-20070123.htm#dt-expression">expression</A> 
  <CODE>.</CODE> (dot).</P>
  <LI>
  <P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-context-position 
  title="context position" name=dt-context-position></A>The <B>context 
  position</B> is the position of the context item within the sequence of items 
  currently being processed. It changes whenever the context item changes. When 
  an instruction such as <A 
  href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A> 
  or <A 
  href="REC-xslt20-20070123.htm#element-for-each"><CODE>xsl:for-each</CODE></A> 
  is used to process a sequence of items, the first item in the sequence is 
  processed with a context position of 1, the second item with a context 
  position of 2, and so on.<SPAN class=definition>]</SPAN> The context position 
  is returned by the XPath <A title=expression 
  href="REC-xslt20-20070123.htm#dt-expression">expression</A> 
  <CODE>position()</CODE>.</P>
  <LI>
  <P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-context-size 
  title="context size" name=dt-context-size></A>The <B>context size</B> is the 
  number of items in the sequence of items currently being processed. It changes 
  whenever instructions such as <A 
  href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A> 
  and <A 
  href="REC-xslt20-20070123.htm#element-for-each"><CODE>xsl:for-each</CODE></A> 
  are used to process a sequence of items; during the processing of each one of 
  those items, the context size is set to the count of the number of items in 
  the sequence (or equivalently, the position of the last item in the 
  sequence).<SPAN class=definition>]</SPAN> The context size is returned by the 
  XPath <A title=expression 
  href="REC-xslt20-20070123.htm#dt-expression">expression</A> 
  <CODE>last()</CODE>.</P></LI></UL>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-context-node 
title="context node" name=dt-context-node></A>If the <A title="context item" 
href="REC-xslt20-20070123.htm#dt-context-item">context 
item</A> is a node (as distinct from an atomic value such as an integer), then 
it is also referred to as the <B>context node</B>. The context node is not an 
independent variable, it changes whenever the context item changes. When the 
context item is an atomic value, there is no context node.<SPAN 
class=definition>]</SPAN> The context node is returned by the XPath <A 
title=expression 
href="REC-xslt20-20070123.htm#dt-expression">expression</A> 
<CODE>self::node()</CODE>, and it is used as the starting node for all relative 
path expressions.</P>
<P>Where the containing element of an XPath expression is an <A 
title=instruction 
href="REC-xslt20-20070123.htm#dt-instruction">instruction</A> 
or a <A title="literal result element" 
href="REC-xslt20-20070123.htm#dt-literal-result-element">literal 
result element</A>, the initial context item, context position, and context size 
for the XPath <A title=expression 
href="REC-xslt20-20070123.htm#dt-expression">expression</A> 
are the same as the <A title="context item" 
href="REC-xslt20-20070123.htm#dt-context-item">context 
item</A>, <A title="context position" 
href="REC-xslt20-20070123.htm#dt-context-position">context 
position</A>, and <A title="context size" 
href="REC-xslt20-20070123.htm#dt-context-size">context 
size</A> for the evaluation of the containing instruction or literal result 
element.</P>
<P>In other cases (for example, where the containing element is <A 
href="REC-xslt20-20070123.htm#element-sort"><CODE>xsl:sort</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-with-param"><CODE>xsl:with-param</CODE></A>, 
or <A 
href="REC-xslt20-20070123.htm#element-key"><CODE>xsl:key</CODE></A>), 
the rules are given in the specification of the containing element.</P>
<P>The <A 
href="REC-xslt20-20070123.htm#function-current"><CODE>current</CODE></A> 
function can be used within any XPath <A title=expression 
href="REC-xslt20-20070123.htm#dt-expression">expression</A> 
to select the item that was supplied as the context item to the XPath expression 
by the XSLT processor. Unlike <CODE>.</CODE> (dot) this is unaffected by changes 
to the context item that occur within the XPath expression. The <A 
href="REC-xslt20-20070123.htm#function-current"><CODE>current</CODE></A> 
function is described in <A 
href="REC-xslt20-20070123.htm#current-function"><I>16.6.1 
current</I></A>.</P>
<P>On completion of an instruction that changes the <A title=focus 
href="REC-xslt20-20070123.htm#dt-focus">focus</A> (such 
as <A 
href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A> 
or <A 
href="REC-xslt20-20070123.htm#element-for-each"><CODE>xsl:for-each</CODE></A>), 
the focus reverts to its previous value.</P>
<P>When a <A title="stylesheet function" 
href="REC-xslt20-20070123.htm#dt-stylesheet-function">stylesheet 
function</A> is called, the focus within the body of the function is initially 
undefined. <SPAN>The focus is also undefined on initial entry to the <A 
title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
if no <A title="initial context node" 
href="REC-xslt20-20070123.htm#dt-initial-context-node">initial 
context node</A> is supplied.</SPAN></P>
<P>When the focus is undefined, evaluation of any <A title=expression 
href="REC-xslt20-20070123.htm#dt-expression">expression</A> 
that references the context item, context position, or context size results in a 
<A title="non-recoverable dynamic error" 
href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
dynamic error</A> [XPDY0002]</P>
<P>The description above gives an outline of the way the <A title=focus 
href="REC-xslt20-20070123.htm#dt-focus">focus</A> works. 
Detailed rules for the effect of each instruction are given separately with the 
description of that instruction. In the absence of specific rules, an 
instruction uses the same focus as its parent instruction.</P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-singleton-focus 
title="singleton focus" name=dt-singleton-focus></A>A <B>singleton focus</B> 
based on a node <VAR>N</VAR> has the <A title="context item" 
href="REC-xslt20-20070123.htm#dt-context-item">context 
item</A> (and therefore the <A title="context node" 
href="REC-xslt20-20070123.htm#dt-context-node">context 
node</A>) set to <VAR>N</VAR>, and the <A title="context position" 
href="REC-xslt20-20070123.htm#dt-context-position">context 
position</A> and <A title="context size" 
href="REC-xslt20-20070123.htm#dt-context-size">context 
size</A> both set to 1 (one).<SPAN class=definition>]</SPAN></P></DIV>
<DIV class=div4>
<H5><A id=evaluation-context name=evaluation-context></A>5.4.3.2 Other 
components of the XPath Dynamic Context</H5>
<P>The previous section explained how the <A title=focus 
href="REC-xslt20-20070123.htm#dt-focus">focus</A> for an 
XPath expression appearing in an XSLT stylesheet is initialized. This section 
explains how the other components of the <A 
href="http://www.w3.org/TR/xpath20/#dt-dynamic-context">dynamic 
context</A><SUP><SMALL>XP</SMALL></SUP> of an XPath expression are 
initialized.</P>
<UL>
  <LI>
  <P>The <A href="http://www.w3.org/TR/xpath20/#dt-variable-values">dynamic 
  variables</A><SUP><SMALL>XP</SMALL></SUP> are the current values of the 
  in-scope <A title="variable-binding element" 
  href="REC-xslt20-20070123.htm#dt-variable-binding-element">variable 
  binding elements</A>.</P>
  <LI>
  <P>The <EM>current date and time</EM> represents an <A 
  title=implementation-dependent 
  href="REC-xslt20-20070123.htm#dt-implementation-dependent">implementation-dependent</A> 
  point in time during processing of the transformation; it does not change 
  during the course of the transformation.</P>
  <LI>
  <P>The <A href="http://www.w3.org/TR/xpath20/#dt-timezone">implicit 
  timezone</A><SUP><SMALL>XP</SMALL></SUP> is <A title=implementation-defined 
  href="REC-xslt20-20070123.htm#dt-implementation-defined">implementation-defined</A>.</P>
  <LI>
  <P>The <A href="http://www.w3.org/TR/xpath20/#dt-known-docs">available 
  documents</A><SUP><SMALL>XP</SMALL></SUP>, and the <A 
  href="http://www.w3.org/TR/xpath20/#dt-known-collections">available 
  collections</A><SUP><SMALL>XP</SMALL></SUP> are determined as part of the 
  process for initiating a transformation (see <A 
  href="REC-xslt20-20070123.htm#initiating"><I>2.3 
  Initiating a Transformation</I></A>).</P>
  <P>The <A href="http://www.w3.org/TR/xpath20/#dt-known-docs">available 
  documents</A><SUP><SMALL>XP</SMALL></SUP> are defined as part of the XPath 2.0 
  dynamic context to support the <A 
  href="http://www.w3.org/TR/xpath-functions/#func-doc"><CODE>doc</CODE></A><SUP><SMALL>FO</SMALL></SUP> 
  function, but this component is also referenced by the similar XSLT <A 
  href="REC-xslt20-20070123.htm#function-document"><CODE>document</CODE></A> 
  function: see <A 
  href="REC-xslt20-20070123.htm#document"><I>16.1 
  Multiple Source Documents</I></A>. This variable defines a mapping between 
  URIs passed to the <A 
  href="http://www.w3.org/TR/xpath-functions/#func-doc"><CODE>doc</CODE></A><SUP><SMALL>FO</SMALL></SUP> 
  or <A 
  href="REC-xslt20-20070123.htm#function-document"><CODE>document</CODE></A> 
  function and the document nodes that are returned.</P>
  <DIV class=note>
  <P class=prefix><B>Note:</B></P>
  <P>Defining this as part of the evaluation context is a formal way of 
  specifying that the way in which URIs get turned into document nodes is 
  outside the control of the language specification, and depends entirely on the 
  run-time environment in which the transformation takes place.</P></DIV>
  <P>The XSLT-defined <A 
  href="REC-xslt20-20070123.htm#function-document"><CODE>document</CODE></A> 
  function allows the use of URI references containing fragment identifiers. The 
  interpretation of a fragment identifier depends on the media type of the 
  resource representation. Therefore, the information supplied in <A 
  href="http://www.w3.org/TR/xpath20/#dt-known-docs">available 
  documents</A><SUP><SMALL>XP</SMALL></SUP> for XSLT processing must provide not 
  only a mapping from URIs to document nodes as required by XPath, but also a 
  mapping from URIs to media types.</P>
  <LI>
  <P>The <A href="http://www.w3.org/TR/xpath20/#dt-default-collection">default 
  collection</A><SUP><SMALL>XP</SMALL></SUP> is <A title=implementation-defined 
  href="REC-xslt20-20070123.htm#dt-implementation-defined">implementation-defined</A>. 
  This allows options such as setting the default collection to be an empty 
  sequence, or to be undefined.</P></LI></UL></DIV></DIV>
<DIV class=div3>
<H4><A id=additional-dynamic-context name=additional-dynamic-context></A>5.4.4 
Additional Dynamic Context Components used by XSLT</H4>
<P>In addition to the values that make up the <A title=focus 
href="REC-xslt20-20070123.htm#dt-focus">focus</A>, an 
XSLT processor maintains a number of other dynamic context components that 
reflect aspects of the evaluation context. These components are fully described 
in the sections of the specification that maintain and use them. They are:</P>
<UL>
  <LI>
  <P>The <A title="current template rule" 
  href="REC-xslt20-20070123.htm#dt-current-template-rule">current 
  template rule</A>, which is the <A title="template rule" 
  href="REC-xslt20-20070123.htm#dt-template-rule">template 
  rule</A> most recently invoked by an <A 
  href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A>, 
  <A 
  href="REC-xslt20-20070123.htm#element-apply-imports"><CODE>xsl:apply-imports</CODE></A>, 
  or <A 
  href="REC-xslt20-20070123.htm#element-next-match"><CODE>xsl:next-match</CODE></A> 
  instruction: see <A 
  href="REC-xslt20-20070123.htm#apply-imports"><I>6.7 
  Overriding Template Rules</I></A>;</P>
  <LI>
  <P>The <A title="current mode" 
  href="REC-xslt20-20070123.htm#dt-current-mode">current 
  mode</A>, which is the <A title=mode 
  href="REC-xslt20-20070123.htm#dt-mode">mode</A> set by 
  the most recent call of <A 
  href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A> 
  (for a full definition see <A 
  href="REC-xslt20-20070123.htm#modes"><I>6.5 
  Modes</I></A>);</P>
  <LI>
  <P>The <A title="current group" 
  href="REC-xslt20-20070123.htm#dt-current-group">current 
  group</A> and <A title="current grouping key" 
  href="REC-xslt20-20070123.htm#dt-current-grouping-key">current 
  grouping key</A>, which provide information about the collection of items 
  currently being processed by an <A 
  href="REC-xslt20-20070123.htm#element-for-each-group"><CODE>xsl:for-each-group</CODE></A> 
  instruction: see <A 
  href="REC-xslt20-20070123.htm#current-group"><I>14.1 
  The Current Group</I></A> and <A 
  href="REC-xslt20-20070123.htm#current-grouping-key"><I>14.2 
  The Current Grouping Key</I></A>;</P>
  <LI>
  <P>The <A title="current captured substrings" 
  href="REC-xslt20-20070123.htm#dt-current-captured-substrings">current 
  captured substrings</A>: this is a sequence of strings, which is maintained 
  when a string is matched against a regular expression using the <A 
  href="REC-xslt20-20070123.htm#element-analyze-string"><CODE>xsl:analyze-string</CODE></A> 
  instruction, and which is accessible using the <A 
  href="REC-xslt20-20070123.htm#function-regex-group"><CODE>regex-group</CODE></A> 
  function: see <A 
  href="REC-xslt20-20070123.htm#regex-group"><I>15.2 
  Captured Substrings</I></A>.</P>
  <LI>
  <P>The <A title="output state" 
  href="REC-xslt20-20070123.htm#dt-output-state">output 
  state</A>: this is a flag whose two possible values are <A 
  title="final output state" 
  href="REC-xslt20-20070123.htm#dt-final-output-state">final 
  output state</A> and <A title="temporary output state" 
  href="REC-xslt20-20070123.htm#dt-temporary-output-state">temporary 
  output state</A>. This flag indicates whether instructions are currently 
  writing to a <A title="final result tree" 
  href="REC-xslt20-20070123.htm#dt-final-result-tree">final 
  result tree</A> or to an internal data structure. The initial setting is <A 
  title="final output state" 
  href="REC-xslt20-20070123.htm#dt-final-output-state">final 
  output state</A>, and it is switched to <A title="temporary output state" 
  href="REC-xslt20-20070123.htm#dt-temporary-output-state">temporary 
  output state</A> by instructions such as <A 
  href="REC-xslt20-20070123.htm#element-variable"><CODE>xsl:variable</CODE></A>. 
  For more details, see <A 
  href="REC-xslt20-20070123.htm#creating-result-trees"><I>19.1 
  Creating Final Result Trees</I></A>.</P></LI></UL>
<P>The following non-normative table summarizes the initial state of each of the 
components in the evaluation context, and the instructions which cause the state 
of the component to change.</P>
<TABLE cellPadding=5 border=1>
  <THEAD>
  <TR>
    <TH align=left>Component</TH>
    <TH align=left>Initial Setting</TH>
    <TH align=left>Set by</TH>
    <TH align=left>Cleared by</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD vAlign=top><A title=focus 
      href="REC-xslt20-20070123.htm#dt-focus">focus</A></TD>
    <TD vAlign=top>singleton focus based on the <A 
      title="initial context node" 
      href="REC-xslt20-20070123.htm#dt-initial-context-node">initial 
      context node</A> if supplied</TD>
    <TD vAlign=top><A 
      href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A>, 
      <A 
      href="REC-xslt20-20070123.htm#element-for-each"><CODE>xsl:for-each</CODE></A>, 
      <A 
      href="REC-xslt20-20070123.htm#element-for-each-group"><CODE>xsl:for-each-group</CODE></A>, 
      <A 
      href="REC-xslt20-20070123.htm#element-analyze-string"><CODE>xsl:analyze-string</CODE></A></TD>
    <TD vAlign=top>calls on <A title="stylesheet function" 
      href="REC-xslt20-20070123.htm#dt-stylesheet-function">stylesheet 
      functions</A></TD></TR>
  <TR>
    <TD vAlign=top><A title="current template rule" 
      href="REC-xslt20-20070123.htm#dt-current-template-rule">current 
      template rule</A></TD>
    <TD vAlign=top><SPAN>If a <A title="named template" 
      href="REC-xslt20-20070123.htm#dt-named-template">named 
      template</A> is supplied as the entry point to the transformation, then 
      null; otherwise the <A title="initial template" 
      href="REC-xslt20-20070123.htm#dt-initial-template">initial 
      template</A></SPAN></TD>
    <TD vAlign=top><A 
      href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A>, 
      <A 
      href="REC-xslt20-20070123.htm#element-apply-imports"><CODE>xsl:apply-imports</CODE></A>, 
      <A 
      href="REC-xslt20-20070123.htm#element-next-match"><CODE>xsl:next-match</CODE></A></TD>
    <TD vAlign=top><A 
      href="REC-xslt20-20070123.htm#element-for-each"><CODE>xsl:for-each</CODE></A>, 
      <A 
      href="REC-xslt20-20070123.htm#element-for-each-group"><CODE>xsl:for-each-group</CODE></A>, 
      and <SPAN><A 
      href="REC-xslt20-20070123.htm#element-analyze-string"><CODE>xsl:analyze-string</CODE></A></SPAN>, 
      and calls on <A title="stylesheet function" 
      href="REC-xslt20-20070123.htm#dt-stylesheet-function">stylesheet 
      functions</A>. Also cleared while evaluating global variables or default 
      values of stylesheet parameters, and the sequence constructors contained 
      in <A 
      href="REC-xslt20-20070123.htm#element-key"><CODE>xsl:key</CODE></A> 
      and <A 
      href="REC-xslt20-20070123.htm#element-sort"><CODE>xsl:sort</CODE></A>.</TD></TR>
  <TR>
    <TD vAlign=top><A title="current mode" 
      href="REC-xslt20-20070123.htm#dt-current-mode">current 
      mode</A></TD>
    <TD vAlign=top>the initial <A title=mode 
      href="REC-xslt20-20070123.htm#dt-mode">mode</A></TD>
    <TD vAlign=top><A 
      href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A></TD>
    <TD vAlign=top>calls on <A title="stylesheet function" 
      href="REC-xslt20-20070123.htm#dt-stylesheet-function">stylesheet 
      functions</A></TD></TR>
  <TR>
    <TD vAlign=top><A title="current group" 
      href="REC-xslt20-20070123.htm#dt-current-group">current 
      group</A></TD>
    <TD vAlign=top>empty sequence</TD>
    <TD vAlign=top><A 
      href="REC-xslt20-20070123.htm#element-for-each-group"><CODE>xsl:for-each-group</CODE></A></TD>
    <TD vAlign=top>calls on <A title="stylesheet function" 
      href="REC-xslt20-20070123.htm#dt-stylesheet-function">stylesheet 
      functions</A></TD></TR>
  <TR>
    <TD vAlign=top><A title="current grouping key" 
      href="REC-xslt20-20070123.htm#dt-current-grouping-key">current 
      grouping key</A></TD>
    <TD vAlign=top>empty sequence</TD>
    <TD vAlign=top><A 
      href="REC-xslt20-20070123.htm#element-for-each-group"><CODE>xsl:for-each-group</CODE></A></TD>
    <TD vAlign=top>calls on <A title="stylesheet function" 
      href="REC-xslt20-20070123.htm#dt-stylesheet-function">stylesheet 
      functions</A></TD></TR>
  <TR>
    <TD vAlign=top><A title="current captured substrings" 
      href="REC-xslt20-20070123.htm#dt-current-captured-substrings">current 
      captured substrings</A></TD>
    <TD vAlign=top>empty sequence</TD>
    <TD vAlign=top><A 
      href="REC-xslt20-20070123.htm#element-matching-substring"><CODE>xsl:matching-substring</CODE></A></TD>
    <TD vAlign=top><A 
      href="REC-xslt20-20070123.htm#element-non-matching-substring"><CODE>xsl:non-matching-substring</CODE></A>; 
      calls on <A title="stylesheet function" 
      href="REC-xslt20-20070123.htm#dt-stylesheet-function">stylesheet 
      functions</A></TD></TR>
  <TR>
    <TD vAlign=top><A title="output state" 
      href="REC-xslt20-20070123.htm#dt-output-state">output 
      state</A></TD>
    <TD vAlign=top><A title="final output state" 
      href="REC-xslt20-20070123.htm#dt-final-output-state">final 
      output state</A></TD>
    <TD vAlign=top>Set to <A title="temporary output state" 
      href="REC-xslt20-20070123.htm#dt-temporary-output-state">temporary 
      output state</A> by instructions such as <A 
      href="REC-xslt20-20070123.htm#element-variable"><CODE>xsl:variable</CODE></A>, 
      <A 
      href="REC-xslt20-20070123.htm#element-attribute"><CODE>xsl:attribute</CODE></A>, 
      etc., and by calls on <A title="stylesheet function" 
      href="REC-xslt20-20070123.htm#dt-stylesheet-function">stylesheet 
      functions</A></TD>
    <TD vAlign=top>None</TD></TR></TBODY></TABLE></DIV></DIV>
<DIV class=div2>
<H3><A id=patterns name=patterns></A>5.5 Patterns</H3>
<P>A <A title="template rule" 
href="REC-xslt20-20070123.htm#dt-template-rule">template 
rule</A> identifies the nodes to which it applies by means of a pattern. As well 
as being used in template rules, patterns are used for numbering (see <A 
href="REC-xslt20-20070123.htm#number"><I>12 
Numbering</I></A>), for grouping (see <A 
href="REC-xslt20-20070123.htm#grouping"><I>14 
Grouping</I></A>), and for declaring <A title="" 
href="REC-xslt20-20070123.htm#key">keys</A> (see <A 
href="REC-xslt20-20070123.htm#key"><I>16.3 
Keys</I></A>).</P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-pattern 
title=pattern name=dt-pattern></A>A <B>pattern</B> specifies a set of conditions 
on a node. A node that satisfies the conditions matches the pattern; a node that 
does not satisfy the conditions does not match the pattern. The syntax for 
patterns is a subset of the syntax for <A title=expression 
href="REC-xslt20-20070123.htm#dt-expression">expressions</A>.<SPAN 
class=definition>]</SPAN> As explained in detail below, a node matches a pattern 
if the node can be selected by <SPAN>deriving an equivalent expression, 
and</SPAN> evaluating this expression with respect to some possible context.</P>
<DIV class=div3>
<H4><A id=pattern-examples name=pattern-examples></A>5.5.1 Examples of 
Patterns</H4>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e8032 name=d5e8032></A>Example: Patterns </DIV>
<P>Here are some examples of patterns:</P>
<UL>
  <LI>
  <P><CODE>para</CODE> matches any <CODE>para</CODE> element.</P>
  <LI>
  <P><CODE>*</CODE> matches any element.</P>
  <LI>
  <P><CODE>chapter|appendix</CODE> matches any <CODE>chapter</CODE> element and 
  any <CODE>appendix</CODE> element.</P>
  <LI>
  <P><CODE>olist/entry</CODE> matches any <CODE>entry</CODE> element with an 
  <CODE>olist</CODE> parent.</P>
  <LI>
  <P><CODE>appendix//para</CODE> matches any <CODE>para</CODE> element with an 
  <CODE>appendix</CODE> ancestor element.</P>
  <LI>
  <P><CODE>schema-element(us:address)</CODE> matches any element that is 
  annotated as an instance of the type defined by the schema element declaration 
  <CODE>us:address</CODE>, and whose name is either <CODE>us:address</CODE> or 
  the name of another element in its substitution group.</P>
  <LI>
  <P><CODE>attribute(*, xs:date)</CODE> matches any attribute annotated as being 
  of type <CODE>xs:date</CODE>.</P>
  <LI>
  <P><CODE>/</CODE> matches a document node.</P>
  <LI>
  <P><CODE>document-node()</CODE> matches a document node.</P>
  <LI>
  <P><CODE>document-node(schema-element(my:invoice))</CODE> matches the document 
  node of a document whose document element <SPAN>is named 
  <CODE>my:invoice</CODE> and matches the type defined by the global element 
  declaration</SPAN> <CODE>my:invoice</CODE>.</P>
  <LI>
  <P><CODE>text()</CODE> matches any text node.</P>
  <LI>
  <P><CODE>node()</CODE> matches any node other than an attribute node, 
  namespace node, or document node.</P>
  <LI>
  <P><CODE>id("W33")</CODE> matches the element with unique ID 
  <CODE>W33</CODE>.</P>
  <LI>
  <P><CODE>para[1]</CODE> matches any <CODE>para</CODE> element that is the 
  first <CODE>para</CODE> child element of its parent. <SPAN>It also matches a 
  parentless <CODE>para</CODE> element.</SPAN></P>
  <LI>
  <P><CODE>//para</CODE> matches any <CODE>para</CODE> element that has a parent 
  node.</P>
  <LI>
  <P><CODE>bullet[position() mod 2 = 0]</CODE> matches any <CODE>bullet</CODE> 
  element that is an even-numbered <CODE>bullet</CODE> child of its parent.</P>
  <LI>
  <P><CODE>div[@class="appendix"]//p</CODE> matches any <CODE>p</CODE> element 
  with a <CODE>div</CODE> ancestor element that has a <CODE>class</CODE> 
  attribute with value <CODE>appendix</CODE>.</P>
  <LI>
  <P><CODE>@class</CODE> matches any <CODE>class</CODE> attribute (<EM>not</EM> 
  any element that has a <CODE>class</CODE> attribute).</P>
  <LI>
  <P><CODE>@*</CODE> matches any attribute node.</P></LI></UL></DIV></DIV>
<DIV class=div3>
<H4><A id=pattern-syntax name=pattern-syntax></A>5.5.2 Syntax of Patterns</H4>
<P><A id=err-XTSE0340 name=err-XTSE0340><SPAN class=error>[ERR 
XTSE0340]</SPAN></A> Where an attribute is defined to contain a <A title=pattern 
href="REC-xslt20-20070123.htm#dt-pattern">pattern</A>, it 
is a <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A> if the pattern does not match the production <A 
href="REC-xslt20-20070123.htm#NT-Pattern">Pattern</A>. 
Every pattern is a legal XPath <A title=expression 
href="REC-xslt20-20070123.htm#dt-expression">expression</A>, 
but the converse is not true: <CODE>2+2</CODE> is an example of a legal XPath 
expression that is not a pattern. The XPath expressions that can be used as 
patterns are those that match the grammar for <A 
href="REC-xslt20-20070123.htm#NT-Pattern">Pattern</A>, 
given below.</P>
<P>Informally, a <A 
href="REC-xslt20-20070123.htm#NT-Pattern">Pattern</A> is 
a set of path expressions separated by <CODE>|</CODE>, where each step in the 
path expression is constrained to be an <A 
href="http://www.w3.org/TR/xpath20/#doc-xpath-AxisStep">AxisStep</A><SUP> 
<SMALL>XP</SMALL></SUP> that uses only the <CODE>child</CODE> or 
<CODE>attribute</CODE> axes. Patterns may also use the <CODE>//</CODE> operator. 
A <A href="http://www.w3.org/TR/xpath20/#doc-xpath-Predicate">Predicate</A><SUP> 
<SMALL>XP</SMALL></SUP> within the <A 
href="http://www.w3.org/TR/xpath20/#doc-xpath-PredicateList">PredicateList</A><SUP> 
<SMALL>XP</SMALL></SUP> in a pattern can contain arbitrary XPath expressions 
(enclosed between square brackets) in the same way as a <A 
href="http://www.w3.org/TR/xpath20/#doc-xpath-Predicate">predicate</A><SUP> 
<SMALL>XP</SMALL></SUP> in a path expression.</P>
<P>Patterns may start with an <A 
href="http://www.w3.org/TR/xpath-functions/#func-id"><CODE>id</CODE></A><SUP> 
<SMALL>FO</SMALL></SUP> or <A 
href="REC-xslt20-20070123.htm#function-key"><CODE>key</CODE></A> 
function call, provided that the value to be matched is supplied as either a 
literal or a reference to a <A title=variable 
href="REC-xslt20-20070123.htm#dt-variable">variable</A> 
or <A title=parameter 
href="REC-xslt20-20070123.htm#dt-parameter">parameter</A>, 
and the key name (in the case of the <A 
href="REC-xslt20-20070123.htm#function-key"><CODE>key</CODE></A> 
function) is supplied as a string literal. <SPAN>These patterns will never match 
a node in a tree whose root is not a document node.</SPAN></P>
<P>If a pattern occurs in part of the <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
where <A title="backwards compatible behavior" 
href="REC-xslt20-20070123.htm#dt-backwards-compatible-behavior">backwards 
compatible behavior</A> is enabled (see <A 
href="REC-xslt20-20070123.htm#backwards"><I>3.8 
Backwards-Compatible Processing</I></A>), then <SPAN>the semantics of the 
pattern are defined on the basis that the equivalent XPath expression is 
evaluated with <A title="XPath 1.0 compatibility mode" 
href="REC-xslt20-20070123.htm#dt-compatibility-mode">XPath 
1.0 compatibility mode</A> set to true.</SPAN></P>
<H5><A id=d5e8328 name=d5e8328></A>Patterns</H5>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=NT-Pattern name=NT-Pattern></A>[1]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>Pattern</CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xslt20-20070123.htm#NT-PathPattern">PathPattern</A></CODE></TD></TR>
  <TR vAlign=baseline>
    <TD></TD>
    <TD></TD>
    <TD></TD>
    <TD><CODE>| <A 
      href="REC-xslt20-20070123.htm#NT-Pattern">Pattern</A> 
      '|' <A 
      href="REC-xslt20-20070123.htm#NT-PathPattern">PathPattern</A></CODE></TD></TR>
  <TR vAlign=baseline>
    <TD><A id=NT-PathPattern name=NT-PathPattern></A>[2]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>PathPattern</CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xslt20-20070123.htm#NT-RelativePathPattern">RelativePathPattern</A></CODE></TD></TR>
  <TR vAlign=baseline>
    <TD></TD>
    <TD></TD>
    <TD></TD>
    <TD><CODE>| '/' <A 
      href="REC-xslt20-20070123.htm#NT-RelativePathPattern">RelativePathPattern</A>?</CODE></TD></TR>
  <TR vAlign=baseline>
    <TD></TD>
    <TD></TD>
    <TD></TD>
    <TD><CODE>| '//' <A 
      href="REC-xslt20-20070123.htm#NT-RelativePathPattern">RelativePathPattern</A></CODE></TD></TR>
  <TR vAlign=baseline>
    <TD></TD>
    <TD></TD>
    <TD></TD>
    <TD><CODE>| <A 
      href="REC-xslt20-20070123.htm#NT-IdKeyPattern">IdKeyPattern</A> 
      (('/' | '//') <A 
      href="REC-xslt20-20070123.htm#NT-RelativePathPattern">RelativePathPattern</A>)?</CODE></TD></TR>
  <TR vAlign=baseline>
    <TD><A id=NT-RelativePathPattern 
      name=NT-RelativePathPattern></A>[3]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>RelativePathPattern</CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xslt20-20070123.htm#NT-PatternStep">PatternStep</A> 
      (('/' | '//') <A 
      href="REC-xslt20-20070123.htm#NT-RelativePathPattern">RelativePathPattern</A>)?</CODE></TD></TR>
  <TR vAlign=baseline>
    <TD><A id=NT-PatternStep name=NT-PatternStep></A>[4]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>PatternStep</CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xslt20-20070123.htm#NT-PatternAxis">PatternAxis</A>? 
      <A 
      href="http://www.w3.org/TR/xpath20/#doc-xpath-NodeTest">NodeTest</A><SUP> 
      <SMALL>XP</SMALL></SUP> <A 
      href="http://www.w3.org/TR/xpath20/#doc-xpath-PredicateList">PredicateList</A><SUP><SMALL>XP</SMALL></SUP></CODE></TD></TR>
  <TR vAlign=baseline>
    <TD><A id=NT-PatternAxis name=NT-PatternAxis></A>[5]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>PatternAxis</CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>('child' '::' | 'attribute' '::' | '@')</CODE></TD></TR>
  <TR vAlign=baseline>
    <TD><A id=NT-IdKeyPattern 
name=NT-IdKeyPattern></A>[6]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>IdKeyPattern</CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>'id' '(' <A 
      href="REC-xslt20-20070123.htm#NT-IdValue">IdValue</A> 
      ')'</CODE></TD></TR>
  <TR vAlign=baseline>
    <TD></TD>
    <TD></TD>
    <TD></TD>
    <TD><CODE>| 'key' '(' <A 
      href="http://www.w3.org/TR/xpath20/#doc-xpath-StringLiteral">StringLiteral</A><SUP><SMALL>XP</SMALL></SUP> 
      ',' <A 
      href="REC-xslt20-20070123.htm#NT-KeyValue">KeyValue</A> 
      ')'</CODE></TD></TR>
  <TR vAlign=baseline>
    <TD><A id=NT-IdValue name=NT-IdValue></A>[7]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>IdValue</CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="http://www.w3.org/TR/xpath20/#doc-xpath-StringLiteral">StringLiteral</A><SUP><SMALL>XP</SMALL></SUP> 
      | <A href="http://www.w3.org/TR/xpath20/#doc-xpath-VarRef">VarRef</A><SUP> 
      <SMALL>XP</SMALL></SUP></CODE></TD></TR>
  <TR vAlign=baseline>
    <TD><A id=NT-KeyValue name=NT-KeyValue></A>[8]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>KeyValue</CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="http://www.w3.org/TR/xpath20/#doc-xpath-Literal">Literal</A><SUP> 
      <SMALL>XP</SMALL></SUP> | <A 
      href="http://www.w3.org/TR/xpath20/#doc-xpath-VarRef">VarRef</A><SUP> 
      <SMALL>XP</SMALL></SUP></CODE></TD></TR></TBODY></TABLE>
<P>The constructs <A 
href="http://www.w3.org/TR/xpath20/#doc-xpath-NodeTest">NodeTest</A><SUP> 
<SMALL>XP</SMALL></SUP>, <A 
href="http://www.w3.org/TR/xpath20/#doc-xpath-PredicateList">PredicateList</A><SUP> 
<SMALL>XP</SMALL></SUP>, <A 
href="http://www.w3.org/TR/xpath20/#doc-xpath-VarRef">VarRef</A><SUP> 
<SMALL>XP</SMALL></SUP>, <A 
href="http://www.w3.org/TR/xpath20/#doc-xpath-Literal">Literal</A><SUP> 
<SMALL>XP</SMALL></SUP>, and <A 
href="http://www.w3.org/TR/xpath20/#doc-xpath-StringLiteral">StringLiteral</A><SUP> 
<SMALL>XP</SMALL></SUP> are part of the XPath expression language, and are 
defined in <A 
href="REC-xslt20-20070123.htm#xpath20">[XPath 
2.0]</A>.</P></DIV>
<DIV class=div3>
<H4><A id=pattern-semantics name=pattern-semantics></A>5.5.3 The Meaning of a 
Pattern</H4>
<P>The meaning of a pattern is defined formally as follows.</P>
<P>First we define the concept of an <EM>equivalent expression</EM>. In general, 
the equivalent expression is the XPath expression that takes the same lexical 
form as the pattern as written. However, if the pattern contains a 
<CODE>PathPattern</CODE> that is a <CODE>RelativePathPattern</CODE>, then the 
first <CODE>PatternStep</CODE> <VAR>PS</VAR> of this 
<CODE>RelativePathPattern</CODE> is adjusted to allow it to match a parentless 
element or attribute node, as follows:</P>
<UL>
  <LI>
  <P>If the <CODE>NodeTest</CODE> in <VAR>PS</VAR> is 
  <CODE>document-node()</CODE> (optionally with arguments), and if no explicit 
  axis is specified, then the axis in step <VAR>PS</VAR> is taken as 
  <CODE>self</CODE> rather than <CODE>child</CODE>.</P>
  <LI>
  <P>If <VAR>PS</VAR> uses the child axis (explicitly or implicitly), and if the 
  <CODE>NodeTest</CODE> in <VAR>PS</VAR> is not <CODE>document-node()</CODE> 
  (optionally with arguments), then the axis in step <VAR>PS</VAR> is replaced 
  by <CODE>child-or-top</CODE>, which is defined as follows. If the context node 
  is a parentless element, comment, processing-instruction, or text node then 
  the <CODE>child-or-top</CODE> axis selects the context node; otherwise it 
  selects the children of the context node. It is a forwards axis whose 
  principal node kind is element.</P>
  <LI>
  <P>If <VAR>PS</VAR> uses the attribute axis, then the axis in step 
  <VAR>PS</VAR> is replaced by <CODE>attribute-or-top</CODE>, which is defined 
  as follows. If the context node is an attribute node with no parent, then the 
  <CODE>attribute-or-top</CODE> axis selects the context node; otherwise it 
  selects the attributes of the context node. It is a forwards axis whose 
  principal node kind is attribute.</P></LI></UL>
<P>The axes <CODE>child-or-top</CODE> and <CODE>attribute-or-top</CODE> are 
introduced only for definitional purposes. They cannot be used explicitly in a 
user-written pattern or expression.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>The purpose of these adjustments is to ensure that a pattern such as 
<CODE>person</CODE> matches any element named <CODE>person</CODE>, even if it 
has no parent; and similarly, that the pattern <CODE>@width</CODE> matches any 
attribute named <CODE>width</CODE>, even a parentless attribute. The rule also 
ensures that a pattern using a <CODE>NodeTest</CODE> of the form 
<CODE>document-node(...)</CODE> matches a document node. The pattern 
<CODE>node()</CODE> will match any element, text node, comment, or processing 
instruction, whether or not it has a parent. For backwards compatibility 
reasons, the pattern <CODE>node()</CODE>, when used without an explicit axis, 
does not match document nodes, attribute nodes, or namespace nodes. The rules 
are also phrased to ensure that positional patterns of the form 
<CODE>para[1]</CODE> continue to count nodes relative to their parent, if they 
have one.</P></DIV>
<P>Let the equivalent expression, calculated according to these rules, be 
<VAR>EE</VAR>.</P>
<P>To determine whether a node <VAR>N</VAR> matches the pattern, evaluate the <A 
title=expression 
href="REC-xslt20-20070123.htm#dt-expression">expression</A> 
<CODE>root(.)//(<VAR>EE</VAR>)</CODE> with a <A title="singleton focus" 
href="REC-xslt20-20070123.htm#dt-singleton-focus">singleton 
focus</A> based on <VAR>N</VAR>. If the result is a sequence of nodes that 
includes <VAR>N</VAR>, then node <VAR>N</VAR> matches the pattern; otherwise 
node <VAR>N</VAR> does not match the pattern.</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e8624 name=d5e8624></A>Example: The Semantics 
of Patterns </DIV>
<P>The pattern <CODE>p</CODE> matches any <CODE>p</CODE> element, because a 
<CODE>p</CODE> element will always be present in the result of evaluating the <A 
title=expression 
href="REC-xslt20-20070123.htm#dt-expression">expression</A> 
<CODE>root(.)//(child-or-top::p)</CODE>. Similarly, <CODE>/</CODE> matches 
<SPAN>a document node, and only a document node,</SPAN> because the result of 
the <A title=expression 
href="REC-xslt20-20070123.htm#dt-expression">expression</A> 
<CODE>root(.)//(/)</CODE> returns the root node of the tree containing the 
context node <SPAN>if and only if it is a document node.</SPAN></P>
<P>The pattern <CODE>node()</CODE> matches all nodes selected by the expression 
<CODE>root(.)//(child-or-top::node())</CODE>, that is, all element, text, 
comment, and processing instruction nodes, whether or not they have a parent. It 
does not match attribute or namespace nodes because the expression does not 
select nodes using the attribute or namespace axes. <SPAN>It does not match 
document nodes because for backwards compatibility reasons the 
<CODE>child-or-top</CODE> axis does not match a document node.</SPAN></P></DIV>
<P>Although the semantics of patterns are specified formally in terms of 
expression evaluation, it is possible to understand pattern matching using a 
different model. In a pattern, <CODE>|</CODE> indicates alternatives; a pattern 
with one or more <CODE>|</CODE> separated alternatives matches if any one of the 
alternatives matches. A pattern such as <CODE>book/chapter/section</CODE> can be 
examined from right to left. A node will only match this pattern if it is a 
<CODE>section</CODE> element; and then, only if its parent is a 
<CODE>chapter</CODE>; and then, only if the parent of that <CODE>chapter</CODE> 
is a <CODE>book</CODE>. When the pattern uses the <CODE>//</CODE> operator, one 
can still read it from right to left, but this time testing the ancestors of a 
node rather than its parent. For example <CODE>appendix//section</CODE> matches 
every <CODE>section</CODE> element that has an ancestor <CODE>appendix</CODE> 
element.</P>
<P>The formal definition, however, is useful for understanding the meaning of a 
pattern such as <CODE>para[1]</CODE>. This matches any node selected by the 
expression <CODE>root(.)//(child-or-top::para[1])</CODE>: that is, any 
<CODE>para</CODE> element that is the first <CODE>para</CODE> child of its 
parent, <SPAN>or a <CODE>para</CODE> element that has no parent.</SPAN></P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>An implementation, of course, may use any algorithm it wishes for evaluating 
patterns, so long as the result corresponds with the formal definition above. An 
implementation that followed the formal definition by evaluating the equivalent 
expression and then testing the membership of a specific node in the result 
would probably be very inefficient.</P></DIV></DIV>
<DIV class=div3>
<H4><A id=pattern-errors name=pattern-errors></A>5.5.4 Errors in Patterns</H4>
<P>Any <A title="dynamic error" 
href="REC-xslt20-20070123.htm#dt-dynamic-error">dynamic 
error</A> or <A title="type errors" 
href="REC-xslt20-20070123.htm#dt-type-error">type 
error</A> that occurs during the evaluation of a <A title=pattern 
href="REC-xslt20-20070123.htm#dt-pattern">pattern</A> 
against a particular node is treated as a <A title="recoverable error" 
href="REC-xslt20-20070123.htm#dt-recoverable-error">recoverable 
error</A> even if the error would not be recoverable under other circumstances. 
The <A title="optional recovery action" 
href="REC-xslt20-20070123.htm#dt-optional-recovery-action">optional 
recovery action</A> is to treat the pattern as not matching that node.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>The reason for this provision is that it is difficult for the stylesheet 
author to predict which predicates in a pattern will actually be evaluated. In 
the case of match patterns in template rules, it is not even possible to predict 
which patterns will be evaluated against a particular node. Making errors in 
patterns recoverable enables an implementation, if it chooses to do so, to 
report such errors while stylesheets are under development, while masking them 
if they occur during production running.</P></DIV>
<P>One particular optimization is <SPAN class=verb>required</SPAN> by this 
specification: for a <A 
href="REC-xslt20-20070123.htm#NT-PathPattern">PathPattern</A> 
that starts with <CODE>/</CODE> or <CODE>//</CODE> or with an <A 
href="REC-xslt20-20070123.htm#NT-IdKeyPattern">IdKeyPattern</A>, 
the result of testing this pattern against a node in a tree whose root is not a 
document node must be a non-match, rather than a dynamic error. This rule 
applies to each <A 
href="REC-xslt20-20070123.htm#NT-PathPattern">PathPattern</A> 
within a <A 
href="REC-xslt20-20070123.htm#NT-Pattern">Pattern</A>.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>Without the above rule, any attempt to apply templates to a parentless 
element node would create the risk of a dynamic error if the stylesheet has a 
template rule specifying <CODE>match="/"</CODE>.</P></DIV></DIV></DIV>
<DIV class=div2>
<H3><A id=attribute-value-templates name=attribute-value-templates></A>5.6 
Attribute Value Templates</H3>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A 
id=dt-attribute-value-template title="attribute value template" 
name=dt-attribute-value-template></A>In an attribute that is designated as an 
<B>attribute value template</B>, such as an attribute of a <A 
title="literal result element" 
href="REC-xslt20-20070123.htm#dt-literal-result-element">literal 
result element</A>, an <A title=expression 
href="REC-xslt20-20070123.htm#dt-expression">expression</A> 
can be used by surrounding the expression with curly brackets 
(<CODE>{}</CODE>)<SPAN class=definition>]</SPAN>.</P>
<P>An attribute value template consists of an alternating sequence of fixed 
parts and variable parts. A variable part consists of an XPath <A 
title=expression 
href="REC-xslt20-20070123.htm#dt-expression">expression</A> 
enclosed in curly brackets (<CODE>{}</CODE>). A fixed part may contain any 
characters, except that a left curly bracket <SPAN class=verb>must</SPAN> be 
written as <CODE>{{</CODE> and a right curly bracket <SPAN 
class=verb>must</SPAN> be written as <CODE>}}</CODE>.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>An expression within a variable part may contain an unescaped curly bracket 
within a <A 
href="http://www.w3.org/TR/xpath20/#doc-xpath-StringLiteral">StringLiteral</A><SUP> 
<SMALL>XP</SMALL></SUP> <SPAN>or within a comment</SPAN>.</P></DIV>
<P><A id=err-XTSE0350 name=err-XTSE0350><SPAN class=error>[ERR 
XTSE0350]</SPAN></A> It is a <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A> if an unescaped left curly bracket appears in a fixed part of an 
attribute value template without a matching right curly bracket.</P>
<P>It is a <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A> if the string contained between matching curly brackets in an 
attribute value template does not match the XPath production <A 
href="http://www.w3.org/TR/xpath20/#doc-xpath-Expr">Expr</A><SUP> 
<SMALL>XP</SMALL></SUP>, or if it contains other XPath static errors. The error 
is signaled using the appropriate XPath error code.</P>
<P><A id=err-XTSE0370 name=err-XTSE0370><SPAN class=error>[ERR 
XTSE0370]</SPAN></A> It is a <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A> if an unescaped right curly bracket occurs in a fixed part of an 
attribute value template.</P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-effective-value 
title="effective value" name=dt-effective-value></A>The result of evaluating an 
attribute value template is referred to as the <B>effective value</B> of the 
attribute.<SPAN class=definition>]</SPAN> The effective value is the string 
obtained by concatenating the expansions of the fixed and variable parts:</P>
<UL>
  <LI>
  <P>The expansion of a fixed part is obtained by replacing any double curly 
  brackets (<CODE>{{</CODE> or <CODE>}}</CODE>) by the corresponding single 
  curly bracket.</P>
  <LI>
  <P>The expansion of a variable part is obtained by evaluating the enclosed 
  XPath <A title=expression 
  href="REC-xslt20-20070123.htm#dt-expression">expression</A> 
  and converting the resulting value to a string. <SPAN>This conversion is done 
  using the rules given in <A 
  href="REC-xslt20-20070123.htm#constructing-simple-content"><I>5.7.2 
  Constructing Simple Content</I></A>.</SPAN></P></LI></UL>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>This process can generate dynamic errors, for example if the sequence 
contains an element with a complex content type (which cannot be 
atomized).</P></DIV>
<P>If <A title="backwards compatible behavior" 
href="REC-xslt20-20070123.htm#dt-backwards-compatible-behavior">backwards 
compatible behavior</A> is enabled for the attribute, the rules for converting 
the value of the expression to a string are modified as follows. After <A 
title=atomize 
href="REC-xslt20-20070123.htm#dt-atomization">atomizing</A> 
the result of the expression, all items other than the first item in the 
resulting sequence are discarded, and the effective value is obtained by 
converting the first item in the sequence to a string. If the atomized sequence 
is empty, the result is a zero-length string.</P>
<P>Curly brackets are not treated specially in an attribute value in an XSLT <A 
title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
unless the attribute is specifically designated as one that permits an attribute 
value template; in an element syntax summary, the value of such attributes is 
surrounded by curly brackets.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>Not all attributes are designated as attribute value templates. Attributes 
whose value is an <A title=expression 
href="REC-xslt20-20070123.htm#dt-expression">expression</A> 
or <A title=pattern 
href="REC-xslt20-20070123.htm#dt-pattern">pattern</A>, 
attributes of <A title=declaration 
href="REC-xslt20-20070123.htm#dt-declaration">declaration</A> 
elements and attributes that refer to named XSLT objects are 
<SPAN>generally</SPAN> not designated as attribute value templates <SPAN>(an 
exception is the <CODE>format</CODE> attribute of <A 
href="REC-xslt20-20070123.htm#element-result-document"><CODE>xsl:result-document</CODE></A>)</SPAN>. 
Namespace declarations are not <SPAN>XDM attribute nodes</SPAN> and are 
therefore never treated as attribute value templates.</P></DIV>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e8932 name=d5e8932></A>Example: Attribute Value 
Templates </DIV>
<P>The following example creates an <CODE>img</CODE> result element from a 
<CODE>photograph</CODE> element in the source; the value of the <CODE>src</CODE> 
and <CODE>width</CODE> attributes are computed using XPath expressions enclosed 
in attribute value templates:</P>
<DIV class=exampleInner><PRE>&lt;xsl:variable name="image-dir" select="'/images'"/&gt;

&lt;xsl:template match="photograph"&gt;
  &lt;img src="{$image-dir}/{href}" width="{size/@width}"/&gt;
&lt;/xsl:template&gt;
</PRE></DIV>
<P>With this source</P>
<DIV class=exampleInner><PRE>&lt;photograph&gt;
  &lt;href&gt;headquarters.jpg&lt;/href&gt;
  &lt;size width="300"/&gt;
&lt;/photograph&gt;
</PRE></DIV>
<P>the result would be</P>
<DIV class=exampleInner><PRE>&lt;img src="/images/headquarters.jpg" width="300"/&gt;
</PRE></DIV></DIV>
<P>&nbsp;</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e8959 name=d5e8959></A>Example: Producing a 
Space-Separated List </DIV>
<P>The following example shows how the values in a sequence are output as a 
space-separated list. The following literal result element:</P>
<DIV class=exampleInner><PRE>&lt;temperature readings="{10.32, 5.50, 8.31}"/&gt;
</PRE></DIV>
<P>produces the output node:</P>
<DIV class=exampleInner><PRE>&lt;temperature readings="10.32 5.5 8.31"/&gt;
</PRE></DIV></DIV>
<P>Curly brackets are <EM>not</EM> recognized recursively inside 
expressions.</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e8975 name=d5e8975></A>Example: Curly Brackets 
can not be Nested </DIV>
<P>For example:</P>
<DIV class=exampleInner><PRE>&lt;a href="#{id({@ref})/title}"&gt;
</PRE></DIV>
<P>is <EM>not</EM> allowed. Instead, use simply:</P>
<DIV class=exampleInner><PRE>&lt;a href="#{id(@ref)/title}"&gt;
</PRE></DIV></DIV></DIV>
<DIV class=div2>
<H3><A id=sequence-constructors name=sequence-constructors></A>5.7 Sequence 
Constructors</H3>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-sequence-constructor 
title="sequence constructor" name=dt-sequence-constructor></A>A <B>sequence 
constructor</B> is a sequence of zero or more sibling nodes in the <A 
title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
that can be evaluated to return a sequence of nodes and atomic values. The way 
that the resulting sequence is used depends on the containing instruction.<SPAN 
class=definition>]</SPAN></P>
<P>Many <A title="XSLT element" 
href="REC-xslt20-20070123.htm#dt-xslt-element">XSLT 
elements</A>, <SPAN>and also</SPAN> <A title="literal result element" 
href="REC-xslt20-20070123.htm#dt-literal-result-element">literal 
result elements</A>, are defined to take a <A title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A> as their content.</P>
<P>Four kinds of nodes may be encountered in a sequence constructor:</P>
<UL>
  <LI>
  <P><EM>Text nodes</EM> appearing in the <A title=stylesheet 
  href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
  (if they have not been removed in the process of whitespace stripping: see <A 
  href="REC-xslt20-20070123.htm#stylesheet-stripping"><I>4.2 
  Stripping Whitespace from the Stylesheet</I></A>) are copied to create a new 
  parentless text node in the result sequence.</P>
  <LI>
  <P><A title="literal result element" 
  href="REC-xslt20-20070123.htm#dt-literal-result-element">Literal 
  result elements</A> are evaluated to create a new parentless element node, 
  having the same <A title=expanded-QName 
  href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded-QName</A> 
  as the literal result element, which is added to the result sequence: see <A 
  href="REC-xslt20-20070123.htm#literal-result-element"><I>11.1 
  Literal Result Elements</I></A></P>
  <LI>
  <P>XSLT <A title=instruction 
  href="REC-xslt20-20070123.htm#dt-instruction">instructions</A> 
  produce a sequence of zero, one, or more items as their result. These items 
  are added to the result sequence. For most XSLT instructions, these items are 
  nodes, but some instructions (<A 
  href="REC-xslt20-20070123.htm#element-sequence"><CODE>xsl:sequence</CODE></A> 
  and <A 
  href="REC-xslt20-20070123.htm#element-copy-of"><CODE>xsl:copy-of</CODE></A>) 
  can also produce atomic values. Several instructions, such as <A 
  href="REC-xslt20-20070123.htm#element-element"><CODE>xsl:element</CODE></A>, 
  return a newly constructed parentless node (which may have its own attributes, 
  namespaces, children, and other descendants). Other instructions, such as <A 
  href="REC-xslt20-20070123.htm#element-if"><CODE>xsl:if</CODE></A>, 
  pass on the items produced by their own nested sequence constructors. The <A 
  href="REC-xslt20-20070123.htm#element-sequence"><CODE>xsl:sequence</CODE></A> 
  instruction may return atomic values, or existing nodes.</P>
  <LI>
  <P><A title="extension instruction" 
  href="REC-xslt20-20070123.htm#dt-extension-instruction">Extension 
  instructions</A> (see <A 
  href="REC-xslt20-20070123.htm#extension-instruction"><I>18.2 
  Extension Instructions</I></A>) also produce a sequence of items as their 
  result. The items in this sequence are added to the result 
sequence.</P></LI></UL>
<P>There are several ways the result of a sequence constructor may be used.</P>
<UL>
  <LI>
  <P>The sequence may be bound to a variable or returned from a stylesheet 
  function, in which case it becomes available as a value to be manipulated in 
  arbitrary ways by XPath expressions. The sequence is bound to a variable when 
  the sequence constructor appears within one of the elements <A 
  href="REC-xslt20-20070123.htm#element-variable"><CODE>xsl:variable</CODE></A>, 
  <A 
  href="REC-xslt20-20070123.htm#element-param"><CODE>xsl:param</CODE></A>, 
  or <A 
  href="REC-xslt20-20070123.htm#element-with-param"><CODE>xsl:with-param</CODE></A>, 
  when this instruction has an <CODE>as</CODE> attribute. The sequence is 
  returned from a stylesheet function when the sequence constructor appears 
  within the <A 
  href="REC-xslt20-20070123.htm#element-function"><CODE>xsl:function</CODE></A> 
  element.</P>
  <DIV class=note>
  <P class=prefix><B>Note:</B></P>
  <P>This will typically expose to the stylesheet elements, attributes, and 
  other nodes that have not yet been attached to a parent node in a <A 
  title="result tree" 
  href="REC-xslt20-20070123.htm#dt-result-tree">result 
  tree</A>. The semantics of XPath expressions when applied to parentless nodes 
  are well-defined; however, such expressions should be used with care. For 
  example, the expression <CODE>/</CODE> <SPAN>causes a type error if the root 
  of the tree containing the context node is not a document node.</SPAN>.</P>
  <P>Parentless attribute nodes require particular care because they have no 
  namespace nodes associated with them. <SPAN>A parentless attribute node is not 
  permitted to contain namespace-sensitive content (for example, a QName or an 
  XPath expression) because there is no information enabling the prefix to be 
  resolved to a namespace URI.</SPAN> Parentless attributes can be useful in an 
  application (for example, they provide an alternative to the use of attribute 
  sets: see <A 
  href="REC-xslt20-20070123.htm#attribute-sets"><I>10.2 
  Named Attribute Sets</I></A>) but they need to be handled with care.</P></DIV>
  <LI>
  <P>The sequence may be returned as the result of the containing element. This 
  happens when the instruction containing the sequence constructor is <A 
  href="REC-xslt20-20070123.htm#element-analyze-string"><CODE>xsl:analyze-string</CODE></A>, 
  <A 
  href="REC-xslt20-20070123.htm#element-apply-imports"><CODE>xsl:apply-imports</CODE></A>, 
  <A 
  href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A>, 
  <A 
  href="REC-xslt20-20070123.htm#element-call-template"><CODE>xsl:call-template</CODE></A>, 
  <A 
  href="REC-xslt20-20070123.htm#element-choose"><CODE>xsl:choose</CODE></A>, 
  <A 
  href="REC-xslt20-20070123.htm#element-fallback"><CODE>xsl:fallback</CODE></A>, 
  <A 
  href="REC-xslt20-20070123.htm#element-for-each"><CODE>xsl:for-each</CODE></A>, 
  <A 
  href="REC-xslt20-20070123.htm#element-for-each-group"><CODE>xsl:for-each-group</CODE></A>, 
  <A 
  href="REC-xslt20-20070123.htm#element-if"><CODE>xsl:if</CODE></A>, 
  <A 
  href="REC-xslt20-20070123.htm#element-matching-substring"><CODE>xsl:matching-substring</CODE></A>, 
  <A 
  href="REC-xslt20-20070123.htm#element-next-match"><CODE>xsl:next-match</CODE></A>, 
  <A 
  href="REC-xslt20-20070123.htm#element-non-matching-substring"><CODE>xsl:non-matching-substring</CODE></A>, 
  <A 
  href="REC-xslt20-20070123.htm#element-otherwise"><CODE>xsl:otherwise</CODE></A>, 
  <A 
  href="REC-xslt20-20070123.htm#element-perform-sort"><CODE>xsl:perform-sort</CODE></A>, 
  <A 
  href="REC-xslt20-20070123.htm#element-sequence"><CODE>xsl:sequence</CODE></A>, 
  or <A 
  href="REC-xslt20-20070123.htm#element-when"><CODE>xsl:when</CODE></A></P>
  <LI>
  <P>The sequence may be used to construct the content of a new element or 
  document node. This happens when the sequence constructor appears as the 
  content of a <A title="literal result element" 
  href="REC-xslt20-20070123.htm#dt-literal-result-element">literal 
  result element</A>, or of one of the instructions <A 
  href="REC-xslt20-20070123.htm#element-copy"><CODE>xsl:copy</CODE></A>, 
  <A 
  href="REC-xslt20-20070123.htm#element-element"><CODE>xsl:element</CODE></A>, 
  <SPAN><A 
  href="REC-xslt20-20070123.htm#element-document"><CODE>xsl:document</CODE></A>, 
  <A 
  href="REC-xslt20-20070123.htm#element-result-document"><CODE>xsl:result-document</CODE></A>,</SPAN> 
  or <A 
  href="REC-xslt20-20070123.htm#element-message"><CODE>xsl:message</CODE></A>. 
  It also happens when the sequence constructor is contained in one of the 
  elements <A 
  href="REC-xslt20-20070123.htm#element-variable"><CODE>xsl:variable</CODE></A>, 
  <A 
  href="REC-xslt20-20070123.htm#element-param"><CODE>xsl:param</CODE></A>, 
  or <A 
  href="REC-xslt20-20070123.htm#element-with-param"><CODE>xsl:with-param</CODE></A>, 
  when this instruction has no <CODE>as</CODE> attribute. For details, see <A 
  href="REC-xslt20-20070123.htm#constructing-complex-content"><I>5.7.1 
  Constructing Complex Content</I></A>.</P>
  <LI>
  <P>The sequence may be used to construct the <A title="string value" 
  href="REC-xslt20-20070123.htm#dt-string-value">string 
  value</A> of an attribute node, <SPAN>text node</SPAN>, namespace node, 
  comment node, or processing instruction node. This happens when the sequence 
  constructor is contained in one of the elements <A 
  href="REC-xslt20-20070123.htm#element-attribute"><CODE>xsl:attribute</CODE></A>, 
  <SPAN><A 
  href="REC-xslt20-20070123.htm#element-value-of"><CODE>xsl:value-of</CODE></A></SPAN>, 
  <A 
  href="REC-xslt20-20070123.htm#element-namespace"><CODE>xsl:namespace</CODE></A>, 
  <A 
  href="REC-xslt20-20070123.htm#element-comment"><CODE>xsl:comment</CODE></A>, 
  or <A 
  href="REC-xslt20-20070123.htm#element-processing-instruction"><CODE>xsl:processing-instruction</CODE></A>. 
  For details, see <A 
  href="REC-xslt20-20070123.htm#constructing-simple-content"><I>5.7.2 
  Constructing Simple Content</I></A>.</P></LI></UL>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>The term <EM><SPAN>sequence</SPAN> constructor</EM> replaces 
<EM>template</EM> as used in XSLT 1.0. The change is made partly for clarity (to 
avoid confusion with <A title="template rule" 
href="REC-xslt20-20070123.htm#dt-template-rule">template 
rules</A> and <A title="named template" 
href="REC-xslt20-20070123.htm#dt-named-template">named 
templates</A>), but also to reflect a more formal definition of the semantics. 
Whereas XSLT 1.0 described a template as a sequence of instructions that write 
to the result tree, XSLT 2.0 describes a <SPAN>sequence</SPAN> constructor as 
something that can be evaluated to return a sequence of <SPAN>items</SPAN>; what 
happens to these items depends on the containing instruction.</P></DIV>
<DIV class=div3>
<H4><A id=constructing-complex-content 
name=constructing-complex-content></A>5.7.1 Constructing Complex Content</H4>
<P>This section describes how the sequence obtained by evaluating a <A 
title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A> may be used to construct the children of a newly constructed 
document node, or the children, attributes and namespaces of a newly constructed 
element node. The sequence of items may be obtained by evaluating the <A 
title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A> contained in an instruction such as <A 
href="REC-xslt20-20070123.htm#element-copy"><CODE>xsl:copy</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-element"><CODE>xsl:element</CODE></A>, 
<SPAN><A 
href="REC-xslt20-20070123.htm#element-document"><CODE>xsl:document</CODE></A></SPAN>, 
<A 
href="REC-xslt20-20070123.htm#element-result-document"><CODE>xsl:result-document</CODE></A>, 
or a <A title="literal result element" 
href="REC-xslt20-20070123.htm#dt-literal-result-element">literal 
result element</A>.</P>
<P>When constructing the content of an element, the 
<CODE>inherit-namespaces</CODE> attribute of the <A 
href="REC-xslt20-20070123.htm#element-element"><CODE>xsl:element</CODE></A> 
or <A 
href="REC-xslt20-20070123.htm#element-copy"><CODE>xsl:copy</CODE></A> 
instruction, or the <CODE>xsl:inherit-namespaces</CODE> property of the literal 
result element, determines whether namespace nodes are to be inherited. The 
effect of this attribute is described in the rules that follow.</P>
<P>The sequence is processed as follows <SPAN>(applying the rules in the order 
they are listed)</SPAN>:</P>
<OL class=enumar>
  <LI>
  <P>The containing instruction may generate attribute nodes and/or namespace 
  nodes, as specified in the rules for the individual instruction. For example, 
  these nodes may be produced by expanding an 
  <CODE>[xsl:]use-attribute-sets</CODE> attribute, or by expanding the 
  attributes of a <A title="literal result element" 
  href="REC-xslt20-20070123.htm#dt-literal-result-element">literal 
  result element</A>. Any such nodes are prepended to the sequence produced by 
  evaluating the <A title="sequence constructor" 
  href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
  constructor</A>.</P>
  <LI>
  <P>Any atomic value in the sequence is cast to a string.</P>
  <DIV class=note>
  <P class=prefix><B>Note:</B></P>
  <P>Casting from <CODE>xs:QName</CODE> or <CODE>xs:NOTATION</CODE> to 
  <CODE>xs:string</CODE> always succeeds, because these values retain a prefix 
  for this purpose. However, there is no guarantee that the prefix used will 
  always be meaningful in the context where the resulting string is 
  used.</P></DIV>
  <LI>
  <P>Any consecutive sequence of strings within the result sequence is converted 
  to a single text node, whose <A title="string value" 
  href="REC-xslt20-20070123.htm#dt-string-value">string 
  value</A> contains the content of each of the strings in turn, with a single 
  space (#x20) used as a separator between successive strings.</P>
  <LI>
  <P>Any document node within the result sequence is replaced by a sequence 
  containing each of its children, in document order.</P>
  <LI>
  <P>Zero-length text nodes within the result sequence are removed.</P>
  <LI>
  <P>Adjacent text nodes within the result sequence are merged into a single 
  text node.</P>
  <LI>
  <P>Invalid namespace and attribute nodes are detected as follows.</P>
  <P><A id=err-XTDE0410 name=err-XTDE0410><SPAN class=error>[ERR 
  XTDE0410]</SPAN></A> It is a <A title="non-recoverable dynamic error" 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A> if the result sequence used to construct the content of an 
  element node contains a namespace node or attribute node that is preceded in 
  the sequence by a node that is neither a namespace node nor an attribute 
  node.</P>
  <P><A id=err-XTDE0420 name=err-XTDE0420><SPAN class=error>[ERR 
  XTDE0420]</SPAN></A> It is a <A title="non-recoverable dynamic error" 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A> if the result sequence used to construct the content of a 
  document node contains a namespace node or attribute node.</P>
  <P><A id=err-XTDE0430 name=err-XTDE0430><SPAN class=error>[ERR 
  XTDE0430]</SPAN></A> It is a <A title="non-recoverable dynamic error" 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A> if the result sequence contains two or more namespace nodes 
  having the same name but different <A title="string value" 
  href="REC-xslt20-20070123.htm#dt-string-value">string 
  values</A> (that is, namespace nodes that map the same prefix to different 
  namespace URIs).</P>
  <P><A id=err-XTDE0440 name=err-XTDE0440><SPAN class=error>[ERR 
  XTDE0440]</SPAN></A> It is a <A title="non-recoverable dynamic error" 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A> if the result sequence contains a namespace node with no 
  name and the element node being constructed has a null namespace URI (that is, 
  it is an error to define a default namespace when the element is in no 
  namespace).</P>
  <LI>
  <P>If the result sequence contains two or more namespace nodes with the same 
  name (or no name) and the same <A title="string value" 
  href="REC-xslt20-20070123.htm#dt-string-value">string 
  value</A> (that is, two namespace nodes mapping the same prefix to the same 
  namespace URI), then all but one of the duplicate nodes are discarded.</P>
  <DIV class=note>
  <P class=prefix><B>Note:</B></P>
  <P>Since the order of namespace nodes is undefined, it is not significant 
  which of the duplicates is retained.</P></DIV>
  <LI>
  <P>If an attribute <VAR>A</VAR> in the result sequence has the same name as 
  another attribute <VAR>B</VAR> that appears later in the result sequence, then 
  attribute <VAR>A</VAR> is discarded from the result sequence.</P>
  <LI>
  <P>Each node in the resulting sequence is attached as a namespace, attribute, 
  or child of the newly constructed element or document node. Conceptually this 
  involves making a deep copy of the node; in practice, however, copying the 
  node will only be necessary if the existing node can be referenced 
  independently of the parent to which it is being attached. When copying an 
  element or processing instruction node, its base URI property is changed to be 
  the same as that of its new parent, unless it has an <CODE>xml:base</CODE> 
  attribute (see <A 
  href="REC-xslt20-20070123.htm#xmlbase">[XML Base]</A>) 
  that overrides this. If the <SPAN>copied</SPAN> element has an 
  <CODE>xml:base</CODE> attribute, its base URI is the value of that attribute, 
  resolved (if it is relative) against the base URI of the new parent node.</P>
  <LI>
  <P>If the newly constructed node is an element node, then namespace fixup is 
  applied to this node, as described in <A 
  href="REC-xslt20-20070123.htm#namespace-fixup"><I>5.7.3 
  Namespace Fixup</I></A>.</P>
  <LI>
  <P>If the newly constructed node is an element node, and if namespaces are 
  inherited, then each namespace node of the newly constructed element 
  (including any produced as a result of the namespace fixup process) is copied 
  to each descendant element of the newly constructed element, unless that 
  element or an intermediate element already has a namespace node with the same 
  name (or absence of a name) <SPAN>or that descendant element or an 
  intermediate element is in no namespace and the namespace node has no 
  name</SPAN>.</P></LI></OL>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e9419 name=d5e9419></A>Example: A Sequence 
Constructor for Complex Content </DIV>
<P>Consider the following stylesheet fragment:</P>
<DIV class=exampleInner><PRE>&lt;td&gt;
  &lt;xsl:attribute name="valign"&gt;top&lt;/xsl:attribute&gt;
  &lt;xsl:value-of select="@description"/&gt;
&lt;/td&gt;
</PRE></DIV>
<P>This fragment consists of a literal result element <CODE>td</CODE>, 
containing a sequence constructor that consists of two instructions: <A 
href="REC-xslt20-20070123.htm#element-attribute"><CODE>xsl:attribute</CODE></A> 
and <A 
href="REC-xslt20-20070123.htm#element-value-of"><CODE>xsl:value-of</CODE></A>. 
The sequence constructor is evaluated to produce a sequence of two nodes: a 
parentless attribute node, and a parentless text node. The <CODE>td</CODE> 
instruction causes a <CODE>td</CODE> element to be created; the new attribute 
therefore becomes an attribute of the new <CODE>td</CODE> element, while the 
text node created by the <A 
href="REC-xslt20-20070123.htm#element-value-of"><CODE>xsl:value-of</CODE></A> 
instruction becomes a child of the <CODE>td</CODE> element (unless it is 
zero-length, in which case it is discarded).</P></DIV>
<P>&nbsp;</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e9453 name=d5e9453></A>Example: Space 
Separators in Element Content </DIV>
<P>Consider the following stylesheet fragment:</P>
<DIV class=exampleInner><PRE>&lt;doc&gt;
  &lt;e&gt;&lt;xsl:sequence select="1 to 5"/&gt;&lt;/e&gt;
  &lt;f&gt;
    &lt;xsl:for-each select="1 to 5"&gt;
      &lt;xsl:value-of select="."/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/f&gt;
&lt;/doc&gt;
</PRE></DIV>
<P>This produces the output (when indented):</P>
<DIV class=exampleInner><PRE>&lt;doc&gt;
  &lt;e&gt;1 2 3 4 5&lt;/e&gt;
  &lt;f&gt;12345&lt;/f&gt;
&lt;/doc&gt;
</PRE></DIV>
<P>The difference between the two cases is that for the <CODE>e</CODE> element, 
the sequence constructor generates a sequence of five atomic values, which are 
therefore separated by spaces. For the <CODE>f</CODE> element, the content is a 
sequence of five text nodes, which are concatenated without space 
separation.</P>
<P>It is important to be aware of the distinction between <A 
href="REC-xslt20-20070123.htm#element-sequence"><CODE>xsl:sequence</CODE></A>, 
which returns the value of its <CODE>select</CODE> expression unchanged, and <A 
href="REC-xslt20-20070123.htm#element-value-of"><CODE>xsl:value-of</CODE></A>, 
which constructs a text node.</P></DIV></DIV>
<DIV class=div3>
<H4><A id=constructing-simple-content name=constructing-simple-content></A>5.7.2 
Constructing Simple Content</H4>
<P>The <A 
href="REC-xslt20-20070123.htm#element-attribute"><CODE>xsl:attribute</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-comment"><CODE>xsl:comment</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-processing-instruction"><CODE>xsl:processing-instruction</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-namespace"><CODE>xsl:namespace</CODE></A><SPAN>, 
and <A 
href="REC-xslt20-20070123.htm#element-value-of"><CODE>xsl:value-of</CODE></A></SPAN> 
elements create nodes that cannot have children. <SPAN>Specifically, the <A 
href="REC-xslt20-20070123.htm#element-attribute"><CODE>xsl:attribute</CODE></A> 
instruction creates an attribute node, <A 
href="REC-xslt20-20070123.htm#element-comment"><CODE>xsl:comment</CODE></A> 
creates a comment node, <A 
href="REC-xslt20-20070123.htm#element-processing-instruction"><CODE>xsl:processing-instruction</CODE></A> 
creates a processing instruction node, <A 
href="REC-xslt20-20070123.htm#element-namespace"><CODE>xsl:namespace</CODE></A> 
creates a namespace node, and <A 
href="REC-xslt20-20070123.htm#element-value-of"><CODE>xsl:value-of</CODE></A> 
creates a text node. The string value of the new node is constructed using 
either the <CODE>select</CODE> attribute of the instruction, or the <A 
title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A> that forms the content of the instruction. The 
<CODE>select</CODE> attribute allows the content to be specified by means of an 
XPath expression, while the sequence constructor allows it to be specified by 
means of a sequence of XSLT instructions. The <CODE>select</CODE> attribute or 
sequence constructor is evaluated to produce a result sequence,</SPAN> and the 
<A title="string value" 
href="REC-xslt20-20070123.htm#dt-string-value">string 
value</A> of the new node is derived from this result sequence according to the 
rules below.</P>
<P>These rules are also used to compute the <A title="effective value" 
href="REC-xslt20-20070123.htm#dt-effective-value">effective 
value</A> of an <A title="attribute value template" 
href="REC-xslt20-20070123.htm#dt-attribute-value-template">attribute 
value template</A>. In this case the sequence being processed is the result of 
evaluating an XPath expression enclosed between curly brackets, and the 
separator is a single space character.</P>
<OL class=enumar>
  <LI>
  <P>Zero-length text nodes in the sequence are discarded.</P>
  <LI>
  <P>Adjacent text nodes in the sequence are merged into a single text node.</P>
  <LI>
  <P>The sequence is <A title=atomize 
  href="REC-xslt20-20070123.htm#dt-atomization">atomized</A>.</P>
  <LI>
  <P>Every value in the atomized sequence is cast to a string.</P>
  <LI>
  <P>The strings within the resulting sequence are concatenated, with a 
  (possibly zero-length) separator inserted between successive strings. 
  <SPAN>The default separator is a single space.</SPAN> In the case of <A 
  href="REC-xslt20-20070123.htm#element-attribute"><CODE>xsl:attribute</CODE></A> 
  and <A 
  href="REC-xslt20-20070123.htm#element-value-of"><CODE>xsl:value-of</CODE></A>, 
  a different separator can be specified using the <CODE>separator</CODE> 
  attribute of the instruction; it is permissible for this to be a zero-length 
  string, in which case the strings are concatenated with no separator. In the 
  case of <A 
  href="REC-xslt20-20070123.htm#element-comment"><CODE>xsl:comment</CODE></A>, 
  <A 
  href="REC-xslt20-20070123.htm#element-processing-instruction"><CODE>xsl:processing-instruction</CODE></A>, 
  and <A 
  href="REC-xslt20-20070123.htm#element-namespace"><CODE>xsl:namespace</CODE></A><SPAN> 
  , and when expanding an <A title="attribute value template" 
  href="REC-xslt20-20070123.htm#dt-attribute-value-template">attribute 
  value template</A></SPAN>, the default separator cannot be changed.</P>
  <LI>
  <P>In the case of <A 
  href="REC-xslt20-20070123.htm#element-processing-instruction"><CODE>xsl:processing-instruction</CODE></A>, 
  any leading spaces in the resulting string are removed.</P>
  <LI>
  <P>The <SPAN>resulting string</SPAN> forms the <A title="string value" 
  href="REC-xslt20-20070123.htm#dt-string-value">string 
  value</A> of the new attribute, namespace, comment, processing-instruction, or 
  text node.</P></LI></OL>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e9607 name=d5e9607></A>Example: Space 
Separators in Attribute Content </DIV>
<P>Consider the following stylesheet fragment:</P>
<DIV class=exampleInner><PRE>&lt;doc&gt;
  &lt;xsl:attribute name="e" select="1 to 5"/&gt;
  &lt;xsl:attribute name="f"&gt;
    &lt;xsl:for-each select="1 to 5"&gt;
      &lt;xsl:value-of select="."/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:attribute&gt;
&lt;/doc&gt;
</PRE></DIV>
<P>This produces the output:</P>
<DIV class=exampleInner><PRE>&lt;doc e="1 2 3 4 5" f="12345"/&gt;
</PRE></DIV>
<P>The difference between the two cases is that for the <CODE>e</CODE> 
attribute, the sequence constructor generates a sequence of five atomic values, 
which are therefore separated by spaces. For the <CODE>f</CODE> attribute, the 
content is supplied as a sequence of five text nodes, which are concatenated 
without space separation.</P>
<P>Specifying <CODE>separator=""</CODE> on the first <A 
href="REC-xslt20-20070123.htm#element-attribute"><CODE>xsl:attribute</CODE></A> 
instruction would cause the attribute value to be <CODE>e="12345"</CODE>. A 
<CODE>separator</CODE> attribute on the second <A 
href="REC-xslt20-20070123.htm#element-attribute"><CODE>xsl:attribute</CODE></A> 
instruction would have no effect, since the separator only affects the way 
adjacent atomic values are handled: separators are never inserted between 
adjacent text nodes.</P></DIV>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>If an attribute value template contains a sequence of fixed and variable 
parts, no additional whitespace is inserted between the expansions of the fixed 
and variable parts. For example, the <A title="effective value" 
href="REC-xslt20-20070123.htm#dt-effective-value">effective 
value</A> of the attribute <CODE>a="chapters{4 to 6}"</CODE> is 
<CODE>a="chapters4 5 6"</CODE>.</P></DIV></DIV>
<DIV class=div3>
<H4><A id=namespace-fixup name=namespace-fixup></A>5.7.3 Namespace Fixup</H4>
<P>In a tree supplied to or constructed by an XSLT processor, the constraints 
relating to namespace nodes that are specified in <A 
href="REC-xslt20-20070123.htm#xpath-datamodel">[Data 
Model]</A> <SPAN class=verb>must</SPAN> be satisfied. For example</P>
<UL>
  <LI>
  <P>If an element node has an <A title=expanded-QName 
  href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded-QName</A> 
  with a non-null namespace URI, then that element node <SPAN><SPAN 
  class=verb>must</SPAN></SPAN> have at least one namespace node whose <A 
  title="string value" 
  href="REC-xslt20-20070123.htm#dt-string-value">string 
  value</A> is the same as that namespace URI.</P>
  <LI>
  <P>If an element node has an attribute node whose <A title=expanded-QName 
  href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded-QName</A> 
  has a non-null namespace URI, then the element <SPAN class=verb>must</SPAN> 
  have at least one namespace node whose <A title="string value" 
  href="REC-xslt20-20070123.htm#dt-string-value">string 
  value</A> is the same as that namespace URI and whose name is non-empty.</P>
  <LI>
  <P>Every element <SPAN class=verb>must</SPAN> have a namespace node whose <A 
  title=expanded-QName 
  href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded-QName</A> 
  has local-part <CODE>xml</CODE> and whose <A title="string value" 
  href="REC-xslt20-20070123.htm#dt-string-value">string 
  value</A> is <CODE>http://www.w3.org/XML/1998/namespace</CODE>. The namespace 
  prefix <CODE>xml</CODE> must not be associated with any other namespace URI, 
  and the namespace URI <CODE>http://www.w3.org/XML/1998/namespace</CODE> must 
  not be associated with any other prefix.</P>
  <LI>
  <P>A namespace node <SPAN class=verb>must not</SPAN> have the name 
  <CODE>xmlns</CODE>.</P></LI></UL>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-namespace-fixup 
title="namespace fixup" name=dt-namespace-fixup></A>The rules for the individual 
XSLT instructions that construct a <A title="result tree" 
href="REC-xslt20-20070123.htm#dt-result-tree">result 
tree</A> (see <A 
href="REC-xslt20-20070123.htm#creating-new-nodes"><I>11 
Creating Nodes and Sequences</I></A>) prescribe some of the situations in which 
namespace nodes are written to the tree. These rules, however, are not 
sufficient to ensure that the prescribed constraints are always satisfied. The 
XSLT processor <SPAN class=verb>must</SPAN> therefore add additional namespace 
nodes to satisfy these constraints. This process is referred to as <B>namespace 
fixup</B>.<SPAN class=definition>]</SPAN></P>
<P>The actual namespace nodes that are added to the tree by the namespace fixup 
process are <A title=implementation-dependent 
href="REC-xslt20-20070123.htm#dt-implementation-dependent">implementation-dependent</A>, 
provided firstly, that at the end of the process the above constraints <SPAN 
class=verb>must</SPAN> all be satisfied, and secondly, that a namespace node 
<SPAN class=verb>must not</SPAN> be added to the tree unless the namespace node 
is necessary either to satisfy these constraints, or to enable the tree to be 
serialized using the original namespace prefixes from the source document or <A 
title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A>.</P>
<P>Namespace fixup <SPAN class=verb>must not</SPAN> result in an element having 
multiple namespace nodes with the same name.</P>
<P>Namespace fixup <SPAN class=verb>may</SPAN>, if necessary to resolve 
conflicts, change the namespace prefix contained in the QName value that holds 
the name of an element or attribute node. <SPAN>This includes the option to add 
or remove a prefix.</SPAN> However, namespace fixup <SPAN class=verb>must 
not</SPAN> change the prefix component contained in a value of type 
<CODE>xs:QName</CODE> or <CODE>xs:NOTATION</CODE> that forms the typed value of 
an element or attribute node.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>Namespace fixup is not used to create namespace declarations for 
<CODE>xs:QName</CODE> or <CODE>xs:NOTATION</CODE> values appearing in the 
content of an element or attribute.</P>
<P>Where values acquire such types as the result of validation, namespace fixup 
does not come into play, because namespace fixup happens before validation: in 
this situation, it is the user's responsibility to ensure that the element being 
validated has the required namespace nodes to enable validation to succeed.</P>
<P>Where existing elements are copied along with their existing type annotations 
(<CODE>validation="preserve"</CODE>) the rules require that existing namespace 
nodes are also copied, so that any namespace-sensitive values remain valid.</P>
<P>Where existing attributes are copied along with their existing type 
annotations, the rules of the XDM data model require that a parentless attribute 
node cannot contain a namespace-sensitive typed value; this means that it is an 
error to copy an attribute using <CODE>validation="preserve"</CODE> if it 
contains namespace-sensitive content.</P></DIV>
<P><A id=err-XTDE0485 name=err-XTDE0485><SPAN class=error>[ERR 
XTDE0485]</SPAN></A> It is a <A title="non-recoverable dynamic error" 
href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
dynamic error</A> if namespace fixup is performed on an element that contains 
among the typed values of the element and its attributes two values of type 
<CODE>xs:QName</CODE> or <CODE>xs:NOTATION</CODE> containing conflicting 
namespace prefixes, that is, two values that use the same prefix to refer to 
different namespace URIs.</P>
<P>Namespace fixup is applied to every element that is constructed using a <A 
title="literal result element" 
href="REC-xslt20-20070123.htm#dt-literal-result-element">literal 
result element</A>, or one of the instructions <A 
href="REC-xslt20-20070123.htm#element-element"><CODE>xsl:element</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-copy"><CODE>xsl:copy</CODE></A>, 
or <A 
href="REC-xslt20-20070123.htm#element-copy-of"><CODE>xsl:copy-of</CODE></A>. 
An implementation is not <SPAN class=verb>required</SPAN> to perform namespace 
fixup for elements in any source document, that is, for a document in the 
initial input sequence, documents loaded using the <A 
href="REC-xslt20-20070123.htm#function-document"><CODE>document</CODE></A>, 
<A 
href="http://www.w3.org/TR/xpath-functions/#func-doc"><CODE>doc</CODE></A><SUP> 
<SMALL>FO</SMALL></SUP> or <A 
href="http://www.w3.org/TR/xpath-functions/#func-collection"><CODE>collection</CODE></A><SUP><SMALL>FO</SMALL></SUP> 
function, documents supplied as the value of a <A title="stylesheet parameter" 
href="REC-xslt20-20070123.htm#dt-stylesheet-parameter">stylesheet 
parameter</A>, or documents returned by an <A title="extension function" 
href="REC-xslt20-20070123.htm#dt-extension-function">extension 
function</A> or <A title="extension instruction" 
href="REC-xslt20-20070123.htm#dt-extension-instruction">extension 
instruction</A>.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>A source document (an input document, a document returned by the <A 
href="REC-xslt20-20070123.htm#function-document"><CODE>document</CODE></A>, 
<A 
href="http://www.w3.org/TR/xpath-functions/#func-doc"><CODE>doc</CODE></A><SUP><SMALL>FO</SMALL></SUP> 
or <A 
href="http://www.w3.org/TR/xpath-functions/#func-collection"><CODE>collection</CODE></A><SUP><SMALL>FO</SMALL></SUP> 
functions, a document returned by an extension function or extension 
instruction, or a document supplied as a stylesheet parameter) is required to 
satisfy the constraints described in <A 
href="REC-xslt20-20070123.htm#xpath-datamodel">[Data 
Model]</A>, including the constraints imposed by the namespace fixup process. 
The effect of supplying a pseudo-document that does not meet these constraints 
is undefined.</P></DIV>
<P>In an Infoset (see <A 
href="REC-xslt20-20070123.htm#xml-infoset">[XML 
Information Set]</A>) created from a document conforming to <A 
href="REC-xslt20-20070123.htm#REC-xml-names">[Namespaces 
in XML 1.0]</A>, it will always be true that if a parent element has an in-scope 
namespace with a non-empty namespace prefix, then its child elements will also 
have an in-scope namespace with the same namespace prefix, though possibly with 
a different namespace URI. This constraint is removed in <A 
href="REC-xslt20-20070123.htm#xml-names11">[Namespaces in 
XML 1.1]</A>. XSLT 2.0 supports the creation of result trees that do not satisfy 
this constraint: the namespace fixup process does not add a namespace node to an 
element merely because its parent node in the <A title="result tree" 
href="REC-xslt20-20070123.htm#dt-result-tree">result 
tree</A> has such a namespace node. <SPAN>However, the process of constructing 
the children of a new element, which is described in <A 
href="REC-xslt20-20070123.htm#constructing-complex-content"><I>5.7.1 
Constructing Complex Content</I></A>, does cause the namespaces of a parent 
element to be inherited by its children unless this is prevented using 
<CODE>[xsl:]inherit-namespaces="no"</CODE> on the instruction that creates the 
parent element.</SPAN></P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>This has implications on serialization, defined in <A 
href="REC-xslt20-20070123.htm#xslt-xquery-serialization">[XSLT 
and XQuery Serialization]</A>. It means that it is possible to create <A 
title="final result tree" 
href="REC-xslt20-20070123.htm#dt-final-result-tree">final 
result trees</A> that cannot be faithfully serialized as XML 1.0 documents. When 
such a result tree is serialized as XML 1.0, namespace declarations written for 
the parent element will be inherited by its child elements as if the 
corresponding namespace nodes were present on the child element<SPAN>, except in 
the case of the default namespace, which can be undeclared using the construct 
<CODE>xmlns=""</CODE></SPAN>. When the same result tree is serialized as XML 
1.1, however, it is possible to undeclare any namespace on the child element 
<SPAN>(for example, <CODE>xmlms:foo=""</CODE>)</SPAN> to prevent this 
inheritance taking place.</P></DIV></DIV></DIV>
<DIV class=div2>
<H3><A id=uri-references name=uri-references></A>5.8 URI References</H3>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-uri-reference 
title="URI Reference" name=dt-uri-reference></A>Within this specification, the 
term <B>URI Reference</B>, unless otherwise stated, refers to a string in the 
lexical space of the <CODE>xs:anyURI</CODE> data type as defined in <A 
href="REC-xslt20-20070123.htm#xmlschema-2">[XML Schema 
Part 2]</A>.<SPAN class=definition>]</SPAN> Note that this is a wider definition 
than that in <A 
href="REC-xslt20-20070123.htm#RFC3986">[RFC3986]</A>: 
<SPAN>in particular, it is designed to accommodate Internationalized Resource 
Identifiers (IRIs) as described in <A 
href="REC-xslt20-20070123.htm#RFC3987">[RFC3987]</A>, and 
thus allows the use of non-ASCII characters without escaping.</SPAN></P>
<P>URI References are used in XSLT with three main roles:</P>
<BLOCKQUOTE>
  <P>As namespace URIs<BR>As collation URIs<BR>As identifiers for resources such 
  as stylesheet modules; these resources are typically accessible using a 
  protocol such as HTTP. Examples of such identifiers are the URIs used in the 
  <CODE>href</CODE> attributes of <A 
  href="REC-xslt20-20070123.htm#element-import"><CODE>xsl:import</CODE></A>, 
  <A 
  href="REC-xslt20-20070123.htm#element-include"><CODE>xsl:include</CODE></A>, 
  and <A 
  href="REC-xslt20-20070123.htm#element-result-document"><CODE>xsl:result-document</CODE></A>.</P></BLOCKQUOTE>
<P>The rules for namespace URIs are given in <A 
href="REC-xslt20-20070123.htm#REC-xml-names">[Namespaces 
in XML 1.0]</A> and <A 
href="REC-xslt20-20070123.htm#xml-names11">[Namespaces in 
XML 1.1]</A>. Those specifications deprecate the use of relative URIs as 
namespace URIs.</P>
<P>The rules for collation URIs are given in <A 
href="REC-xslt20-20070123.htm#xpath-functions">[Functions 
and Operators]</A>.</P>
<P>URI references used to identify external resources must conform to the same 
rules as the locator attribute (<CODE>href</CODE>) defined in section 5.4 of <A 
href="REC-xslt20-20070123.htm#xlink">[XLink]</A>. If the 
URI reference is relative, then it is resolved (unless otherwise specified) 
against the base URI of the containing element node, according to the rules of 
<SPAN><A 
href="REC-xslt20-20070123.htm#RFC3986">[RFC3986]</A></SPAN>, 
after first escaping all characters that need to be escaped to make it a valid 
RFC3986 URI reference. (But a relative URI in the <CODE>href</CODE> attribute of 
<A 
href="REC-xslt20-20070123.htm#element-result-document"><CODE>xsl:result-document</CODE></A> 
is resolved against the <A title="base output URI" 
href="REC-xslt20-20070123.htm#dt-base-output-uri">Base 
Output URI</A>.)</P>
<P>Other URI references appearing in an XSLT stylesheet document, for example 
the system identifiers of external entities or the value of the 
<CODE>xml:base</CODE> attribute, must follow the rules in their respective 
specifications.</P></DIV></DIV>
<DIV class=div1>
<H2><A id=rules name=rules></A>6 Template Rules</H2>
<P>Template rules define the processing that can be applied to nodes that match 
a particular <A title=pattern 
href="REC-xslt20-20070123.htm#dt-pattern">pattern</A>.</P>
<DIV class=div2>
<H3><A id=defining-templates name=defining-templates></A>6.1 Defining 
Templates</H3>
<P class=element-syntax><A id=element-template 
name=element-template></A><CODE>&lt;!-- Category: declaration 
--&gt;<BR>&lt;xsl:template<BR>&nbsp;&nbsp;match? = 
<VAR>pattern</VAR><BR>&nbsp;&nbsp;name? = 
<VAR>qname</VAR><BR>&nbsp;&nbsp;priority? = 
<VAR>number</VAR><BR>&nbsp;&nbsp;mode? = <VAR>tokens</VAR><BR>&nbsp;&nbsp;as? = 
<VAR>sequence-type</VAR>&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: (<A 
href="REC-xslt20-20070123.htm#element-param">xsl:param</A>*, 
<VAR>sequence-constructor</VAR>) --&gt;<BR>&lt;/xsl:template&gt;</CODE></P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-template 
title=template name=dt-template></A>An <A 
href="REC-xslt20-20070123.htm#element-template"><CODE>xsl:template</CODE></A> 
declaration defines a <B>template</B>, which contains a <SPAN><A 
title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A></SPAN> for creating nodes and/or atomic values. A template can 
serve either as a <A title="template rule" 
href="REC-xslt20-20070123.htm#dt-template-rule">template 
rule</A>, invoked by matching nodes against a <A title=pattern 
href="REC-xslt20-20070123.htm#dt-pattern">pattern</A>, or 
as a <A title="named template" 
href="REC-xslt20-20070123.htm#dt-named-template">named 
template</A>, invoked explicitly by name. It is also possible for the same 
template to serve in both capacities.<SPAN class=definition>]</SPAN></P>
<P><A id=err-XTSE0500 name=err-XTSE0500><SPAN class=error>[ERR 
XTSE0500]</SPAN></A> An <A 
href="REC-xslt20-20070123.htm#element-template"><CODE>xsl:template</CODE></A> 
element <SPAN class=verb>must</SPAN> have either a <CODE>match</CODE> attribute 
or a <CODE>name</CODE> attribute, or both. An <A 
href="REC-xslt20-20070123.htm#element-template"><CODE>xsl:template</CODE></A> 
element that has no <CODE>match</CODE> attribute <SPAN class=verb>must</SPAN> 
have no <CODE>mode</CODE> attribute and no <CODE>priority</CODE> attribute.</P>
<P>If an <A 
href="REC-xslt20-20070123.htm#element-template"><CODE>xsl:template</CODE></A> 
element has a <CODE>match</CODE> attribute, then it is a <A 
title="template rule" 
href="REC-xslt20-20070123.htm#dt-template-rule">template 
rule</A>. If it has a <CODE>name</CODE> attribute, then it is a <A 
title="named template" 
href="REC-xslt20-20070123.htm#dt-named-template">named 
template</A>.</P>
<P>A <A title=template 
href="REC-xslt20-20070123.htm#dt-template">template</A> 
may be invoked in a number of ways, depending on whether it is a <A 
title="template rule" 
href="REC-xslt20-20070123.htm#dt-template-rule">template 
rule</A>, a <A title="named template" 
href="REC-xslt20-20070123.htm#dt-named-template">named 
template</A>, or both. The result of invoking the template is the result of 
evaluating the <A title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A> contained in the <A 
href="REC-xslt20-20070123.htm#element-template"><CODE>xsl:template</CODE></A> 
element (see <A 
href="REC-xslt20-20070123.htm#sequence-constructors"><I>5.7 
Sequence Constructors</I></A>).</P>
<P>If an <CODE>as</CODE> attribute is present, the <CODE>as</CODE> attribute 
defines the required type of the result. The result of evaluating the <A 
title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A> is then converted to the required type using the <A 
title="function conversion rules" 
href="REC-xslt20-20070123.htm#dt-function-conversion-rules">function 
conversion rules</A>. If no <CODE>as</CODE> attribute is specified, the default 
value is <CODE>item()*</CODE>, which permits any value. No conversion then takes 
place.</P>
<P><A id=err-XTTE0505 name=err-XTTE0505><SPAN class=error>[ERR 
XTTE0505]</SPAN></A> It is a <A title="type errors" 
href="REC-xslt20-20070123.htm#dt-type-error">type 
error</A> if the result of evaluating the <A title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A> cannot be converted to the required type.</P></DIV>
<DIV class=div2>
<H3><A id=defining-template-rules name=defining-template-rules></A>6.2 Defining 
Template Rules</H3>
<P>This section describes <A title="template rule" 
href="REC-xslt20-20070123.htm#dt-template-rule">template 
rules</A>. <A title="named template" 
href="REC-xslt20-20070123.htm#dt-named-template">Named 
templates</A> are described in <A 
href="REC-xslt20-20070123.htm#named-templates"><I>10.1 
Named Templates</I></A>.</P>
<P>A <A title="template rule" 
href="REC-xslt20-20070123.htm#dt-template-rule">template 
rule</A> is specified using the <A 
href="REC-xslt20-20070123.htm#element-template"><CODE>xsl:template</CODE></A> 
element <SPAN>with a <CODE>match</CODE> attribute</SPAN>. The <CODE>match</CODE> 
attribute is a <A 
href="REC-xslt20-20070123.htm#NT-Pattern">Pattern</A> 
that identifies the node or nodes to which the rule applies. The result of 
applying the template rule is the result of evaluating the <SPAN>sequence</SPAN> 
constructor contained in the <A 
href="REC-xslt20-20070123.htm#element-template"><CODE>xsl:template</CODE></A> 
element, with the matching node used as the <A title="context node" 
href="REC-xslt20-20070123.htm#dt-context-node">context 
node</A>.</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e10170 name=d5e10170></A>Example: A simple 
Template Rule </DIV>
<P>For example, an XML document might contain:</P>
<DIV class=exampleInner><PRE>This is an &lt;emph&gt;important&lt;/emph&gt; point.
</PRE></DIV>
<P>The following <A title="template rule" 
href="REC-xslt20-20070123.htm#dt-template-rule">template 
rule</A> matches <CODE>emph</CODE> elements and produces a 
<CODE>fo:wrapper</CODE> element with a <CODE>font-weight</CODE> property of 
<CODE>bold</CODE>.</P>
<DIV class=exampleInner><PRE>&lt;xsl:template match="emph"&gt;
  &lt;fo:wrapper font-weight="bold" xmlns:fo="http://www.w3.org/1999/XSL/Format"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:wrapper&gt;
&lt;/xsl:template&gt;
</PRE></DIV></DIV>
<P>A <A title="template rule" 
href="REC-xslt20-20070123.htm#dt-template-rule">template 
rule</A> is evaluated when an <A 
href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A> 
instruction selects a node that matches the pattern specified in the 
<CODE>match</CODE> attribute. The <A 
href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A> 
instruction is described in the next section. If several template rules match a 
selected node, only one of them is evaluated, as described in <A 
href="REC-xslt20-20070123.htm#conflict"><I>6.4 Conflict 
Resolution for Template Rules</I></A>.</P></DIV>
<DIV class=div2>
<H3><A id=applying-templates name=applying-templates></A>6.3 Applying Template 
Rules</H3>
<P class=element-syntax><A id=element-apply-templates 
name=element-apply-templates></A><CODE>&lt;!-- Category: instruction 
--&gt;<BR>&lt;xsl:apply-templates<BR>&nbsp;&nbsp;select? = 
<VAR>expression</VAR><BR>&nbsp;&nbsp;mode? = 
<VAR>token</VAR>&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: (<A 
href="REC-xslt20-20070123.htm#element-sort">xsl:sort</A> 
| <A 
href="REC-xslt20-20070123.htm#element-with-param">xsl:with-param</A>)* 
--&gt;<BR>&lt;/xsl:apply-templates&gt;</CODE></P>
<P>The <A 
href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A> 
instruction takes as input a sequence of nodes (typically nodes in a <A 
title="source tree" 
href="REC-xslt20-20070123.htm#dt-source-tree">source 
tree</A>), and produces as output a sequence of items; these will often be nodes 
to be added to a <A title="result tree" 
href="REC-xslt20-20070123.htm#dt-result-tree">result 
tree</A>.</P>
<P>If the instruction has one or more <A 
href="REC-xslt20-20070123.htm#element-sort"><CODE>xsl:sort</CODE></A> 
children, then the input sequence is sorted as described in <A 
href="REC-xslt20-20070123.htm#sorting"><I>13 
Sorting</I></A>. The result of this sort is referred to below as the <B>sorted 
sequence</B>; if there are no <A 
href="REC-xslt20-20070123.htm#element-sort"><CODE>xsl:sort</CODE></A> 
elements, then the sorted sequence is the same as the input sequence.</P>
<P>Each node in the input sequence is processed by finding a <A 
title="template rule" 
href="REC-xslt20-20070123.htm#dt-template-rule">template 
rule</A> whose <A title=pattern 
href="REC-xslt20-20070123.htm#dt-pattern">pattern</A> 
matches that node. If there is more than one, the best among them is chosen, 
using rules described in <A 
href="REC-xslt20-20070123.htm#conflict"><I>6.4 Conflict 
Resolution for Template Rules</I></A>. If there is no template rule whose 
pattern matches the node, a built-in template rule is used (see <A 
href="REC-xslt20-20070123.htm#built-in-rule"><I>6.6 
Built-in Template Rules</I></A>). The chosen template rule is evaluated. The 
rule that matches the <VAR>N</VAR>th node in the sorted sequence is evaluated 
with that node as the <A title="context item" 
href="REC-xslt20-20070123.htm#dt-context-item">context 
item</A>, with <VAR>N</VAR> as the <A title="context position" 
href="REC-xslt20-20070123.htm#dt-context-position">context 
position</A>, and with the length of the sorted sequence as the <A 
title="context size" 
href="REC-xslt20-20070123.htm#dt-context-size">context 
size</A>. Each template rule that is evaluated produces a sequence of items as 
its result. The resulting sequences (one for each node in the sorted sequence) 
are then concatenated, to form a single sequence. They are concatenated 
retaining the order of the nodes in the sorted sequence. The final concatenated 
sequence forms the result of the <A 
href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A> 
instruction.</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e10281 name=d5e10281></A>Example: Applying 
Template Rules </DIV>
<P>Suppose the source document is as follows:</P>
<DIV class=exampleInner><PRE>&lt;message&gt;Proceed &lt;emph&gt;at once&lt;/emph&gt; to the exit!&lt;/message&gt;
</PRE></DIV>
<P>This can be processed using the two template rules shown below.</P>
<DIV class=exampleInner><PRE>&lt;xsl:template match="message"&gt;
  &lt;p&gt;
    &lt;xsl:apply-templates select="child::node()"/&gt;
  &lt;/p&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="emph"&gt;
  &lt;b&gt;
    &lt;xsl:apply-templates select="child::node()"/&gt;
  &lt;/b&gt;
&lt;/xsl:template&gt;
</PRE></DIV>
<P>There is no template rule for the document node; the built-in template rule 
for this node will cause the <CODE>message</CODE> element to be processed. The 
template rule for the <CODE>message</CODE> element causes a <CODE>p</CODE> 
element to be written to the <A title="result tree" 
href="REC-xslt20-20070123.htm#dt-result-tree">result 
tree</A>; the contents of this <CODE>p</CODE> element are constructed as the 
result of the <A 
href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A> 
instruction. This instruction selects the three child nodes of the 
<CODE>message</CODE> element (a text node containing the value 
"<CODE>Proceed</CODE> ", an <CODE>emph</CODE> element node, and a text node 
containing the value " <CODE>to the exit!</CODE>"). The two text nodes are 
processed using the built-in template rule for text nodes, which returns a copy 
of the text node. The <CODE>emph</CODE> element is processed using the explicit 
template rule that specifies <CODE>match="emph"</CODE>.</P>
<P>When the <CODE>emph</CODE> element is processed, this template rule 
constructs a <CODE>b</CODE> element. The contents of the <CODE>b</CODE> element 
are constructed by means of another <A 
href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A> 
instruction, which in this case selects a single node (the text node containing 
the value "<CODE>at once</CODE>"). This is again processed using the built-in 
template rule for text nodes, which returns a copy of the text node.</P>
<P>The final result of the <CODE>match="message"</CODE> template rule thus 
consists of a <CODE>p</CODE> element node with three children: a text node 
containing the value "<CODE>Proceed</CODE> ", a <CODE>b</CODE> element that is 
the parent of a text node containing the value "<CODE>at once</CODE>", and a 
text node containing the value " <CODE>to the exit!</CODE>". This <A 
title="result tree" 
href="REC-xslt20-20070123.htm#dt-result-tree">result 
tree</A> might be serialized as:</P>
<DIV class=exampleInner><PRE>&lt;p&gt;Proceed &lt;b&gt;at once&lt;/b&gt; to the exit!&lt;/p&gt;
</PRE></DIV></DIV>
<P>The default value of the <CODE>select</CODE> attribute is 
<CODE>child::node()</CODE>, which causes all the children of context node to be 
processed.</P>
<P><A id=err-XTTE0510 name=err-XTTE0510><SPAN class=error>[ERR 
XTTE0510]</SPAN></A> It is a <A title="type errors" 
href="REC-xslt20-20070123.htm#dt-type-error">type 
error</A> if an <A 
href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A> 
instruction with no <CODE>select</CODE> attribute is evaluated when the <A 
title="context item" 
href="REC-xslt20-20070123.htm#dt-context-item">context 
item</A> is not a node.</P>
<P>A <CODE>select</CODE> attribute can be used to process nodes selected by an 
expression instead of processing all children. The value of the 
<CODE>select</CODE> attribute is an <A title=expression 
href="REC-xslt20-20070123.htm#dt-expression">expression</A>. 
The expression <SPAN class=verb>must</SPAN> evaluate to a sequence of nodes (it 
can contain zero, one, or more nodes).</P>
<P><A id=err-XTTE0520 name=err-XTTE0520><SPAN class=error>[ERR 
XTTE0520]</SPAN></A> It is a <A title="type errors" 
href="REC-xslt20-20070123.htm#dt-type-error">type 
error</A> if the sequence returned by the <CODE>select</CODE> expression 
contains an item that is not a node.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>In XSLT 1.0, the <CODE>select</CODE> attribute selected a set of nodes, which 
by default were processed in document order. In XSLT 2.0, it selects a sequence 
of nodes. In cases that would have been valid in XSLT 1.0, the expression will 
return a sequence of nodes in document order, so the effect is the 
same.</P></DIV>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e10435 name=d5e10435></A>Example: Applying 
Templates to Selected Nodes </DIV>
<P>The following example processes all of the <CODE>given-name</CODE> children 
of the <CODE>author</CODE> elements that are children of 
<CODE>author-group</CODE>:</P>
<DIV class=exampleInner><PRE>&lt;xsl:template match="author-group"&gt;
  &lt;fo:wrapper&gt;
    &lt;xsl:apply-templates select="author/given-name"/&gt;
  &lt;/fo:wrapper&gt;
&lt;/xsl:template&gt;
</PRE></DIV></DIV>
<P>&nbsp;</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e10451 name=d5e10451></A>Example: Applying 
Templates to Nodes that are not Descendants </DIV>
<P>It is also possible to process elements that are not descendants of the 
context node. This example assumes that a <CODE>department</CODE> element has 
<CODE>group</CODE> children and <CODE>employee</CODE> descendants. It finds an 
employee's department and then processes the <CODE>group</CODE> children of the 
<CODE>department</CODE>.</P>
<DIV class=exampleInner><PRE>&lt;xsl:template match="employee"&gt;
  &lt;fo:block&gt;
    Employee &lt;xsl:apply-templates select="name"/&gt; belongs to group
    &lt;xsl:apply-templates select="ancestor::department/group"/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;
</PRE></DIV></DIV>
<P>&nbsp;</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e10473 name=d5e10473></A>Example: Matching by 
Schema-Defined Types </DIV>
<P>It is possible to write template rules that are matched according to the 
schema-defined type of an element or attribute. The following example applies 
different formatting to the children of an element depending on their type:</P>
<DIV class=exampleInner><PRE>&lt;xsl:template match="product"&gt;
  &lt;table&gt;
    &lt;xsl:apply-templates select="*"/&gt;
  &lt;/table&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="product/*" priority="3"&gt;
  &lt;tr&gt;
    &lt;td&gt;&lt;xsl:value-of select="name()"/&gt;&lt;/td&gt;
    &lt;td&gt;&lt;xsl:next-match/&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="product/element(*, xs:decimal) | 
                     product/element(*, xs:double)" priority="2"&gt;  
  &lt;xsl:value-of select="format-number(xs:double(.), '#,###0.00')"/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="product/element(*, xs:date)" priority="2"&gt;
  &lt;xsl:value-of select="format-date(., '[Mn] [D], [Y]')"/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="product/*" priority="1.5"&gt;
  &lt;xsl:value-of select="."/&gt;
&lt;/xsl:template&gt;
</PRE></DIV>
<P>The <A 
href="REC-xslt20-20070123.htm#element-next-match"><CODE>xsl:next-match</CODE></A> 
instruction is described in <A 
href="REC-xslt20-20070123.htm#apply-imports"><I>6.7 
Overriding Template Rules</I></A>.</P></DIV>
<P>&nbsp;</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e10487 name=d5e10487></A>Example: Re-ordering 
Elements in the Result Tree </DIV>
<P>Multiple <A 
href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A> 
elements can be used within a single template to do simple reordering. The 
following example creates two HTML tables. The first table is filled with 
domestic sales while the second table is filled with foreign sales.</P>
<DIV class=exampleInner><PRE>&lt;xsl:template match="product"&gt;
  &lt;table&gt;
    &lt;xsl:apply-templates select="sales/domestic"/&gt;
  &lt;/table&gt;
  &lt;table&gt;
    &lt;xsl:apply-templates select="sales/foreign"/&gt;
  &lt;/table&gt;
&lt;/xsl:template&gt;
</PRE></DIV></DIV>
<P>&nbsp;</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e10497 name=d5e10497></A>Example: Processing 
Recursive Structures </DIV>
<P>It is possible for there to be two matching descendants where one is a 
descendant of the other. This case is not treated specially: both descendants 
will be processed as usual.</P>
<P>For example, given a source document</P>
<DIV class=exampleInner><PRE>&lt;doc&gt;&lt;div&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/doc&gt;
</PRE></DIV>
<P>the rule</P>
<DIV class=exampleInner><PRE>&lt;xsl:template match="doc"&gt;
  &lt;xsl:apply-templates select=".//div"/&gt;
&lt;/xsl:template&gt;
</PRE></DIV>
<P>will process both the outer <CODE>div</CODE> and inner <CODE>div</CODE> 
elements.</P>
<P>This means that if the template rule for the <CODE>div</CODE> element 
processes its own children, then these grandchildren will be processed more than 
once, which is probably not what is required. The solution is to process one 
level at a time in a recursive descent, by using <CODE>select="div"</CODE> in 
place of <CODE>select=".//div"</CODE></P></DIV>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P><SPAN>The <A 
href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A> 
instruction is most commonly used</SPAN> to process nodes that are descendants 
of the context node. Such use of <A 
href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A> 
cannot result in non-terminating processing loops. However, when <A 
href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A> 
is used to process elements that are not descendants of the context node, the 
possibility arises of non-terminating loops. For example,</P>
<DIV class=exampleInner><PRE>&lt;xsl:template match="foo"&gt;
  &lt;xsl:apply-templates select="."/&gt;
&lt;/xsl:template&gt;
</PRE></DIV>
<P>Implementations may be able to detect such loops in some cases, but the 
possibility exists that a <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
may enter a non-terminating loop that an implementation is unable to detect. 
This may present a denial of service security risk.</P></DIV></DIV>
<DIV class=div2>
<H3><A id=conflict name=conflict></A>6.4 Conflict Resolution for Template 
Rules</H3>
<P>It is possible for a node in a source document to match more than one <A 
title="template rule" 
href="REC-xslt20-20070123.htm#dt-template-rule">template 
rule</A>. <SPAN>When this happens, only one template rule is evaluated for the 
node.</SPAN> The template rule to be used is determined as follows:</P>
<OL class=enumar>
  <LI>
  <P>First, only the matching template rule or rules with the highest <A 
  title="import precedence" 
  href="REC-xslt20-20070123.htm#dt-import-precedence">import 
  precedence</A> are considered. Other matching template rules with lower 
  precedence are eliminated from consideration.</P>
  <LI>
  <P>Next, of the remaining matching rules, only those with the highest priority 
  are considered. Other matching template rules with lower priority are 
  eliminated from consideration. The priority of a template rule is specified by 
  the <CODE>priority</CODE> attribute on the <A 
  href="REC-xslt20-20070123.htm#element-template"><CODE>xsl:template</CODE></A> 
  declaration.</P>
  <P><A id=err-XTSE0530 name=err-XTSE0530><SPAN class=error>[ERR 
  XTSE0530]</SPAN></A> The value of this attribute <SPAN class=verb>must</SPAN> 
  <SPAN>conform to the rules for the <CODE>xs:decimal</CODE> type defined in <A 
  href="REC-xslt20-20070123.htm#xmlschema-2">[XML Schema 
  Part 2]</A>. Negative values are permitted.</SPAN>.</P>
  <P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-default-priority 
  title="default priority" name=dt-default-priority></A>If no 
  <CODE>priority</CODE> attribute is specified on the <A 
  href="REC-xslt20-20070123.htm#element-template"><CODE>xsl:template</CODE></A> 
  element, a <B>default priority</B> is computed, based on the syntax of the 
  pattern supplied in the <CODE>match</CODE> attribute.<SPAN 
  class=definition>]</SPAN> The rules are as follows:</P>
  <UL>
    <LI>
    <P>If the pattern contains multiple alternatives separated by <CODE>|</CODE> 
    , then the template rule is treated equivalently to a set of template rules, 
    one for each alternative. However, it is not an error if a node matches more 
    than one of the alternatives.</P>
    <LI>
    <P>If the pattern has the form <CODE>/</CODE>, then the priority is 
−0.5.</P>
    <LI>
    <P>If the pattern has the form of a <A title=QName 
    href="REC-xslt20-20070123.htm#dt-qname">QName</A> 
    optionally preceded by a <A 
    href="REC-xslt20-20070123.htm#NT-PatternAxis">PatternAxis</A> 
    or has the form <CODE>processing-instruction(</CODE><A 
    href="http://www.w3.org/TR/xpath20/#doc-xpath-StringLiteral"> 
    StringLiteral</A><SUP><SMALL>XP</SMALL></SUP><CODE>)</CODE> or 
    <CODE>processing-instruction(</CODE><A 
    href="http://www.w3.org/TR/REC-xml-names/#NT-NCName">NCName</A><SUP> 
    <SMALL>Names</SMALL></SUP><CODE>)</CODE> optionally preceded by a <A 
    href="REC-xslt20-20070123.htm#NT-PatternAxis">PatternAxis</A>, 
    then the priority is 0.</P>
    <LI>
    <P>If the pattern has the form of an <A 
    href="http://www.w3.org/TR/xpath20/#doc-xpath-ElementTest">ElementTest</A><SUP><SMALL>XP</SMALL></SUP> 
    or <A 
    href="http://www.w3.org/TR/xpath20/#doc-xpath-AttributeTest">AttributeTest</A><SUP><SMALL>XP</SMALL></SUP>, 
    optionally preceded by a <A 
    href="REC-xslt20-20070123.htm#NT-PatternAxis">PatternAxis</A>, 
    then the priority is as shown in the table below. In this table, the symbols 
    <VAR>E</VAR>, <VAR>A</VAR>, and <VAR>T</VAR> represent an arbitrary element 
    name, attribute name, and type name respectively, while the symbol 
    <CODE>*</CODE> represents itself. The presence or absence of the 
    <SPAN>symbol <CODE>?</CODE> following a type name</SPAN> does not affect the 
    priority.</P>
    <TABLE cellPadding=5 border=1>
      <THEAD>
      <TR>
        <TH align=left>Format</TH>
        <TH align=left>Priority</TH>
        <TH align=left>Notes</TH></TR></THEAD>
      <TBODY>
      <TR>
        <TD><CODE>element()</CODE></TD>
        <TD>−0.5</TD>
        <TD>(equivalent to <CODE>*</CODE>)</TD></TR>
      <TR>
        <TD><CODE>element(*)</CODE></TD>
        <TD>−0.5</TD>
        <TD>(equivalent to <CODE>*</CODE>)</TD></TR>
      <TR>
        <TD><CODE>attribute()</CODE></TD>
        <TD>−0.5</TD>
        <TD>(equivalent to <CODE>@*</CODE>)</TD></TR>
      <TR>
        <TD><CODE>attribute(*)</CODE></TD>
        <TD>−0.5</TD>
        <TD>(equivalent to <CODE>@*</CODE>)</TD></TR>
      <TR>
        <TD><CODE>element(<VAR>E</VAR>)</CODE></TD>
        <TD>0</TD>
        <TD>(equivalent to E)</TD></TR>
      <TR>
        <TD><CODE>element(*,<VAR>T</VAR>)</CODE></TD>
        <TD>0</TD>
        <TD>(matches by type only)</TD></TR>
      <TR>
        <TD><CODE>attribute(<VAR>A</VAR>)</CODE></TD>
        <TD>0</TD>
        <TD>(equivalent to <CODE>@A</CODE>)</TD></TR>
      <TR>
        <TD><CODE>attribute(*,<VAR>T</VAR>)</CODE></TD>
        <TD>0</TD>
        <TD>(matches by type only)</TD></TR>
      <TR>
        <TD><CODE>element(<VAR>E</VAR>,<VAR>T</VAR>)</CODE></TD>
        <TD>0.25</TD>
        <TD>(matches by name and type)</TD></TR>
      <TR>
        <TD><CODE>schema-element(<VAR>E</VAR>)</CODE></TD>
        <TD>0.25</TD>
        <TD>(matches by substitution group and type)</TD></TR>
      <TR>
        <TD><CODE>attribute(<VAR>A</VAR>,<VAR>T</VAR>)</CODE></TD>
        <TD>0.25</TD>
        <TD>(matches by name and type)</TD></TR>
      <TR>
        <TD><CODE>schema-attribute(<VAR>A</VAR>)</CODE></TD>
        <TD>0.25</TD>
        <TD>(matches by name and type)</TD></TR></TBODY></TABLE>
    <LI>
    <P>If the pattern has the form of a <A 
    href="http://www.w3.org/TR/xpath20/#doc-xpath-DocumentTest">DocumentTest</A><SUP><SMALL>XP</SMALL></SUP>, 
    then if it includes no <A 
    href="http://www.w3.org/TR/xpath20/#doc-xpath-ElementTest">ElementTest</A><SUP><SMALL>XP</SMALL></SUP> 
    <SPAN>or <A 
    href="http://www.w3.org/TR/xpath20/#doc-xpath-SchemaElementTest">SchemaElementTest</A><SUP><SMALL>XP</SMALL></SUP></SPAN> 
    the priority is −0.5. If it does include an <A 
    href="http://www.w3.org/TR/xpath20/#doc-xpath-ElementTest">ElementTest</A><SUP><SMALL>XP</SMALL></SUP> 
    <SPAN>or <A 
    href="http://www.w3.org/TR/xpath20/#doc-xpath-SchemaElementTest">SchemaElementTest</A><SUP><SMALL>XP</SMALL></SUP></SPAN>, 
    then the priority is the same as the priority of that <A 
    href="http://www.w3.org/TR/xpath20/#doc-xpath-ElementTest">ElementTest</A><SUP><SMALL>XP</SMALL></SUP> 
    <SPAN>or <A 
    href="http://www.w3.org/TR/xpath20/#doc-xpath-SchemaElementTest">SchemaElementTest</A><SUP><SMALL>XP</SMALL></SUP></SPAN>, 
    computed according to the table above.</P>
    <LI>
    <P>If the pattern has the form <A 
    href="http://www.w3.org/TR/REC-xml-names/#NT-NCName">NCName</A><SUP> 
    <SMALL>Names</SMALL></SUP><CODE>:*</CODE> or <CODE>*:</CODE><A 
    href="http://www.w3.org/TR/REC-xml-names/#NT-NCName">NCName</A><SUP> 
    <SMALL>Names</SMALL></SUP>, optionally preceded by a <A 
    href="REC-xslt20-20070123.htm#NT-PatternAxis">PatternAxis</A>, 
    then the priority is −0.25.</P>
    <LI>
    <P>If the pattern is any other <A 
    href="http://www.w3.org/TR/xpath20/#doc-xpath-NodeTest">NodeTest</A><SUP> 
    <SMALL>XP</SMALL></SUP>, optionally preceded by a <A 
    href="REC-xslt20-20070123.htm#NT-PatternAxis">PatternAxis</A>, 
    then the priority is −0.5.</P>
    <LI>
    <P>Otherwise, the priority is 0.5.</P></LI></UL>
  <DIV class=note>
  <P class=prefix><B>Note:</B></P>
  <P>In many cases this means that highly selective patterns have higher 
  priority than less selective patterns. The most common kind of pattern (a 
  pattern that tests for a node of a <SPAN>particular kind, with a particular <A 
  title=expanded-QName 
  href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded-QName</A> 
  or a particular type)</SPAN> has priority 0. The next less specific kind of 
  pattern (a pattern that tests for a node of a particular kind and an <A 
  title=expanded-QName 
  href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded-QName</A> 
  with a particular namespace URI) has priority −0.25. Patterns less specific 
  than this (patterns that just test for nodes <SPAN>of a given kind</SPAN>) 
  have priority −0.5. <SPAN>Patterns that specify both the name and the required 
  type have a priority of +0.25, putting them above patterns that only specify 
  the name <EM>or</EM> the type.</SPAN> Patterns more specific than <SPAN>this, 
  for example patterns that include predicates or that specify the ancestry of 
  the required node,</SPAN> have priority 0.5.</P>
  <P>However, it is not invariably true that a more selective pattern has higher 
  priority than a less selective pattern. For example, the priority of the 
  pattern <CODE>node()[self::*]</CODE> is higher than that of the pattern 
  <CODE>salary</CODE>. <SPAN>Similarly, the patterns <CODE>attribute(*, 
  xs:decimal)</CODE> and <CODE>attribute(*, xs:short)</CODE> have the same 
  priority, despite the fact that the latter pattern matches a subset of the 
  nodes matched by the former.</SPAN> Therefore, to achieve clarity in a <A 
  title=stylesheet 
  href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
  it is good practice to allocate explicit priorities.</P></DIV></LI></OL>
<P><A id=err-XTRE0540 name=err-XTRE0540><SPAN class=error>[ERR 
XTRE0540]</SPAN></A> It is a <A title="recoverable error" 
href="REC-xslt20-20070123.htm#dt-recoverable-error">recoverable 
dynamic error</A> if the conflict resolution algorithm for template rules leaves 
more than one matching template rule. The <A title="optional recovery action" 
href="REC-xslt20-20070123.htm#dt-optional-recovery-action">optional 
recovery action</A> is to select, from the matching template rules that are 
left, the one that occurs last in <A title="declaration order" 
href="REC-xslt20-20070123.htm#dt-declaration-order">declaration 
order</A>.</P></DIV>
<DIV class=div2>
<H3><A id=modes name=modes></A>6.5 Modes</H3>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-mode title=mode 
name=dt-mode></A><B>Modes</B> allow a node in a <A title="source tree" 
href="REC-xslt20-20070123.htm#dt-source-tree">source 
tree</A> to be processed multiple times, each time producing a different result. 
They also allow different sets of <A title="template rule" 
href="REC-xslt20-20070123.htm#dt-template-rule">template 
rules</A> to be active when processing different trees, for example when 
processing documents loaded using the <A 
href="REC-xslt20-20070123.htm#function-document"><CODE>document</CODE></A> 
function (see <A 
href="REC-xslt20-20070123.htm#document"><I>16.1 Multiple 
Source Documents</I></A>) or when processing <A title="temporary tree" 
href="REC-xslt20-20070123.htm#dt-temporary-tree">temporary 
trees</A>.<SPAN class=definition>]</SPAN></P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-default-mode 
title="default mode" name=dt-default-mode></A>There is always a <B>default 
mode</B> available. The default mode is an unnamed <A title=mode 
href="REC-xslt20-20070123.htm#dt-mode">mode</A>, and it 
is used when no <CODE>mode</CODE> attribute is specified on an <A 
href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A> 
instruction.<SPAN class=definition>]</SPAN></P>
<P>Every <A title=mode 
href="REC-xslt20-20070123.htm#dt-mode">mode</A> other 
than the <A title="default mode" 
href="REC-xslt20-20070123.htm#dt-default-mode">default 
mode</A> is identified by a <A title=QName 
href="REC-xslt20-20070123.htm#dt-qname">QName</A>.</P>
<P>A <A title="template rule" 
href="REC-xslt20-20070123.htm#dt-template-rule">template 
rule</A> is applicable to one or more modes. The modes to which it is applicable 
are defined by the <CODE>mode</CODE> attribute of the <A 
href="REC-xslt20-20070123.htm#element-template"><CODE>xsl:template</CODE></A> 
element. If the attribute is omitted, then the template rule is applicable to 
the <A title="default mode" 
href="REC-xslt20-20070123.htm#dt-default-mode">default 
mode</A>. If the attribute is present, then its value <SPAN 
class=verb>must</SPAN> be a non-empty whitespace-separated list of tokens, each 
of which defines a mode to which the template rule is applicable. Each token 
<SPAN class=verb>must</SPAN> be one of the following:</P>
<UL>
  <LI>
  <P>a <A title=QName 
  href="REC-xslt20-20070123.htm#dt-qname">QName</A>, 
  which is expanded as described in <A 
  href="REC-xslt20-20070123.htm#qname"><I>5.1 Qualified 
  Names</I></A> to define the name of the mode</P>
  <LI>
  <P>the token <CODE>#default</CODE>, to indicate that the template rule is 
  applicable to the <A title="default mode" 
  href="REC-xslt20-20070123.htm#dt-default-mode">default 
  mode</A></P>
  <LI>
  <P>the token <CODE>#all</CODE>, to indicate that the template rule is 
  applicable to all modes <SPAN>(that is, to the default mode and to every mode 
  that is named in an <A 
  href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A> 
  instruction or <A 
  href="REC-xslt20-20070123.htm#element-template"><CODE>xsl:template</CODE></A> 
  declaration anywhere in the stylesheet)</SPAN>.</P></LI></UL>
<P><A id=err-XTSE0550 name=err-XTSE0550><SPAN class=error>[ERR 
XTSE0550]</SPAN></A> It is a <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A> if the list is empty, if the same token is included more than once in 
the list, if the list contains an invalid token, or if the token 
<CODE>#all</CODE> appears together with any other value.</P>
<P>The <A 
href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A> 
element also has an optional <CODE>mode</CODE> attribute. The value of this 
attribute <SPAN class=verb>must</SPAN> either be a <A title=QName 
href="REC-xslt20-20070123.htm#dt-qname">QName</A>, which 
is expanded as described in <A 
href="REC-xslt20-20070123.htm#qname"><I>5.1 Qualified 
Names</I></A> to define the name of a mode, or the token <CODE>#default</CODE>, 
to indicate that the <A title="default mode" 
href="REC-xslt20-20070123.htm#dt-default-mode">default 
mode</A> is to be used, or the token <CODE>#current</CODE>, to indicate that the 
<A title="current mode" 
href="REC-xslt20-20070123.htm#dt-current-mode">current 
mode</A> is to be used. If the attribute is omitted, the <A title="default mode" 
href="REC-xslt20-20070123.htm#dt-default-mode">default 
mode</A> is used.</P>
<P>When searching for a template rule to process each node selected by the <A 
href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A> 
instruction, only those template rules that are applicable to the selected mode 
are considered.</P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-current-mode 
title="current mode" name=dt-current-mode></A>At any point in the processing of 
a stylesheet, there is a <B>current mode</B>. When the transformation is 
initiated, the current mode is the <A title="default mode" 
href="REC-xslt20-20070123.htm#dt-default-mode">default 
mode</A>, <SPAN>unless a different initial mode has been supplied, as described 
in <A href="REC-xslt20-20070123.htm#initiating"><I>2.3 
Initiating a Transformation</I></A>.</SPAN> Whenever an <A 
href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A> 
instruction is evaluated, the current mode becomes the mode selected by this 
instruction.<SPAN class=definition>]</SPAN> When a stylesheet function is 
called, the current mode becomes the <A title="default mode" 
href="REC-xslt20-20070123.htm#dt-default-mode">default 
mode</A>. No other instruction changes the current mode. On completion of the <A 
href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A> 
instruction, <SPAN>or on return from a stylesheet function call,</SPAN> the 
current mode reverts to its previous value. The current mode is used when an <A 
href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A> 
instruction uses the syntax <CODE>mode="#current"</CODE>; it is also used by the 
<A 
href="REC-xslt20-20070123.htm#element-apply-imports"><CODE>xsl:apply-imports</CODE></A> 
<SPAN>and <A 
href="REC-xslt20-20070123.htm#element-next-match"><CODE>xsl:next-match</CODE></A></SPAN> 
instructions (see <A 
href="REC-xslt20-20070123.htm#apply-imports"><I>6.7 
Overriding Template Rules</I></A>).</P></DIV>
<DIV class=div2>
<H3><A id=built-in-rule name=built-in-rule></A>6.6 Built-in Template Rules</H3>
<P>When a node is selected by <A 
href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A> 
and there is no template rule in the <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
that can be used to process that node, a built-in template rule is evaluated 
instead.</P>
<P>The built-in template rules apply to all modes.</P>
<P>The built-in rule for document nodes and element nodes is equivalent to 
calling <A 
href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A> 
with no <CODE>select</CODE> attribute, and with the <CODE>mode</CODE> attribute 
set to <CODE>#current</CODE>. If the built-in rule was invoked with parameters, 
those parameters are passed on in the implicit <A 
href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A> 
instruction.</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e11192 name=d5e11192></A>Example: Using a 
Built-In Template Rule </DIV>
<P>For example, suppose the stylesheet contains the following instruction:</P>
<DIV class=exampleInner><PRE>&lt;xsl:apply-templates select="title" mode="mm"&gt;
  &lt;xsl:with-param name="init" select="10"/&gt;
&lt;/xsl:apply-templates&gt;
</PRE></DIV>
<P>If there is no explicit template rule that matches the <CODE>title</CODE> 
element, then the following implicit rule is used:</P>
<DIV class=exampleInner><PRE>&lt;xsl:template match="title" mode="#all"&gt;
  &lt;xsl:param name="init"/&gt;
  &lt;xsl:apply-templates mode="#current"&gt;
    &lt;xsl:with-param name="init" select="$init"/&gt;
  &lt;/xsl:apply-templates&gt;
&lt;/xsl:template&gt;
</PRE></DIV></DIV>
<P>The built-in <A title="template rule" 
href="REC-xslt20-20070123.htm#dt-template-rule">template 
rule</A> for text and attribute nodes returns a text node containing the <A 
title="string value" 
href="REC-xslt20-20070123.htm#dt-string-value">string 
value</A> of the context node. It is effectively:</P>
<DIV class=exampleInner><PRE>&lt;xsl:template match="text()|@*" mode="#all"&gt;
  &lt;xsl:value-of select="string(.)"/&gt;
&lt;/xsl:template&gt;
</PRE></DIV>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>This text node may have a string value that is zero-length.</P></DIV>
<P>The built-in <A title="template rule" 
href="REC-xslt20-20070123.htm#dt-template-rule">template 
rule</A> for processing instructions and comments does nothing (it returns the 
empty sequence).</P>
<DIV class=exampleInner><PRE>&lt;xsl:template match="processing-instruction()|comment()" mode="#all"/&gt;
</PRE></DIV>
<P>The built-in <A title="template rule" 
href="REC-xslt20-20070123.htm#dt-template-rule">template 
rule</A> for namespace nodes is also to do nothing. There is no pattern that can 
match a namespace node, <SPAN>so the built-in template rule is always used when 
<A 
href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A> 
selects a namespace node.</SPAN></P>
<P>The built-in <A title="template rule" 
href="REC-xslt20-20070123.htm#dt-template-rule">template 
rules</A> have lower <A title="import precedence" 
href="REC-xslt20-20070123.htm#dt-import-precedence">import 
precedence</A> than all other template rules. Thus, the stylesheet author can 
override a built-in template rule by including an explicit template 
rule.</P></DIV>
<DIV class=div2>
<H3><A id=apply-imports name=apply-imports></A>6.7 Overriding Template 
Rules</H3>
<P class=element-syntax><A id=element-apply-imports 
name=element-apply-imports></A><CODE>&lt;!-- Category: instruction 
--&gt;<BR>&lt;xsl:apply-imports&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: <A 
href="REC-xslt20-20070123.htm#element-with-param">xsl:with-param</A>* 
--&gt;<BR>&lt;/xsl:apply-imports&gt;</CODE></P>
<P class=element-syntax><A id=element-next-match 
name=element-next-match></A><CODE>&lt;!-- Category: instruction 
--&gt;<BR>&lt;xsl:next-match&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: (<A 
href="REC-xslt20-20070123.htm#element-with-param">xsl:with-param</A> 
| <A 
href="REC-xslt20-20070123.htm#element-fallback">xsl:fallback</A>)* 
--&gt;<BR>&lt;/xsl:next-match&gt;</CODE></P>
<P>A <A title="template rule" 
href="REC-xslt20-20070123.htm#dt-template-rule">template 
rule</A> that is being used to override another template rule (see <A 
href="REC-xslt20-20070123.htm#conflict"><I>6.4 Conflict 
Resolution for Template Rules</I></A>) can use the <A 
href="REC-xslt20-20070123.htm#element-apply-imports"><CODE>xsl:apply-imports</CODE></A> 
or <A 
href="REC-xslt20-20070123.htm#element-next-match"><CODE>xsl:next-match</CODE></A> 
instruction to invoke the overridden template rule. The <A 
href="REC-xslt20-20070123.htm#element-apply-imports"><CODE>xsl:apply-imports</CODE></A> 
instruction only considers template rules in imported stylesheet modules; the <A 
href="REC-xslt20-20070123.htm#element-next-match"><CODE>xsl:next-match</CODE></A> 
instruction considers all other template rules of lower <A 
title="import precedence" 
href="REC-xslt20-20070123.htm#dt-import-precedence">import 
precedence</A> and/or priority. <SPAN>Both instructions will invoke the built-in 
template rule for the node (see <A 
href="REC-xslt20-20070123.htm#built-in-rule"><I>6.6 
Built-in Template Rules</I></A>) if no other template rule is found.</SPAN></P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A 
id=dt-current-template-rule title="current template rule" 
name=dt-current-template-rule></A>At any point in the processing of a <A 
title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A>, 
there may be a <B>current template rule</B>. Whenever a <A title="template rule" 
href="REC-xslt20-20070123.htm#dt-template-rule">template 
rule</A> is chosen <SPAN>as a result of evaluating <A 
href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-apply-imports"><CODE>xsl:apply-imports</CODE></A>, 
or <A 
href="REC-xslt20-20070123.htm#element-next-match"><CODE>xsl:next-match</CODE></A></SPAN>, 
the template rule becomes the current template rule for the evaluation of the 
rule's sequence constructor. When an <A 
href="REC-xslt20-20070123.htm#element-for-each"><CODE>xsl:for-each</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-for-each-group"><CODE>xsl:for-each-group</CODE></A>, 
<SPAN>or <A 
href="REC-xslt20-20070123.htm#element-analyze-string"><CODE>xsl:analyze-string</CODE></A> 
instruction is evaluated, or when evaluating a sequence constructor contained in 
an <A 
href="REC-xslt20-20070123.htm#element-sort"><CODE>xsl:sort</CODE></A> 
or <A 
href="REC-xslt20-20070123.htm#element-key"><CODE>xsl:key</CODE></A> 
element, or when</SPAN> a <A title="stylesheet function" 
href="REC-xslt20-20070123.htm#dt-stylesheet-function">stylesheet 
function</A> is called (see <A 
href="REC-xslt20-20070123.htm#stylesheet-functions"><I>10.3 
Stylesheet Functions</I></A>), the current template rule becomes null for the 
evaluation of that instruction or function.<SPAN class=definition>]</SPAN></P>
<P>The current template rule is not affected by invoking named templates (see <A 
href="REC-xslt20-20070123.htm#named-templates"><I>10.1 
Named Templates</I></A>) or named attribute sets (see <A 
href="REC-xslt20-20070123.htm#attribute-sets"><I>10.2 
Named Attribute Sets</I></A>). While evaluating a <A title="global variable" 
href="REC-xslt20-20070123.htm#dt-global-variable">global 
variable</A> <SPAN>or the default value of a <A title="stylesheet parameter" 
href="REC-xslt20-20070123.htm#dt-stylesheet-parameter">stylesheet 
parameter</A></SPAN> (see <A 
href="REC-xslt20-20070123.htm#global-variables"><I>9.5 
Global Variables and Parameters</I></A>) the current template rule is null.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>These rules ensure that when <A 
href="REC-xslt20-20070123.htm#element-apply-imports"><CODE>xsl:apply-imports</CODE></A> 
or <A 
href="REC-xslt20-20070123.htm#element-next-match"><CODE>xsl:next-match</CODE></A> 
is called, the <A title="context item" 
href="REC-xslt20-20070123.htm#dt-context-item">context 
item</A> is the same as when the current template rule was invoked, and is 
always a node.</P></DIV>
<P><SPAN>Both <A 
href="REC-xslt20-20070123.htm#element-apply-imports"><CODE>xsl:apply-imports</CODE></A> 
and <A 
href="REC-xslt20-20070123.htm#element-next-match"><CODE>xsl:next-match</CODE></A> 
search</SPAN> for a <A title="template rule" 
href="REC-xslt20-20070123.htm#dt-template-rule">template 
rule</A> that matches the <A title="context node" 
href="REC-xslt20-20070123.htm#dt-context-node">context 
node</A>, and that is applicable to the <A title="current mode" 
href="REC-xslt20-20070123.htm#dt-current-mode">current 
mode</A> (see <A 
href="REC-xslt20-20070123.htm#modes"><I>6.5 
Modes</I></A>). In choosing a template rule, <SPAN>they use</SPAN> the usual 
criteria such as the priority and <A title="import precedence" 
href="REC-xslt20-20070123.htm#dt-import-precedence">import 
precedence</A> of the template rules, but <SPAN>they consider as candidates only 
a subset of the template rules in the <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A>. 
This subset differs between the two instructions:</SPAN></P>
<UL>
  <LI>
  <P>The <A 
  href="REC-xslt20-20070123.htm#element-apply-imports"><CODE>xsl:apply-imports</CODE></A> 
  instruction considers as candidates only those template rules contained in <A 
  title="stylesheet level" 
  href="REC-xslt20-20070123.htm#dt-stylesheet-level">stylesheet 
  levels</A> that are descendants in the <A title="import tree" 
  href="REC-xslt20-20070123.htm#dt-import-tree">import 
  tree</A> of the <A title="stylesheet level" 
  href="REC-xslt20-20070123.htm#dt-stylesheet-level">stylesheet 
  level</A> that contains the <A title="current template rule" 
  href="REC-xslt20-20070123.htm#dt-current-template-rule">current 
  template rule</A>.</P>
  <DIV class=note>
  <P class=prefix><B>Note:</B></P>
  <P>This is <EM>not</EM> the same as saying that the search considers all 
  template rules whose import precedence is lower than that of the current 
  template rule.</P></DIV>
  <LI>
  <P>The <A 
  href="REC-xslt20-20070123.htm#element-next-match"><CODE>xsl:next-match</CODE></A> 
  instruction considers as candidates all those template rules that come after 
  the <A title="current template rule" 
  href="REC-xslt20-20070123.htm#dt-current-template-rule">current 
  template rule</A> in the ordering of template rules implied by the conflict 
  resolution rules given in <A 
  href="REC-xslt20-20070123.htm#conflict"><I>6.4 Conflict 
  Resolution for Template Rules</I></A>. That is, it considers all template 
  rules with lower <A title="import precedence" 
  href="REC-xslt20-20070123.htm#dt-import-precedence">import 
  precedence</A> than the <A title="current template rule" 
  href="REC-xslt20-20070123.htm#dt-current-template-rule">current 
  template rule</A>, plus the template rules that are at the same import 
  precedence that have lower priority than the current template rule. If the 
  processor has recovered from the error that occurs when two matching template 
  rules have the same import precedence and priority, then it also considers all 
  matching template rules with the same import precedence and priority that 
  occur before the current template rule in <A title="declaration order" 
  href="REC-xslt20-20070123.htm#dt-declaration-order">declaration 
  order</A>.</P>
  <DIV class=note>
  <P class=prefix><B>Note:</B></P>
  <P>As explained in <A 
  href="REC-xslt20-20070123.htm#conflict"><I>6.4 Conflict 
  Resolution for Template Rules</I></A>, a template rule whose match pattern 
  contains multiple alternatives separated by <CODE>|</CODE> is treated 
  equivalently to a set of template rules, one for each alternative. This means 
  that where the same node matches more than one alternative, and the 
  alternatives have different priority, it is possible for an <A 
  href="REC-xslt20-20070123.htm#element-next-match"><CODE>xsl:next-match</CODE></A> 
  instruction to cause the current template rule to be invoked recursively. This 
  situation does not occur when the alternatives have the same 
  priority.</P></DIV></LI></UL>
<P>If no matching template rule is found that satisfies these criteria, the 
built-in template rule for the node <SPAN>kind</SPAN> is used (see <A 
href="REC-xslt20-20070123.htm#built-in-rule"><I>6.6 
Built-in Template Rules</I></A>).</P>
<P>An <A 
href="REC-xslt20-20070123.htm#element-apply-imports"><CODE>xsl:apply-imports</CODE></A> 
<SPAN>or <A 
href="REC-xslt20-20070123.htm#element-next-match"><CODE>xsl:next-match</CODE></A></SPAN> 
instruction may use <A 
href="REC-xslt20-20070123.htm#element-with-param"><CODE>xsl:with-param</CODE></A> 
child elements to pass parameters to the chosen <A title="template rule" 
href="REC-xslt20-20070123.htm#dt-template-rule">template 
rule</A> (see <A 
href="REC-xslt20-20070123.htm#with-param"><I>10.1.1 
Passing Parameters to Templates</I></A>). It also passes on any <A 
title="tunnel parameter" 
href="REC-xslt20-20070123.htm#dt-tunnel-parameter">tunnel 
parameters</A> as described in <A 
href="REC-xslt20-20070123.htm#tunnel-params"><I>10.1.2 
Tunnel Parameters</I></A>.</P>
<P><A id=err-XTDE0560 name=err-XTDE0560><SPAN class=error>[ERR 
XTDE0560]</SPAN></A> It is a <A title="non-recoverable dynamic error" 
href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
dynamic error</A> if <A 
href="REC-xslt20-20070123.htm#element-apply-imports"><CODE>xsl:apply-imports</CODE></A> 
<SPAN>or <A 
href="REC-xslt20-20070123.htm#element-next-match"><CODE>xsl:next-match</CODE></A></SPAN> 
is evaluated when the <A title="current template rule" 
href="REC-xslt20-20070123.htm#dt-current-template-rule">current 
template rule</A> is null.</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e11507 name=d5e11507></A>Example: Using 
<CODE>xsl:apply-imports</CODE> </DIV>
<P>For example, suppose the stylesheet <CODE>doc.xsl</CODE> contains a <A 
title="template rule" 
href="REC-xslt20-20070123.htm#dt-template-rule">template 
rule</A> for <CODE>example</CODE> elements:</P>
<DIV class=exampleInner><PRE>&lt;xsl:template match="example"&gt;
  &lt;pre&gt;&lt;xsl:apply-templates/&gt;&lt;/pre&gt;
&lt;/xsl:template&gt;
</PRE></DIV>
<P>Another stylesheet could import <CODE>doc.xsl</CODE> and modify the treatment 
of <CODE>example</CODE> elements as follows:</P>
<DIV class=exampleInner><PRE>&lt;xsl:import href="doc.xsl"/&gt;

&lt;xsl:template match="example"&gt;
  &lt;div style="border: solid red"&gt;
     &lt;xsl:apply-imports/&gt;
  &lt;/div&gt;
&lt;/xsl:template&gt;
</PRE></DIV>
<P>The combined effect would be to transform an <CODE>example</CODE> into an 
element of the form:</P>
<DIV class=exampleInner><PRE>&lt;div style="border: solid red"&gt;&lt;pre&gt;...&lt;/pre&gt;&lt;/div&gt;
</PRE></DIV></DIV>
<P>An <A 
href="REC-xslt20-20070123.htm#element-fallback"><CODE>xsl:fallback</CODE></A> 
instruction appearing as a child of an <A 
href="REC-xslt20-20070123.htm#element-next-match"><CODE>xsl:next-match</CODE></A> 
instruction is ignored by an XSLT 2.0 processor, but can be used to define 
fallback behavior when the stylesheet is processed by an XSLT 1.0 processor in 
forwards-compatible mode.</P></DIV></DIV>
<DIV class=div1>
<H2><A id=for-each name=for-each></A>7 Repetition</H2>
<P class=element-syntax><A id=element-for-each 
name=element-for-each></A><CODE>&lt;!-- Category: instruction 
--&gt;<BR>&lt;xsl:for-each<BR>&nbsp;&nbsp;<B>select</B> = 
<VAR>expression</VAR>&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: (<A 
href="REC-xslt20-20070123.htm#element-sort">xsl:sort</A>*, 
<VAR>sequence-constructor</VAR>) --&gt;<BR>&lt;/xsl:for-each&gt;</CODE></P>
<P>The <A 
href="REC-xslt20-20070123.htm#element-for-each"><CODE>xsl:for-each</CODE></A> 
instruction processes each item in a sequence of items, evaluating the <A 
title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A> within the <A 
href="REC-xslt20-20070123.htm#element-for-each"><CODE>xsl:for-each</CODE></A> 
instruction once for each item in that sequence.</P>
<P>The <CODE>select</CODE> attribute is <SPAN class=verb>required</SPAN>, and 
the <A title=expression 
href="REC-xslt20-20070123.htm#dt-expression">expression</A> 
<SPAN class=verb>must</SPAN> evaluate to a sequence, called the input sequence. 
If there is an <A 
href="REC-xslt20-20070123.htm#element-sort"><CODE>xsl:sort</CODE></A> 
element present (see <A 
href="REC-xslt20-20070123.htm#sorting"><I>13 
Sorting</I></A>) the input sequence is sorted to produce a sorted sequence. 
Otherwise, the sorted sequence is the same as the input sequence.</P>
<P>The <A 
href="REC-xslt20-20070123.htm#element-for-each"><CODE>xsl:for-each</CODE></A> 
instruction contains a <A title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A>. The <A title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A> is evaluated once for each item in the sorted sequence, with the 
<A title=focus 
href="REC-xslt20-20070123.htm#dt-focus">focus</A> set as 
follows:</P>
<UL>
  <LI>
  <P>The <A title="context item" 
  href="REC-xslt20-20070123.htm#dt-context-item">context 
  item</A> is the item being processed. If this is a node, it will also be the 
  <A title="context node" 
  href="REC-xslt20-20070123.htm#dt-context-node">context 
  node</A>. If it is not a node, there will be no context node: that is, 
  <SPAN>any attempt to reference the context node will result in a <A 
  title="non-recoverable dynamic error" 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A>.</SPAN></P>
  <LI>
  <P>The <A title="context position" 
  href="REC-xslt20-20070123.htm#dt-context-position">context 
  position</A> is the position of this item in the sorted sequence.</P>
  <LI>
  <P>The <A title="context size" 
  href="REC-xslt20-20070123.htm#dt-context-size">context 
  size</A> is the size of the sorted sequence (which is the same as the size of 
  the input sequence).</P></LI></UL>
<P>For each item in the input sequence, evaluating the <A 
title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A> produces a sequence of items (see <A 
href="REC-xslt20-20070123.htm#sequence-constructors"><I>5.7 
Sequence Constructors</I></A>). These output sequences are concatenated; 
<SPAN>if item <VAR>Q</VAR> follows item <VAR>P</VAR> in the sorted sequence, 
then the result of evaluating the sequence constructor with <VAR>Q</VAR> as the 
context item is concatenated after the result of evaluating the sequence 
constructor with <VAR>P</VAR> as the context item.</SPAN> The result of the <A 
href="REC-xslt20-20070123.htm#element-for-each"><CODE>xsl:for-each</CODE></A> 
instruction is the concatenated sequence of items.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>With XSLT 1.0, the selected nodes were processed in document order. With XSLT 
2.0, XPath expressions that would have been valid under XPath 1.0 (such as path 
expressions and union expressions) will return a sequence of nodes that is 
already in document order, so backwards compatibility is maintained.</P></DIV>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e11663 name=d5e11663></A>Example: Using 
<CODE>xsl:for-each</CODE> </DIV>
<P>For example, given an XML document with this structure</P>
<DIV class=exampleInner><PRE>&lt;customers&gt;
  &lt;customer&gt;
    &lt;name&gt;...&lt;/name&gt;
    &lt;order&gt;...&lt;/order&gt;
    &lt;order&gt;...&lt;/order&gt;
  &lt;/customer&gt;
  &lt;customer&gt;
    &lt;name&gt;...&lt;/name&gt;
    &lt;order&gt;...&lt;/order&gt;
    &lt;order&gt;...&lt;/order&gt;
  &lt;/customer&gt;
&lt;/customers&gt;
</PRE></DIV>
<P>the following would create an HTML document containing a table with a row for 
each <CODE>customer</CODE> element</P>
<DIV class=exampleInner><PRE>&lt;xsl:template match="/"&gt;
  &lt;html&gt;
    &lt;head&gt;
      &lt;title&gt;Customers&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
      &lt;table&gt;
        &lt;tbody&gt;
          &lt;xsl:for-each select="customers/customer"&gt;
            &lt;tr&gt;
              &lt;th&gt;
                &lt;xsl:apply-templates select="name"/&gt;
              &lt;/th&gt;
              &lt;xsl:for-each select="order"&gt;
                &lt;td&gt;
                  &lt;xsl:apply-templates/&gt;
                &lt;/td&gt;
              &lt;/xsl:for-each&gt;
            &lt;/tr&gt;
          &lt;/xsl:for-each&gt;
        &lt;/tbody&gt;
      &lt;/table&gt;
    &lt;/body&gt;
  &lt;/html&gt;
&lt;/xsl:template&gt;
</PRE></DIV></DIV></DIV>
<DIV class=div1>
<H2><A id=conditionals name=conditionals></A>8 Conditional Processing</H2>
<P>There are two instructions in XSLT that support conditional processing: <A 
href="REC-xslt20-20070123.htm#element-if"><CODE>xsl:if</CODE></A> 
and <A 
href="REC-xslt20-20070123.htm#element-choose"><CODE>xsl:choose</CODE></A>. 
The <A 
href="REC-xslt20-20070123.htm#element-if"><CODE>xsl:if</CODE></A> 
instruction provides simple if-then conditionality; the <A 
href="REC-xslt20-20070123.htm#element-choose"><CODE>xsl:choose</CODE></A> 
instruction supports selection of one choice when there are several 
possibilities.</P>
<DIV class=div2>
<H3><A id=xsl-if name=xsl-if></A>8.1 Conditional Processing with <A 
href="REC-xslt20-20070123.htm#element-if"><CODE>xsl:if</CODE></A></H3>
<P class=element-syntax><A id=element-if name=element-if></A><CODE>&lt;!-- 
Category: instruction --&gt;<BR>&lt;xsl:if<BR>&nbsp;&nbsp;<B>test</B> = 
<VAR>expression</VAR>&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: 
<VAR>sequence-constructor</VAR> --&gt;<BR>&lt;/xsl:if&gt;</CODE></P>
<P>The <A 
href="REC-xslt20-20070123.htm#element-if"><CODE>xsl:if</CODE></A> 
element has a mandatory <CODE>test</CODE> attribute, which specifies an <A 
title=expression 
href="REC-xslt20-20070123.htm#dt-expression">expression</A>. 
The content is a <A title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A>.</P>
<P>The result of the <A 
href="REC-xslt20-20070123.htm#element-if"><CODE>xsl:if</CODE></A> 
instruction depends on the <A 
href="http://www.w3.org/TR/xpath20/#dt-ebv">effective boolean 
value</A><SUP><SMALL>XP</SMALL></SUP> of the expression in the <CODE>test</CODE> 
attribute. The rules for determining the effective boolean value of an 
expression are given in <A 
href="REC-xslt20-20070123.htm#xpath20">[XPath 2.0]</A>: 
they are the same as the rules used for XPath conditional expressions.</P>
<P>If the effective boolean value of the <A title=expression 
href="REC-xslt20-20070123.htm#dt-expression">expression</A> 
is true, then the <A title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A> is evaluated (see <A 
href="REC-xslt20-20070123.htm#sequence-constructors"><I>5.7 
Sequence Constructors</I></A>), and the resulting node sequence is returned as 
the result of the <A 
href="REC-xslt20-20070123.htm#element-if"><CODE>xsl:if</CODE></A> 
instruction; otherwise, <SPAN>the sequence constructor is not evaluated, 
and</SPAN> the empty sequence is returned.</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e11752 name=d5e11752></A>Example: Using 
<CODE>xsl:if</CODE> </DIV>
<P>In the following example, the names in a group of names are formatted as a 
comma separated list:</P>
<DIV class=exampleInner><PRE>&lt;xsl:template match="namelist/name"&gt;
  &lt;xsl:apply-templates/&gt;
  &lt;xsl:if test="not(position()=last())"&gt;, &lt;/xsl:if&gt;
&lt;/xsl:template&gt;
</PRE></DIV>
<P>The following colors every other table row yellow:</P>
<DIV class=exampleInner><PRE>&lt;xsl:template match="item"&gt;
  &lt;tr&gt;
    &lt;xsl:if test="position() mod 2 = 0"&gt;
       &lt;xsl:attribute name="bgcolor"&gt;yellow&lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/tr&gt;
&lt;/xsl:template&gt;
</PRE></DIV></DIV></DIV>
<DIV class=div2>
<H3><A id=xsl-choose name=xsl-choose></A>8.2 Conditional Processing with <A 
href="REC-xslt20-20070123.htm#element-choose"><CODE>xsl:choose</CODE></A></H3>
<P class=element-syntax><A id=element-choose 
name=element-choose></A><CODE>&lt;!-- Category: instruction 
--&gt;<BR>&lt;xsl:choose&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: (<A 
href="REC-xslt20-20070123.htm#element-when">xsl:when</A>+, 
<A 
href="REC-xslt20-20070123.htm#element-otherwise">xsl:otherwise</A>?) 
--&gt;<BR>&lt;/xsl:choose&gt;</CODE></P>
<P class=element-syntax><A id=element-when 
name=element-when></A><CODE>&lt;xsl:when<BR>&nbsp;&nbsp;<B>test</B> = 
<VAR>expression</VAR>&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: 
<VAR>sequence-constructor</VAR> --&gt;<BR>&lt;/xsl:when&gt;</CODE></P>
<P class=element-syntax><A id=element-otherwise 
name=element-otherwise></A><CODE>&lt;xsl:otherwise&gt;<BR>&nbsp;&nbsp;&lt;!-- 
Content: <VAR>sequence-constructor</VAR> 
--&gt;<BR>&lt;/xsl:otherwise&gt;</CODE></P>
<P>The <A 
href="REC-xslt20-20070123.htm#element-choose"><CODE>xsl:choose</CODE></A> 
element selects one among a number of possible alternatives. It consists of a 
sequence of one or more <A 
href="REC-xslt20-20070123.htm#element-when"><CODE>xsl:when</CODE></A> 
elements followed by an optional <A 
href="REC-xslt20-20070123.htm#element-otherwise"><CODE>xsl:otherwise</CODE></A> 
element. Each <A 
href="REC-xslt20-20070123.htm#element-when"><CODE>xsl:when</CODE></A> 
element has a single attribute, <CODE>test</CODE>, which specifies an <A 
title=expression 
href="REC-xslt20-20070123.htm#dt-expression">expression</A>. 
The content of the <A 
href="REC-xslt20-20070123.htm#element-when"><CODE>xsl:when</CODE></A> 
and <A 
href="REC-xslt20-20070123.htm#element-otherwise"><CODE>xsl:otherwise</CODE></A> 
elements is a <A title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A>.</P>
<P>When an <A 
href="REC-xslt20-20070123.htm#element-choose"><CODE>xsl:choose</CODE></A> 
element is processed, each of the <A 
href="REC-xslt20-20070123.htm#element-when"><CODE>xsl:when</CODE></A> 
elements is tested in turn (that is, in <SPAN>the order that</SPAN> the elements 
appear in the stylesheet), until one of the <A 
href="REC-xslt20-20070123.htm#element-when"><CODE>xsl:when</CODE></A> 
elements is satisfied. <SPAN>If none of the <A 
href="REC-xslt20-20070123.htm#element-when"><CODE>xsl:when</CODE></A> 
elements is satisfied, then the <A 
href="REC-xslt20-20070123.htm#element-otherwise"><CODE>xsl:otherwise</CODE></A> 
element is considered, as described below.</SPAN></P>
<P>An <A 
href="REC-xslt20-20070123.htm#element-when"><CODE>xsl:when</CODE></A> 
element is satisfied if the <A 
href="http://www.w3.org/TR/xpath20/#dt-ebv">effective boolean 
value</A><SUP><SMALL>XP</SMALL></SUP> of the <A title=expression 
href="REC-xslt20-20070123.htm#dt-expression">expression</A> 
in its <CODE>test</CODE> attribute is <CODE>true</CODE>. The rules for 
determining the effective boolean value of an expression are given in <A 
href="REC-xslt20-20070123.htm#xpath20">[XPath 2.0]</A>: 
they are the same as the rules used for XPath conditional expressions.</P>
<P>The content of the first, and only the first, <A 
href="REC-xslt20-20070123.htm#element-when"><CODE>xsl:when</CODE></A> 
element that is satisfied is evaluated, and the resulting sequence is returned 
as the result of the <A 
href="REC-xslt20-20070123.htm#element-choose"><CODE>xsl:choose</CODE></A> 
instruction. If no <A 
href="REC-xslt20-20070123.htm#element-when"><CODE>xsl:when</CODE></A> 
element is satisfied, the content of the <A 
href="REC-xslt20-20070123.htm#element-otherwise"><CODE>xsl:otherwise</CODE></A> 
element is evaluated, and the resulting sequence is returned as the result of 
the <A 
href="REC-xslt20-20070123.htm#element-choose"><CODE>xsl:choose</CODE></A> 
instruction. If no <A 
href="REC-xslt20-20070123.htm#element-when"><CODE>xsl:when</CODE></A> 
element is satisfied, and no <A 
href="REC-xslt20-20070123.htm#element-otherwise"><CODE>xsl:otherwise</CODE></A> 
element is present, the result of the <A 
href="REC-xslt20-20070123.htm#element-choose"><CODE>xsl:choose</CODE></A> 
instruction is an empty sequence.</P>
<P>Only the <SPAN>sequence</SPAN> constructor of the selected <A 
href="REC-xslt20-20070123.htm#element-when"><CODE>xsl:when</CODE></A> 
or <A 
href="REC-xslt20-20070123.htm#element-otherwise"><CODE>xsl:otherwise</CODE></A> 
instruction is evaluated. The <CODE>test</CODE> expressions for <A 
href="REC-xslt20-20070123.htm#element-when"><CODE>xsl:when</CODE></A> 
instructions after the selected one are not evaluated.</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e11904 name=d5e11904></A>Example: Using 
<CODE>xsl:choose</CODE> </DIV>
<P>The following example enumerates items in an ordered list using arabic 
numerals, letters, or roman numerals depending on the depth to which the ordered 
lists are nested.</P>
<DIV class=exampleInner><PRE>&lt;xsl:template match="orderedlist/listitem"&gt;
  &lt;fo:list-item indent-start='2pi'&gt;
    &lt;fo:list-item-label&gt;
      &lt;xsl:variable name="level"
                    select="count(ancestor::orderedlist) mod 3"/&gt;
      &lt;xsl:choose&gt;
        &lt;xsl:when test='$level=1'&gt;
          &lt;xsl:number format="i"/&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:when test='$level=2'&gt;
          &lt;xsl:number format="a"/&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:otherwise&gt;
          &lt;xsl:number format="1"/&gt;
        &lt;/xsl:otherwise&gt;
      &lt;/xsl:choose&gt;
      &lt;xsl:text&gt;. &lt;/xsl:text&gt;
    &lt;/fo:list-item-label&gt;
    &lt;fo:list-item-body&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/fo:list-item-body&gt;
  &lt;/fo:list-item&gt;
&lt;/xsl:template&gt;
</PRE></DIV></DIV></DIV></DIV>
<DIV class=div1>
<H2><A id=variables-and-parameters name=variables-and-parameters></A>9 Variables 
and Parameters</H2>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A 
id=dt-variable-binding-element title="variable-binding element" 
name=dt-variable-binding-element></A>The two elements <A 
href="REC-xslt20-20070123.htm#element-variable"><CODE>xsl:variable</CODE></A> 
and <A 
href="REC-xslt20-20070123.htm#element-param"><CODE>xsl:param</CODE></A> 
are referred to as <B>variable-binding elements</B> <SPAN 
class=definition>]</SPAN>.</P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-variable 
title=variable name=dt-variable></A>The <A 
href="REC-xslt20-20070123.htm#element-variable"><CODE>xsl:variable</CODE></A> 
element declares a <B>variable</B>, which may be a <A title="global variable" 
href="REC-xslt20-20070123.htm#dt-global-variable">global 
variable</A> or a <A title="local variable" 
href="REC-xslt20-20070123.htm#dt-local-variable">local 
variable</A>.<SPAN class=definition>]</SPAN></P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-parameter 
title=parameter name=dt-parameter></A>The <A 
href="REC-xslt20-20070123.htm#element-param"><CODE>xsl:param</CODE></A> 
element declares a <B>parameter</B>, which may be a <A 
title="stylesheet parameter" 
href="REC-xslt20-20070123.htm#dt-stylesheet-parameter">stylesheet 
parameter</A>, a <A title="template parameter" 
href="REC-xslt20-20070123.htm#dt-template-parameter">template 
parameter</A>, or a <A title="function parameter" 
href="REC-xslt20-20070123.htm#dt-function-parameter">function 
parameter</A>. A parameter is a <A title=variable 
href="REC-xslt20-20070123.htm#dt-variable">variable</A> 
with the additional property that its value can be set by the caller when the 
stylesheet, the template, or the function is invoked.<SPAN 
class=definition>]</SPAN></P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-value title=value 
name=dt-value></A>A variable is a binding between a name and a value. The 
<B>value</B> of a variable is any sequence (of nodes and/or atomic values), as 
defined in <A 
href="REC-xslt20-20070123.htm#xpath-datamodel">[Data 
Model]</A>.<SPAN class=definition>]</SPAN></P>
<DIV class=div2>
<H3><A id=variables name=variables></A>9.1 Variables</H3>
<P class=element-syntax><A id=element-variable 
name=element-variable></A><CODE>&lt;!-- Category: declaration --&gt;<BR>&lt;!-- 
Category: instruction --&gt;<BR>&lt;xsl:variable<BR>&nbsp;&nbsp;<B>name</B> = 
<VAR>qname</VAR><BR>&nbsp;&nbsp;select? = 
<VAR>expression</VAR><BR>&nbsp;&nbsp;as? = 
<VAR>sequence-type</VAR>&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: 
<VAR>sequence-constructor</VAR> --&gt;<BR>&lt;/xsl:variable&gt;</CODE></P>
<P>The <A 
href="REC-xslt20-20070123.htm#element-variable"><CODE>xsl:variable</CODE></A> 
element has a <SPAN class=verb>required</SPAN> <CODE>name</CODE> attribute, 
which specifies the name of the variable. The value of the <CODE>name</CODE> 
attribute is a <A title=QName 
href="REC-xslt20-20070123.htm#dt-qname">QName</A>, which 
is expanded as described in <A 
href="REC-xslt20-20070123.htm#qname"><I>5.1 Qualified 
Names</I></A>.</P>
<P>The <A 
href="REC-xslt20-20070123.htm#element-variable"><CODE>xsl:variable</CODE></A> 
element has an optional <CODE>as</CODE> attribute, which specifies the <A 
title="required type" 
href="REC-xslt20-20070123.htm#dt-required-type">required 
type</A> of the variable. The value of the <CODE>as</CODE> attribute is a <A 
href="http://www.w3.org/TR/xpath20/#doc-xpath-SequenceType">SequenceType</A><SUP> 
<SMALL>XP</SMALL></SUP>, as defined in <A 
href="REC-xslt20-20070123.htm#xpath20">[XPath 
2.0]</A>.</P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-supplied-value 
title="supplied value" name=dt-supplied-value></A>The value of the variable is 
computed using the <A title=expression 
href="REC-xslt20-20070123.htm#dt-expression">expression</A> 
given in the <CODE>select</CODE> attribute or the contained <A 
title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A>, as described in <A 
href="REC-xslt20-20070123.htm#variable-values"><I>9.3 
Values of Variables and Parameters</I></A>. This value is referred to as the 
<B>supplied value</B> of the variable.<SPAN class=definition>]</SPAN> <SPAN>If 
the <A 
href="REC-xslt20-20070123.htm#element-variable"><CODE>xsl:variable</CODE></A> 
element has a <CODE>select</CODE> attribute, then the sequence constructor <SPAN 
class=verb>must</SPAN> be empty.</SPAN></P>
<P>If the <CODE>as</CODE> attribute is specified, then the <A 
title="supplied value" 
href="REC-xslt20-20070123.htm#dt-supplied-value">supplied 
value</A> of the variable is converted to the required type, using the <A 
title="function conversion rules" 
href="REC-xslt20-20070123.htm#dt-function-conversion-rules">function 
conversion rules</A>.</P>
<P><A id=err-XTTE0570 name=err-XTTE0570><SPAN class=error>[ERR 
XTTE0570]</SPAN></A> It is a <A title="type errors" 
href="REC-xslt20-20070123.htm#dt-type-error">type 
error</A> if the <A title="supplied value" 
href="REC-xslt20-20070123.htm#dt-supplied-value">supplied 
value</A> of a variable cannot be converted to the required type.</P>
<P>If the <CODE>as</CODE> attribute is omitted, the <A title="supplied value" 
href="REC-xslt20-20070123.htm#dt-supplied-value">supplied 
value</A> of the variable is used directly, and no conversion takes 
place.</P></DIV>
<DIV class=div2>
<H3><A id=parameters name=parameters></A>9.2 Parameters</H3>
<P class=element-syntax><A id=element-param name=element-param></A><CODE>&lt;!-- 
Category: declaration --&gt;<BR>&lt;xsl:param<BR>&nbsp;&nbsp;<B>name</B> = 
<VAR>qname</VAR><BR>&nbsp;&nbsp;select? = 
<VAR>expression</VAR><BR>&nbsp;&nbsp;as? = 
<VAR>sequence-type</VAR><BR>&nbsp;&nbsp;required? = "yes" | 
"no"<BR>&nbsp;&nbsp;tunnel? = "yes" | "no"&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: 
<VAR>sequence-constructor</VAR> --&gt;<BR>&lt;/xsl:param&gt;</CODE></P>
<P>The <A 
href="REC-xslt20-20070123.htm#element-param"><CODE>xsl:param</CODE></A> 
element may be used as a child of <A 
href="REC-xslt20-20070123.htm#element-stylesheet"><CODE>xsl:stylesheet</CODE></A>, 
to define a parameter to the transformation; or as a child of <A 
href="REC-xslt20-20070123.htm#element-template"><CODE>xsl:template</CODE></A> 
to define a parameter to a template, which may be supplied when the template is 
invoked using <A 
href="REC-xslt20-20070123.htm#element-call-template"><CODE>xsl:call-template</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-apply-imports"><CODE>xsl:apply-imports</CODE></A> 
<SPAN>or <A 
href="REC-xslt20-20070123.htm#element-next-match"><CODE>xsl:next-match</CODE></A></SPAN>; 
or as a child of <A 
href="REC-xslt20-20070123.htm#element-function"><CODE>xsl:function</CODE></A> 
to define a parameter to a stylesheet function, which may be supplied when the 
function is called from an XPath <A title=expression 
href="REC-xslt20-20070123.htm#dt-expression">expression</A>.</P>
<P>The <A 
href="REC-xslt20-20070123.htm#element-param"><CODE>xsl:param</CODE></A> 
element has a <SPAN class=verb>required</SPAN> <CODE>name</CODE> attribute, 
which specifies the name of the parameter. The value of the <CODE>name</CODE> 
attribute is a <A title=QName 
href="REC-xslt20-20070123.htm#dt-qname">QName</A>, which 
is expanded as described in <A 
href="REC-xslt20-20070123.htm#qname"><I>5.1 Qualified 
Names</I></A>.</P>
<P><A id=err-XTSE0580 name=err-XTSE0580><SPAN class=error>[ERR 
XTSE0580]</SPAN></A> It is a <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A> if two parameters of a template or of a stylesheet function have the 
same name.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>For rules concerning stylesheet parameters, see <A 
href="REC-xslt20-20070123.htm#global-variables"><I>9.5 
Global Variables and Parameters</I></A>. Local variables may <A title=shadows 
href="REC-xslt20-20070123.htm#dt-shadows">shadow</A> 
template parameters and function parameters: see <A 
href="REC-xslt20-20070123.htm#scope-of-variables"><I>9.7 
Scope of Variables</I></A>.</P></DIV>
<P>The <A title="supplied value" 
href="REC-xslt20-20070123.htm#dt-supplied-value">supplied 
value</A> of the parameter is the value supplied by the caller. If no value was 
supplied by the caller, and if the parameter is not mandatory, then the supplied 
value is computed using the <A title=expression 
href="REC-xslt20-20070123.htm#dt-expression">expression</A> 
given in the <CODE>select</CODE> attribute or the contained <A 
title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A>, as described in <A 
href="REC-xslt20-20070123.htm#variable-values"><I>9.3 
Values of Variables and Parameters</I></A>. <SPAN>If the <A 
href="REC-xslt20-20070123.htm#element-param"><CODE>xsl:param</CODE></A> 
element has a <CODE>select</CODE> attribute, then the sequence constructor <SPAN 
class=verb>must</SPAN> be empty.</SPAN></P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>This specification does not dictate whether and when the default value of a 
parameter is evaluated. For example, if the default is specified as 
<CODE>&lt;xsl:param name="p"&gt;&lt;foo/&gt;&lt;/xsl:param&gt;</CODE>, then it 
is not specified whether a distinct <CODE>foo</CODE> element node will be 
created on each invocation of the template, or whether the same <CODE>foo</CODE> 
element node will be used for each invocation. However, it is permissible for 
the default value to depend on the values of other parameters, or on the 
evaluation context, in which case the default must effectively be evaluated on 
each invocation.</P></DIV>
<P>The <A 
href="REC-xslt20-20070123.htm#element-param"><CODE>xsl:param</CODE></A> 
element has an optional <CODE>as</CODE> attribute, which specifies the <A 
title="required type" 
href="REC-xslt20-20070123.htm#dt-required-type">required 
type</A> of the parameter. The value of the <CODE>as</CODE> attribute is a <A 
href="http://www.w3.org/TR/xpath20/#doc-xpath-SequenceType">SequenceType</A><SUP> 
<SMALL>XP</SMALL></SUP>, as defined in <A 
href="REC-xslt20-20070123.htm#xpath20">[XPath 
2.0]</A>.</P>
<P>If the <CODE>as</CODE> attribute is specified, then the <A 
title="supplied value" 
href="REC-xslt20-20070123.htm#dt-supplied-value">supplied 
value</A> of the parameter is converted to the required type, using the <A 
title="function conversion rules" 
href="REC-xslt20-20070123.htm#dt-function-conversion-rules">function 
conversion rules</A>.</P>
<P><A id=err-XTTE0590 name=err-XTTE0590><SPAN class=error>[ERR 
XTTE0590]</SPAN></A> It is a <A title="type errors" 
href="REC-xslt20-20070123.htm#dt-type-error">type 
error</A> if the conversion of the <A title="supplied value" 
href="REC-xslt20-20070123.htm#dt-supplied-value">supplied 
value</A> of a parameter to its required type fails.</P>
<P>If the <CODE>as</CODE> attribute is omitted, the <A title="supplied value" 
href="REC-xslt20-20070123.htm#dt-supplied-value">supplied 
value</A> of the parameter is used directly, and no conversion takes place.</P>
<P>The optional <CODE>required</CODE> attribute may be used to indicate that a 
parameter is mandatory. This attribute may be specified for <A 
title="stylesheet parameter" 
href="REC-xslt20-20070123.htm#dt-stylesheet-parameter">stylesheet 
parameters</A> and for <A title="template parameter" 
href="REC-xslt20-20070123.htm#dt-template-parameter">template 
parameters</A>; it <SPAN class=verb>must not</SPAN> be specified for <A 
title="function parameter" 
href="REC-xslt20-20070123.htm#dt-function-parameter">function 
parameters</A>, which are always mandatory. <SPAN>A parameter is mandatory if it 
is a <A title="function parameter" 
href="REC-xslt20-20070123.htm#dt-function-parameter">function 
parameter</A> or if the <CODE>required</CODE> attribute is present and has the 
value <CODE>yes</CODE>. Otherwise, the parameter is optional. If the parameter 
is mandatory, then</SPAN> the <A 
href="REC-xslt20-20070123.htm#element-param"><CODE>xsl:param</CODE></A> 
element <SPAN class=verb>must</SPAN> be empty and <SPAN class=verb>must 
not</SPAN> have a <CODE>select</CODE> attribute.</P>
<P><A id=err-XTTE0600 name=err-XTTE0600><SPAN class=error>[ERR 
XTTE0600]</SPAN></A> If a default value is given explicitly, that is, if there 
is either a <CODE>select</CODE> attribute or a non-empty <A 
title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A>, then it is a <A title="type errors" 
href="REC-xslt20-20070123.htm#dt-type-error">type 
error</A> if the default value cannot be converted to the required type, using 
the <A title="function conversion rules" 
href="REC-xslt20-20070123.htm#dt-function-conversion-rules">function 
conversion rules</A>.</P>
<P>If an optional parameter has no <CODE>select</CODE> attribute and has an 
empty <A title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A>, and if there is no <CODE>as</CODE> attribute, then the default 
value of the parameter is a zero length string.</P>
<P><A id=err-XTDE0610 name=err-XTDE0610><SPAN class=error>[ERR 
XTDE0610]</SPAN></A> If an optional parameter has no <CODE>select</CODE> 
attribute and has an empty <A title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A>, and if there is an <CODE>as</CODE> attribute, then the default 
value of the parameter is an empty sequence. If the empty sequence is not a 
valid instance of the required type defined in the <CODE>as</CODE> attribute, 
then the parameter is treated as a required parameter, which means that it is a 
<A title="non-recoverable dynamic error" 
href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
dynamic error</A> if the caller supplies no value for the parameter.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>The effect of these rules is that specifying <CODE>&lt;xsl:param name="p" 
as="xs:date" select="2"/&gt;</CODE> is an error, but if the default value of the 
parameter is never used, then the processor has discretion whether or not to 
report the error. By contrast, <CODE>&lt;xsl:param name="p" 
as="xs:date"/&gt;</CODE> is treated as if <CODE>required="yes"</CODE> had been 
specified: the empty sequence is not a valid instance of <CODE>xs:date</CODE>, 
so in effect there is no default value and the parameter is therefore treated as 
being mandatory.</P></DIV>
<P>The optional <CODE>tunnel</CODE> attribute may be used to indicate that a 
parameter is a <A title="tunnel parameter" 
href="REC-xslt20-20070123.htm#dt-tunnel-parameter">tunnel 
parameter</A>. The default is <CODE>no</CODE>; the value <CODE>yes</CODE> may be 
specified only for <A title="template parameter" 
href="REC-xslt20-20070123.htm#dt-template-parameter">template 
parameters</A>. Tunnel parameters are described in <A 
href="REC-xslt20-20070123.htm#tunnel-params"><I>10.1.2 
Tunnel Parameters</I></A></P></DIV>
<DIV class=div2>
<H3><A id=variable-values name=variable-values></A>9.3 Values of Variables and 
Parameters</H3>
<P>A <A title="variable-binding element" 
href="REC-xslt20-20070123.htm#dt-variable-binding-element">variable-binding 
element</A> may specify the <A title="supplied value" 
href="REC-xslt20-20070123.htm#dt-supplied-value">supplied 
value</A> of the <A title=variable 
href="REC-xslt20-20070123.htm#dt-variable">variable</A> 
or <A title=parameter 
href="REC-xslt20-20070123.htm#dt-parameter">parameter</A> 
in <SPAN>four</SPAN> different ways.</P>
<UL>
  <LI>
  <P>If the <A title="variable-binding element" 
  href="REC-xslt20-20070123.htm#dt-variable-binding-element">variable-binding 
  element</A> has a <CODE>select</CODE> attribute, then the value of the 
  attribute <SPAN class=verb>must</SPAN> be an <A title=expression 
  href="REC-xslt20-20070123.htm#dt-expression">expression</A> 
  and the <A title="supplied value" 
  href="REC-xslt20-20070123.htm#dt-supplied-value">supplied 
  value</A> of the variable is the value that results from evaluating the 
  expression. In this case, the content of the variable-binding element <SPAN 
  class=verb>must</SPAN> be empty.</P>
  <LI>
  <P>If the <A title="variable-binding element" 
  href="REC-xslt20-20070123.htm#dt-variable-binding-element">variable-binding 
  element</A> has empty content and <SPAN>has neither a <CODE>select</CODE> 
  attribute nor an <CODE>as</CODE> attribute</SPAN>, then the <A 
  title="supplied value" 
  href="REC-xslt20-20070123.htm#dt-supplied-value">supplied 
  value</A> of the variable is a zero-length string. Thus</P>
  <DIV class=exampleInner><PRE>&lt;xsl:variable name="x"/&gt;
</PRE></DIV>
  <P>is equivalent to</P>
  <DIV class=exampleInner><PRE>&lt;xsl:variable name="x" select="''"/&gt;
</PRE></DIV>
  <LI>
  <P>If a <A title="variable-binding element" 
  href="REC-xslt20-20070123.htm#dt-variable-binding-element">variable-binding 
  element</A> has no <CODE>select</CODE> attribute and has non-empty content 
  (that is, the variable-binding element has one or more child nodes), and has 
  no <CODE>as</CODE> attribute, then the content of the variable-binding element 
  specifies the <A title="supplied value" 
  href="REC-xslt20-20070123.htm#dt-supplied-value">supplied 
  value</A>. The content of the variable-binding element is a <A 
  title="sequence constructor" 
  href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
  constructor</A>; a new document is constructed with a document node having as 
  its children the sequence of nodes that results from evaluating the sequence 
  constructor and then applying the rules given in <A 
  href="REC-xslt20-20070123.htm#constructing-complex-content"><I>5.7.1 
  Constructing Complex Content</I></A>. The value of the variable is then a 
  singleton sequence containing this document node. For further information, see 
  <A 
  href="REC-xslt20-20070123.htm#temporary-trees"><I>9.4 
  Creating implicit document nodes</I></A>.</P>
  <LI>
  <P>If a <A title="variable-binding element" 
  href="REC-xslt20-20070123.htm#dt-variable-binding-element">variable-binding 
  element</A> has an <CODE>as</CODE> attribute but no <CODE>select</CODE> 
  attribute, then the <A title="supplied value" 
  href="REC-xslt20-20070123.htm#dt-supplied-value">supplied 
  value</A> is the sequence that results from evaluating the (possibly empty) <A 
  title="sequence constructor" 
  href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
  constructor</A> contained within the variable-binding element (see <A 
  href="REC-xslt20-20070123.htm#sequence-constructors"><I>5.7 
  Sequence Constructors</I></A>).</P></LI></UL>
<P>These combinations are summarized in the table below.</P>
<TABLE cellPadding=5 border=1>
  <COLGROUP>
  <COL width="12%">
  <COL width="12%">
  <COL width="12%">
  <COL>
  <THEAD>
  <TR>
    <TH align=left>select attribute</TH>
    <TH align=left>as attribute</TH>
    <TH align=left>content</TH>
    <TH align=left>Effect</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD vAlign=top>present</TD>
    <TD vAlign=top>absent</TD>
    <TD vAlign=top>empty</TD>
    <TD vAlign=top>Value is obtained by evaluating the <CODE>select</CODE> 
      attribute</TD></TR>
  <TR>
    <TD vAlign=top>present</TD>
    <TD vAlign=top>present</TD>
    <TD vAlign=top>empty</TD>
    <TD vAlign=top>Value is obtained by evaluating the <CODE>select</CODE> 
      attribute, adjusted to the type required by the <CODE>as</CODE> 
    attribute</TD></TR>
  <TR>
    <TD vAlign=top>present</TD>
    <TD vAlign=top>absent</TD>
    <TD vAlign=top>present</TD>
    <TD vAlign=top>Static error</TD></TR>
  <TR>
    <TD vAlign=top>present</TD>
    <TD vAlign=top>present</TD>
    <TD vAlign=top>present</TD>
    <TD vAlign=top>Static error</TD></TR>
  <TR>
    <TD vAlign=top>absent</TD>
    <TD vAlign=top>absent</TD>
    <TD vAlign=top>empty</TD>
    <TD vAlign=top>Value is a zero-length string</TD></TR>
  <TR>
    <TD vAlign=top>absent</TD>
    <TD vAlign=top>present</TD>
    <TD vAlign=top>empty</TD>
    <TD vAlign=top>Value is an empty sequence, provided the <CODE>as</CODE> 
      attribute permits an empty sequence</TD></TR>
  <TR>
    <TD vAlign=top>absent</TD>
    <TD vAlign=top>absent</TD>
    <TD vAlign=top>present</TD>
    <TD vAlign=top><SPAN>Value is a document node whose content is obtained by 
      evaluating the sequence constructor</SPAN></TD></TR>
  <TR>
    <TD vAlign=top>absent</TD>
    <TD vAlign=top>present</TD>
    <TD vAlign=top>present</TD>
    <TD vAlign=top>Value is obtained by evaluating the sequence constructor, 
      adjusted to the type required by the <CODE>as</CODE> 
  attribute</TD></TR></TBODY></TABLE>
<P><A id=err-XTSE0620 name=err-XTSE0620><SPAN class=error>[ERR 
XTSE0620]</SPAN></A> It is a <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A> if a <A title="variable-binding element" 
href="REC-xslt20-20070123.htm#dt-variable-binding-element">variable-binding 
element</A> has a <CODE>select</CODE> attribute and has non-empty content.</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e12625 name=d5e12625></A>Example: Values of 
Variables </DIV>
<P>The value of the following variable is the sequence of integers (1, 2, 
3):</P>
<DIV class=exampleInner><PRE>&lt;xsl:variable name="i" as="xs:integer*" select="1 to 3"/&gt;
</PRE></DIV>
<P>The value of the following variable is an integer, assuming that the 
attribute <CODE>@size</CODE> exists, and is annotated either as an integer, or 
as <SPAN><CODE>xs:untypedAtomic</CODE></SPAN>:</P>
<DIV class=exampleInner><PRE>&lt;xsl:variable name="i" as="xs:integer" select="@size"/&gt;
</PRE></DIV>
<P>The value of the following variable is a zero-length string:</P>
<DIV class=exampleInner><PRE>&lt;xsl:variable name="z"/&gt;
</PRE></DIV>
<P>The value of the following variable is document node containing an empty 
element as a child:</P>
<DIV class=exampleInner><PRE>&lt;xsl:variable name="doc"&gt;&lt;c/&gt;&lt;/xsl:variable&gt;
</PRE></DIV>
<P>The value of the following variable is sequence of integers (2, 4, 6):</P>
<DIV class=exampleInner><PRE>&lt;xsl:variable name="seq" as="xs:integer*"&gt;
  &lt;xsl:for-each select="1 to 3"&gt;
    &lt;xsl:sequence select=".*2"/&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:variable&gt;
</PRE></DIV>
<P>The value of the following variable is sequence of parentless attribute 
nodes:</P>
<DIV class=exampleInner><PRE>&lt;xsl:variable name="attset" as="attribute()+"&gt;
  &lt;xsl:attribute name="x"&gt;2&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="y"&gt;3&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="z"&gt;4&lt;/xsl:attribute&gt;    
&lt;/xsl:variable&gt;
</PRE></DIV>
<P>The value of the following variable is an empty sequence:</P>
<DIV class=exampleInner><PRE>&lt;xsl:variable name="empty" as="empty-sequence()"/&gt;
</PRE></DIV></DIV>
<P>The actual value of the variable depends on the <A title="supplied value" 
href="REC-xslt20-20070123.htm#dt-supplied-value">supplied 
value</A>, as described above, and the required type, which is determined by the 
value of the <CODE>as</CODE> attribute.</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e12672 name=d5e12672></A>Example: Pitfalls with 
Numeric Predicates </DIV>
<P>When a variable is used to select nodes by position, be careful not to 
do:</P>
<DIV class=exampleInner><PRE>&lt;xsl:variable name="n"&gt;2&lt;/xsl:variable&gt;
...
&lt;xsl:value-of select="td[$n]"/&gt;
</PRE></DIV>
<P>This will output the values of all the <CODE>td</CODE> elements, 
space-separated (or in backwards compatibility mode, the value of the first 
<CODE>td</CODE> element), because the variable <CODE>n</CODE> will be bound to a 
node, not a number. Instead, do one of the following:</P>
<DIV class=exampleInner><PRE>&lt;xsl:variable name="n" select="2"/&gt;
...
&lt;xsl:value-of select="td[$n]"/&gt;
</PRE></DIV>
<P>or</P>
<DIV class=exampleInner><PRE>&lt;xsl:variable name="n"&gt;2&lt;/xsl:variable&gt;
...
&lt;xsl:value-of select="td[position()=$n]"/&gt;
</PRE></DIV>
<P>or</P>
<DIV class=exampleInner><PRE>&lt;xsl:variable name="n" as="xs:integer"&gt;2&lt;/xsl:variable&gt;
...
&lt;xsl:value-of select="td[$n]"/&gt;
</PRE></DIV></DIV></DIV>
<DIV class=div2>
<H3><A id=temporary-trees name=temporary-trees></A>9.4 <SPAN>Creating implicit 
document nodes</SPAN></H3>
<P>A document node is created implicitly when evaluating an <A 
href="REC-xslt20-20070123.htm#element-variable"><CODE>xsl:variable</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-param"><CODE>xsl:param</CODE></A>, 
or <A 
href="REC-xslt20-20070123.htm#element-with-param"><CODE>xsl:with-param</CODE></A> 
element that has non-empty content and that has no <CODE>as</CODE> attribute. 
This element is referred to as the variable-binding element. The value of the <A 
title=variable 
href="REC-xslt20-20070123.htm#dt-variable">variable</A> 
is a single node, the document node of the <A title="temporary tree" 
href="REC-xslt20-20070123.htm#dt-temporary-tree">temporary 
tree</A>. The content of the document node is formed from the result of 
evaluating the <A title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A> contained within the variable-binding element, as described in 
<A 
href="REC-xslt20-20070123.htm#constructing-complex-content"><I>5.7.1 
Constructing Complex Content</I></A>.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>The construct:</P>
<DIV class=exampleInner><PRE>&lt;xsl:variable name="tree"&gt;
  &lt;a/&gt;
&lt;/xsl:variable&gt;
</PRE></DIV>
<P>can be regarded as a shorthand for:</P>
<DIV class=exampleInner><PRE>&lt;xsl:variable name="tree" as="document-node()"&gt;
  &lt;xsl:document validation="preserve"&gt;
    &lt;a/&gt;
  &lt;/xsl:document&gt;  
&lt;/xsl:variable&gt;
</PRE></DIV></DIV>
<P>The base URI of the document node is taken from the base URI of the variable 
binding element in the stylesheet. (See <A 
href="http://www.w3.org/TR/xpath-datamodel/#dm-base-uri">Section 5.2 base-uri 
Accessor</A><SUP><SMALL>DM</SMALL></SUP> in <A 
href="REC-xslt20-20070123.htm#xpath-datamodel">[Data 
Model]</A>)</P>
<P>No document-level validation takes place (which means, for example, that 
there is no checking that ID values are unique). However, type annotations on 
nodes within the new tree are copied unchanged.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>The base URI of other nodes in the tree is determined by the rules for 
constructing complex content. The effect of these rules is that the base URI of 
a node in the temporary tree is determined as if all the nodes in the temporary 
tree came from a single entity whose URI was the base URI of the <A 
title="variable-binding element" 
href="REC-xslt20-20070123.htm#dt-variable-binding-element">variable-binding 
element</A>. Thus, the base URI of the document node will be equal to the base 
URI of the variable-binding element; an <CODE>xml:base</CODE> attribute within 
the temporary tree will change the base URI for its parent element and that 
element's descendants, just as it would within a document constructed by 
parsing.</P></DIV>
<P>The <CODE>document-uri</CODE> and <CODE>unparsed-entities</CODE> properties 
of the new document node are set to empty.</P>
<P>A <A title="temporary tree" 
href="REC-xslt20-20070123.htm#dt-temporary-tree">temporary 
tree</A> is available for processing in exactly the same way as any source 
document. For example, its nodes are accessible using path expressions, and they 
can be processed using instructions such as <A 
href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A> 
and <A 
href="REC-xslt20-20070123.htm#element-for-each"><CODE>xsl:for-each</CODE></A>. 
Also, the <A 
href="REC-xslt20-20070123.htm#function-key"><CODE>key</CODE></A> 
and <A 
href="http://www.w3.org/TR/xpath-functions/#func-id"><CODE>id</CODE></A><SUP> 
<SMALL>FO</SMALL></SUP> functions can be used to find nodes within a temporary 
tree <SPAN>rooted at a document node</SPAN>, provided that at the time the 
function is called, the context item is a node within the temporary tree.</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e12785 name=d5e12785></A>Example: Two-Phase 
Transformation </DIV>
<P>For example, the following stylesheet uses a temporary tree as the 
intermediate result of a two-phase transformation, using different <A title=mode 
href="REC-xslt20-20070123.htm#dt-mode">modes</A> for the 
two phases (see <A 
href="REC-xslt20-20070123.htm#modes"><I>6.5 
Modes</I></A>). <SPAN>Typically, the template rules in module 
<CODE>phase1.xsl</CODE> will be declared with <CODE>mode="phase1"</CODE>, while 
those in module <CODE>phase2.xsl</CODE> will be declared with 
<CODE>mode="phase2"</CODE>:</SPAN></P>
<DIV class=exampleInner><PRE>&lt;xsl:stylesheet
  version="2.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:import href="phase1.xsl"/&gt;
&lt;xsl:import href="phase2.xsl"/&gt;

&lt;xsl:variable name="intermediate"&gt;
  &lt;xsl:apply-templates select="/" mode="phase1"/&gt;
&lt;/xsl:variable&gt;

&lt;xsl:template match="/"&gt;
  &lt;xsl:apply-templates select="$intermediate" mode="phase2"/&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;
</PRE></DIV></DIV>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>The algorithm for matching nodes against template rules is exactly the same 
regardless which tree the nodes come from. <SPAN>If different template rules are 
to be used when processing different trees, then unless</SPAN> nodes from 
different trees can be distinguished by means of <A title=pattern 
href="REC-xslt20-20070123.htm#dt-pattern">patterns</A>, 
it is a good idea to use <A title=mode 
href="REC-xslt20-20070123.htm#dt-mode">modes</A> to 
ensure that each tree is processed using the appropriate set of template 
rules.</P></DIV></DIV>
<DIV class=div2>
<H3><A id=global-variables name=global-variables></A>9.5 Global Variables and 
Parameters</H3>
<P>Both <A 
href="REC-xslt20-20070123.htm#element-variable"><CODE>xsl:variable</CODE></A> 
and <A 
href="REC-xslt20-20070123.htm#element-param"><CODE>xsl:param</CODE></A> 
are allowed as <A title=declaration 
href="REC-xslt20-20070123.htm#dt-declaration">declaration</A> 
elements<SPAN>: that is, they may appear as children of the <A 
href="REC-xslt20-20070123.htm#element-stylesheet"><CODE>xsl:stylesheet</CODE></A> 
element.</SPAN></P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-global-variable 
title="global variable" name=dt-global-variable></A>A top-level <A 
title="variable-binding element" 
href="REC-xslt20-20070123.htm#dt-variable-binding-element">variable-binding 
element</A> declares a <B>global variable</B> that is visible everywhere (except 
where it is <A title=shadows 
href="REC-xslt20-20070123.htm#dt-shadows">shadowed</A> by 
another binding).<SPAN class=definition>]</SPAN></P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-stylesheet-parameter 
title="stylesheet parameter" name=dt-stylesheet-parameter></A>A top-level <A 
href="REC-xslt20-20070123.htm#element-param"><CODE>xsl:param</CODE></A> 
element declares a <B>stylesheet parameter</B>. A stylesheet parameter is a 
global variable with the additional property that its value can be supplied by 
the caller when a transformation is initiated.<SPAN class=definition>]</SPAN> 
<SPAN>As described in <A 
href="REC-xslt20-20070123.htm#parameters"><I>9.2 
Parameters</I></A>, a stylesheet parameter may be declared as being mandatory, 
or may have a default value specified for use when no value is supplied by the 
caller.</SPAN> <SPAN>The mechanism by which the caller supplies a value for a 
stylesheet parameter is <A title=implementation-defined 
href="REC-xslt20-20070123.htm#dt-implementation-defined">implementation-defined</A>.</SPAN> 
An XSLT <A title=processor 
href="REC-xslt20-20070123.htm#dt-processor">processor</A> 
<SPAN class=verb>must</SPAN> provide such a mechanism.</P>
<P>It is an error if no value is supplied for a mandatory stylesheet parameter 
<SPAN class=error>[see <A 
href="REC-xslt20-20070123.htm#err-XTDE0050">ERR 
XTDE0050</A>]</SPAN>.</P>
<P>If a <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
contains more than one binding for a global variable of a particular name, then 
the binding with the highest <A title="import precedence" 
href="REC-xslt20-20070123.htm#dt-import-precedence">import 
precedence</A> is used.</P>
<P><A id=err-XTSE0630 name=err-XTSE0630><SPAN class=error>[ERR 
XTSE0630]</SPAN></A> It is a <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A> if a <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
contains more than one binding of a global variable with the same name and same 
<A title="import precedence" 
href="REC-xslt20-20070123.htm#dt-import-precedence">import 
precedence</A><SPAN>, unless it also contains another binding with the same name 
and higher import precedence</SPAN>.</P>
<P>For a global variable or the default value of a stylesheet parameter, the <A 
title=expression 
href="REC-xslt20-20070123.htm#dt-expression">expression</A> 
or <A title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A> specifying the variable value is evaluated with a <A 
title="singleton focus" 
href="REC-xslt20-20070123.htm#dt-singleton-focus">singleton 
focus</A> based on the <SPAN>root</SPAN> node of the <SPAN>tree</SPAN> 
containing the <A title="initial context node" 
href="REC-xslt20-20070123.htm#dt-initial-context-node">initial 
context node</A>. An XPath error will be reported if the evaluation of a global 
variable or parameter references the context item, context position, or context 
size when no initial context node is supplied. <SPAN>The values of other 
components of the dynamic context are the initial values as defined in <A 
href="REC-xslt20-20070123.htm#xpath-dynamic-context"><I>5.4.3 
Initializing the Dynamic Context</I></A> and <A 
href="REC-xslt20-20070123.htm#additional-dynamic-context"><I>5.4.4 
Additional Dynamic Context Components used by XSLT</I></A></SPAN>.</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e12936 name=d5e12936></A>Example: A Stylesheet 
Parameter </DIV>
<P>The following example declares a global parameter 
<CODE>para-font-size</CODE>, which is referenced in an <A 
title="attribute value template" 
href="REC-xslt20-20070123.htm#dt-attribute-value-template">attribute 
value template</A>.</P>
<DIV class=exampleInner><PRE>&lt;xsl:param name="para-font-size" as="xs:string"&gt;12pt&lt;/xsl:param&gt;

&lt;xsl:template match="para"&gt;
 &lt;fo:block font-size="{$para-font-size}"&gt;
   &lt;xsl:apply-templates/&gt;
 &lt;/fo:block&gt;
&lt;/xsl:template&gt;
</PRE></DIV>
<P>The implementation <SPAN>must</SPAN> provide a mechanism allowing the user to 
supply a value for the parameter <CODE>para-font-size</CODE> when invoking the 
stylesheet; the value <CODE>12pt</CODE> acts as a default.</P></DIV></DIV>
<DIV class=div2>
<H3><A id=local-variables name=local-variables></A>9.6 Local Variables and 
Parameters</H3>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-local-variable 
title="local variable" name=dt-local-variable></A>As well as being allowed as <A 
title=declaration 
href="REC-xslt20-20070123.htm#dt-declaration">declaration</A> 
elements, the <A 
href="REC-xslt20-20070123.htm#element-variable"><CODE>xsl:variable</CODE></A> 
element is also allowed in <A title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructors</A>. Such a variable is known as a <B>local variable</B>.<SPAN 
class=definition>]</SPAN></P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-template-parameter 
title="template parameter" name=dt-template-parameter></A> An <A 
href="REC-xslt20-20070123.htm#element-param"><CODE>xsl:param</CODE></A> 
element may appear as a child of an <A 
href="REC-xslt20-20070123.htm#element-template"><CODE>xsl:template</CODE></A> 
element, before any non-<A 
href="REC-xslt20-20070123.htm#element-param"><CODE>xsl:param</CODE></A> 
children of that element. Such a parameter is known as a <B>template 
parameter</B>. A template parameter is a <A title="local variable" 
href="REC-xslt20-20070123.htm#dt-local-variable">local 
variable</A> with the additional property that its value can be set when the 
template is called, using any of the instructions <A 
href="REC-xslt20-20070123.htm#element-call-template"><CODE>xsl:call-template</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-apply-imports"><CODE>xsl:apply-imports</CODE></A>, 
<SPAN>or <A 
href="REC-xslt20-20070123.htm#element-next-match"><CODE>xsl:next-match</CODE></A></SPAN>.<SPAN 
class=definition> ]</SPAN></P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-function-parameter 
title="function parameter" name=dt-function-parameter></A> An <A 
href="REC-xslt20-20070123.htm#element-param"><CODE>xsl:param</CODE></A> 
element may appear as a child of an <A 
href="REC-xslt20-20070123.htm#element-function"><CODE>xsl:function</CODE></A> 
element, before any non-<A 
href="REC-xslt20-20070123.htm#element-param"><CODE>xsl:param</CODE></A> 
children of that element. Such a parameter is known as a <B>function 
parameter</B>. A function parameter is a <A title="local variable" 
href="REC-xslt20-20070123.htm#dt-local-variable">local 
variable</A> with the additional property that its value can be set when the 
function is called, using a function call in an XPath <A title=expression 
href="REC-xslt20-20070123.htm#dt-expression">expression</A>.<SPAN 
class=definition>]</SPAN></P>
<P>The result of evaluating a local <A 
href="REC-xslt20-20070123.htm#element-variable"><CODE>xsl:variable</CODE></A> 
or <A 
href="REC-xslt20-20070123.htm#element-param"><CODE>xsl:param</CODE></A> 
element (that is, the contribution it makes to the result of the <A 
title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A> it is part of) is an empty sequence.</P></DIV>
<DIV class=div2>
<H3><A id=scope-of-variables name=scope-of-variables></A>9.7 Scope of 
Variables</H3>
<P>For any <A title="variable-binding element" 
href="REC-xslt20-20070123.htm#dt-variable-binding-element">variable-binding 
element</A>, there is a region <SPAN>(more specifically, a set of element 
nodes)</SPAN> of the <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
within which the binding is visible. The set of variable bindings in scope for 
an XPath <A title=expression 
href="REC-xslt20-20070123.htm#dt-expression">expression</A> 
consists of those bindings that are visible at the point in the stylesheet where 
the expression occurs.</P>
<P>A global <A title="variable-binding element" 
href="REC-xslt20-20070123.htm#dt-variable-binding-element">variable 
binding element</A> is visible everywhere in the <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
(including other <A title="stylesheet module" 
href="REC-xslt20-20070123.htm#dt-stylesheet-module">stylesheet 
modules</A>) except within the <A 
href="REC-xslt20-20070123.htm#element-variable"><CODE>xsl:variable</CODE></A> 
or <A 
href="REC-xslt20-20070123.htm#element-param"><CODE>xsl:param</CODE></A> 
element itself and any region where it is <A title=shadows 
href="REC-xslt20-20070123.htm#dt-shadows">shadowed</A> by 
another variable binding.</P>
<P>A local <A title="variable-binding element" 
href="REC-xslt20-20070123.htm#dt-variable-binding-element">variable 
binding element</A> is visible for all following siblings and their 
descendants<SPAN>, with two exceptions: it is not visible in any region where it 
is <A title=shadows 
href="REC-xslt20-20070123.htm#dt-shadows">shadowed</A> by 
another variable binding, and it is not visible within the subtree rooted at an 
<A 
href="REC-xslt20-20070123.htm#element-fallback"><CODE>xsl:fallback</CODE></A> 
instruction that is a sibling of the variable binding element.</SPAN> The 
binding is not visible for the <A 
href="REC-xslt20-20070123.htm#element-variable"><CODE>xsl:variable</CODE></A> 
or <A 
href="REC-xslt20-20070123.htm#element-param"><CODE>xsl:param</CODE></A> 
element itself.</P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-shadows 
title=shadows name=dt-shadows></A>A binding <B>shadows</B> another binding if 
the binding occurs at a point where the other binding is visible, and the 
bindings have the same name. <SPAN class=definition>]</SPAN> It is not an error 
if a binding established by a local <A 
href="REC-xslt20-20070123.htm#element-variable"><CODE>xsl:variable</CODE></A> 
or <A 
href="REC-xslt20-20070123.htm#element-param"><CODE>xsl:param</CODE></A> 
<A title=shadows 
href="REC-xslt20-20070123.htm#dt-shadows">shadows</A> a 
global binding. In this case, the global binding will not be visible in the 
region of the <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
where it is shadowed by the other binding.</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e13122 name=d5e13122></A>Example: Local 
Variable Shadowing a Global Variable </DIV>
<P>The following is allowed:</P>
<DIV class=exampleInner><PRE>&lt;xsl:param name="x" select="1"/&gt;
&lt;xsl:template name="foo"&gt;
  &lt;xsl:variable name="x" select="2"/&gt;
&lt;/xsl:template&gt;
</PRE></DIV></DIV>
<P>It is also not an error if a binding established by a local <A 
href="REC-xslt20-20070123.htm#element-variable"><CODE>xsl:variable</CODE></A> 
element <A title=shadows 
href="REC-xslt20-20070123.htm#dt-shadows">shadows</A> a 
binding established by another local <A 
href="REC-xslt20-20070123.htm#element-variable"><CODE>xsl:variable</CODE></A> 
or <A 
href="REC-xslt20-20070123.htm#element-param"><CODE>xsl:param</CODE></A>.</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e13143 name=d5e13143></A>Example: Misuse of 
Variable Shadowing </DIV>
<P>The following is not an error, but the effect is probably not what was 
intended. The template outputs <CODE>&lt;x value="1"/&gt;</CODE>, because the 
declaration of the inner variable named <CODE>$x</CODE> has no effect on the 
value of the outer variable named <CODE>$x</CODE>.</P>
<DIV class=exampleInner><PRE>&lt;xsl:variable name="x" select="1"/&gt;
&lt;xsl:template name="foo"&gt;
  &lt;xsl:for-each select="1 to 5"&gt;
    &lt;xsl:variable name="x" select="$x+1"/&gt;
  &lt;/xsl:for-each&gt;
  &lt;x value="{$x}"/&gt;
&lt;/xsl:template&gt;
</PRE></DIV></DIV>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>Once a variable has been given a value, the value cannot subsequently be 
changed. XSLT does not provide an equivalent to the assignment operator 
available in many procedural programming languages.</P>
<P>This is because an assignment operator would make it harder to create an 
implementation that processes a document other than in a batch-like way, 
starting at the beginning and continuing through to the end.</P></DIV>
<P>As well as global variables and local variables, an XPath <A title=expression 
href="REC-xslt20-20070123.htm#dt-expression">expression</A> 
may also declare range variables for use locally within an expression. For 
details, see <A 
href="REC-xslt20-20070123.htm#xpath20">[XPath 
2.0]</A>.</P>
<P>Where a reference to a variable occurs in an XPath expression, it is resolved 
first by reference to range variables that are in scope, then by reference to 
local variables and parameters, and finally by reference to global variables and 
parameters. A range variable may shadow a local variable or a global variable. 
XPath also allows a range variable to shadow another range variable.</P></DIV>
<DIV class=div2>
<H3><A id=circularity name=circularity></A>9.8 Circular Definitions</H3>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-circularity 
title=circularity name=dt-circularity></A>A <B>circularity</B> is said to exist 
if a construct such as a <A title="global variable" 
href="REC-xslt20-20070123.htm#dt-global-variable">global 
variable</A>, an <A title="attribute set" 
href="REC-xslt20-20070123.htm#dt-attribute-set">attribute 
set</A>, or a <A title=key 
href="REC-xslt20-20070123.htm#dt-key">key</A> is defined 
in terms of itself. For example, if the <A title=expression 
href="REC-xslt20-20070123.htm#dt-expression">expression</A> 
or <A title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A> specifying the value of a <A title="global variable" 
href="REC-xslt20-20070123.htm#dt-global-variable">global 
variable</A> <VAR>X</VAR> references a global variable <VAR>Y</VAR>, then the 
value for <VAR>Y</VAR> <SPAN class=verb>must</SPAN> be computed before the value 
of <VAR>X</VAR>. A circularity exists if it is impossible to do this for all 
global variable definitions.<SPAN class=definition>]</SPAN></P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e13219 name=d5e13219></A>Example: Circular 
Variable Definitions </DIV>
<P>The following two declarations create a circularity:</P>
<DIV class=exampleInner><PRE>&lt;xsl:variable name="x" select="$y+1"/&gt;
&lt;xsl:variable name="y" select="$x+1"/&gt;
</PRE></DIV></DIV>
<P>&nbsp;</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e13226 name=d5e13226></A>Example: Circularity 
involving Variables and Functions </DIV>
<P>The definition of a global variable can be circular even if no other variable 
is involved. For example the following two declarations (see <A 
href="REC-xslt20-20070123.htm#stylesheet-functions"><I>10.3 
Stylesheet Functions</I></A> for an explanation of the <A 
href="REC-xslt20-20070123.htm#element-function"><CODE>xsl:function</CODE></A> 
element) also create a circularity:</P>
<DIV class=exampleInner><PRE>&lt;xsl:variable name="x" select="my:f()"/&gt;

&lt;xsl:function name="my:f"&gt;
  &lt;xsl:sequence select="$x"/&gt;
&lt;/xsl:function&gt;
</PRE></DIV></DIV>
<P>&nbsp;</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e13238 name=d5e13238></A>Example: Circularity 
involving Variables and Templates </DIV>
<P>The definition of a variable is also circular if the evaluation of the 
variable invokes an <A 
href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A> 
instruction and the variable is referenced in the pattern used in the 
<CODE>match</CODE> attribute of any template rule in the <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A>. 
For example the following definition is circular:</P>
<DIV class=exampleInner><PRE>&lt;xsl:variable name="x"&gt;
  &lt;xsl:apply-templates select="//param[1]"/&gt;
&lt;/xsl:variable&gt;

&lt;xsl:template match="param[$x]"&gt;1&lt;/xsl:template&gt;
</PRE></DIV></DIV>
<P>&nbsp;</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e13254 name=d5e13254></A>Example: Circularity 
involving Variables and Keys </DIV>
<P>Similarly, a variable definition is circular if it causes a call on the <A 
href="REC-xslt20-20070123.htm#function-key"><CODE>key</CODE></A> 
function, and the definition of that <A title="" 
href="REC-xslt20-20070123.htm#key">key</A> refers to that 
variable in its <CODE>match</CODE> or <CODE>use</CODE> attributes. So the 
following definition is circular:</P>
<DIV class=exampleInner><PRE>&lt;xsl:variable name="x" select="my:f(10)"/&gt;

&lt;xsl:function name="my:f"&gt;
  &lt;xsl:param name="arg1"/&gt;
  &lt;xsl:sequence select="key('k', $arg1)"/&gt;
&lt;/xsl:function&gt;

&lt;xsl:key name="k" match="item[@code=$x]" use="@desc"/&gt;
</PRE></DIV></DIV>
<P><A id=err-XTDE0640 name=err-XTDE0640><SPAN class=error>[ERR 
XTDE0640]</SPAN></A> In general, a <A title=circularity 
href="REC-xslt20-20070123.htm#dt-circularity">circularity</A> 
in a <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
is a <A title="non-recoverable dynamic error" 
href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
dynamic error</A>. However, as with all other dynamic errors, an implementation 
will signal the error only if it actually executes the instructions and 
expressions that participate in the circularity. Because different 
implementations may optimize the execution of a stylesheet in different ways, it 
is <A title=implementation-dependent 
href="REC-xslt20-20070123.htm#dt-implementation-dependent">implementation-dependent</A> 
whether a particular circularity will actually be signaled.</P>
<P>For example, in the following declarations, the function declares a 
<SPAN>local variable <CODE>$b</CODE>, but it returns a result that does not 
require the variable to be evaluated. It is <A title=implementation-dependent 
href="REC-xslt20-20070123.htm#dt-implementation-dependent">implementation-dependent</A> 
whether the value is actually evaluated</SPAN>, and it is therefore 
implementation-dependent whether the circularity is signaled as an error:</P>
<DIV class=exampleInner><PRE>&lt;xsl:variable name="x" select="my:f(1)/&gt;

&lt;xsl:function name="my:f"&gt;
  &lt;xsl:param name="a"/&gt;
  &lt;xsl:variable name="b" select="$x"/&gt;  
  &lt;xsl:sequence select="$a + 2"/&gt;
&lt;/xsl:function&gt;
</PRE></DIV>
<P>Circularities usually involve global variables or parameters, but they can 
also exist between <A title="" 
href="REC-xslt20-20070123.htm#key">key</A> definitions 
(see <A href="REC-xslt20-20070123.htm#key"><I>16.3 
Keys</I></A>), between named <A title="attribute set" 
href="REC-xslt20-20070123.htm#dt-attribute-set">attribute 
sets</A> (see <A 
href="REC-xslt20-20070123.htm#attribute-sets"><I>10.2 
Named Attribute Sets</I></A>), or between any combination of these constructs. 
For example, a circularity exists if a key definition invokes a function that 
references an attribute set that calls the <A 
href="REC-xslt20-20070123.htm#function-key"><CODE>key</CODE></A> 
function, supplying the name of the original key definition as an argument.</P>
<P>Circularity is not the same as recursion. Stylesheet functions (see <A 
href="REC-xslt20-20070123.htm#stylesheet-functions"><I>10.3 
Stylesheet Functions</I></A>) and named templates (see <A 
href="REC-xslt20-20070123.htm#named-templates"><I>10.1 
Named Templates</I></A>) may call other functions and named templates without 
restriction. With careless coding, recursion may be non-terminating. 
Implementations are <SPAN class=verb>required</SPAN> to signal circularity as a 
<A title="dynamic error" 
href="REC-xslt20-20070123.htm#dt-dynamic-error">dynamic 
error</A>, but they are not <SPAN class=verb>required</SPAN> to detect 
non-terminating recursion.</P></DIV></DIV>
<DIV class=div1>
<H2><A id=callable-components name=callable-components></A>10 Callable 
Components</H2>
<P>This section describes three constructs that can be used to provide 
subroutine-like functionality that can be invoked from anywhere in the 
stylesheet: named templates (see <A 
href="REC-xslt20-20070123.htm#named-templates"><I>10.1 
Named Templates</I></A>), named attribute sets (see <A 
href="REC-xslt20-20070123.htm#attribute-sets"><I>10.2 
Named Attribute Sets</I></A>) and <A title="stylesheet function" 
href="REC-xslt20-20070123.htm#dt-stylesheet-function">stylesheet 
functions</A> (see <A 
href="REC-xslt20-20070123.htm#stylesheet-functions"><I>10.3 
Stylesheet Functions</I></A>).</P>
<DIV class=div2>
<H3><A id=named-templates name=named-templates></A>10.1 Named Templates</H3>
<P class=element-syntax><A id=element-call-template 
name=element-call-template></A><CODE>&lt;!-- Category: instruction 
--&gt;<BR>&lt;xsl:call-template<BR>&nbsp;&nbsp;<B>name</B> = 
<VAR>qname</VAR>&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: <A 
href="REC-xslt20-20070123.htm#element-with-param">xsl:with-param</A>* 
--&gt;<BR>&lt;/xsl:call-template&gt;</CODE></P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-named-template 
title="named template" name=dt-named-template></A>Templates can be invoked by 
name. An <A 
href="REC-xslt20-20070123.htm#element-template"><CODE>xsl:template</CODE></A> 
element with a <CODE>name</CODE> attribute defines a <B>named template</B>.<SPAN 
class=definition>]</SPAN> The value of the <CODE>name</CODE> attribute is a <A 
title=QName 
href="REC-xslt20-20070123.htm#dt-qname">QName</A>, which 
is expanded as described in <A 
href="REC-xslt20-20070123.htm#qname"><I>5.1 Qualified 
Names</I></A>. If an <A 
href="REC-xslt20-20070123.htm#element-template"><CODE>xsl:template</CODE></A> 
element has a <CODE>name</CODE> attribute, it may, but need not, also have a 
<CODE>match</CODE> attribute. An <A 
href="REC-xslt20-20070123.htm#element-call-template"><CODE>xsl:call-template</CODE></A> 
instruction invokes a template by name; it has a <SPAN 
class=verb>required</SPAN> <CODE>name</CODE> attribute that identifies the 
template to be invoked. Unlike <A 
href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A>, 
the <A 
href="REC-xslt20-20070123.htm#element-call-template"><CODE>xsl:call-template</CODE></A> 
instruction does not change the <A title=focus 
href="REC-xslt20-20070123.htm#dt-focus">focus</A>.</P>
<P>The <CODE>match</CODE>, <CODE>mode</CODE> and <CODE>priority</CODE> 
attributes on an <A 
href="REC-xslt20-20070123.htm#element-template"><CODE>xsl:template</CODE></A> 
element <SPAN>have no effect when</SPAN> the <A title=template 
href="REC-xslt20-20070123.htm#dt-template">template</A> 
is invoked by an <A 
href="REC-xslt20-20070123.htm#element-call-template"><CODE>xsl:call-template</CODE></A> 
instruction. Similarly, the <CODE>name</CODE> attribute on an <A 
href="REC-xslt20-20070123.htm#element-template"><CODE>xsl:template</CODE></A> 
element <SPAN>has no effect when</SPAN> the template is invoked by an <A 
href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A> 
instruction.</P>
<P><A id=err-XTSE0650 name=err-XTSE0650><SPAN class=error>[ERR 
XTSE0650]</SPAN></A> It is a <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A> if a <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
contains an <A 
href="REC-xslt20-20070123.htm#element-call-template"><CODE>xsl:call-template</CODE></A> 
instruction whose <CODE>name</CODE> attribute does not match the 
<CODE>name</CODE> attribute of any <A 
href="REC-xslt20-20070123.htm#element-template"><CODE>xsl:template</CODE></A> 
in the <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A>.</P>
<P><A id=err-XTSE0660 name=err-XTSE0660><SPAN class=error>[ERR 
XTSE0660]</SPAN></A> It is a <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A> if a <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
contains more than one <A title=template 
href="REC-xslt20-20070123.htm#dt-template">template</A> 
with the same name and the same <A title="import precedence" 
href="REC-xslt20-20070123.htm#dt-import-precedence">import 
precedence</A><SPAN>, unless it also contains a <A title=template 
href="REC-xslt20-20070123.htm#dt-template">template</A> 
with the same name and higher <A title="import precedence" 
href="REC-xslt20-20070123.htm#dt-import-precedence">import 
precedence</A></SPAN>.</P>
<P>The target <A title=template 
href="REC-xslt20-20070123.htm#dt-template">template</A> 
for an <A 
href="REC-xslt20-20070123.htm#element-call-template"><CODE>xsl:call-template</CODE></A> 
instruction is the template whose <CODE>name</CODE> attribute matches the 
<CODE>name</CODE> attribute of the <A 
href="REC-xslt20-20070123.htm#element-call-template"><CODE>xsl:call-template</CODE></A> 
instruction and that has higher <A title="import precedence" 
href="REC-xslt20-20070123.htm#dt-import-precedence">import 
precedence</A> than any other template with this name. The result of evaluating 
an <A 
href="REC-xslt20-20070123.htm#element-call-template"><CODE>xsl:call-template</CODE></A> 
instruction is the sequence produced by evaluating the <A 
title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A> contained in its target <A title=template 
href="REC-xslt20-20070123.htm#dt-template">template</A> 
(see <A 
href="REC-xslt20-20070123.htm#sequence-constructors"><I>5.7 
Sequence Constructors</I></A>).</P>
<DIV class=div3>
<H4><A id=with-param name=with-param></A>10.1.1 Passing Parameters to 
Templates</H4>
<P class=element-syntax><A id=element-with-param 
name=element-with-param></A><CODE>&lt;xsl:with-param<BR>&nbsp;&nbsp;<B>name</B> 
= <VAR>qname</VAR><BR>&nbsp;&nbsp;select? = 
<VAR>expression</VAR><BR>&nbsp;&nbsp;as? = 
<VAR>sequence-type</VAR><BR>&nbsp;&nbsp;tunnel? = "yes" | 
"no"&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: <VAR>sequence-constructor</VAR> 
--&gt;<BR>&lt;/xsl:with-param&gt;</CODE></P>
<P>Parameters are passed to templates using the <A 
href="REC-xslt20-20070123.htm#element-with-param"><CODE>xsl:with-param</CODE></A> 
element. The <SPAN class=verb>required</SPAN> <CODE>name</CODE> attribute 
specifies the name of the <A title="template parameter" 
href="REC-xslt20-20070123.htm#dt-template-parameter">template 
parameter</A> (the variable the value of whose binding is to be replaced). The 
value of the <CODE>name</CODE> attribute is a <A title=QName 
href="REC-xslt20-20070123.htm#dt-qname">QName</A>, which 
is expanded as described in <A 
href="REC-xslt20-20070123.htm#qname"><I>5.1 Qualified 
Names</I></A>.</P>
<P><A 
href="REC-xslt20-20070123.htm#element-with-param"><CODE>xsl:with-param</CODE></A> 
is allowed within <A 
href="REC-xslt20-20070123.htm#element-call-template"><CODE>xsl:call-template</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-apply-imports"><CODE>xsl:apply-imports</CODE></A>, 
<SPAN>and <A 
href="REC-xslt20-20070123.htm#element-next-match"><CODE>xsl:next-match</CODE></A></SPAN>.</P>
<P><A id=err-XTSE0670 name=err-XTSE0670><SPAN class=error>[ERR 
XTSE0670]</SPAN></A> It is a <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A> if a single <A 
href="REC-xslt20-20070123.htm#element-call-template"><CODE>xsl:call-template</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-apply-imports"><CODE>xsl:apply-imports</CODE></A>, 
<SPAN>or <A 
href="REC-xslt20-20070123.htm#element-next-match"><CODE>xsl:next-match</CODE></A></SPAN> 
element contains two or more <A 
href="REC-xslt20-20070123.htm#element-with-param"><CODE>xsl:with-param</CODE></A> 
elements with <SPAN>matching <CODE>name</CODE> attributes</SPAN>.</P>
<P>The value of the parameter is specified in the same way as for <A 
href="REC-xslt20-20070123.htm#element-variable"><CODE>xsl:variable</CODE></A> 
and <A 
href="REC-xslt20-20070123.htm#element-param"><CODE>xsl:param</CODE></A> 
(see <A 
href="REC-xslt20-20070123.htm#variable-values"><I>9.3 
Values of Variables and Parameters</I></A>)<SPAN>, taking account of the values 
of the <CODE>select</CODE> and <CODE>as</CODE> attributes and the content of the 
<A 
href="REC-xslt20-20070123.htm#element-with-param"><CODE>xsl:with-param</CODE></A> 
element, if any.</SPAN></P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>It is possible to have an <CODE>as</CODE> attribute on the <A 
href="REC-xslt20-20070123.htm#element-with-param"><CODE>xsl:with-param</CODE></A> 
element that differs from the <CODE>as</CODE> attribute on the corresponding <A 
href="REC-xslt20-20070123.htm#element-param"><CODE>xsl:param</CODE></A> 
element describing the formal parameters of the called template.</P>
<P>In this situation, the supplied value of the parameter will first be 
processed according to the rules of the <CODE>as</CODE> attribute on the <A 
href="REC-xslt20-20070123.htm#element-with-param"><CODE>xsl:with-param</CODE></A> 
element, and the resulting value will then be further processed according to the 
rules of the <CODE>as</CODE> attribute on the <A 
href="REC-xslt20-20070123.htm#element-param"><CODE>xsl:param</CODE></A> 
element.</P>
<P>For example, suppose the supplied value is a node with <A 
title="type annotation" 
href="REC-xslt20-20070123.htm#dt-annotation">type 
annotation</A> <SPAN><CODE>xs:untypedAtomic</CODE></SPAN>, and the <A 
href="REC-xslt20-20070123.htm#element-with-param"><CODE>xsl:with-param</CODE></A> 
element specifies <CODE>as="xs:integer"</CODE>, while the <A 
href="REC-xslt20-20070123.htm#element-param"><CODE>xsl:param</CODE></A> 
element specifies <CODE>as="xs:double"</CODE>. Then the node will first be 
atomized and the resulting untyped atomic value will be cast to 
<CODE>xs:integer</CODE>. If this succeeds, the <CODE>xs:integer</CODE> will then 
be promoted to an <CODE>xs:double</CODE>.</P></DIV>
<P>The <A title=focus 
href="REC-xslt20-20070123.htm#dt-focus">focus</A> used 
for computing the value specified by the <A 
href="REC-xslt20-20070123.htm#element-with-param"><CODE>xsl:with-param</CODE></A> 
element is the same as that used for the <A 
href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-apply-imports"><CODE>xsl:apply-imports</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-next-match"><CODE>xsl:next-match</CODE></A>, 
or <A 
href="REC-xslt20-20070123.htm#element-call-template"><CODE>xsl:call-template</CODE></A> 
element within which it occurs.</P>
<P><A id=err-XTSE0680 name=err-XTSE0680><SPAN class=error>[ERR 
XTSE0680]</SPAN></A> In the case of <A 
href="REC-xslt20-20070123.htm#element-call-template"><CODE>xsl:call-template</CODE></A>, 
it is a <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A> to pass a <SPAN>non-tunnel</SPAN> parameter named <VAR>x</VAR> to a 
template that does not have a <A title="template parameter" 
href="REC-xslt20-20070123.htm#dt-template-parameter">template 
parameter</A> named <VAR>x</VAR><SPAN>, unless <A 
title="backwards compatible behavior" 
href="REC-xslt20-20070123.htm#dt-backwards-compatible-behavior">backwards 
compatible behavior</A> is enabled for the <A 
href="REC-xslt20-20070123.htm#element-call-template"><CODE>xsl:call-template</CODE></A> 
instruction</SPAN>. This is not an error in the case of <A 
href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-apply-imports"><CODE>xsl:apply-imports</CODE></A>, 
<SPAN>and <A 
href="REC-xslt20-20070123.htm#element-next-match"><CODE>xsl:next-match</CODE></A></SPAN>; 
in these cases the parameter is simply ignored.</P>
<P>The optional <CODE>tunnel</CODE> attribute may be used to indicate that a 
parameter is a <A title="tunnel parameter" 
href="REC-xslt20-20070123.htm#dt-tunnel-parameter">tunnel 
parameter</A>. The default is <CODE>no</CODE>. Tunnel parameters are described 
in <A 
href="REC-xslt20-20070123.htm#tunnel-params"><I>10.1.2 
Tunnel Parameters</I></A></P>
<P><A id=err-XTSE0690 name=err-XTSE0690><SPAN class=error>[ERR 
XTSE0690]</SPAN></A> It is a <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A> if a template that is invoked using <A 
href="REC-xslt20-20070123.htm#element-call-template"><CODE>xsl:call-template</CODE></A> 
declares a <A title="template parameter" 
href="REC-xslt20-20070123.htm#dt-template-parameter">template 
parameter</A> specifying <CODE>required="yes"</CODE> <SPAN>and not specifying 
<CODE>tunnel="yes"</CODE></SPAN>, if no value for this parameter is supplied by 
the calling instruction.</P>
<P><A id=err-XTDE0700 name=err-XTDE0700><SPAN class=error>[ERR 
XTDE0700]</SPAN></A> In other cases, it is a <A 
title="non-recoverable dynamic error" 
href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
dynamic error</A> if the template that is invoked declares a <A 
title="template parameter" 
href="REC-xslt20-20070123.htm#dt-template-parameter">template 
parameter</A> with <CODE>required="yes"</CODE> and no value for this parameter 
is supplied by the calling instruction.</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e13826 name=d5e13826></A>Example: A Named 
Template </DIV>
<P>This example defines a named template for a <CODE>numbered-block</CODE> with 
an argument to control the format of the number.</P>
<DIV class=exampleInner><PRE>&lt;xsl:template name="numbered-block"&gt;
  &lt;xsl:param name="format"&gt;1. &lt;/xsl:param&gt;
  &lt;fo:block&gt;
    &lt;xsl:number format="{$format}"/&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="ol//ol/li"&gt;
  &lt;xsl:call-template name="numbered-block"&gt;
    &lt;xsl:with-param name="format"&gt;a. &lt;/xsl:with-param&gt;
  &lt;/xsl:call-template&gt;
&lt;/xsl:template&gt;
</PRE></DIV></DIV>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>Arguments to <A title="stylesheet function" 
href="REC-xslt20-20070123.htm#dt-stylesheet-function">stylesheet 
functions</A> are supplied as part of an XPath function call: see <A 
href="REC-xslt20-20070123.htm#stylesheet-functions"><I>10.3 
Stylesheet Functions</I></A></P></DIV></DIV>
<DIV class=div3>
<H4><A id=tunnel-params name=tunnel-params></A>10.1.2 Tunnel Parameters</H4>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-tunnel-parameter 
title="tunnel parameter" name=dt-tunnel-parameter></A>A parameter passed to a 
template may be defined as a <B>tunnel parameter</B>. Tunnel parameters have the 
property that they are automatically passed on by the called template to any 
further templates that it calls, and so on recursively.<SPAN 
class=definition>]</SPAN> Tunnel parameters thus allow values to be set that are 
accessible during an entire phase of stylesheet processing, without the need for 
each template that is used during that phase to be aware of the parameter.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>Tunnel parameters are conceptually similar to dynamically-scoped variables in 
some functional programming languages.</P></DIV>
<P>A <A title="tunnel parameter" 
href="REC-xslt20-20070123.htm#dt-tunnel-parameter">tunnel 
parameter</A> is created by using an <A 
href="REC-xslt20-20070123.htm#element-with-param"><CODE>xsl:with-param</CODE></A> 
element that specifies <CODE>tunnel="yes"</CODE>. A template that requires 
access to the value of a tunnel parameter must declare it using an <A 
href="REC-xslt20-20070123.htm#element-param"><CODE>xsl:param</CODE></A> 
element that also specifies <CODE>tunnel="yes"</CODE>.</P>
<P>On any template call using an <A 
href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-call-template"><CODE>xsl:call-template</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-apply-imports"><CODE>xsl:apply-imports</CODE></A> 
or <A 
href="REC-xslt20-20070123.htm#element-next-match"><CODE>xsl:next-match</CODE></A> 
instruction, a set of <A title="tunnel parameter" 
href="REC-xslt20-20070123.htm#dt-tunnel-parameter">tunnel 
parameters</A> is passed from the calling template to the called template. This 
set consists of any parameters explicitly created using <CODE>&lt;xsl:with-param 
tunnel="yes"&gt;</CODE>, overlaid on a base set of tunnel parameters. If the <A 
href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-call-template"><CODE>xsl:call-template</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-apply-imports"><CODE>xsl:apply-imports</CODE></A> 
or <A 
href="REC-xslt20-20070123.htm#element-next-match"><CODE>xsl:next-match</CODE></A> 
instruction has an <A 
href="REC-xslt20-20070123.htm#element-template"><CODE>xsl:template</CODE></A> 
declaration as an ancestor element in the stylesheet, then the base set consists 
of the tunnel parameters that were passed to that template; otherwise (for 
example, if the instruction is within a global variable declaration, an <A 
title="attribute set" 
href="REC-xslt20-20070123.htm#dt-attribute-set">attribute 
set</A> declaration, or a <A title="stylesheet function" 
href="REC-xslt20-20070123.htm#dt-stylesheet-function">stylesheet 
function</A>), the base set is empty. If a parameter created using 
<CODE>&lt;xsl:with-param tunnel="yes"&gt;</CODE> has the same <A 
title=expanded-QName 
href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded-QName</A> 
as a parameter in the base set, then the parameter created using <A 
href="REC-xslt20-20070123.htm#element-with-param"><CODE>xsl:with-param</CODE></A> 
overrides the parameter in the base set; otherwise, the parameter created using 
<A 
href="REC-xslt20-20070123.htm#element-with-param"><CODE>xsl:with-param</CODE></A> 
is added to the base set.</P>
<P>When a template accesses the value of a <A title="tunnel parameter" 
href="REC-xslt20-20070123.htm#dt-tunnel-parameter">tunnel 
parameter</A> by declaring it with <CODE>xsl:param tunnel="yes"</CODE>, this 
does not remove the parameter from the base set of tunnel parameters that is 
passed on to any templates called by this template.</P>
<P>Two sibling <A 
href="REC-xslt20-20070123.htm#element-with-param"><CODE>xsl:with-param</CODE></A> 
elements must have distinct parameter names, even if one is a <A 
title="tunnel parameter" 
href="REC-xslt20-20070123.htm#dt-tunnel-parameter">tunnel 
parameter</A> and the other is not. Equally, two sibling <A 
href="REC-xslt20-20070123.htm#element-param"><CODE>xsl:param</CODE></A> 
elements representing <A title="template parameter" 
href="REC-xslt20-20070123.htm#dt-template-parameter">template 
parameters</A> must have distinct parameter names, even if one is a <A 
title="tunnel parameter" 
href="REC-xslt20-20070123.htm#dt-tunnel-parameter">tunnel 
parameter</A> and the other is not. However, the tunnel parameters that are 
implicitly passed in a template call may have names that duplicate the names of 
non-tunnel parameters that are explicitly passed on the same call.</P>
<P><A title="tunnel parameter" 
href="REC-xslt20-20070123.htm#dt-tunnel-parameter">Tunnel 
parameters</A> are not passed in calls to <A title="stylesheet function" 
href="REC-xslt20-20070123.htm#dt-stylesheet-function">stylesheet 
functions</A>.</P>
<P>All other options of <A 
href="REC-xslt20-20070123.htm#element-with-param"><CODE>xsl:with-param</CODE></A> 
and <A 
href="REC-xslt20-20070123.htm#element-param"><CODE>xsl:param</CODE></A> 
are available with <A title="tunnel parameter" 
href="REC-xslt20-20070123.htm#dt-tunnel-parameter">tunnel 
parameters</A> just as with non-tunnel parameters. For example, parameters may 
be declared as mandatory or optional, a default value may be specified, and a 
required type may be specified. If any conversion is required from the supplied 
value of a tunnel parameter to the required type specified in <A 
href="REC-xslt20-20070123.htm#element-param"><CODE>xsl:param</CODE></A>, 
then the converted value is used within the receiving template, but the value 
that is passed on in any further template calls is the original supplied value 
before conversion. Equally, any default value is local to the template: 
specifying a default value for a tunnel parameter does not change the set of 
tunnel parameters that is passed on in further template calls.</P>
<P>The set of <A title="tunnel parameter" 
href="REC-xslt20-20070123.htm#dt-tunnel-parameter">tunnel 
parameters</A> that is passed to the <A title="initial template" 
href="REC-xslt20-20070123.htm#dt-initial-template">initial 
template</A> is empty.</P>
<P><A title="tunnel parameter" 
href="REC-xslt20-20070123.htm#dt-tunnel-parameter">Tunnel 
parameters</A> are passed unchanged through a built-in template rule (see <A 
href="REC-xslt20-20070123.htm#built-in-rule"><I>6.6 
Built-in Template Rules</I></A>).</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e13990 name=d5e13990></A>Example: Using Tunnel 
Parameters </DIV>
<P>Suppose that the equations in a scientific paper are to be sequentially 
numbered, but that the format of the number depends on the context in which the 
equations appear. It is possible to reflect this using a rule of the form:</P>
<DIV class=exampleInner><PRE>&lt;xsl:template match="equation"&gt;
  &lt;xsl:param name="equation-format" select="'(1)'" tunnel="yes"/&gt;
  &lt;xsl:number level="any" format="{$equation-format}"/&gt;
&lt;/xsl:template&gt;
</PRE></DIV>
<P>At any level of processing above this level, it is possible to determine how 
the equations will be numbered, for example:</P>
<DIV class=exampleInner><PRE>&lt;xsl:template match="appendix"&gt;
  ...
  &lt;xsl:apply-templates&gt;
    &lt;xsl:with-param name="equation-format" select="'[i]'" tunnel="yes"/&gt;
  &lt;/xsl:apply-templates&gt;
  ...
&lt;/xsl:template&gt;
</PRE></DIV>
<P>The parameter value is passed transparently through all the intermediate 
layers of template rules until it reaches the rule with 
<CODE>match="equation"</CODE>. The effect is similar to using a global variable, 
except that the parameter can take different values during different phases of 
the transformation.</P></DIV></DIV></DIV>
<DIV class=div2>
<H3><A id=attribute-sets name=attribute-sets></A>10.2 Named Attribute Sets</H3>
<P class=element-syntax><A id=element-attribute-set 
name=element-attribute-set></A><CODE>&lt;!-- Category: declaration 
--&gt;<BR>&lt;xsl:attribute-set<BR>&nbsp;&nbsp;<B>name</B> = 
<VAR>qname</VAR><BR>&nbsp;&nbsp;use-attribute-sets? = 
<VAR>qnames</VAR>&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: <A 
href="REC-xslt20-20070123.htm#element-attribute">xsl:attribute</A>* 
--&gt;<BR>&lt;/xsl:attribute-set&gt;</CODE></P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-attribute-set 
title="attribute set" name=dt-attribute-set></A>The <A 
href="REC-xslt20-20070123.htm#element-attribute-set"><CODE>xsl:attribute-set</CODE></A> 
element defines a named <B>attribute set</B>: that is, a collection of attribute 
<SPAN>definitions</SPAN> that can be used repeatedly on different constructed 
elements.<SPAN class=definition>]</SPAN></P>
<P>The <SPAN class=verb>required</SPAN> <CODE>name</CODE> attribute specifies 
the name of the attribute set. The value of the <CODE>name</CODE> attribute is a 
<A title=QName 
href="REC-xslt20-20070123.htm#dt-qname">QName</A>, which 
is expanded as described in <A 
href="REC-xslt20-20070123.htm#qname"><I>5.1 Qualified 
Names</I></A>. The content of the <A 
href="REC-xslt20-20070123.htm#element-attribute-set"><CODE>xsl:attribute-set</CODE></A> 
element consists of zero or more <A 
href="REC-xslt20-20070123.htm#element-attribute"><CODE>xsl:attribute</CODE></A> 
instructions that are evaluated to produce the attributes in the set.</P>
<P>The result of evaluating an attribute set is a sequence of attribute nodes. 
Evaluating the same attribute set more than once can produce different results, 
because although an attribute set does not have parameters, it may contain 
expressions or instructions whose value depends on the evaluation context.</P>
<P><A title="attribute set" 
href="REC-xslt20-20070123.htm#dt-attribute-set">Attribute 
sets</A> are used by specifying a <CODE>use-attribute-sets</CODE> attribute on 
the <A 
href="REC-xslt20-20070123.htm#element-element"><CODE>xsl:element</CODE></A> 
or <A 
href="REC-xslt20-20070123.htm#element-copy"><CODE>xsl:copy</CODE></A> 
instruction, or by specifying an <CODE>xsl:use-attribute-sets</CODE> attribute 
on a literal result element. An attribute set may be defined in terms of other 
attribute sets by using the <CODE>use-attribute-sets</CODE> attribute on the <A 
href="REC-xslt20-20070123.htm#element-attribute-set"><CODE>xsl:attribute-set</CODE></A> 
element itself. The value of the <CODE>[xsl:]use-attribute-sets</CODE> attribute 
is in each case a whitespace-separated list of names of attribute sets. Each 
name is specified as a <A title=QName 
href="REC-xslt20-20070123.htm#dt-qname">QName</A>, which 
is expanded as described in <A 
href="REC-xslt20-20070123.htm#qname"><I>5.1 Qualified 
Names</I></A>.</P>
<P>Specifying a <CODE>use-attribute-sets</CODE> attribute is broadly equivalent 
to adding <A 
href="REC-xslt20-20070123.htm#element-attribute"><CODE>xsl:attribute</CODE></A> 
instructions for each of the attributes in each of the named attribute sets to 
the beginning of the content of the instruction with the 
<CODE>[xsl:]use-attribute-sets</CODE> attribute, in the same order in which the 
names of the attribute sets are specified in the <CODE>use-attribute-sets</CODE> 
attribute.</P>
<P>More formally, an <CODE>xsl:use-attribute-sets</CODE> attribute is expanded 
using the following recursive algorithm, or any algorithm that produces the same 
results:</P>
<UL>
  <LI>
  <P>The value of the attribute is tokenized as a list of QNames.</P>
  <LI>
  <P>Each QName in the list is processed, in order, as follows:</P>
  <UL>
    <LI>
    <P>The QName must match the <CODE>name</CODE> attribute of one or more <A 
    href="REC-xslt20-20070123.htm#element-attribute-set"><CODE>xsl:attribute-set</CODE></A> 
    declarations in the stylesheet.</P>
    <LI>
    <P>Each <A 
    href="REC-xslt20-20070123.htm#element-attribute-set"><CODE>xsl:attribute-set</CODE></A> 
    declaration whose name matches is processed as follows. Where two such 
    declarations have different <A title="import precedence" 
    href="REC-xslt20-20070123.htm#dt-import-precedence">import 
    precedence</A>, the one with lower import precedence is processed first. 
    Where two declarations have the same import precedence, they are processed 
    in <A title="declaration order" 
    href="REC-xslt20-20070123.htm#dt-declaration-order">declaration 
    order</A>.</P>
    <UL>
      <LI>
      <P>If the <A 
      href="REC-xslt20-20070123.htm#element-attribute-set"><CODE>xsl:attribute-set</CODE></A> 
      declaration has a <CODE>use-attribute-sets</CODE> attribute, the attribute 
      is expanded by applying this algorithm recursively.</P>
      <LI>
      <P>If the <A 
      href="REC-xslt20-20070123.htm#element-attribute-set"><CODE>xsl:attribute-set</CODE></A> 
      declaration contains one or more <A 
      href="REC-xslt20-20070123.htm#element-attribute"><CODE>xsl:attribute</CODE></A> 
      instructions, these instructions are evaluated (following the rules for 
      evaluating a <A title="sequence constructor" 
      href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
      constructor</A>: see <A 
      href="REC-xslt20-20070123.htm#sequence-constructors"><I>5.7 
      Sequence Constructors</I></A>) to produce a sequence of attribute nodes. 
      These attribute nodes are appended to the result 
  sequence.</P></LI></UL></LI></UL></LI></UL>
<P>The <A 
href="REC-xslt20-20070123.htm#element-attribute"><CODE>xsl:attribute</CODE></A> 
instructions are evaluated using the same <A title=focus 
href="REC-xslt20-20070123.htm#dt-focus">focus</A> as is 
used for evaluating the element that is the parent of the 
<CODE>[xsl:]use-attribute-sets</CODE> attribute forming the initial input to the 
algorithm. However, the static context for the evaluation depends on the 
position of the <A 
href="REC-xslt20-20070123.htm#element-attribute"><CODE>xsl:attribute</CODE></A> 
instruction in the stylesheet: thus, only local variables declared within an <A 
href="REC-xslt20-20070123.htm#element-attribute"><CODE>xsl:attribute</CODE></A> 
instruction, and global variables, are visible.</P>
<P>The set of attribute nodes produced by expanding 
<CODE>xsl:use-attribute-sets</CODE> may include several attributes with the same 
name. When the attributes are added to an element node, only the last of the 
duplicates will take effect.</P>
<P>The way in which each instruction uses the results of expanding the 
<CODE>[xsl:]use-attribute-sets</CODE> attribute is described in the 
specification for the relevant instruction: see <A 
href="REC-xslt20-20070123.htm#literal-result-element"><I>11.1 
Literal Result Elements</I></A>, <A 
href="REC-xslt20-20070123.htm#xsl-element"><I>11.2 
Creating Element Nodes Using xsl:element</I></A> , and <A 
href="REC-xslt20-20070123.htm#copying"><I>11.9 Copying 
Nodes</I></A>.</P>
<P><A id=err-XTSE0710 name=err-XTSE0710><SPAN class=error>[ERR 
XTSE0710]</SPAN></A> It is a <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A> if the value of the <CODE>use-attribute-sets</CODE> attribute of an <A 
href="REC-xslt20-20070123.htm#element-copy"><CODE>xsl:copy</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-element"><CODE>xsl:element</CODE></A>, 
or <A 
href="REC-xslt20-20070123.htm#element-attribute-set"><CODE>xsl:attribute-set</CODE></A> 
element, or the <CODE>xsl:use-attribute-sets</CODE> attribute of a <A 
title="literal result element" 
href="REC-xslt20-20070123.htm#dt-literal-result-element">literal 
result element</A>, is not a <SPAN>whitespace-separated</SPAN> sequence of <A 
title=QName 
href="REC-xslt20-20070123.htm#dt-qname">QNames</A>, or if 
it contains a QName that does not match the <CODE>name</CODE> attribute of any 
<A 
href="REC-xslt20-20070123.htm#element-attribute-set"><CODE>xsl:attribute-set</CODE></A> 
declaration in the stylesheet.</P>
<P><A id=err-XTSE0720 name=err-XTSE0720><SPAN class=error>[ERR 
XTSE0720]</SPAN></A> It is a <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A> if an <A 
href="REC-xslt20-20070123.htm#element-attribute-set"><CODE>xsl:attribute-set</CODE></A> 
element directly or indirectly references itself via the names contained in the 
<CODE>use-attribute-sets</CODE> attribute.</P>
<P>Each attribute node produced by expanding an attribute set has a <A 
title="type annotation" 
href="REC-xslt20-20070123.htm#dt-annotation">type 
annotation</A> determined by the rules for the <A 
href="REC-xslt20-20070123.htm#element-attribute"><CODE>xsl:attribute</CODE></A> 
instruction that created the attribute node: see <A 
href="REC-xslt20-20070123.htm#annotation-for-constructed-attribute"><I>11.3.1 
Setting the Type Annotation for a Constructed Attribute Node</I></A>. These type 
annotations may be preserved, stripped, or replaced as determined by the rules 
for the instruction that creates the element in which the attributes are 
used.</P>
<P>Attribute sets are used as follows:</P>
<UL>
  <LI>
  <P>The <A 
  href="REC-xslt20-20070123.htm#element-copy"><CODE>xsl:copy</CODE></A> 
  and <A 
  href="REC-xslt20-20070123.htm#element-element"><CODE>xsl:element</CODE></A> 
  instructions have an <CODE>use-attribute-sets</CODE> attribute. The sequence 
  of attribute nodes produced by evaluating this attribute is prepended to the 
  sequence produced by evaluating the <A title="sequence constructor" 
  href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
  constructor</A> contained within the instruction.</P>
  <LI>
  <P><A title="literal result element" 
  href="REC-xslt20-20070123.htm#dt-literal-result-element">Literal 
  result elements</A> allow an <CODE>xsl:use-attribute-sets</CODE> attribute, 
  which is evaluated in the same way as the <CODE>use-attribute-sets</CODE> 
  attribute of <A 
  href="REC-xslt20-20070123.htm#element-element"><CODE>xsl:element</CODE></A> 
  and <A 
  href="REC-xslt20-20070123.htm#element-copy"><CODE>xsl:copy</CODE></A>. 
  The sequence of attribute nodes produced by evaluating this attribute is 
  prepended to the sequence of attribute nodes produced by evaluating the 
  attributes of the literal result element, which in turn is prepended to the 
  sequence produced by evaluating the <A title="sequence constructor" 
  href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
  constructor</A> contained with the literal result element.</P></LI></UL>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e14293 name=d5e14293></A>Example: Using 
Attribute Sets </DIV>
<P>The following example creates a named <A title="attribute set" 
href="REC-xslt20-20070123.htm#dt-attribute-set">attribute 
set</A> <CODE>title-style</CODE> and uses it in a <A title="template rule" 
href="REC-xslt20-20070123.htm#dt-template-rule">template 
rule</A>.</P>
<DIV class=exampleInner><PRE>&lt;xsl:template match="chapter/heading"&gt;
  &lt;fo:block font-stretch="condensed" xsl:use-attribute-sets="title-style"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:attribute-set name="title-style"&gt;
  &lt;xsl:attribute name="font-size"&gt;12pt&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="font-weight"&gt;bold&lt;/xsl:attribute&gt;
&lt;/xsl:attribute-set&gt;
</PRE></DIV></DIV>
<P>&nbsp;</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e14309 name=d5e14309></A>Example: Overriding 
Attributes in an Attribute Set </DIV>
<P>The following example creates a named attribute set <CODE>base-style</CODE> 
and uses it in a template rule with multiple specifications of the 
attributes:</P>
<DL>
  <DT class=label>font-family 
  <DD>
  <P>is specified only in the attribute set</P>
  <DT class=label>font-size 
  <DD>
  <P>is specified in the attribute set, is specified on the literal result 
  element, and in an <A 
  href="REC-xslt20-20070123.htm#element-attribute"><CODE>xsl:attribute</CODE></A> 
  instruction</P>
  <DT class=label>font-style 
  <DD>
  <P>is specified in the attribute set, and on the literal result element</P>
  <DT class=label>font-weight 
  <DD>
  <P>is specified in the attribute set, and in an <A 
  href="REC-xslt20-20070123.htm#element-attribute"><CODE>xsl:attribute</CODE></A> 
  instruction</P></DD></DL>
<P>Stylesheet fragment:</P>
<DIV class=exampleInner><PRE>&lt;xsl:attribute-set name="base-style"&gt;
  &lt;xsl:attribute name="font-family"&gt;Univers&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="font-size"&gt;10pt&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="font-style"&gt;normal&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="font-weight"&gt;normal&lt;/xsl:attribute&gt;
&lt;/xsl:attribute-set&gt;

&lt;xsl:template match="o"&gt;
  &lt;fo:block xsl:use-attribute-sets="base-style"
            font-size="12pt"
            font-style="italic"&gt;
    &lt;xsl:attribute name="font-size"&gt;14pt&lt;/xsl:attribute&gt;
    &lt;xsl:attribute name="font-weight"&gt;bold&lt;/xsl:attribute&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;
</PRE></DIV>
<P>Result:</P>
<DIV class=exampleInner><PRE>&lt;fo:block font-family="Univers"
          font-size="14pt"
          font-style="italic"
          font-weight="bold"&gt;
...
&lt;/fo:block&gt;
</PRE></DIV></DIV></DIV>
<DIV class=div2>
<H3><A id=stylesheet-functions name=stylesheet-functions></A>10.3 Stylesheet 
Functions</H3>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-stylesheet-function 
title="stylesheet function" name=dt-stylesheet-function></A>An <A 
href="REC-xslt20-20070123.htm#element-function"><CODE>xsl:function</CODE></A> 
declaration declares the name, parameters, and implementation of a <B>stylesheet 
function</B> that can be called from any XPath <A title=expression 
href="REC-xslt20-20070123.htm#dt-expression">expression</A> 
within the <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A>.<SPAN 
class=definition>]</SPAN></P>
<P class=element-syntax><A id=element-function 
name=element-function></A><CODE>&lt;!-- Category: declaration 
--&gt;<BR>&lt;xsl:function<BR>&nbsp;&nbsp;<B>name</B> = 
<VAR>qname</VAR><BR>&nbsp;&nbsp;as? = 
<VAR>sequence-type</VAR><BR>&nbsp;&nbsp;override? = "yes" | 
"no"&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: (<A 
href="REC-xslt20-20070123.htm#element-param">xsl:param</A>*, 
<VAR>sequence-constructor</VAR>) --&gt;<BR>&lt;/xsl:function&gt;</CODE></P>
<P>The <A 
href="REC-xslt20-20070123.htm#element-function"><CODE>xsl:function</CODE></A> 
declaration defines a <A title="stylesheet function" 
href="REC-xslt20-20070123.htm#dt-stylesheet-function">stylesheet 
function</A> that can be called from any XPath <A title=expression 
href="REC-xslt20-20070123.htm#dt-expression">expression</A> 
used in the <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
(including an XPath expression used within a predicate in a <A title=pattern 
href="REC-xslt20-20070123.htm#dt-pattern">pattern</A>). 
The <CODE>name</CODE> attribute specifies the name of the function. The value of 
the <CODE>name</CODE> attribute is a <A title=QName 
href="REC-xslt20-20070123.htm#dt-qname">QName</A>, which 
is expanded as described in <A 
href="REC-xslt20-20070123.htm#qname"><I>5.1 Qualified 
Names</I></A>.</P>
<P>An <A 
href="REC-xslt20-20070123.htm#element-function"><CODE>xsl:function</CODE></A> 
declaration can only appear as a top-level element in a <SPAN>stylesheet 
module</SPAN>.</P>
<P><A id=err-XTSE0740 name=err-XTSE0740><SPAN class=error>[ERR 
XTSE0740]</SPAN></A> A <A title="stylesheet function" 
href="REC-xslt20-20070123.htm#dt-stylesheet-function">stylesheet 
function</A> <SPAN class=verb>must</SPAN> have a prefixed name, to remove any 
risk of a clash with a function in the default function namespace. It is a <A 
title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A> if the name has no prefix..</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>To prevent the namespace declaration used for the function name appearing in 
the result document, use the <CODE>exclude-result-prefixes</CODE> attribute on 
the <A 
href="REC-xslt20-20070123.htm#element-stylesheet"><CODE>xsl:stylesheet</CODE></A> 
element: see <A 
href="REC-xslt20-20070123.htm#lre-namespaces"><I>11.1.3 
Namespace Nodes for Literal Result Elements</I></A>.</P>
<P>The prefix <SPAN class=verb>must not</SPAN> refer to a <A 
title="reserved namespace" 
href="REC-xslt20-20070123.htm#dt-reserved-namespace">reserved 
namespace</A>: <SPAN class=error>[see <A 
href="REC-xslt20-20070123.htm#err-XTSE0080">ERR 
XTSE0080</A>]</SPAN></P></DIV>
<P>The content of the <A 
href="REC-xslt20-20070123.htm#element-function"><CODE>xsl:function</CODE></A> 
element consists of zero or more <A 
href="REC-xslt20-20070123.htm#element-param"><CODE>xsl:param</CODE></A> 
elements that specify the formal arguments of the function, followed by <SPAN>a 
<A title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A> that defines the value to be returned by the 
function.</SPAN></P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-arity title=arity 
name=dt-arity></A>The <B>arity</B> of a stylesheet function is the number of <A 
href="REC-xslt20-20070123.htm#element-param"><CODE>xsl:param</CODE></A> 
elements in the function definition.<SPAN class=definition>]</SPAN> Optional 
arguments are not allowed.</P>
<P><A id=err-XTSE0760 name=err-XTSE0760><SPAN class=error>[ERR 
XTSE0760]</SPAN></A> Because arguments to a stylesheet function call <SPAN 
class=verb>must</SPAN> all be specified, the <A 
href="REC-xslt20-20070123.htm#element-param"><CODE>xsl:param</CODE></A> 
elements within an <A 
href="REC-xslt20-20070123.htm#element-function"><CODE>xsl:function</CODE></A> 
element <SPAN class=verb>must not</SPAN> specify a default value: this means 
they <SPAN class=verb>must</SPAN> be empty, and <SPAN class=verb>must not</SPAN> 
have a <CODE>select</CODE> attribute.</P>
<P>A <A title="stylesheet function" 
href="REC-xslt20-20070123.htm#dt-stylesheet-function">stylesheet 
function</A> is included in the <EM>in-scope functions</EM> of the static 
context for all XPath expressions used in the <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A>, 
unless</P>
<UL>
  <LI>
  <P>there is another <A title="stylesheet function" 
  href="REC-xslt20-20070123.htm#dt-stylesheet-function">stylesheet 
  function</A> with the same name and <A title=arity 
  href="REC-xslt20-20070123.htm#dt-arity">arity</A>, and 
  higher <A title="import precedence" 
  href="REC-xslt20-20070123.htm#dt-import-precedence">import 
  precedence</A>, or</P>
  <LI>
  <P>the <CODE>override</CODE> attribute has the value <CODE>no</CODE> and there 
  is already a function with the same name and <A title=arity 
  href="REC-xslt20-20070123.htm#dt-arity">arity</A> in 
  the in-scope functions.</P></LI></UL>
<P>The optional <CODE>override</CODE> attribute defines what happens if this 
function has the same name and <A title=arity 
href="REC-xslt20-20070123.htm#dt-arity">arity</A> as a 
function provided by the implementer or made available in the static context 
using an implementation-defined mechanism. If the <CODE>override</CODE> 
attribute has the value <CODE>yes</CODE>, then this function is used in 
preference; if it has the value <CODE>no</CODE>, then the other function is used 
in preference. The default value is <CODE>yes</CODE>.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>Specifying <CODE>override="yes"</CODE> ensures interoperable behavior: the 
same code will execute with all processors. Specifying 
<CODE>override="no"</CODE> is useful when writing a fallback implementation of a 
function that is available with some processors but not others: it allows the 
vendor's implementation of the function <SPAN>(or a user's implementation 
written as an extension function)</SPAN> to be used in preference to the 
stylesheet implementation, which is useful when the <SPAN>extension 
function</SPAN> is more efficient.</P>
<P>The <CODE>override</CODE> attribute does <EM>not</EM> affect the rules for 
deciding which of several <A title="stylesheet function" 
href="REC-xslt20-20070123.htm#dt-stylesheet-function">stylesheet 
functions</A> with the same name and <A title=arity 
href="REC-xslt20-20070123.htm#dt-arity">arity</A> takes 
precedence.</P></DIV>
<P><A id=err-XTSE0770 name=err-XTSE0770><SPAN class=error>[ERR 
XTSE0770]</SPAN></A> It is a <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A> for a <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
to contain two or more functions with the same <A title=expanded-QName 
href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded-QName</A>, 
the same <A title=arity 
href="REC-xslt20-20070123.htm#dt-arity">arity</A>, and 
the same <A title="import precedence" 
href="REC-xslt20-20070123.htm#dt-import-precedence">import 
precedence</A>, unless there is another function with the same <A 
title=expanded-QName 
href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded-QName</A> 
and arity, and a higher import precedence.</P>
<P>As defined in XPath, the function that is executed as the result of a 
function call is identified by looking in the in-scope functions of the static 
context for a function whose name and <A title=arity 
href="REC-xslt20-20070123.htm#dt-arity">arity</A> matches 
the name and number of arguments in the function call.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>Functions are not polymorphic. Although the XPath function call mechanism 
allows two functions to have the same name and different <A title=arity 
href="REC-xslt20-20070123.htm#dt-arity">arity</A>, it 
does not allow them to be distinguished by the types of their 
arguments.</P></DIV>
<P>The optional <CODE>as</CODE> attribute indicates the <A title="required type" 
href="REC-xslt20-20070123.htm#dt-required-type">required 
type</A> of the result of the function. The value of the <CODE>as</CODE> 
attribute is a <A 
href="http://www.w3.org/TR/xpath20/#doc-xpath-SequenceType">SequenceType</A><SUP> 
<SMALL>XP</SMALL></SUP>, as defined in <A 
href="REC-xslt20-20070123.htm#xpath20">[XPath 
2.0]</A>.</P>
<P><A id=err-XTTE0780 name=err-XTTE0780><SPAN class=error>[ERR 
XTTE0780]</SPAN></A> If the <CODE>as</CODE> attribute is specified, then the 
result evaluated by the <A title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A> (see <A 
href="REC-xslt20-20070123.htm#sequence-constructors"><I>5.7 
Sequence Constructors</I></A>) is converted to the required type, using the <A 
title="function conversion rules" 
href="REC-xslt20-20070123.htm#dt-function-conversion-rules">function 
conversion rules</A>. It is a <A title="type errors" 
href="REC-xslt20-20070123.htm#dt-type-error">type 
error</A> if this conversion fails. If the <CODE>as</CODE> attribute is omitted, 
the calculated result is used as supplied, and no conversion takes place.</P>
<P>If a <A title="stylesheet function" 
href="REC-xslt20-20070123.htm#dt-stylesheet-function">stylesheet 
function</A> has been defined with a particular <A title=expanded-QName 
href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded-QName</A>, 
then a call on <A 
href="REC-xslt20-20070123.htm#function-function-available"><CODE>function-available</CODE></A> 
will return true when called with an argument that is a <A title="lexical QName" 
href="REC-xslt20-20070123.htm#dt-lexical-qname">lexical 
QName</A> that expands to this same <A title=expanded-QName 
href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded-QName</A>.</P>
<P>The <A 
href="REC-xslt20-20070123.htm#element-param"><CODE>xsl:param</CODE></A> 
elements define the formal arguments to the function. These are interpreted 
positionally. When the function is called using a function-call in an XPath <A 
title=expression 
href="REC-xslt20-20070123.htm#dt-expression">expression</A>, 
the first argument supplied is assigned to the first <A 
href="REC-xslt20-20070123.htm#element-param"><CODE>xsl:param</CODE></A> 
element, the second argument supplied is assigned to the second <A 
href="REC-xslt20-20070123.htm#element-param"><CODE>xsl:param</CODE></A> 
element, and so on.</P>
<P>The <CODE>as</CODE> attribute of the <A 
href="REC-xslt20-20070123.htm#element-param"><CODE>xsl:param</CODE></A> 
element defines the required type of the parameter. The rules for converting the 
values of the actual arguments supplied in the function call to the types 
required by each <A 
href="REC-xslt20-20070123.htm#element-param"><CODE>xsl:param</CODE></A> 
element are defined in <A 
href="REC-xslt20-20070123.htm#xpath20">[XPath 2.0]</A>. 
The rules that apply are those for the case where <A 
title="XPath 1.0 compatibility mode" 
href="REC-xslt20-20070123.htm#dt-compatibility-mode">XPath 
1.0 compatibility mode</A> is set to <CODE>false</CODE>.</P>
<P><A id=err-XTTE0790 name=err-XTTE0790><SPAN class=error>[ERR 
XTTE0790]</SPAN></A> If the value of a parameter to a <A 
title="stylesheet function" 
href="REC-xslt20-20070123.htm#dt-stylesheet-function">stylesheet 
function</A> cannot be converted to the required type, a <A title="type errors" 
href="REC-xslt20-20070123.htm#dt-type-error">type 
error</A> is signaled.</P>
<P>If the <CODE>as</CODE> attribute is omitted, no conversion takes place and 
any value is accepted.</P>
<P>Within the body of a stylesheet function, the <A title=focus 
href="REC-xslt20-20070123.htm#dt-focus">focus</A> is 
initially undefined; this means that any attempt to reference the context item, 
context position, or context size is a <A title="non-recoverable dynamic error" 
href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
dynamic error</A>. <SPAN>[XPDY0002]</SPAN></P>
<P>It is not possible within the body of the <A title="stylesheet function" 
href="REC-xslt20-20070123.htm#dt-stylesheet-function">stylesheet 
function</A> to access the values of local variables that were in scope in the 
place where the function call was written. Global variables, however, remain 
available.</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e14761 name=d5e14761></A>Example: A Stylesheet 
Function </DIV>
<P>The following example creates a recursive <A title="stylesheet function" 
href="REC-xslt20-20070123.htm#dt-stylesheet-function">stylesheet 
function</A> named <CODE>str:reverse</CODE> that reverses the words in a 
supplied sentence, and then invokes this function from within a <A 
title="template rule" 
href="REC-xslt20-20070123.htm#dt-template-rule">template 
rule</A>.</P>
<DIV class=exampleInner><PRE>&lt;xsl:transform 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"
  xmlns:str="http://example.com/namespace"
  version="2.0"
  exclude-result-prefixes="str"&gt;

&lt;xsl:function name="str:reverse" as="xs:string"&gt;
  &lt;xsl:param name="sentence" as="xs:string"/&gt;
  &lt;xsl:sequence  
     select="if (contains($sentence, ' '))
             then concat(str:reverse(substring-after($sentence, ' ')),
                         ' ',
                         substring-before($sentence, ' '))
             else $sentence"/&gt;
&lt;/xsl:function&gt;

&lt;xsl:template match="/"&gt;
&lt;output&gt;
  &lt;xsl:value-of select="str:reverse('DOG BITES MAN')"/&gt;
&lt;/output&gt;
&lt;/xsl:template&gt;

&lt;/xsl:transform&gt;
</PRE></DIV>
<P>An alternative way of writing the same function is to implement the 
conditional logic at the XSLT level, thus:</P>
<DIV class=exampleInner><PRE>&lt;xsl:function name="str:reverse" as="xs:string"&gt;
  &lt;xsl:param name="sentence" as="xs:string"/&gt;
  &lt;xsl:choose&gt;
    &lt;xsl:when test="contains($sentence, ' ')"&gt;  
      &lt;xsl:sequence select="concat(str:reverse(substring-after($sentence, ' ')),
                                ' ',
                                substring-before($sentence, ' '))"/&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;
      &lt;xsl:sequence select="$sentence"/&gt;
    &lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
&lt;/xsl:function&gt;
</PRE></DIV></DIV>
<P>&nbsp;</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e14781 name=d5e14781></A>Example: Declaring the 
Return Type of a Function </DIV>
<P>The following example illustrates the use of the <CODE>as</CODE> attribute in 
a function definition. It returns a string containing the representation of its 
integer argument, expressed as a roman numeral. For example, the function call 
<CODE>num:roman(7)</CODE> will return the string <CODE>"vii"</CODE>. This 
example uses the <A 
href="REC-xslt20-20070123.htm#element-number"><CODE>xsl:number</CODE></A> 
instruction, described in <A 
href="REC-xslt20-20070123.htm#number"><I>12 
Numbering</I></A>. The <A 
href="REC-xslt20-20070123.htm#element-number"><CODE>xsl:number</CODE></A> 
instruction returns a text node, and the <A title="function conversion rules" 
href="REC-xslt20-20070123.htm#dt-function-conversion-rules">function 
conversion rules</A> are invoked to convert this text node to the type declared 
in the <A 
href="REC-xslt20-20070123.htm#element-function"><CODE>xsl:function</CODE></A> 
element, namely <CODE>xs:string</CODE>. So the text node is <A title=atomize 
href="REC-xslt20-20070123.htm#dt-atomization">atomized</A> 
to a string.</P>
<DIV class=exampleInner><PRE>&lt;xsl:function name="num:roman" as="xs:string"&gt;
  &lt;xsl:param name="value" as="xs:integer"/&gt;
  &lt;xsl:number value="$value" format="i"/&gt;
&lt;/xsl:function&gt;
</PRE></DIV></DIV></DIV></DIV>
<DIV class=div1>
<H2><A id=creating-new-nodes name=creating-new-nodes></A>11 Creating Nodes and 
Sequences</H2>
<P>This section describes instructions that directly create new nodes, or 
sequences of nodes and atomic values.</P>
<DIV class=div2>
<H3><A id=literal-result-element name=literal-result-element></A>11.1 Literal 
Result Elements</H3>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A 
id=dt-literal-result-element title="literal result element" 
name=dt-literal-result-element></A>In a <A title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A>, an element in the <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
that does not belong to the <A title="XSLT namespace" 
href="REC-xslt20-20070123.htm#dt-xslt-namespace">XSLT 
namespace</A> and that is not an <A title="extension instruction" 
href="REC-xslt20-20070123.htm#dt-extension-instruction">extension 
instruction</A> (see <A 
href="REC-xslt20-20070123.htm#extension-instruction"><I>18.2 
Extension Instructions</I></A>) is classified as a <B>literal result 
element</B>.<SPAN class=definition>]</SPAN> A literal result element is 
evaluated to construct a new element node with the same <A title=expanded-QName 
href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded-QName</A> 
<SPAN>(that is, the same namespace URI, local name, and namespace 
prefix)</SPAN>. The result of evaluating a literal result element is a node 
sequence containing one element, the newly constructed element node.</P>
<P>The content of the element is a <A title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A> (see <A 
href="REC-xslt20-20070123.htm#sequence-constructors"><I>5.7 
Sequence Constructors</I></A>). The sequence obtained by evaluating this 
sequence constructor, after prepending any attribute nodes produced as described 
in <A 
href="REC-xslt20-20070123.htm#attributes-for-lres"><I>11.1.2 
Attribute Nodes for Literal Result Elements</I></A> and namespace nodes produced 
as described in <A 
href="REC-xslt20-20070123.htm#lre-namespaces"><I>11.1.3 
Namespace Nodes for Literal Result Elements</I></A>, is used to construct the 
content of the element, following the rules in <A 
href="REC-xslt20-20070123.htm#constructing-complex-content"><I>5.7.1 
Constructing Complex Content</I></A></P>
<P>The base URI of the new element is copied from the base URI of the literal 
result element in the stylesheet, unless the content of the new element includes 
an <CODE>xml:base</CODE> attribute, in which case the base URI of the new 
element is the value of that attribute, resolved (if it is a relative URI) 
against the base URI of the literal result element in the stylesheet. (Note, 
however, that this is only relevant when creating a parentless element. When the 
literal result element is copied to form a child of an element or document node, 
the base URI of the new copy is taken from that of its new parent.)</P>
<DIV class=div3>
<H4><A id=setting-annotation-for-lre name=setting-annotation-for-lre></A>11.1.1 
Setting the Type Annotation for Literal Result Elements</H4>
<P>The attributes <CODE>xsl:type</CODE> and <CODE>xsl:validation</CODE> may be 
used on a literal result element to invoke validation of the contents of the 
element against a type definition or element declaration in a schema, and to 
determine the <A title="type annotation" 
href="REC-xslt20-20070123.htm#dt-annotation">type 
annotation</A> that the new element node will carry. These attributes also 
affect the type annotation carried by any elements and attributes that have the 
new element node as an ancestor. These two attributes are both optional, and if 
one is specified then the other <SPAN class=verb>must</SPAN> be omitted.</P>
<P>The value of the <CODE>xsl:validation</CODE> attribute, if present, must be 
one of the values <CODE>strict</CODE>, <CODE>lax</CODE>, <CODE>preserve</CODE>, 
or <CODE>strip</CODE>. The value of the <CODE>xsl:type</CODE> attribute, if 
present, must be a <A title=QName 
href="REC-xslt20-20070123.htm#dt-qname">QName</A> 
identifying a type definition that is present in the <A 
title="in-scope schema component" 
href="REC-xslt20-20070123.htm#dt-in-scope-schema-component">in-scope 
schema components</A> for the stylesheet. Neither attribute may be specified as 
an <A title="attribute value template" 
href="REC-xslt20-20070123.htm#dt-attribute-value-template">attribute 
value template.</A> The effect of these attributes is described in <A 
href="REC-xslt20-20070123.htm#validation"><I>19.2 
Validation</I></A>.</P></DIV>
<DIV class=div3>
<H4><A id=attributes-for-lres name=attributes-for-lres></A>11.1.2 Attribute 
Nodes for Literal Result Elements</H4>
<P>Attribute nodes for a literal result element may be created by including <A 
href="REC-xslt20-20070123.htm#element-attribute"><CODE>xsl:attribute</CODE></A> 
instructions within the <A title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A>. Additionally, attribute nodes are created corresponding to the 
attributes of the literal result element in the stylesheet, and as a result of 
expanding the <CODE>xsl:use-attribute-sets</CODE> attribute of the literal 
result element, if present.</P>
<P>The sequence that is used to construct the content of the literal result 
element (as described in <A 
href="REC-xslt20-20070123.htm#constructing-complex-content"><I>5.7.1 
Constructing Complex Content</I></A>) is the concatenation of the following four 
sequences, in order:</P>
<OL class=enumar>
  <LI>
  <P>The sequence of namespace nodes produced as described in <A 
  href="REC-xslt20-20070123.htm#lre-namespaces"><I>11.1.3 
  Namespace Nodes for Literal Result Elements</I></A>.</P>
  <LI>
  <P>The sequence of attribute nodes produced by expanding the 
  <CODE>xsl:use-attribute-sets</CODE> attribute (if present) following the rules 
  given in <A 
  href="REC-xslt20-20070123.htm#attribute-sets"><I>10.2 
  Named Attribute Sets</I></A></P>
  <LI>
  <P>The attributes produced by processing the attributes of the literal result 
  element itself, other than attributes in the <A title="" 
  href="REC-xslt20-20070123.htm#xslt-namespace">XSLT 
  namespace</A>. The way these are processed is described below.</P>
  <LI>
  <P>The sequence produced by evaluating the contained <A 
  title="sequence constructor" 
  href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
  constructor</A>, if the element is not empty.</P></LI></OL>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>The significance of this order is that an attribute produced by an 
<CODE>xsl:attribute</CODE><SPAN>, <A 
href="REC-xslt20-20070123.htm#element-copy"><CODE>xsl:copy</CODE></A>, 
or <A 
href="REC-xslt20-20070123.htm#element-copy-of"><CODE>xsl:copy-of</CODE></A></SPAN> 
instruction in the content of the literal result element takes precedence over 
an attribute produced by expanding an attribute of the literal result element 
itself, which in turn takes precedence over an attribute produced by expanding 
the <CODE>xsl:use-attribute-sets</CODE> attribute. This is because of the rules 
in <A 
href="REC-xslt20-20070123.htm#constructing-complex-content"><I>5.7.1 
Constructing Complex Content</I></A>, which specify that when two or more 
attributes in the sequence have the same name, all but the last of the 
duplicates are discarded.</P>
<P>Although the above rules place namespace nodes before attributes, this is not 
strictly necessary, because the rules in <A 
href="REC-xslt20-20070123.htm#constructing-complex-content"><I>5.7.1 
Constructing Complex Content</I></A> allow the namespaces and attributes to 
appear in any order so long as both come before other kinds of node. The order 
of namespace nodes and attribute nodes in the sequence has no effect on the 
relative position of the nodes in document order once they are added to a 
tree.</P></DIV>
<P>Each attribute of the literal result element, other than an attribute in the 
<A title="XSLT namespace" 
href="REC-xslt20-20070123.htm#dt-xslt-namespace">XSLT 
namespace</A>, is processed to produce an attribute for the element in the <A 
title="result tree" 
href="REC-xslt20-20070123.htm#dt-result-tree">result 
tree</A>.</P>
<P>The value of such an attribute is interpreted as an <A 
title="attribute value template" 
href="REC-xslt20-20070123.htm#dt-attribute-value-template">attribute 
value template</A>: it can therefore contain <A title=expression 
href="REC-xslt20-20070123.htm#dt-expression">expressions</A> 
contained in curly brackets (<CODE>{}</CODE>). The new attribute node will have 
the same <A title=expanded-QName 
href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded-QName</A> 
<SPAN>(that is, the same namespace URI, local name, and namespace prefix)</SPAN> 
as the attribute in the stylesheet tree, and its <A title="string value" 
href="REC-xslt20-20070123.htm#dt-string-value">string 
value</A> will be the same as the <A title="effective value" 
href="REC-xslt20-20070123.htm#dt-effective-value">effective 
value</A> of the attribute in the stylesheet tree. The <A 
title="type annotation" 
href="REC-xslt20-20070123.htm#dt-annotation">type 
annotation</A> on the attribute will initially be 
<SPAN><CODE>xs:untypedAtomic</CODE></SPAN>, and the <A title="typed value" 
href="REC-xslt20-20070123.htm#dt-typed-value">typed 
value</A> of the attribute node will be the same as its <A title="string value" 
href="REC-xslt20-20070123.htm#dt-string-value">string 
value</A>.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>The eventual <A title="type annotation" 
href="REC-xslt20-20070123.htm#dt-annotation">type 
annotation</A> of the attribute in the <A title="result tree" 
href="REC-xslt20-20070123.htm#dt-result-tree">result 
tree</A> depends on the <CODE>xsl:validation</CODE> and <CODE>xsl:type</CODE> 
attributes of the parent literal result element, and on the instructions used to 
create its ancestor elements. If the <CODE>xsl:validation</CODE> attribute is 
set to <CODE>preserve</CODE> or <CODE>strip</CODE>, the type annotation will be 
<SPAN><CODE>xs:untypedAtomic</CODE></SPAN>, and the <A title="typed value" 
href="REC-xslt20-20070123.htm#dt-typed-value">typed 
value</A> of the attribute node will be the same as its <A title="string value" 
href="REC-xslt20-20070123.htm#dt-string-value">string 
value</A>. If the <CODE>xsl:validation</CODE> attribute is set to 
<CODE>strict</CODE> or <CODE>lax</CODE>, or if the <CODE>xsl:type</CODE> 
attribute is used, the type annotation on the attribute will be set as a result 
of the schema validation process applied to the parent element. If neither 
attribute is present, the type annotation on the attribute will be 
<SPAN><CODE>xs:untypedAtomic</CODE></SPAN>.</P></DIV>
<P>If the name of a constructed attribute is <CODE>xml:id</CODE>, the processor 
must perform attribute value normalization by effectively applying the <A 
href="http://www.w3.org/TR/xpath-functions/#func-normalize-space"><CODE>normalize-space</CODE></A><SUP><SMALL>FO</SMALL></SUP> 
function to the value of the attribute, and the resulting attribute node must be 
given the <CODE>is-id</CODE> property.</P>
<P><A id=err-XTRE0795 name=err-XTRE0795><SPAN class=error>[ERR 
XTRE0795]</SPAN></A> It is a <A title="recoverable error" 
href="REC-xslt20-20070123.htm#dt-recoverable-error">recoverable 
dynamic error</A> if the name of a constructed attribute is 
<CODE>xml:space</CODE> and the value is not either <CODE>default</CODE> or 
<CODE>preserve</CODE>. The <A title="optional recovery action" 
href="REC-xslt20-20070123.htm#dt-optional-recovery-action">optional 
recovery action</A> is to construct the attribute with the value as requested.. 
This applies whether the attribute is constructed using a literal result 
element, or by using the <A 
href="REC-xslt20-20070123.htm#element-attribute"><CODE>xsl:attribute</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-copy"><CODE>xsl:copy</CODE></A>, 
or <A 
href="REC-xslt20-20070123.htm#element-copy-of"><CODE>xsl:copy-of</CODE></A> 
instructions.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>The <CODE>xml:base</CODE>, <CODE>xml:lang</CODE>, <CODE>xml:space</CODE>, and 
<CODE>xml:id</CODE> attributes have two effects in XSLT. They behave as standard 
XSLT attributes, which means for example that if they appear on a literal result 
element, they will be copied to the <A title="result tree" 
href="REC-xslt20-20070123.htm#dt-result-tree">result 
tree</A> in the same way as any other attribute. In addition, they have their 
standard meaning as defined in the core XML specifications. Thus, an 
<CODE>xml:base</CODE> attribute in the stylesheet affects the base URI of the 
element on which it appears, and an <CODE>xml:space</CODE> attribute affects the 
interpretation of <A title="whitespace text node" 
href="REC-xslt20-20070123.htm#dt-whitespace-text-node">whitespace 
text nodes</A> within that element. One consequence of this is that it is 
inadvisable to write these attributes as attribute value templates: although an 
XSLT processor will understand this notation, the XML parser will not. See also 
<A 
href="REC-xslt20-20070123.htm#namespace-aliasing"><I>11.1.4 
Namespace Aliasing</I></A> which describes how to use <A 
href="REC-xslt20-20070123.htm#element-namespace-alias"><CODE>xsl:namespace-alias</CODE></A> 
with these attributes.</P>
<P>The same is true of the schema-defined attributes <CODE>xsi:type</CODE>, 
<CODE>xsi:nil</CODE>, <SPAN><CODE>xsi:noNamespaceSchemaLocation</CODE></SPAN>, 
and <CODE>xsi:schemaLocation</CODE>. If the stylesheet is processed by a schema 
processor, these attributes will be recognized and interpreted by the schema 
processor, but <SPAN>in addition the XSLT processor treats them like any other 
attribute on a literal result element: that is, their <A title="effective value" 
href="REC-xslt20-20070123.htm#dt-effective-value">effective 
value</A> (after expanding <A title="attribute value template" 
href="REC-xslt20-20070123.htm#dt-attribute-value-template">attribute 
value templates</A>) is copied to the result tree in the same way as any other 
attribute.</SPAN> If the <A title="result tree" 
href="REC-xslt20-20070123.htm#dt-result-tree">result 
tree</A> is validated, the copied attributes will again be recognized and 
interpreted by the schema processor.</P>
<P>None of these attributes will be generated in the <A title="result tree" 
href="REC-xslt20-20070123.htm#dt-result-tree">result 
tree</A> unless the stylesheet writes them to the result tree explicitly, in the 
same way as any other attribute.</P></DIV>
<P><A id=err-XTSE0805 name=err-XTSE0805><SPAN class=error>[ERR 
XTSE0805]</SPAN></A> It is a <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A> if an attribute on a literal result element is in the <A 
title="XSLT namespace" 
href="REC-xslt20-20070123.htm#dt-xslt-namespace">XSLT 
namespace</A>, unless it is one of the attributes explicitly defined in this 
specification.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>If there is a need to create attributes in the XSLT namespace, this can be 
achieved using <A 
href="REC-xslt20-20070123.htm#element-attribute"><CODE>xsl:attribute</CODE></A>, 
or by means of the <A 
href="REC-xslt20-20070123.htm#element-namespace-alias"><CODE>xsl:namespace-alias</CODE></A> 
declaration.</P></DIV></DIV>
<DIV class=div3>
<H4><A id=lre-namespaces name=lre-namespaces></A>11.1.3 Namespace Nodes for 
Literal Result Elements</H4>
<P>The created element node will have a copy of the namespace nodes that were 
present on the element node in the stylesheet tree with the exception of any 
namespace node whose <A title="string value" 
href="REC-xslt20-20070123.htm#dt-string-value">string 
value</A> is designated as an <B>excluded namespace</B>. Special considerations 
apply to aliased namespaces: see <A 
href="REC-xslt20-20070123.htm#namespace-aliasing"><I>11.1.4 
Namespace Aliasing</I></A></P>
<P>The following namespaces are designated as excluded namespaces:</P>
<UL>
  <LI>
  <P>The <A title="XSLT namespace" 
  href="REC-xslt20-20070123.htm#dt-xslt-namespace">XSLT 
  namespace</A> URI (<CODE>http://www.w3.org/1999/XSL/Transform</CODE>)</P>
  <LI>
  <P>A namespace URI declared as an extension namespace (see <A 
  href="REC-xslt20-20070123.htm#extension-instruction"><I>18.2 
  Extension Instructions</I></A>)</P>
  <LI>
  <P>A namespace URI designated by using an 
  <CODE>[xsl:]exclude-result-prefixes</CODE> attribute either on the literal 
  result element itself or on an ancestor element. The attribute <SPAN 
  class=verb>must</SPAN> be in the XSLT namespace only if its parent element is 
  <EM>not</EM> in the XSLT namespace.</P>
  <P>The value of the attribute is either <CODE>#all</CODE>, or a 
  whitespace-separated list of tokens, each of which is either a namespace 
  prefix or <CODE>#default</CODE>. The namespace bound to each of the prefixes 
  is designated as an excluded namespace.</P>
  <P><A id=err-XTSE0808 name=err-XTSE0808><SPAN class=error>[ERR 
  XTSE0808]</SPAN></A> It is a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A> if a namespace prefix is used within the 
  <CODE>[xsl:]exclude-result-prefixes</CODE> attribute and there is no namespace 
  binding in scope for that prefix.</P>
  <P>The default namespace of the parent element of the 
  <CODE>[xsl:]exclude-result-prefixes</CODE> attribute (see <A 
  href="http://www.w3.org/TR/xpath-datamodel/#ElementNode">Section 6.2 Element 
  Nodes</A><SUP><SMALL>DM</SMALL></SUP>) may be designated as an excluded 
  namespace by including <CODE>#default</CODE> in the list of namespace 
  prefixes.</P>
  <P><A id=err-XTSE0809 name=err-XTSE0809><SPAN class=error>[ERR 
  XTSE0809]</SPAN></A> It is a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A> if the value <CODE>#default</CODE> is used within the 
  <CODE>[xsl:]exclude-result-prefixes</CODE> attribute and the parent element of 
  the <CODE>[xsl:]exclude-result-prefixes</CODE> attribute has no default 
  namespace.</P>
  <P>The value <CODE>#all</CODE> indicates that all namespaces that are in scope 
  for the stylesheet element that is the parent of the 
  <CODE>[xsl:]exclude-result-prefixes</CODE> attribute are designated as 
  excluded namespaces.</P>
  <P>The designation of a namespace as an excluded namespace is effective within 
  the subtree of the stylesheet module rooted at the element bearing the 
  <CODE>[xsl:]exclude-result-prefixes</CODE> attribute; a subtree rooted at an 
  <A 
  href="REC-xslt20-20070123.htm#element-stylesheet"><CODE>xsl:stylesheet</CODE></A> 
  element does not include any stylesheet modules imported or included by 
  children of that <A 
  href="REC-xslt20-20070123.htm#element-stylesheet"><CODE>xsl:stylesheet</CODE></A> 
  element.</P></LI></UL>
<P>The excluded namespaces, as described above, <EM>only</EM> affect namespace 
nodes copied from the stylesheet when processing a literal result element. There 
is no guarantee that an excluded namespace will not appear on the <A 
title="result tree" 
href="REC-xslt20-20070123.htm#dt-result-tree">result 
tree</A> for some other reason. Namespace nodes are also written to the result 
tree as part of the process of namespace fixup (see <A 
href="REC-xslt20-20070123.htm#namespace-fixup"><I>5.7.3 
Namespace Fixup</I></A>), or as the result of instructions such as <A 
href="REC-xslt20-20070123.htm#element-copy"><CODE>xsl:copy</CODE></A> 
and <A 
href="REC-xslt20-20070123.htm#element-element"><CODE>xsl:element</CODE></A>.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>When a stylesheet uses a namespace declaration only for the purposes of 
addressing a <A title="source tree" 
href="REC-xslt20-20070123.htm#dt-source-tree">source 
tree</A>, specifying the prefix in the 
<CODE>[xsl:]exclude-result-prefixes</CODE> attribute will avoid superfluous 
namespace declarations in the serialized <A title="result tree" 
href="REC-xslt20-20070123.htm#dt-result-tree">result 
tree</A>. The attribute is also useful to prevent namespaces used solely for the 
naming of stylesheet functions or extension functions from appearing in the 
serialized result tree.</P></DIV>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e15344 name=d5e15344></A>Example: Excluding 
Namespaces from the Result Tree </DIV>
<P>For example, consider the following stylesheet:</P>
<DIV class=exampleInner><PRE>&lt;xsl:stylesheet xsl:version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:a="a.uri"
  xmlns:b="b.uri"&gt;
  exclude-result-prefixes="#all"&gt;
  
&lt;xsl:template match="/"&gt;
  &lt;foo xmlns:c="c.uri" xmlns:d="d.uri" xmlns:a2="a.uri" 
       xsl:exclude-result-prefixes="c"/&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;
</PRE></DIV>
<P>The result of this stylesheet will be:</P>
<DIV class=exampleInner><PRE>&lt;foo xmlns:d="d.uri"/&gt;
</PRE></DIV>
<P>The namespaces <CODE>a.uri</CODE> and <CODE>b.uri</CODE> are excluded by 
virtue of the <CODE>exclude-result-prefixes</CODE> attribute on the <A 
href="REC-xslt20-20070123.htm#element-stylesheet"><CODE>xsl:stylesheet</CODE></A> 
element, and the namespace <CODE>c.uri</CODE> is excluded by virtue of the 
<CODE>xsl:exclude-result-prefixes</CODE> attribute on the <CODE>foo</CODE> 
element. The setting <CODE>#all</CODE> does not affect the namespace 
<CODE>d.uri</CODE> because <CODE>d.uri</CODE> is not an in-scope namespace for 
the <A 
href="REC-xslt20-20070123.htm#element-stylesheet"><CODE>xsl:stylesheet</CODE></A> 
element. The element in the <A title="result tree" 
href="REC-xslt20-20070123.htm#dt-result-tree">result 
tree</A> does not have a namespace node corresponding to 
<CODE>xmlns:a2="a.uri"</CODE> because the effect of 
<CODE>exclude-result-prefixes</CODE> is to designate the namespace URI 
<CODE>a.uri</CODE> as an excluded namespace, irrespective of how many prefixes 
are bound to this namespace URI.</P>
<P>If the stylesheet is changed so that the literal result element has an 
attribute <CODE>b:bar="3"</CODE>, then the element in the <A title="result tree" 
href="REC-xslt20-20070123.htm#dt-result-tree">result 
tree</A> will typically have a namespace declaration 
<CODE>xmlns:b="b.uri"</CODE> <SPAN>(the processor may choose a different 
namespace prefix if this is necessary to avoid conflicts)</SPAN>. The 
<CODE>exclude-result-prefixes</CODE> attribute makes <CODE>b.uri</CODE> an 
excluded namespace, so the namespace node is not automatically copied from the 
stylesheet, but the presence of an attribute whose name is in the namespace 
<CODE>b.uri</CODE> forces the namespace fixup process (see <A 
href="REC-xslt20-20070123.htm#namespace-fixup"><I>5.7.3 
Namespace Fixup</I></A>) to introduce a namespace node for this 
namespace.</P></DIV>
<P>A literal result element may have an optional 
<CODE>xsl:inherit-namespaces</CODE> attribute, with the value <CODE>yes</CODE> 
or <CODE>no</CODE>. The default value is <CODE>yes</CODE>. If the value is set 
to <CODE>yes</CODE>, or is omitted, then the namespace nodes created for the 
newly constructed element are copied to the children and descendants of the 
newly constructed element, as described in <A 
href="REC-xslt20-20070123.htm#constructing-complex-content"><I>5.7.1 
Constructing Complex Content</I></A>. If the value is set to <CODE>no</CODE>, 
then these namespace nodes are not automatically copied to the children. This 
may result in namespace undeclarations (such as <CODE>xmlns=""</CODE> or, in the 
case of XML 1.1, <CODE>xmlns:p=""</CODE>) appearing on the child elements when a 
<A title="final result tree" 
href="REC-xslt20-20070123.htm#dt-final-result-tree">final 
result tree</A> is serialized.</P></DIV>
<DIV class=div3>
<H4><A id=namespace-aliasing name=namespace-aliasing></A>11.1.4 Namespace 
Aliasing</H4>
<P>When a stylesheet is used to define a transformation whose output is itself a 
stylesheet module, or in certain other cases where the result document uses 
namespaces that it would be inconvenient to use in the stylesheet, namespace 
aliasing can be used to declare a mapping between a namespace URI used in the 
stylesheet and the corresponding namespace URI to be used in the result 
document.</P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A 
id=dt-literal-namespace-uri title="literal namespace URI" 
name=dt-literal-namespace-uri></A>A namespace URI in the stylesheet tree that is 
being used to specify a namespace URI in the <A title="result tree" 
href="REC-xslt20-20070123.htm#dt-result-tree">result 
tree</A> is called a <B>literal namespace URI</B>.<SPAN 
class=definition>]</SPAN></P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-target-namespace-uri 
title="target namespace URI" name=dt-target-namespace-uri></A>The namespace URI 
that is to be used in the <A title="result tree" 
href="REC-xslt20-20070123.htm#dt-result-tree">result 
tree</A> as a substitute for a <A title="literal namespace URI" 
href="REC-xslt20-20070123.htm#dt-literal-namespace-uri">literal 
namespace URI</A> is called the <B>target namespace URI</B>.<SPAN 
class=definition>]</SPAN></P>
<P>Either of the <A title="literal namespace URI" 
href="REC-xslt20-20070123.htm#dt-literal-namespace-uri">literal 
namespace URI</A> or the <A title="target namespace URI" 
href="REC-xslt20-20070123.htm#dt-target-namespace-uri">target 
namespace URI</A> can be <EM>null</EM>: this is treated as a reference to the 
set of names that are in no namespace.</P>
<P class=element-syntax><A id=element-namespace-alias 
name=element-namespace-alias></A><CODE>&lt;!-- Category: declaration 
--&gt;<BR>&lt;xsl:namespace-alias<BR>&nbsp;&nbsp;<B>stylesheet-prefix</B> = 
<VAR>prefix</VAR> | "#default"<BR>&nbsp;&nbsp;<B>result-prefix</B> = 
<VAR>prefix</VAR> | "#default"&nbsp;/&gt;</CODE></P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-alias title=alias 
name=dt-alias></A>A stylesheet can use the <A 
href="REC-xslt20-20070123.htm#element-namespace-alias"><CODE>xsl:namespace-alias</CODE></A> 
element to declare that a <A title="literal namespace URI" 
href="REC-xslt20-20070123.htm#dt-literal-namespace-uri">literal 
namespace URI</A> is being used as an <B>alias</B> for a <A 
title="target namespace URI" 
href="REC-xslt20-20070123.htm#dt-target-namespace-uri">target 
namespace URI</A>.<SPAN class=definition>]</SPAN></P>
<P>The effect is that when names in the namespace identified by the <A 
title="literal namespace URI" 
href="REC-xslt20-20070123.htm#dt-literal-namespace-uri">literal 
namespace URI</A> are copied to the <A title="result tree" 
href="REC-xslt20-20070123.htm#dt-result-tree">result 
tree</A>, the namespace URI in the result tree will be the <A 
title="target namespace URI" 
href="REC-xslt20-20070123.htm#dt-target-namespace-uri">target 
namespace URI</A>, instead of the literal namespace URI. This applies to:</P>
<UL>
  <LI>
  <P>the namespace URI in the <A title=expanded-QName 
  href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded-QName</A> 
  of a literal result element in the stylesheet</P>
  <LI>
  <P>the namespace URI in the <A title=expanded-QName 
  href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded-QName</A> 
  of an attribute specified on a literal result element in the 
  stylesheet</P></LI></UL>
<P>Where namespace aliasing changes the namespace URI part of the <A 
title=expanded-QName 
href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded-QName</A> 
containing the name of an element or attribute node, the namespace prefix in 
that expanded-QName is replaced by the prefix indicated by the 
<CODE>result-prefix</CODE> attribute of the <A 
href="REC-xslt20-20070123.htm#element-namespace-alias"><CODE>xsl:namespace-alias</CODE></A> 
declaration.</P>
<P>The <A 
href="REC-xslt20-20070123.htm#element-namespace-alias"><CODE>xsl:namespace-alias</CODE></A> 
element declares that the namespace URI bound to the prefix specified by the 
<CODE>stylesheet-prefix</CODE> is the <A title="literal namespace URI" 
href="REC-xslt20-20070123.htm#dt-literal-namespace-uri">literal 
namespace URI</A>, and the namespace URI bound to the prefix specified by the 
<CODE>result-prefix</CODE> attribute is the <A title="target namespace URI" 
href="REC-xslt20-20070123.htm#dt-target-namespace-uri">target 
namespace URI</A>. Thus, the <CODE>stylesheet-prefix</CODE> attribute specifies 
the namespace URI that will appear in the stylesheet, and the 
<CODE>result-prefix</CODE> attribute specifies the corresponding namespace URI 
that will appear in the <A title="result tree" 
href="REC-xslt20-20070123.htm#dt-result-tree">result 
tree</A>.</P>
<P>The default namespace (as declared by <CODE>xmlns</CODE>) may be specified by 
using <CODE>#default</CODE> instead of a prefix. <SPAN>If no default namespace 
is in force, specifying <CODE>#default</CODE> denotes the null namespace URI. 
This allows elements that are in no namespace in the stylesheet to acquire a 
namespace in the result document, or vice versa.</SPAN></P>
<P>If a <A title="literal namespace URI" 
href="REC-xslt20-20070123.htm#dt-literal-namespace-uri">literal 
namespace URI</A> is declared to be an alias for multiple different <A 
title="literal namespace URI" 
href="REC-xslt20-20070123.htm#dt-literal-namespace-uri">target 
namespace URIs</A>, then the declaration with the highest <A 
title="import precedence" 
href="REC-xslt20-20070123.htm#dt-import-precedence">import 
precedence</A> is used.</P>
<P><A id=err-XTSE0810 name=err-XTSE0810><SPAN class=error>[ERR 
XTSE0810]</SPAN></A> It is a <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A> if there is more than one such declaration with the same <A 
title="literal namespace URI" 
href="REC-xslt20-20070123.htm#dt-literal-namespace-uri">literal 
namespace URI</A> and the same <A title="import precedence" 
href="REC-xslt20-20070123.htm#dt-import-precedence">import 
precedence</A> and different values for the <A title="target namespace URI" 
href="REC-xslt20-20070123.htm#dt-target-namespace-uri">target 
namespace URI</A>, unless there is also an <A 
href="REC-xslt20-20070123.htm#element-namespace-alias"><CODE>xsl:namespace-alias</CODE></A> 
declaration with the same <A title="literal namespace URI" 
href="REC-xslt20-20070123.htm#dt-literal-namespace-uri">literal 
namespace URI</A> and a higher import precedence.</P>
<P><A id=err-XTSE0812 name=err-XTSE0812><SPAN class=error>[ERR 
XTSE0812]</SPAN></A> It is a <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A> if a value other than <CODE>#default</CODE> is specified for either 
the <CODE>stylesheet-prefix</CODE> or the <CODE>result-prefix</CODE> attributes 
of the <A 
href="REC-xslt20-20070123.htm#element-namespace-alias"><CODE>xsl:namespace-alias</CODE></A> 
element when there is no in-scope binding for that namespace prefix.</P>
<P>When a literal result element is processed, its namespace nodes are handled 
as follows:</P>
<UL>
  <LI>
  <P>A namespace node whose string value is a <A title="literal namespace URI" 
  href="REC-xslt20-20070123.htm#dt-literal-namespace-uri">literal 
  namespace URI</A> is not copied to the <A title="result tree" 
  href="REC-xslt20-20070123.htm#dt-result-tree">result 
  tree</A>.</P>
  <LI>
  <P>A namespace node whose string value is a <A title="target namespace URI" 
  href="REC-xslt20-20070123.htm#dt-target-namespace-uri">target 
  namespace URI</A> is copied to the <A title="result tree" 
  href="REC-xslt20-20070123.htm#dt-result-tree">result 
  tree</A>, whether or not the URI identifies an excluded namespace.</P></LI></UL>
<P>In the event that the same URI is used as a <A title="literal namespace URI" 
href="REC-xslt20-20070123.htm#dt-literal-namespace-uri">literal 
namespace URI</A> and a <A title="target namespace URI" 
href="REC-xslt20-20070123.htm#dt-target-namespace-uri">target 
namespace URI</A>, the second of these rules takes precedence.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>These rules achieve the effect that the element generated from the literal 
result element will have an in-scope namespace node that binds the 
<CODE>result-prefix</CODE> to the <A title="target namespace URI" 
href="REC-xslt20-20070123.htm#dt-target-namespace-uri">target 
namespace URI</A>, provided that the namespace declaration associating this 
prefix with this URI is in scope for both the <A 
href="REC-xslt20-20070123.htm#element-namespace-alias"><CODE>xsl:namespace-alias</CODE></A> 
instruction and for the literal result element. Conversely, the 
<CODE>stylesheet-prefix</CODE> and the <A title="literal namespace URI" 
href="REC-xslt20-20070123.htm#dt-literal-namespace-uri">literal 
namespace URI</A> will not normally appear in the <A title="result tree" 
href="REC-xslt20-20070123.htm#dt-result-tree">result 
tree</A>.</P></DIV>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e15715 name=d5e15715></A>Example: Using 
<CODE>xsl:namespace-alias</CODE> to Generate a Stylesheet </DIV>
<P>When literal result elements are being used to create element, attribute, or 
namespace nodes that use the <A title="XSLT namespace" 
href="REC-xslt20-20070123.htm#dt-xslt-namespace">XSLT 
namespace</A> URI, the stylesheet may use an alias.</P>
<P>For example, the stylesheet</P>
<DIV class=exampleInner><PRE>&lt;xsl:stylesheet
  version="2.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:fo="http://www.w3.org/1999/XSL/Format"
  xmlns:axsl="file://namespace.alias"&gt;

&lt;xsl:namespace-alias stylesheet-prefix="axsl" result-prefix="xsl"/&gt;

&lt;xsl:template match="/"&gt;
  &lt;axsl:stylesheet version="2.0"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/axsl:stylesheet&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="elements"&gt;
  &lt;axsl:template match="/"&gt;
     &lt;axsl:comment select="system-property('xsl:version')"/&gt;
     &lt;axsl:apply-templates/&gt;
  &lt;/axsl:template&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="block"&gt;
  &lt;axsl:template match="{.}"&gt;
     &lt;fo:block&gt;&lt;axsl:apply-templates/&gt;&lt;/fo:block&gt;
  &lt;/axsl:template&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;
</PRE></DIV>
<P>will generate an XSLT stylesheet from a document of the form:</P>
<DIV class=exampleInner><PRE>&lt;elements&gt;
&lt;block&gt;p&lt;/block&gt;
&lt;block&gt;h1&lt;/block&gt;
&lt;block&gt;h2&lt;/block&gt;
&lt;block&gt;h3&lt;/block&gt;
&lt;block&gt;h4&lt;/block&gt;
&lt;/elements&gt;
</PRE></DIV>
<P>The output of the transformation will be a stylesheet such as the following. 
Whitespace has been added for clarity. Note that an implementation may output 
different namespace prefixes from those appearing in this example; however, the 
rules guarantee that there will be a namespace node that binds the prefix 
<CODE>xsl</CODE> to the URI <CODE>http://www.w3.org/1999/XSL/Transform</CODE>, 
which makes it safe to use the QName <CODE>xsl:version</CODE> in the content of 
the generated stylesheet.</P>
<DIV class=exampleInner><PRE>&lt;xsl:stylesheet
  version="2.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform" 
  xmlns:fo="http://www.w3.org/1999/XSL/Format"&gt;

&lt;xsl:template match="/"&gt;
  &lt;xsl:comment select="system-property('xsl:version')"/&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;
  
&lt;xsl:template match="p"&gt;
  &lt;fo:block&gt;&lt;xsl:apply-templates/&gt;&lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="h1"&gt;
  &lt;fo:block&gt;&lt;xsl:apply-templates/&gt;&lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="h2"&gt;
  &lt;fo:block&gt;&lt;xsl:apply-templates/&gt;&lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="h3"&gt;
  &lt;fo:block&gt;&lt;xsl:apply-templates/&gt;&lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="h4"&gt;
  &lt;fo:block&gt;&lt;xsl:apply-templates/&gt;&lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;
</PRE></DIV></DIV>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>It may be necessary also to use aliases for namespaces other than the XSLT 
namespace URI. For example, it can be useful to define an alias for the 
namespace <CODE>http://www.w3.org/2001/XMLSchema-instance</CODE>, so that the 
stylesheet can use the attributes <CODE>xsi:type</CODE>, <CODE>xsi:nil</CODE>, 
and <CODE>xsi:schemaLocation</CODE> on a literal result element, without running 
the risk that a schema processor will interpret these as applying to the 
stylesheet itself. Equally, literal result elements belonging to a namespace 
dealing with digital signatures might cause XSLT stylesheets to be mishandled by 
general-purpose security software; using an alias for the namespace would avoid 
the possibility of such mishandling.</P></DIV>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e15762 name=d5e15762></A>Example: Aliasing the 
XML Namespace </DIV>
<P>It is possible to define an alias for the XML namespace.</P>
<DIV class=exampleInner><PRE>&lt;xsl:stylesheet xmlns:axml="http://www.example.com/alias-xml"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                version="2.0"&gt;

&lt;xsl:namespace-alias stylesheet-prefix="axml" result-prefix="xml"/&gt;

&lt;xsl:template match="/"&gt;
  &lt;name axml:space="preserve"&gt;
    &lt;first&gt;James&lt;/first&gt;
    &lt;xsl:text&gt; &lt;/xsl:text&gt;
    &lt;last&gt;Clark&lt;/last&gt;
  &lt;/name&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;
</PRE></DIV>
<P>produces the output:</P>
<DIV class=exampleInner><PRE>&lt;name xml:space="preserve"&gt;&lt;first&gt;James&lt;/first&gt; &lt;last&gt;Clark&lt;/last&gt;&lt;/name&gt;
</PRE></DIV>
<P>This allows an <CODE>xml:space</CODE> attribute to be generated in the output 
without affecting the way the stylesheet is parsed. The same technique can be 
used for other attributes such as <CODE>xml:lang</CODE>, <CODE>xml:base</CODE>, 
and <CODE>xml:id</CODE>.</P></DIV>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>Namespace aliasing is only necessary when literal result elements are used. 
The problem of reserved namespaces does not arise when using <A 
href="REC-xslt20-20070123.htm#element-element"><CODE>xsl:element</CODE></A> 
and <A 
href="REC-xslt20-20070123.htm#element-attribute"><CODE>xsl:attribute</CODE></A> 
to construct the <A title="result tree" 
href="REC-xslt20-20070123.htm#dt-result-tree">result 
tree</A>. Therefore, as an alternative to using <A 
href="REC-xslt20-20070123.htm#element-namespace-alias"><CODE>xsl:namespace-alias</CODE></A>, 
it is always possible to achieve the desired effect by replacing literal result 
elements with <A 
href="REC-xslt20-20070123.htm#element-element"><CODE>xsl:element</CODE></A> 
and <A 
href="REC-xslt20-20070123.htm#element-attribute"><CODE>xsl:attribute</CODE></A> 
instructions.</P></DIV></DIV></DIV>
<DIV class=div2>
<H3><A id=xsl-element name=xsl-element></A>11.2 Creating Element Nodes Using 
<CODE>xsl:element</CODE></H3>
<P class=element-syntax><A id=element-element 
name=element-element></A><CODE>&lt;!-- Category: instruction 
--&gt;<BR>&lt;xsl:element<BR>&nbsp;&nbsp;<B>name</B> = { <VAR>qname</VAR> 
}<BR>&nbsp;&nbsp;namespace? = { <VAR>uri-reference</VAR> 
}<BR>&nbsp;&nbsp;inherit-namespaces? = "yes" | 
"no"<BR>&nbsp;&nbsp;use-attribute-sets? = <VAR>qnames</VAR><BR>&nbsp;&nbsp;type? 
= <VAR>qname</VAR><BR>&nbsp;&nbsp;validation? = "strict" | "lax" | "preserve" | 
"strip"&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: <VAR>sequence-constructor</VAR> 
--&gt;<BR>&lt;/xsl:element&gt;</CODE></P>
<P>The <A 
href="REC-xslt20-20070123.htm#element-element"><CODE>xsl:element</CODE></A> 
instruction allows an element to be created with a computed name. The <A 
title=expanded-QName 
href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded-QName</A> 
of the element to be created is specified by a <SPAN class=verb>required</SPAN> 
<CODE>name</CODE> attribute and an optional <CODE>namespace</CODE> 
attribute.</P>
<P>The content of the <A 
href="REC-xslt20-20070123.htm#element-element"><CODE>xsl:element</CODE></A> 
instruction is a <A title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A> for the children, attributes, and namespaces of the created 
element. The sequence obtained by evaluating this sequence constructor (see <A 
href="REC-xslt20-20070123.htm#sequence-constructors"><I>5.7 
Sequence Constructors</I></A>) is used to construct the content of the element, 
as described in <A 
href="REC-xslt20-20070123.htm#constructing-complex-content"><I>5.7.1 
Constructing Complex Content</I></A>.</P>
<P>The <A 
href="REC-xslt20-20070123.htm#element-element"><CODE>xsl:element</CODE></A> 
element may have a <CODE>use-attribute-sets</CODE> attribute, whose value is a 
whitespace-separated list of QNames that identify <A 
href="REC-xslt20-20070123.htm#element-attribute-set"><CODE>xsl:attribute-set</CODE></A> 
declarations. If this attribute is present, it is expanded as described in <A 
href="REC-xslt20-20070123.htm#attribute-sets"><I>10.2 
Named Attribute Sets</I></A> to produce a sequence of attribute nodes. This 
sequence is prepended to the sequence produced as a result of evaluating the <A 
title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A>, as described in <A 
href="REC-xslt20-20070123.htm#constructing-complex-content"><I>5.7.1 
Constructing Complex Content</I></A>.</P>
<P>The result of evaluating the <A 
href="REC-xslt20-20070123.htm#element-element"><CODE>xsl:element</CODE></A> 
instruction, except in error cases, is the newly constructed element node.</P>
<P>The <CODE>name</CODE> attribute is interpreted as an <A 
title="attribute value template" 
href="REC-xslt20-20070123.htm#dt-attribute-value-template">attribute 
value template</A>, whose <A title="effective value" 
href="REC-xslt20-20070123.htm#dt-effective-value">effective 
value</A> <SPAN class=verb>must</SPAN> be a <A title="lexical QName" 
href="REC-xslt20-20070123.htm#dt-lexical-qname">lexical 
QName</A>.</P>
<P><A id=err-XTDE0820 name=err-XTDE0820><SPAN class=error>[ERR 
XTDE0820]</SPAN></A> It is a <A title="non-recoverable dynamic error" 
href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
dynamic error</A> if the <A title="effective value" 
href="REC-xslt20-20070123.htm#dt-effective-value">effective 
value</A> of the <CODE>name</CODE> attribute is not a <A title="lexical QName" 
href="REC-xslt20-20070123.htm#dt-lexical-qname">lexical 
QName</A>.</P>
<P><A id=err-XTDE0830 name=err-XTDE0830><SPAN class=error>[ERR 
XTDE0830]</SPAN></A> In the case of an <A 
href="REC-xslt20-20070123.htm#element-element"><CODE>xsl:element</CODE></A> 
instruction with no <CODE>namespace</CODE> attribute, it is a <A 
title="non-recoverable dynamic error" 
href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
dynamic error</A> if the <A title="effective value" 
href="REC-xslt20-20070123.htm#dt-effective-value">effective 
value</A> of the <CODE>name</CODE> attribute is a <A title=QName 
href="REC-xslt20-20070123.htm#dt-qname">QName</A> whose 
prefix is not declared in an in-scope namespace declaration for the <A 
href="REC-xslt20-20070123.htm#element-element"><CODE>xsl:element</CODE></A> 
instruction.</P>
<P>If the <CODE>namespace</CODE> attribute is not present then the <A 
title=QName 
href="REC-xslt20-20070123.htm#dt-qname">QName</A> is 
expanded into an <A title=expanded-QName 
href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded-QName</A> 
using the namespace declarations in effect for the <A 
href="REC-xslt20-20070123.htm#element-element"><CODE>xsl:element</CODE></A> 
element, including any default namespace declaration.</P>
<P>If the <CODE>namespace</CODE> attribute is present, then it too is 
interpreted as an <A title="attribute value template" 
href="REC-xslt20-20070123.htm#dt-attribute-value-template">attribute 
value template</A>. The <A title="effective value" 
href="REC-xslt20-20070123.htm#dt-effective-value">effective 
value</A> <SPAN><SPAN class=verb>must</SPAN> be in the lexical space of the 
<CODE>xs:anyURI</CODE> type.</SPAN> If the string is zero-length, then the <A 
title=expanded-QName 
href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded-QName</A> 
of the element has a null namespace URI. Otherwise, the string is used as the 
namespace URI of the <A title=expanded-QName 
href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded-QName</A> 
of the element to be created. The local part of the <A title="lexical QName" 
href="REC-xslt20-20070123.htm#dt-lexical-qname">lexical 
QName</A> specified by the <CODE>name</CODE> attribute is used as the local part 
of the <A title=expanded-QName 
href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded-QName</A> 
of the element to be created.</P>
<P><A id=err-XTDE0835 name=err-XTDE0835><SPAN class=error>[ERR 
XTDE0835]</SPAN></A> It is a <A title="non-recoverable dynamic error" 
href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
dynamic error</A> if the <A title="effective value" 
href="REC-xslt20-20070123.htm#dt-effective-value">effective 
value</A> of the <CODE>namespace</CODE> attribute is not in the lexical space of 
the <CODE>xs:anyURI</CODE> data type.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>The <SPAN>XDM</SPAN> data model requires the name of a node to be an instance 
of <CODE>xs:QName</CODE>, and XML Schema defines the namespace part of an 
<CODE>xs:QName</CODE> to be an instance of <CODE>xs:anyURI</CODE>. However, the 
schema specification, and the specifications that it refers to, give 
implementations some flexibility in how strictly they enforce these 
constraints.</P></DIV>
<P>The prefix of the <A title="lexical QName" 
href="REC-xslt20-20070123.htm#dt-lexical-qname">lexical 
QName</A> specified in the <CODE>name</CODE> attribute (or the absence of a 
prefix) is copied to the prefix part of the <A title=expanded-QName 
href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded-QName</A> 
representing the name of the new element node. In the event of a conflict 
<SPAN>a prefix may subsequently be added, changed, or removed</SPAN> during the 
namespace fixup process (see <A 
href="REC-xslt20-20070123.htm#namespace-fixup"><I>5.7.3 
Namespace Fixup</I></A>).</P>
<P>The <A 
href="REC-xslt20-20070123.htm#element-element"><CODE>xsl:element</CODE></A> 
instruction has an optional <CODE>inherit-namespaces</CODE> attribute, with the 
value <CODE>yes</CODE> or <CODE>no</CODE>. The default value is 
<CODE>yes</CODE>. If the value is set to <CODE>yes</CODE>, or is omitted, then 
the namespace nodes created for the newly constructed element (whether these 
were copied from those of the source node, or generated as a result of namespace 
fixup) are copied to the children and descendants of the newly constructed 
element, as described in <A 
href="REC-xslt20-20070123.htm#constructing-complex-content"><I>5.7.1 
Constructing Complex Content</I></A>. If the value is set to <CODE>no</CODE>, 
then these namespace nodes are not automatically copied to the children. This 
may result in namespace undeclarations (such as <CODE>xmlns=""</CODE> or, in the 
case of XML Namespaces 1.1, <CODE>xmlns:p=""</CODE>) appearing on the child 
elements when a <A title="final result tree" 
href="REC-xslt20-20070123.htm#dt-final-result-tree">final 
result tree</A> is serialized.</P>
<P>The base URI of the new element is copied from the base URI of the <A 
href="REC-xslt20-20070123.htm#element-element"><CODE>xsl:element</CODE></A> 
instruction in the stylesheet, unless the content of the new element includes an 
<CODE>xml:base</CODE> attribute, in which case the base URI of the new element 
is the value of that attribute, resolved (if it is a relative URI) against the 
base URI of the <A 
href="REC-xslt20-20070123.htm#element-element"><CODE>xsl:element</CODE></A> 
instruction in the stylesheet. (Note, however, that this is only relevant when 
creating parentless elements. When the new element is copied to form a child of 
an element or document node, the base URI of the new copy is taken from that of 
its new parent.)</P>
<DIV class=div3>
<H4><A id=annotation-for-constructed-element 
name=annotation-for-constructed-element></A>11.2.1 Setting the Type Annotation 
for a Constructed Element Node</H4>
<P>The optional attributes <CODE>type</CODE> and <CODE>validation</CODE> may be 
used on the <A 
href="REC-xslt20-20070123.htm#element-element"><CODE>xsl:element</CODE></A> 
instruction to invoke validation of the contents of the element against a type 
definition or element declaration in a schema, and to determine the <A 
title="type annotation" 
href="REC-xslt20-20070123.htm#dt-annotation">type 
annotation</A> that the new element node will carry. These attributes also 
affect the type annotation carried by any elements and attributes that have the 
new element node as an ancestor. These two attributes are both optional, and if 
one is specified then the other <SPAN class=verb>must</SPAN> be omitted. The 
permitted values of these attributes and their semantics are described in <A 
href="REC-xslt20-20070123.htm#validation"><I>19.2 
Validation</I></A>.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>The final type annotation of the element in the <A title="result tree" 
href="REC-xslt20-20070123.htm#dt-result-tree">result 
tree</A> also depends on the <CODE>type</CODE> and <CODE>validation</CODE> 
attributes of the instructions used to create the ancestors of the 
element.</P></DIV></DIV></DIV>
<DIV class=div2>
<H3><A id=creating-attributes name=creating-attributes></A>11.3 Creating 
Attribute Nodes Using <CODE>xsl:attribute</CODE></H3>
<P class=element-syntax><A id=element-attribute 
name=element-attribute></A><CODE>&lt;!-- Category: instruction 
--&gt;<BR>&lt;xsl:attribute<BR>&nbsp;&nbsp;<B>name</B> = { <VAR>qname</VAR> 
}<BR>&nbsp;&nbsp;namespace? = { <VAR>uri-reference</VAR> 
}<BR>&nbsp;&nbsp;select? = <VAR>expression</VAR><BR>&nbsp;&nbsp;separator? = { 
<VAR>string</VAR> }<BR>&nbsp;&nbsp;type? = 
<VAR>qname</VAR><BR>&nbsp;&nbsp;validation? = "strict" | "lax" | "preserve" | 
"strip"&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: <VAR>sequence-constructor</VAR> 
--&gt;<BR>&lt;/xsl:attribute&gt;</CODE></P>
<P>The <A 
href="REC-xslt20-20070123.htm#element-attribute"><CODE>xsl:attribute</CODE></A> 
element can be used to add attributes to result elements whether created by 
literal result elements in the stylesheet or by instructions such as <A 
href="REC-xslt20-20070123.htm#element-element"><CODE>xsl:element</CODE></A> 
or <A 
href="REC-xslt20-20070123.htm#element-copy"><CODE>xsl:copy</CODE></A>. 
The <A title=expanded-QName 
href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded-QName</A> 
of the attribute to be created is specified by a <SPAN 
class=verb>required</SPAN> <CODE>name</CODE> attribute and an optional 
<CODE>namespace</CODE> attribute. <SPAN>Except in error cases,</SPAN> the result 
of evaluating an <A 
href="REC-xslt20-20070123.htm#element-attribute"><CODE>xsl:attribute</CODE></A> 
instruction is the newly constructed attribute node.</P>
<P>The string value of the new attribute node may be defined either by using the 
<CODE>select</CODE> attribute, or by the <A title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A> that forms the content of the <A 
href="REC-xslt20-20070123.htm#element-attribute"><CODE>xsl:attribute</CODE></A> 
element. These are mutually exclusive. If neither is present, the value of the 
new attribute node will be a zero-length string. The way in which the value is 
constructed is specified in <A 
href="REC-xslt20-20070123.htm#constructing-simple-content"><I>5.7.2 
Constructing Simple Content</I></A>.</P>
<P><A id=err-XTSE0840 name=err-XTSE0840><SPAN class=error>[ERR 
XTSE0840]</SPAN></A> It is a <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A> if the <CODE>select</CODE> attribute of the <A 
href="REC-xslt20-20070123.htm#element-attribute"><CODE>xsl:attribute</CODE></A> 
element is present unless the element has empty content.</P>
<P>If the <CODE>separator</CODE> attribute is present, then the <A 
title="effective value" 
href="REC-xslt20-20070123.htm#dt-effective-value">effective 
value</A> of this attribute is used to separate adjacent items in the result 
sequence, as described in <A 
href="REC-xslt20-20070123.htm#constructing-simple-content"><I>5.7.2 
Constructing Simple Content</I></A>. In the absence of this attribute, the 
default separator is a single space (#x20) when the content is specified using 
the <CODE>select</CODE> attribute, or a zero-length string when the content is 
specified using a <A title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A>.</P>
<P>The <CODE>name</CODE> attribute is interpreted as an <A 
title="attribute value template" 
href="REC-xslt20-20070123.htm#dt-attribute-value-template">attribute 
value template</A><SPAN>, whose <A title="effective value" 
href="REC-xslt20-20070123.htm#dt-effective-value">effective 
value</A> <SPAN class=verb>must</SPAN> be a <A title="lexical QName" 
href="REC-xslt20-20070123.htm#dt-lexical-qname">lexical 
QName</A>.</SPAN></P>
<P><A id=err-XTDE0850 name=err-XTDE0850><SPAN class=error>[ERR 
XTDE0850]</SPAN></A> It is a <A title="non-recoverable dynamic error" 
href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
dynamic error</A> if the <A title="effective value" 
href="REC-xslt20-20070123.htm#dt-effective-value">effective 
value</A> of the <CODE>name</CODE> attribute is not a <A title="lexical QName" 
href="REC-xslt20-20070123.htm#dt-lexical-qname">lexical 
QName</A>.</P>
<P><A id=err-XTDE0855 name=err-XTDE0855><SPAN class=error>[ERR 
XTDE0855]</SPAN></A> In the case of an <A 
href="REC-xslt20-20070123.htm#element-attribute"><CODE>xsl:attribute</CODE></A> 
instruction with no <CODE>namespace</CODE> attribute, it is a <A 
title="non-recoverable dynamic error" 
href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
dynamic error</A> if the <A title="effective value" 
href="REC-xslt20-20070123.htm#dt-effective-value">effective 
value</A> of the <CODE>name</CODE> attribute is the string 
<CODE>xmlns</CODE>.</P>
<P><A id=err-XTDE0860 name=err-XTDE0860><SPAN class=error>[ERR 
XTDE0860]</SPAN></A> In the case of an <A 
href="REC-xslt20-20070123.htm#element-attribute"><CODE>xsl:attribute</CODE></A> 
instruction with no <CODE>namespace</CODE> attribute, it is a <A 
title="non-recoverable dynamic error" 
href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
dynamic error</A> if the <A title="effective value" 
href="REC-xslt20-20070123.htm#dt-effective-value">effective 
value</A> of the <CODE>name</CODE> attribute is a <A title="lexical QName" 
href="REC-xslt20-20070123.htm#dt-lexical-qname">lexical 
QName</A> whose prefix is not declared in an in-scope namespace declaration for 
the <A 
href="REC-xslt20-20070123.htm#element-attribute"><CODE>xsl:attribute</CODE></A> 
instruction.</P>
<P>If the <CODE>namespace</CODE> attribute is not present, then the <A 
title="lexical QName" 
href="REC-xslt20-20070123.htm#dt-lexical-qname">lexical 
QName</A> is expanded into an <A title=expanded-QName 
href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded-QName</A> 
using the namespace declarations in effect for the <A 
href="REC-xslt20-20070123.htm#element-attribute"><CODE>xsl:attribute</CODE></A> 
element, <EM>not</EM> including any default namespace declaration.</P>
<P>If the <CODE>namespace</CODE> attribute is present, then it too is 
interpreted as an <A title="attribute value template" 
href="REC-xslt20-20070123.htm#dt-attribute-value-template">attribute 
value template</A>. The <A title="effective value" 
href="REC-xslt20-20070123.htm#dt-effective-value">effective 
value</A> <SPAN><SPAN class=verb>must</SPAN> be in the lexical space of the 
<CODE>xs:anyURI</CODE> type.</SPAN> If the string is zero-length, then the <A 
title=expanded-QName 
href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded-QName</A> 
of the attribute has a null namespace URI. Otherwise, the string is used as the 
namespace URI of the <A title=expanded-QName 
href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded-QName</A> 
of the attribute to be created. The local part of the <A title="lexical QName" 
href="REC-xslt20-20070123.htm#dt-lexical-qname">lexical 
QName</A> specified by the <CODE>name</CODE> attribute is used as the local part 
of the <A title=expanded-QName 
href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded-QName</A> 
of the attribute to be created.</P>
<P><A id=err-XTDE0865 name=err-XTDE0865><SPAN class=error>[ERR 
XTDE0865]</SPAN></A> It is a <A title="non-recoverable dynamic error" 
href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
dynamic error</A> if the <A title="effective value" 
href="REC-xslt20-20070123.htm#dt-effective-value">effective 
value</A> of the <CODE>namespace</CODE> attribute is not in the lexical space of 
the <CODE>xs:anyURI</CODE> data type.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>The same considerations apply as for elements: <SPAN class=error>[see <A 
href="REC-xslt20-20070123.htm#err-XTDE0835">ERR 
XTDE0835</A>]</SPAN> in <A 
href="REC-xslt20-20070123.htm#xsl-element"><I>11.2 
Creating Element Nodes Using xsl:element</I></A> .</P></DIV>
<P>The prefix of the <A title="lexical QName" 
href="REC-xslt20-20070123.htm#dt-lexical-qname">lexical 
QName</A> specified in the <CODE>name</CODE> attribute (or the absence of a 
prefix) is copied to the prefix part of the <A title=expanded-QName 
href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded-QName</A> 
representing the name of the new attribute node. In the event of a conflict this 
prefix (or absence of a prefix) may subsequently be changed during the namespace 
fixup process (see <A 
href="REC-xslt20-20070123.htm#namespace-fixup"><I>5.7.3 
Namespace Fixup</I></A>). If the attribute is in a non-null namespace and no 
prefix is specified, then the namespace fixup process will invent a prefix.</P>
<P>If the name of a constructed attribute is <CODE>xml:id</CODE>, <SPAN>the 
processor must perform attribute value normalization by effectively applying the 
<A 
href="http://www.w3.org/TR/xpath-functions/#func-normalize-space"><CODE>normalize-space</CODE></A><SUP><SMALL>FO</SMALL></SUP> 
function to the value of the attribute,</SPAN> and the resulting attribute node 
must be given the <CODE>is-id</CODE> property. This applies whether the 
attribute is constructed using the <A 
href="REC-xslt20-20070123.htm#element-attribute"><CODE>xsl:attribute</CODE></A> 
instruction or whether it is constructed using an attribute of a literal result 
element. This does not imply any constraints on the value of the attribute, or 
on its uniqueness, and it does not affect the <A title="type annotation" 
href="REC-xslt20-20070123.htm#dt-annotation">type 
annotation</A> of the attribute, unless the containing document is 
validated.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>The effect of setting the <CODE>is-id</CODE> property is that the parent 
element can be located within the containing document by use of the <A 
href="http://www.w3.org/TR/xpath-functions/#func-id"><CODE>id</CODE></A><SUP> 
<SMALL>FO</SMALL></SUP> function. In effect, XSLT when constructing a document 
performs some of the functions of an <CODE>xml:id</CODE> processor, as defined 
in <A href="REC-xslt20-20070123.htm#xml-id">[xml:id]</A>; 
the other aspects of <CODE>xml:id</CODE> processing are performed during 
validation.</P></DIV>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e16466 name=d5e16466></A>Example: Creating a 
List-Valued Attribute </DIV>
<P>The following instruction creates the attribute <CODE>colors="red green 
blue"</CODE>:</P>
<DIV class=exampleInner><PRE>&lt;xsl:attribute name="colors" select="'red', 'green', 'blue'"/&gt;
</PRE></DIV></DIV>
<P>&nbsp;</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e16476 name=d5e16476></A>Example: Namespaces 
are not Attributes </DIV>
<P>It is not an error to write:</P>
<DIV class=exampleInner><PRE>&lt;xsl:attribute name="xmlns:xsl" 
   namespace="file://some.namespace"&gt;http://www.w3.org/1999/XSL/Transform&lt;/xsl:attribute&gt;
</PRE></DIV>
<P>However, this will not result in the namespace declaration 
<CODE>xmlns:xsl="http://www.w3.org/1999/XSL/Transform"</CODE> being output. 
Instead, it will produce an attribute node with local name <CODE>xsl</CODE>, and 
with a system-allocated namespace prefix mapped to the namespace URI 
<CODE>file://some.namespace</CODE>. This is because the namespace fixup process 
is not allowed to use <CODE>xmlns</CODE> as the name of a namespace 
node.</P></DIV>
<P>As described in <A 
href="REC-xslt20-20070123.htm#constructing-complex-content"><I>5.7.1 
Constructing Complex Content</I></A>, <SPAN>in a sequence that is used to 
construct the content of an element,</SPAN> any attribute nodes <SPAN 
class=verb>must</SPAN> appear in the sequence before any element, text, comment, 
or processing instruction nodes. Where the sequence contains two or more 
attribute nodes with the same <A title=expanded-QName 
href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded-QName</A>, 
the one that comes last is the only one that takes effect.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>If a collection of attributes is generated repeatedly, this can be done 
conveniently by using named attribute sets: see <A 
href="REC-xslt20-20070123.htm#attribute-sets"><I>10.2 
Named Attribute Sets</I></A></P></DIV>
<DIV class=div3>
<H4><A id=annotation-for-constructed-attribute 
name=annotation-for-constructed-attribute></A>11.3.1 Setting the Type Annotation 
for a Constructed Attribute Node</H4>
<P>The optional attributes <CODE>type</CODE> and <CODE>validation</CODE> may be 
used on the <A 
href="REC-xslt20-20070123.htm#element-attribute"><CODE>xsl:attribute</CODE></A> 
instruction to invoke validation of the contents of the attribute against a type 
definition or attribute declaration in a schema, and to determine the <A 
title="type annotation" 
href="REC-xslt20-20070123.htm#dt-annotation">type 
annotation</A> that the new attribute node will carry. These two attributes are 
both optional, and if one is specified then the other <SPAN 
class=verb>must</SPAN> be omitted. The permitted values of these attributes and 
their semantics are described in <A 
href="REC-xslt20-20070123.htm#validation"><I>19.2 
Validation</I></A>.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>The final <A title="type annotation" 
href="REC-xslt20-20070123.htm#dt-annotation">type 
annotation</A> of the attribute in the <A title="result tree" 
href="REC-xslt20-20070123.htm#dt-result-tree">result 
tree</A> also depends on the <CODE>type</CODE> and <CODE>validation</CODE> 
attributes of the instructions used to create the ancestors of the 
attribute.</P></DIV></DIV></DIV>
<DIV class=div2>
<H3><A id=creating-text-nodes name=creating-text-nodes></A>11.4 Creating Text 
Nodes</H3>
<P>This section describes three different ways of creating text nodes: by means 
of literal text nodes in the stylesheet, or by using the <A 
href="REC-xslt20-20070123.htm#element-text"><CODE>xsl:text</CODE></A> 
and <A 
href="REC-xslt20-20070123.htm#element-value-of"><CODE>xsl:value-of</CODE></A> 
instructions. It is also possible to create text nodes using the <A 
href="REC-xslt20-20070123.htm#element-number"><CODE>xsl:number</CODE></A> 
instruction described in <A 
href="REC-xslt20-20070123.htm#number"><I>12 
Numbering</I></A>.</P>
<P>If and when the sequence that results from evaluating a <A 
title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A> is used to form the content of a node, as described in <A 
href="REC-xslt20-20070123.htm#constructing-simple-content"><I>5.7.2 
Constructing Simple Content</I></A> and <A 
href="REC-xslt20-20070123.htm#constructing-complex-content"><I>5.7.1 
Constructing Complex Content</I></A>, adjacent text nodes in the sequence are 
merged. Within the sequence itself, however, they exist as distinct nodes.</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e16577 name=d5e16577></A>Example: A sequence of 
text nodes </DIV>
<P>The following function returns a sequence of three text nodes:</P>
<DIV class=exampleInner><PRE>&lt;xsl:function name="f:wrap"&gt;
  &lt;xsl:param name="s"/&gt;
  &lt;xsl:text&gt;(&lt;/xsl:text&gt;
  &lt;xsl:value-of select="$s"/&gt;
  &lt;xsl:text&gt;)&lt;/xsl:text&gt;
&lt;/xsl:function&gt;
</PRE></DIV>
<P>When this function is called as follows:</P>
<DIV class=exampleInner><PRE>&lt;xsl:value-of select="f:wrap('---')"/&gt;
</PRE></DIV>
<P>the result is:</P>
<DIV class=exampleInner><PRE>(---)
</PRE></DIV>
<P>No additional spaces are inserted, because the calling <A 
href="REC-xslt20-20070123.htm#element-value-of"><CODE>xsl:value-of</CODE></A> 
instruction merges adjacent text nodes before atomizing the sequence. However, 
the result of the instruction:</P>
<DIV class=exampleInner><PRE>&lt;xsl:value-of select="data(f:wrap('---'))"/&gt;
</PRE></DIV>
<P>is:</P>
<DIV class=exampleInner><PRE>( --- )
</PRE></DIV>
<P>because in this case the three text nodes are atomized to form three strings, 
and spaces are inserted between adjacent strings.</P></DIV>
<P>It is possible to construct text nodes whose string value is zero-length. A 
zero-length text node, when atomized, produces a zero-length string. However, 
zero-length text nodes are ignored when they appear in a sequence that is used 
to form the content of a node, as described in <A 
href="REC-xslt20-20070123.htm#constructing-complex-content"><I>5.7.1 
Constructing Complex Content</I></A> and <A 
href="REC-xslt20-20070123.htm#constructing-simple-content"><I>5.7.2 
Constructing Simple Content</I></A>.</P>
<DIV class=div3>
<H4><A id=literal-text-nodes name=literal-text-nodes></A>11.4.1 Literal Text 
Nodes</H4>
<P>A <A title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A> can contain text nodes. Each text node in a sequence constructor 
remaining after <A title="whitespace text node" 
href="REC-xslt20-20070123.htm#dt-whitespace-text-node">whitespace 
text nodes</A> have been stripped as specified in <A 
href="REC-xslt20-20070123.htm#stylesheet-stripping"><I>4.2 
Stripping Whitespace from the Stylesheet</I></A> will construct a new text node 
with the same <A title="string value" 
href="REC-xslt20-20070123.htm#dt-string-value">string 
value</A>. The resulting text node is added to the result of the containing 
sequence constructor.</P>
<P>Text is processed at the tree level. Thus, markup of <CODE>&amp;lt;</CODE> in 
a template will be represented in the stylesheet tree by a text node that 
includes the character <CODE>&lt;</CODE>. This will create a text node in the <A 
title="result tree" 
href="REC-xslt20-20070123.htm#dt-result-tree">result 
tree</A> that contains a <CODE>&lt;</CODE> character, which will be represented 
by the markup <CODE>&amp;lt;</CODE> (or an equivalent character reference) when 
the result tree is serialized as an XML document, unless otherwise specified 
using <A title="character map" 
href="REC-xslt20-20070123.htm#dt-character-map">character 
maps</A> (see <A 
href="REC-xslt20-20070123.htm#character-maps"><I>20.1 
Character Maps</I></A>) or <CODE>disable-output-escaping</CODE> (see <A 
href="REC-xslt20-20070123.htm#disable-output-escaping"><I>20.2 
Disabling Output Escaping</I></A>).</P></DIV>
<DIV class=div3>
<H4><A id=xsl-text name=xsl-text></A>11.4.2 Creating Text Nodes Using 
<CODE>xsl:text</CODE></H4>
<P class=element-syntax><A id=element-text name=element-text></A><CODE>&lt;!-- 
Category: instruction --&gt;<BR>&lt;xsl:text<BR>&nbsp;&nbsp;<SPAN 
class=grayed>[disable-output-escaping]?</SPAN> = "yes" | 
"no"&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: #PCDATA 
--&gt;<BR>&lt;/xsl:text&gt;</CODE></P>
<P>The <A 
href="REC-xslt20-20070123.htm#element-text"><CODE>xsl:text</CODE></A> 
element is evaluated to contruct a new text node. The content of the <A 
href="REC-xslt20-20070123.htm#element-text"><CODE>xsl:text</CODE></A> 
element is a single text node whose value forms the <A title="string value" 
href="REC-xslt20-20070123.htm#dt-string-value">string 
value</A> of the <SPAN>new</SPAN> text node. An <A 
href="REC-xslt20-20070123.htm#element-text"><CODE>xsl:text</CODE></A> 
element may be empty, in which case the result of evaluating the instruction is 
<SPAN>a text node whose string value is the zero-length string</SPAN>.</P>
<P>The result of evaluating an <A 
href="REC-xslt20-20070123.htm#element-text"><CODE>xsl:text</CODE></A> 
instruction is the newly constructed text node.</P>
<P>A text node that is an immediate child of an <A 
href="REC-xslt20-20070123.htm#element-text"><CODE>xsl:text</CODE></A> 
instruction will not be stripped from the stylesheet tree, even if it consists 
entirely of whitespace (see <A 
href="REC-xslt20-20070123.htm#strip"><I>4.4 Stripping 
Whitespace from a Source Tree</I></A>).</P>
<P>For the effect of the <A title=deprecated 
href="REC-xslt20-20070123.htm#dt-deprecated">deprecated</A> 
<CODE>disable-output-escaping</CODE> attribute, see <A 
href="REC-xslt20-20070123.htm#disable-output-escaping"><I>20.2 
Disabling Output Escaping</I></A></P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>It is not always necessary to use the <A 
href="REC-xslt20-20070123.htm#element-text"><CODE>xsl:text</CODE></A> 
instruction to write text nodes to the <A title="result tree" 
href="REC-xslt20-20070123.htm#dt-result-tree">result 
tree</A>. Literal text can be written to the result tree by including it 
anywhere in a <A title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A>, while computed text can be output using the <A 
href="REC-xslt20-20070123.htm#element-value-of"><CODE>xsl:value-of</CODE></A> 
instruction. The principal reason for using <A 
href="REC-xslt20-20070123.htm#element-text"><CODE>xsl:text</CODE></A> 
is that it offers improved control over whitespace handling.</P></DIV></DIV>
<DIV class=div3>
<H4><A id=value-of name=value-of></A>11.4.3 Generating Text with <A 
href="REC-xslt20-20070123.htm#element-value-of"><CODE>xsl:value-of</CODE></A></H4>
<P>Within a <A title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A>, the <A 
href="REC-xslt20-20070123.htm#element-value-of"><CODE>xsl:value-of</CODE></A> 
instruction can be used to generate computed text nodes. The <A 
href="REC-xslt20-20070123.htm#element-value-of"><CODE>xsl:value-of</CODE></A> 
instruction computes the text using an <A title=expression 
href="REC-xslt20-20070123.htm#dt-expression">expression</A> 
that is specified as the value of the <CODE>select</CODE> attribute, or by means 
of contained instructions. This might, for example, extract text from a <A 
title="source tree" 
href="REC-xslt20-20070123.htm#dt-source-tree">source 
tree</A> or insert the value of a variable.</P>
<P class=element-syntax><A id=element-value-of 
name=element-value-of></A><CODE>&lt;!-- Category: instruction 
--&gt;<BR>&lt;xsl:value-of<BR>&nbsp;&nbsp;select? = 
<VAR>expression</VAR><BR>&nbsp;&nbsp;separator? = { <VAR>string</VAR> 
}<BR>&nbsp;&nbsp;<SPAN class=grayed>[disable-output-escaping]?</SPAN> = "yes" | 
"no"&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: <VAR>sequence-constructor</VAR> 
--&gt;<BR>&lt;/xsl:value-of&gt;</CODE></P>
<P>The <A 
href="REC-xslt20-20070123.htm#element-value-of"><CODE>xsl:value-of</CODE></A> 
instruction is evaluated to construct a new text node; the result of the 
instruction is the newly constructed text node.</P>
<P>The string value of the new text node may be defined either by using the 
<CODE>select</CODE> attribute, or by the <A title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A> (see <A 
href="REC-xslt20-20070123.htm#sequence-constructors"><I>5.7 
Sequence Constructors</I></A>) that forms the content of the <A 
href="REC-xslt20-20070123.htm#element-value-of"><CODE>xsl:value-of</CODE></A> 
element. These are mutually exclusive, and one of them must be present. The way 
in which the value is constructed is specified in <A 
href="REC-xslt20-20070123.htm#constructing-simple-content"><I>5.7.2 
Constructing Simple Content</I></A>.</P>
<P><A id=err-XTSE0870 name=err-XTSE0870><SPAN class=error>[ERR 
XTSE0870]</SPAN></A> It is a <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A> if the <CODE>select</CODE> attribute of the <A 
href="REC-xslt20-20070123.htm#element-value-of"><CODE>xsl:value-of</CODE></A> 
element is present when the content of the element is non-empty, or if the 
<CODE>select</CODE> attribute is absent when the content is empty.</P>
<P>If the <CODE>separator</CODE> attribute is present, then the <A 
title="effective value" 
href="REC-xslt20-20070123.htm#dt-effective-value">effective 
value</A> of this attribute is used to separate adjacent items in the result 
sequence, as described in <A 
href="REC-xslt20-20070123.htm#constructing-simple-content"><I>5.7.2 
Constructing Simple Content</I></A>. In the absence of this attribute, the 
default separator is a single space (#x20) when the content is specified using 
the <CODE>select</CODE> attribute, or a zero-length string when the content is 
specified using a <A title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A>.</P>
<P>Special rules apply when <A title="backwards compatible behavior" 
href="REC-xslt20-20070123.htm#dt-backwards-compatible-behavior">backwards 
compatible behavior</A> is enabled for the instruction. If no 
<CODE>separator</CODE> attribute is present, and if the <CODE>select</CODE> 
attribute is present, then all items in the <A title=atomize 
href="REC-xslt20-20070123.htm#dt-atomization">atomized</A> 
result sequence other than the first are ignored.</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e16837 name=d5e16837></A>Example: Generating a 
List with Separators </DIV>
<P>The instruction:</P>
<DIV class=exampleInner><PRE>&lt;x&gt;&lt;xsl:value-of select="1 to 4" separator="|"/&gt;&lt;/x&gt;
</PRE></DIV>
<P>produces the output:</P>
<DIV class=exampleInner><PRE>&lt;x&gt;1|2|3|4&lt;/x&gt;
</PRE></DIV></DIV>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>The <A 
href="REC-xslt20-20070123.htm#element-copy-of"><CODE>xsl:copy-of</CODE></A> 
element can be used to copy a sequence of nodes to the <A title="result tree" 
href="REC-xslt20-20070123.htm#dt-result-tree">result 
tree</A> without <A title=atomize 
href="REC-xslt20-20070123.htm#dt-atomization">atomization</A>. 
See <A href="REC-xslt20-20070123.htm#copy-of"><I>11.9.2 
Deep Copy</I></A>.</P></DIV>
<P>For the effect of the <A title=deprecated 
href="REC-xslt20-20070123.htm#dt-deprecated">deprecated</A> 
<CODE>disable-output-escaping</CODE> attribute, see <A 
href="REC-xslt20-20070123.htm#disable-output-escaping"><I>20.2 
Disabling Output Escaping</I></A></P></DIV></DIV>
<DIV class=div2>
<H3><A id=creating-document-nodes name=creating-document-nodes></A>11.5 Creating 
Document Nodes</H3>
<P class=element-syntax><A id=element-document 
name=element-document></A><CODE>&lt;!-- Category: instruction 
--&gt;<BR>&lt;xsl:document<BR>&nbsp;&nbsp;validation? = "strict" | "lax" | 
"preserve" | "strip"<BR>&nbsp;&nbsp;type? = 
<VAR>qname</VAR>&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: 
<VAR>sequence-constructor</VAR> --&gt;<BR>&lt;/xsl:document&gt;</CODE></P>
<P>The <A 
href="REC-xslt20-20070123.htm#element-document"><CODE>xsl:document</CODE></A> 
instruction is used to create a new document node. The content of the <A 
href="REC-xslt20-20070123.htm#element-document"><CODE>xsl:document</CODE></A> 
element is a <A title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A> for the children of the new document node. A document node is 
created, and the sequence obtained by evaluating the sequence constructor is 
used to construct the content of the document, as described in <A 
href="REC-xslt20-20070123.htm#constructing-complex-content"><I>5.7.1 
Constructing Complex Content</I></A>. The <A title="temporary tree" 
href="REC-xslt20-20070123.htm#dt-temporary-tree">temporary 
tree</A> rooted at this document node forms the <A title="result tree" 
href="REC-xslt20-20070123.htm#dt-result-tree">result 
tree</A>.</P>
<P>Except in error situations, the result of evaluating the <A 
href="REC-xslt20-20070123.htm#element-document"><CODE>xsl:document</CODE></A> 
instruction is a single node, the newly constructed document node.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>The new document is not serialized. To construct a document that is to form a 
final result rather than an intermediate result, use the <A 
href="REC-xslt20-20070123.htm#element-result-document"><CODE>xsl:result-document</CODE></A> 
instruction described in <A 
href="REC-xslt20-20070123.htm#creating-result-trees"><I>19.1 
Creating Final Result Trees</I></A>.</P></DIV>
<P>The optional attributes <CODE>type</CODE> and <CODE>validation</CODE> may be 
used on the <A 
href="REC-xslt20-20070123.htm#element-document"><CODE>xsl:document</CODE></A> 
instruction to validate the contents of the new document, and to determine the 
<A title="type annotation" 
href="REC-xslt20-20070123.htm#dt-annotation">type 
annotation</A> that elements and attributes within the <A title="result tree" 
href="REC-xslt20-20070123.htm#dt-result-tree">result 
tree</A> will carry. The permitted values and their semantics are described in 
<A 
href="REC-xslt20-20070123.htm#validating-document-nodes"><I>19.2.2 
Validating Document Nodes</I></A>.</P>
<P>The base URI of the new document node is taken from the base URI of the <A 
href="REC-xslt20-20070123.htm#element-document"><CODE>xsl:document</CODE></A> 
instruction.</P>
<P>The <CODE>document-uri</CODE> and <CODE>unparsed-entities</CODE> properties 
of the new document node are set to empty.</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e16953 name=d5e16953></A>Example: Checking 
Uniqueness Constraints in a Temporary Tree </DIV>
<P>The following example creates a temporary tree held in a variable. The use of 
an enclosed <A 
href="REC-xslt20-20070123.htm#element-document"><CODE>xsl:document</CODE></A> 
instruction ensures that uniqueness constraints defined in the schema for the 
relevant elements are checked.</P>
<DIV class=exampleInner><PRE>&lt;xsl:variable name="tree" as="document-node()"&gt;
  &lt;xsl:document validation="strict"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:document&gt;
&lt;/xsl:variable&gt;
</PRE></DIV></DIV></DIV>
<DIV class=div2>
<H3><A id=creating-processing-instructions 
name=creating-processing-instructions></A>11.6 Creating Processing 
Instructions</H3>
<P class=element-syntax><A id=element-processing-instruction 
name=element-processing-instruction></A><CODE>&lt;!-- Category: instruction 
--&gt;<BR>&lt;xsl:processing-instruction<BR>&nbsp;&nbsp;<B>name</B> = { 
<VAR>ncname</VAR> }<BR>&nbsp;&nbsp;select? = 
<VAR>expression</VAR>&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: 
<VAR>sequence-constructor</VAR> 
--&gt;<BR>&lt;/xsl:processing-instruction&gt;</CODE></P>
<P>The <A 
href="REC-xslt20-20070123.htm#element-processing-instruction"><CODE>xsl:processing-instruction</CODE></A> 
element is evaluated to create a processing instruction node.</P>
<P>The <A 
href="REC-xslt20-20070123.htm#element-processing-instruction"><CODE>xsl:processing-instruction</CODE></A> 
element has a <SPAN class=verb>required</SPAN> <CODE>name</CODE> attribute that 
specifies the name of the processing instruction node. The value of the 
<CODE>name</CODE> attribute is interpreted as an <A 
title="attribute value template" 
href="REC-xslt20-20070123.htm#dt-attribute-value-template">attribute 
value template</A>.</P>
<P>The string value of the new processing-instruction node may be defined either 
by using the <CODE>select</CODE> attribute, or by the <A 
title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A> that forms the content of the <A 
href="REC-xslt20-20070123.htm#element-processing-instruction"><CODE>xsl:processing-instruction</CODE></A> 
element. These are mutually exclusive. If neither is present, the string value 
of the new processing-instruction node will be a zero-length string. The way in 
which the value is constructed is specified in <A 
href="REC-xslt20-20070123.htm#constructing-simple-content"><I>5.7.2 
Constructing Simple Content</I></A>.</P>
<P><A id=err-XTSE0880 name=err-XTSE0880><SPAN class=error>[ERR 
XTSE0880]</SPAN></A> It is a <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A> if the <CODE>select</CODE> attribute of the <A 
href="REC-xslt20-20070123.htm#element-processing-instruction"><CODE>xsl:processing-instruction</CODE></A> 
element is present unless the element has empty content.</P>
<P>Except in error situations, the result of evaluating the <A 
href="REC-xslt20-20070123.htm#element-processing-instruction"><CODE>xsl:processing-instruction</CODE></A> 
instruction is a single node, the newly constructed processing instruction 
<SPAN>node</SPAN>.</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e17032 name=d5e17032></A>Example: Creating a 
Processing Instruction </DIV>
<P>This instruction:</P>
<DIV class=exampleInner><PRE>&lt;xsl:processing-instruction name="xml-stylesheet"
  select="('href=&amp;quot;book.css&amp;quot;', 'type=&amp;quot;text/css&amp;quot;)"/&gt;
</PRE></DIV>
<P>creates the processing instruction</P>
<DIV class=exampleInner><PRE>&lt;?xml-stylesheet href="book.css" type="text/css"?&gt;
</PRE></DIV>
<P>Note that the <CODE>xml-stylesheet</CODE> processing instruction contains 
<EM>pseudo-attributes</EM> in the form <CODE>name="value"</CODE>. Although these 
have the same textual form as attributes in an element start tag, they are not 
represented as <SPAN>XDM</SPAN> attribute nodes, and cannot therefore be 
constructed using <A 
href="REC-xslt20-20070123.htm#element-attribute"><CODE>xsl:attribute</CODE></A> 
instructions.</P></DIV>
<P><A id=err-XTDE0890 name=err-XTDE0890><SPAN class=error>[ERR 
XTDE0890]</SPAN></A> It is a <A title="non-recoverable dynamic error" 
href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
dynamic error</A> if the <A title="effective value" 
href="REC-xslt20-20070123.htm#dt-effective-value">effective 
value</A> of the <CODE>name</CODE> attribute is not both an <A 
href="http://www.w3.org/TR/REC-xml-names/#NT-NCName">NCName</A><SUP> 
<SMALL>Names</SMALL></SUP> and a <A 
href="http://www.w3.org/TR/2000/REC-xml-20001006#NT-PITarget">PITarget</A><SUP> 
<SMALL>XML</SMALL></SUP>.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P><SPAN>Because these rules disallow the name <CODE>xml</CODE>,</SPAN> the <A 
href="REC-xslt20-20070123.htm#element-processing-instruction"><CODE>xsl:processing-instruction</CODE></A> 
cannot be used to output an XML declaration. The <A 
href="REC-xslt20-20070123.htm#element-output"><CODE>xsl:output</CODE></A> 
declaration should be used to control this instead (see <A 
href="REC-xslt20-20070123.htm#serialization"><I>20 
Serialization</I></A>).</P></DIV>
<P>If the result of evaluating the content of the <A 
href="REC-xslt20-20070123.htm#element-processing-instruction"><CODE>xsl:processing-instruction</CODE></A> 
contains the string <CODE>?&gt;</CODE>, this string is modified by inserting a 
space between the <CODE>?</CODE> and <CODE>&gt;</CODE> characters.</P>
<P>The base URI of the new processing-instruction is copied from the base URI of 
the <A 
href="REC-xslt20-20070123.htm#element-processing-instruction"><CODE>xsl:processing-instruction</CODE></A> 
element in the stylesheet. (Note, however, that this is only relevant when 
creating a parentless processing instruction. When the new processing 
instruction is copied to form a child of an element or document node, the base 
URI of the new copy is taken from that of its new parent.)</P></DIV>
<DIV class=div2>
<H3><A id=creating-namespace-nodes name=creating-namespace-nodes></A>11.7 
Creating Namespace Nodes</H3>
<P class=element-syntax><A id=element-namespace 
name=element-namespace></A><CODE>&lt;!-- Category: instruction 
--&gt;<BR>&lt;xsl:namespace<BR>&nbsp;&nbsp;<B>name</B> = { <VAR>ncname</VAR> 
}<BR>&nbsp;&nbsp;select? = <VAR>expression</VAR>&gt;<BR>&nbsp;&nbsp;&lt;!-- 
Content: <VAR>sequence-constructor</VAR> 
--&gt;<BR>&lt;/xsl:namespace&gt;</CODE></P>
<P>The <A 
href="REC-xslt20-20070123.htm#element-namespace"><CODE>xsl:namespace</CODE></A> 
element is evaluated to create a namespace node. Except in error situations, the 
result of evaluating the <A 
href="REC-xslt20-20070123.htm#element-namespace"><CODE>xsl:namespace</CODE></A> 
instruction is a single node, the newly constructed namespace node.</P>
<P>The <A 
href="REC-xslt20-20070123.htm#element-namespace"><CODE>xsl:namespace</CODE></A> 
element has a <SPAN class=verb>required</SPAN> <CODE>name</CODE> attribute that 
specifies the name of the namespace node (that is, the namespace prefix). The 
value of the <CODE>name</CODE> attribute is interpreted as an <A 
title="attribute value template" 
href="REC-xslt20-20070123.htm#dt-attribute-value-template">attribute 
value template</A>. If the <SPAN><A title="effective value" 
href="REC-xslt20-20070123.htm#dt-effective-value">effective 
value</A></SPAN> of the <CODE>name</CODE> attribute is a zero-length string, a 
namespace node is added for the default namespace.</P>
<P>The string value of the new namespace node (that is, the namespace URI) may 
be defined either by using the <CODE>select</CODE> attribute, or by the <A 
title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A> that forms the content of the <A 
href="REC-xslt20-20070123.htm#element-namespace"><CODE>xsl:namespace</CODE></A> 
element. These are mutually exclusive. Since the string value of a namespace 
node cannot be a zero-length string, one of them must be present. The way in 
which the value is constructed is specified in <A 
href="REC-xslt20-20070123.htm#constructing-simple-content"><I>5.7.2 
Constructing Simple Content</I></A>.</P>
<P><A id=err-XTDE0905 name=err-XTDE0905><SPAN class=error>[ERR 
XTDE0905]</SPAN></A> It is a <A title="non-recoverable dynamic error" 
href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
dynamic error</A> if the string value of the new namespace node is not valid in 
the lexical space of the data type <CODE>xs:anyURI</CODE>. <SPAN 
class=error>[see <A 
href="REC-xslt20-20070123.htm#err-XTDE0835">ERR 
XTDE0835</A>]</SPAN></P>
<P><A id=err-XTSE0910 name=err-XTSE0910><SPAN class=error>[ERR 
XTSE0910]</SPAN></A> It is a <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A> if the <CODE>select</CODE> attribute of the <A 
href="REC-xslt20-20070123.htm#element-namespace"><CODE>xsl:namespace</CODE></A> 
element is present when the element has content other than one or more <A 
href="REC-xslt20-20070123.htm#element-fallback"><CODE>xsl:fallback</CODE></A> 
instructions, or if the <CODE>select</CODE> attribute is absent when the element 
has empty content.</P>
<P>Note the restrictions described in <A 
href="REC-xslt20-20070123.htm#constructing-complex-content"><I>5.7.1 
Constructing Complex Content</I></A> for the position of a namespace node 
relative to other nodes in the node sequence returned by a sequence 
constructor.</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e17221 name=d5e17221></A>Example: Constructing 
a QName-Valued Attribute </DIV>
<P>This literal result element:</P>
<DIV class=exampleInner><PRE>&lt;data xsi:type="xs:integer" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
  &lt;xsl:namespace name="xs" select="'http://www.w3.org/2001/XMLSchema'"/&gt;
  &lt;xsl:text&gt;42&lt;/xsl:text&gt;
&lt;/data&gt;
</PRE></DIV>
<P>would typically cause the output document to contain the element:</P>
<DIV class=exampleInner><PRE>&lt;data xsi:type="xs:integer"
     xmlns:xs="http://www.w3.org/2001/XMLSchema"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;42&lt;/data&gt;
</PRE></DIV>
<P>In this case, the element is constructed using a literal result element, and 
the namespace <CODE>xmlns:xs="http://www.w3.org/2001/XMLSchema"</CODE> could 
therefore have been added to the <A title="result tree" 
href="REC-xslt20-20070123.htm#dt-result-tree">result 
tree</A> simply by declaring it as one of the in-scope namespaces in the 
stylesheet. In practice, the <A 
href="REC-xslt20-20070123.htm#element-namespace"><CODE>xsl:namespace</CODE></A> 
instruction is more likely to be useful in situations where the element is 
constructed using an <A 
href="REC-xslt20-20070123.htm#element-element"><CODE>xsl:element</CODE></A> 
instruction, which does not copy all the in-scope namespaces from the 
stylesheet.</P></DIV>
<P><A id=err-XTDE0920 name=err-XTDE0920><SPAN class=error>[ERR 
XTDE0920]</SPAN></A> It is a <A title="non-recoverable dynamic error" 
href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
dynamic error</A> if the <A title="effective value" 
href="REC-xslt20-20070123.htm#dt-effective-value">effective 
value</A> of the <CODE>name</CODE> attribute is neither a zero-length string nor 
an <A href="http://www.w3.org/TR/REC-xml-names/#NT-NCName">NCName</A><SUP> 
<SMALL>Names</SMALL></SUP>, or if it is <CODE>xmlns</CODE>.</P>
<P><A id=err-XTDE0925 name=err-XTDE0925><SPAN class=error>[ERR 
XTDE0925]</SPAN></A> It is a <A title="non-recoverable dynamic error" 
href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
dynamic error</A> if the <A 
href="REC-xslt20-20070123.htm#element-namespace"><CODE>xsl:namespace</CODE></A> 
instruction generates a namespace node whose name is <CODE>xml</CODE> and whose 
string value is not <CODE>http://www.w3.org/XML/1998/namespace</CODE>, or a 
namespace node whose string value is 
<CODE>http://www.w3.org/XML/1998/namespace</CODE> and whose name is not 
<CODE>xml</CODE>.</P>
<P><A id=err-XTDE0930 name=err-XTDE0930><SPAN class=error>[ERR 
XTDE0930]</SPAN></A> It is a <A title="non-recoverable dynamic error" 
href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
dynamic error</A> if evaluating the <SPAN><CODE>select</CODE> attribute or the 
contained <A title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A> of an <A 
href="REC-xslt20-20070123.htm#element-namespace"><CODE>xsl:namespace</CODE></A> 
instruction</SPAN> results in a zero-length string.</P>
<P>For details of other error conditions that may arise, see <A 
href="REC-xslt20-20070123.htm#sequence-constructors"><I>5.7 
Sequence Constructors</I></A>.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>It is rarely necessary to use <A 
href="REC-xslt20-20070123.htm#element-namespace"><CODE>xsl:namespace</CODE></A> 
to create a namespace node in the <A title="result tree" 
href="REC-xslt20-20070123.htm#dt-result-tree">result 
tree</A>; in most circumstances, the required namespace nodes will be created 
automatically, as a side-effect of writing elements or attributes that use the 
namespace. An example where <A 
href="REC-xslt20-20070123.htm#element-namespace"><CODE>xsl:namespace</CODE></A> 
is needed is a situation where the required namespace is used only within 
attribute values in the result document, not in element or attribute names; 
especially where the required namespace prefix or namespace URI is computed at 
run-time and is not present in either the source document or the stylesheet.</P>
<P>Adding a namespace node to the <A title="result tree" 
href="REC-xslt20-20070123.htm#dt-result-tree">result 
tree</A> will never change the <A title=expanded-QName 
href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded-QName</A> 
of any element or attribute node in the result tree: that is, it will never 
change the namespace URI of an element or attribute. It <SPAN>might</SPAN>, 
however, constrain the choice of prefixes when namespace fixup is performed.</P>
<P>Namespace prefixes for element and attribute names are effectively 
established by the namespace fixup process described in <A 
href="REC-xslt20-20070123.htm#namespace-fixup"><I>5.7.3 
Namespace Fixup</I></A>. The fixup process ensures that an element has in-scope 
namespace nodes for the namespace URIs used in the element name and in its 
attribute names, and the serializer will typically use these namespace nodes to 
determine the prefix to use in the serialized output. The fixup process cannot 
generate namespace nodes that are inconsistent with those already present in the 
tree. This means that it is not possible for the processor to decide the prefix 
to use for an element or for any of its attributes until all the namespace nodes 
for the element have been added.</P>
<P>If a namespace prefix is mapped to a particular namespace URI using the <A 
href="REC-xslt20-20070123.htm#element-namespace"><CODE>xsl:namespace</CODE></A> 
instruction, or by using <A 
href="REC-xslt20-20070123.htm#element-copy"><CODE>xsl:copy</CODE></A> 
or <A 
href="REC-xslt20-20070123.htm#element-copy-of"><CODE>xsl:copy-of</CODE></A> 
to copy a namespace node, this prevents the namespace fixup process (and hence 
the serializer) from using the same prefix for a different namespace URI on the 
same element.</P></DIV>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e17356 name=d5e17356></A>Example: Conflicting 
Namespace Prefixes </DIV>
<P>Given the instruction:</P>
<DIV class=exampleInner><PRE>&lt;xsl:element name="p:item" xmlns:p="http://www.example.com/p"&gt;
  &lt;xsl:namespace name="p"&gt;http://www.example.com/q&lt;/xsl:namespace&gt;
&lt;/xsl:element&gt;
</PRE></DIV>
<P>a possible serialization of the <A title="result tree" 
href="REC-xslt20-20070123.htm#dt-result-tree">result 
tree</A> is:</P>
<DIV class=exampleInner><PRE>&lt;ns0:item xmlns:ns0="http://www.example.com/p" xmlns:p="http://www.example.com/q"/&gt;
</PRE></DIV>
<P>The processor must invent a namespace prefix for the URI <CODE>p.uri</CODE>; 
it cannot use the prefix <CODE>p</CODE> because that prefix has been explicitly 
associated with a different URI.</P></DIV>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>The <A 
href="REC-xslt20-20070123.htm#element-namespace"><CODE>xsl:namespace</CODE></A> 
instruction cannot be used to generate a <B>namespace undeclaration</B> of the 
form <CODE>xmlns=""</CODE> (nor the new forms of namespace undeclaration 
permitted in <A 
href="REC-xslt20-20070123.htm#xml-names11">[Namespaces in 
XML 1.1]</A>). Namespace undeclarations are generated automatically by the 
serializer if <SPAN><CODE>undeclare-prefixes="yes"</CODE></SPAN> is specified on 
<A 
href="REC-xslt20-20070123.htm#element-output"><CODE>xsl:output</CODE></A>, 
whenever a parent element has a namespace node for the default namespace prefix, 
and a child element has no namespace node for that prefix.</P></DIV></DIV>
<DIV class=div2>
<H3><A id=creating-comments name=creating-comments></A>11.8 Creating 
Comments</H3>
<P class=element-syntax><A id=element-comment 
name=element-comment></A><CODE>&lt;!-- Category: instruction 
--&gt;<BR>&lt;xsl:comment<BR>&nbsp;&nbsp;select? = 
<VAR>expression</VAR>&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: 
<VAR>sequence-constructor</VAR> --&gt;<BR>&lt;/xsl:comment&gt;</CODE></P>
<P>The <A 
href="REC-xslt20-20070123.htm#element-comment"><CODE>xsl:comment</CODE></A> 
element is evaluated to contruct a new comment node. Except in error cases, the 
result of evaluating the <A 
href="REC-xslt20-20070123.htm#element-comment"><CODE>xsl:comment</CODE></A> 
instruction is a single node, the newly constructed comment node.</P>
<P>The string value of the new comment node may be defined either by using the 
<CODE>select</CODE> attribute, or by the <A title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A> that forms the content of the <A 
href="REC-xslt20-20070123.htm#element-comment"><CODE>xsl:comment</CODE></A> 
element. These are mutually exclusive. If neither is present, the value of the 
new comment node will be a zero-length string. The way in which the value is 
constructed is specified in <A 
href="REC-xslt20-20070123.htm#constructing-simple-content"><I>5.7.2 
Constructing Simple Content</I></A>.</P>
<P><A id=err-XTSE0940 name=err-XTSE0940><SPAN class=error>[ERR 
XTSE0940]</SPAN></A> It is a <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A> if the <CODE>select</CODE> attribute of the <A 
href="REC-xslt20-20070123.htm#element-comment"><CODE>xsl:comment</CODE></A> 
element is present unless the element has empty content.</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e17444 name=d5e17444></A>Example: Generating a 
Comment Node </DIV>
<P>For example, this</P>
<DIV class=exampleInner><PRE>&lt;xsl:comment&gt;This file is automatically generated. Do not edit!&lt;/xsl:comment&gt;
</PRE></DIV>
<P>would create the comment</P>
<DIV class=exampleInner><PRE>&lt;!--This file is automatically generated. Do not edit!--&gt;
</PRE></DIV></DIV>
<P>In the generated comment node, the processor <SPAN class=verb>must</SPAN> 
insert a space after any occurrence of <CODE>-</CODE> that is followed by 
another <CODE>-</CODE> or that ends the comment.</P></DIV>
<DIV class=div2>
<H3><A id=copying name=copying></A>11.9 Copying Nodes</H3>
<DIV class=div3>
<H4><A id=shallow-copy name=shallow-copy></A>11.9.1 Shallow Copy</H4>
<P class=element-syntax><A id=element-copy name=element-copy></A><CODE>&lt;!-- 
Category: instruction --&gt;<BR>&lt;xsl:copy<BR>&nbsp;&nbsp;copy-namespaces? = 
"yes" | "no"<BR>&nbsp;&nbsp;inherit-namespaces? = "yes" | 
"no"<BR>&nbsp;&nbsp;use-attribute-sets? = <VAR>qnames</VAR><BR>&nbsp;&nbsp;type? 
= <VAR>qname</VAR><BR>&nbsp;&nbsp;validation? = "strict" | "lax" | "preserve" | 
"strip"&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: <VAR>sequence-constructor</VAR> 
--&gt;<BR>&lt;/xsl:copy&gt;</CODE></P>
<P>The <A 
href="REC-xslt20-20070123.htm#element-copy"><CODE>xsl:copy</CODE></A> 
instruction provides a way of copying the context item. If the <A 
title="context item" 
href="REC-xslt20-20070123.htm#dt-context-item">context 
item</A> is a node, evaluating the <A 
href="REC-xslt20-20070123.htm#element-copy"><CODE>xsl:copy</CODE></A> 
instruction constructs a copy of the context node, and the result of the <A 
href="REC-xslt20-20070123.htm#element-copy"><CODE>xsl:copy</CODE></A> 
instruction is this newly constructed node. <SPAN>By default,</SPAN> the 
namespace nodes of the context node are automatically copied as well, but the 
attributes and children of the node are not automatically copied.</P>
<P>When the <A title="context item" 
href="REC-xslt20-20070123.htm#dt-context-item">context 
item</A> is an atomic value, the <A 
href="REC-xslt20-20070123.htm#element-copy"><CODE>xsl:copy</CODE></A> 
instruction returns this value. <SPAN>The <A title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A>, if present, is not evaluated.</SPAN></P>
<P>When the <A title="context item" 
href="REC-xslt20-20070123.htm#dt-context-item">context 
item</A> is an attribute node, text node, comment node, processing instruction 
node, or namespace node, the <A 
href="REC-xslt20-20070123.htm#element-copy"><CODE>xsl:copy</CODE></A> 
instruction returns a new node that is a copy of the context node. The new node 
will have the same node kind, name, and string value as the context node. 
<SPAN>In the case of an attribute node, it will also have the same values for 
the <CODE>is-id</CODE> and <CODE>is-idrefs</CODE> properties.</SPAN> The <A 
title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A>, if present, is not evaluated.</P>
<P><SPAN>When the context item is a document node or element node, the <A 
href="REC-xslt20-20070123.htm#element-copy"><CODE>xsl:copy</CODE></A> 
instruction returns a new node that has the same node kind and name as the 
context node. The content of the new node is formed by evaluating the <A 
title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A> contained in the <A 
href="REC-xslt20-20070123.htm#element-copy"><CODE>xsl:copy</CODE></A> 
instruction.</SPAN> The sequence obtained by evaluating this sequence 
constructor is used (after prepending any attribute nodes or namespace nodes as 
described in the following paragraphs) to construct the content of the document 
or element node, as described in <A 
href="REC-xslt20-20070123.htm#constructing-complex-content"><I>5.7.1 
Constructing Complex Content</I></A>.</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e17557 name=d5e17557></A>Example: Identity 
Transformation </DIV>
<P>The identity transformation can be written using <A 
href="REC-xslt20-20070123.htm#element-copy"><CODE>xsl:copy</CODE></A> 
as follows:</P>
<DIV class=exampleInner><PRE>&lt;xsl:template match="@*|node()"&gt;
  &lt;xsl:copy&gt;
    &lt;xsl:apply-templates select="@*|node()"/&gt;
  &lt;/xsl:copy&gt;
&lt;/xsl:template&gt;
</PRE></DIV>
<P>This template rule can be used to copy any node in a tree by applying 
template rules to its attributes and children. It can be combined with 
additional template rules that modify selected nodes, for example if all nodes 
are to be copied except <CODE>note</CODE> elements and their contents, this can 
be achieved by using the identity template rule together with the template 
rule:</P>
<DIV class=exampleInner><PRE>&lt;xsl:template match="note"/&gt;
</PRE></DIV></DIV>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>The <A 
href="REC-xslt20-20070123.htm#element-copy"><CODE>xsl:copy</CODE></A> 
instruction is most useful when copying element nodes. In other cases, the <A 
href="REC-xslt20-20070123.htm#element-copy-of"><CODE>xsl:copy-of</CODE></A> 
instruction is more flexible, because it has a <CODE>select</CODE> attribute 
allowing selection of the nodes or values to be copied.</P></DIV>
<P>The <A 
href="REC-xslt20-20070123.htm#element-copy"><CODE>xsl:copy</CODE></A> 
instruction has an optional <CODE>use-attribute-sets</CODE> attribute, whose 
value is a <SPAN>whitespace-separated</SPAN> list of QNames that identify <A 
href="REC-xslt20-20070123.htm#element-attribute-set"><CODE>xsl:attribute-set</CODE></A> 
declarations. This attribute is used only when copying element nodes. This list 
is expanded as described in <A 
href="REC-xslt20-20070123.htm#attribute-sets"><I>10.2 
Named Attribute Sets</I></A> to produce a sequence of attribute nodes. This 
sequence is prepended to the sequence produced as a result of evaluating the <A 
title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A>.</P>
<P>The <A 
href="REC-xslt20-20070123.htm#element-copy"><CODE>xsl:copy</CODE></A> 
instruction has an optional <CODE>copy-namespaces</CODE> attribute, with the 
value <CODE>yes</CODE> or <CODE>no</CODE>. The default value is 
<CODE>yes</CODE>. The attribute is used only when copying element nodes. If the 
value is set to <CODE>yes</CODE>, or is omitted, then all the namespace nodes of 
the source element are copied as namespace nodes for the result element. These 
copied namespace nodes are prepended to the sequence produced as a result of 
evaluating the <A title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A> (it is immaterial whether they come before or after any 
attribute nodes produced by expanding the <CODE>use-attribute-sets</CODE> 
attribute). If the value is set to <CODE>no</CODE>, then the namespace nodes are 
not copied. However, namespace nodes will still be added to the result element 
as <SPAN class=verb>required</SPAN> by the namespace fixup process: see <A 
href="REC-xslt20-20070123.htm#namespace-fixup"><I>5.7.3 
Namespace Fixup</I></A>.</P>
<P>The <A 
href="REC-xslt20-20070123.htm#element-copy"><CODE>xsl:copy</CODE></A> 
instruction has an optional <CODE>inherit-namespaces</CODE> attribute, with the 
value <CODE>yes</CODE> or <CODE>no</CODE>. The default value is 
<CODE>yes</CODE>. The attribute is used only when copying element nodes. If the 
value is set to <CODE>yes</CODE>, or is omitted, then the namespace nodes 
created for the newly constructed element (whether these were copied from those 
of the source node, or generated as a result of namespace fixup) are copied to 
the children and descendants of the newly constructed element, as described in 
<A 
href="REC-xslt20-20070123.htm#constructing-complex-content"><I>5.7.1 
Constructing Complex Content</I></A>. If the value is set to <CODE>no</CODE>, 
then these namespace nodes are not automatically copied to the children. This 
may result in namespace undeclarations (such as <CODE>xmlns=""</CODE> or, in the 
case of XML Namespaces 1.1, <CODE>xmlns:p=""</CODE>) appearing on the child 
elements when a <A title="final result tree" 
href="REC-xslt20-20070123.htm#dt-final-result-tree">final 
result tree</A> is serialized.</P>
<P><A id=err-XTTE0950 name=err-XTTE0950><SPAN class=error>[ERR 
XTTE0950]</SPAN></A> It is a <A title="type errors" 
href="REC-xslt20-20070123.htm#dt-type-error">type 
error</A> to use the <A 
href="REC-xslt20-20070123.htm#element-copy"><CODE>xsl:copy</CODE></A> 
or <A 
href="REC-xslt20-20070123.htm#element-copy-of"><CODE>xsl:copy-of</CODE></A> 
instruction to copy a node that has namespace-sensitive content if the 
<CODE>copy-namespaces</CODE> attribute has the value <CODE>no</CODE> and its 
explicit or implicit <CODE>validation</CODE> attribute has the value 
<CODE>preserve</CODE>. It is also a type error if either of these instructions 
(with <CODE>validation="preserve"</CODE>) is used to copy an attribute having 
namespace-sensitive content, unless the parent element is also copied. A node 
has namespace-sensitive content if its typed value contains an item of type 
<CODE>xs:QName</CODE> or <CODE>xs:NOTATION</CODE> or a type derived therefrom. 
The reason this is an error is because the validity of the content depends on 
the namespace context being preserved.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>When attribute nodes are copied, whether with <A 
href="REC-xslt20-20070123.htm#element-copy"><CODE>xsl:copy</CODE></A> 
or with <A 
href="REC-xslt20-20070123.htm#element-copy-of"><CODE>xsl:copy-of</CODE></A>, 
the processor does not automatically copy any associated namespace information. 
The namespace used in the attribute name itself will be declared by virtue of 
the namespace fixup process (see <A 
href="REC-xslt20-20070123.htm#namespace-fixup"><I>5.7.3 
Namespace Fixup</I></A>) when the attribute is added to an element in the <A 
title="result tree" 
href="REC-xslt20-20070123.htm#dt-result-tree">result 
tree</A>, but if namespace <SPAN>prefixes</SPAN> are used in the content of the 
attribute (for example, if the value of the attribute is an XPath expression) 
then it is the responsibility of the stylesheet author to ensure that suitable 
namespace nodes are added to the <A title="result tree" 
href="REC-xslt20-20070123.htm#dt-result-tree">result 
tree</A>. This can be achieved by copying the namespace nodes using <A 
href="REC-xslt20-20070123.htm#element-copy"><CODE>xsl:copy</CODE></A>, 
or by generating them using <A 
href="REC-xslt20-20070123.htm#element-namespace"><CODE>xsl:namespace</CODE></A>.</P></DIV>
<P>The optional attributes <CODE>type</CODE> and <CODE>validation</CODE> may be 
used on the <A 
href="REC-xslt20-20070123.htm#element-copy"><CODE>xsl:copy</CODE></A> 
instruction to validate the contents of an element, attribute or document node 
against a type definition, element declaration, or attribute declaration in a 
schema, and thus to determine the <A title="type annotation" 
href="REC-xslt20-20070123.htm#dt-annotation">type 
annotation</A> that the new copy of an element or attribute node will carry. 
These attributes are ignored when copying an item that is not an element, 
attribute or document node. When the node being copied is an element or document 
node, these attributes also affect the type annotation carried by any elements 
and attributes that have the copied element or document node as an ancestor. 
These two attributes are both optional, and if one is specified then the other 
<SPAN class=verb>must</SPAN> be omitted. The permitted values of these 
attributes and their semantics are described in <A 
href="REC-xslt20-20070123.htm#validation"><I>19.2 
Validation</I></A>.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>The final <A title="type annotation" 
href="REC-xslt20-20070123.htm#dt-annotation">type 
annotation</A> of the node in the <A title="result tree" 
href="REC-xslt20-20070123.htm#dt-result-tree">result 
tree</A> also depends on the <CODE>type</CODE> and <CODE>validation</CODE> 
attributes of the instructions used to create the ancestors of the 
node.</P></DIV>
<P>The base URI of a node is copied<SPAN>, except in the case of an element node 
having an <CODE>xml:base</CODE> attribute, in which case the base URI of the new 
node is taken as the value of the <CODE>xml:base</CODE> attribute, resolved if 
it is relative against the base URI of the <A 
href="REC-xslt20-20070123.htm#element-copy"><CODE>xsl:copy</CODE></A> 
instruction</SPAN>. If the copied node is subsequently attached as a child to a 
new element <SPAN>or document node</SPAN>, the final copy of the node inherits 
its base URI from its parent node, unless this is overridden using an 
<CODE>xml:base</CODE> attribute.</P>
<P>When an <CODE>xml:id</CODE> attribute is copied, using either the <A 
href="REC-xslt20-20070123.htm#element-copy"><CODE>xsl:copy</CODE></A> 
or <A 
href="REC-xslt20-20070123.htm#element-copy-of"><CODE>xsl:copy-of</CODE></A> 
instruction, it is <A title=implementation-defined 
href="REC-xslt20-20070123.htm#dt-implementation-defined">implementation-defined</A> 
whether the value of the attribute is subjected to attribute value normalization 
(that is, effectively applying the <A 
href="http://www.w3.org/TR/xpath-functions/#func-normalize-space"><CODE>normalize-space</CODE></A><SUP><SMALL>FO</SMALL></SUP> 
function).</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>In most cases the value will already have been subjected to attribute value 
normalization on the source tree, but if this processing has not been performed 
on the source tree, it is not an error for it to be performed on the result 
tree.</P></DIV></DIV>
<DIV class=div3>
<H4><A id=copy-of name=copy-of></A>11.9.2 Deep Copy</H4>
<P class=element-syntax><A id=element-copy-of 
name=element-copy-of></A><CODE>&lt;!-- Category: instruction 
--&gt;<BR>&lt;xsl:copy-of<BR>&nbsp;&nbsp;<B>select</B> = 
<VAR>expression</VAR><BR>&nbsp;&nbsp;copy-namespaces? = "yes" | 
"no"<BR>&nbsp;&nbsp;type? = <VAR>qname</VAR><BR>&nbsp;&nbsp;validation? = 
"strict" | "lax" | "preserve" | "strip"&nbsp;/&gt;</CODE></P>
<P>The <A 
href="REC-xslt20-20070123.htm#element-copy-of"><CODE>xsl:copy-of</CODE></A> 
instruction can be used to construct a copy of a sequence of nodes <SPAN>and/or 
atomic values</SPAN>, with each new node containing copies of all the children, 
attributes, and (by default) namespaces of the original node, recursively. The 
result of evaluating the instruction is a sequence of <SPAN>items</SPAN> 
corresponding one-to-one with the supplied sequence, and retaining its 
order.</P>
<P>The <SPAN class=verb>required</SPAN> <CODE>select</CODE> attribute contains 
an <A title=expression 
href="REC-xslt20-20070123.htm#dt-expression">expression</A>, 
<SPAN>whose value may be any sequence of nodes and atomic values</SPAN>. The 
items in this sequence are processed as follows:</P>
<UL>
  <LI>
  <P>If the item is an element node, a new element is constructed and appended 
  to the result sequence. The new element will have the same <A 
  title=expanded-QName 
  href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded-QName</A> 
  as the original, and it will have <SPAN>deep</SPAN> copies of the attribute 
  nodes and children of the element node.</P>
  <P>The new element will also have namespace nodes copied from the original 
  element node, unless they are excluded by <SPAN>specifying 
  <CODE>copy-namespaces="no"</CODE>. If this attribute is omitted, or takes the 
  value <CODE>yes</CODE>, then all the namespace nodes of the original element 
  are copied to the new element. If it takes the value <CODE>no</CODE>, then 
  none of the namespace nodes are copied: however, namespace nodes will still be 
  created in the <A title="result tree" 
  href="REC-xslt20-20070123.htm#dt-result-tree">result 
  tree</A> as <SPAN class=verb>required</SPAN> by the namespace fixup process: 
  see <A 
  href="REC-xslt20-20070123.htm#namespace-fixup"><I>5.7.3 
  Namespace Fixup</I></A>. This attribute affects all elements copied by this 
  instruction: both elements selected directly by the <CODE>select</CODE> <A 
  title=expression 
  href="REC-xslt20-20070123.htm#dt-expression">expression</A>, 
  and elements that are descendants of nodes selected by the <CODE>select</CODE> 
  expression.</SPAN></P>
  <P>The new element will have the same values of the <CODE>is-id</CODE>, 
  <CODE>is-idrefs</CODE>, and <CODE>nilled</CODE> properties as the original 
  element.</P>
  <LI>
  <P>If the item is a document node, the instruction adds a new document node to 
  the result sequence; the children of this document node will be one-to-one 
  copies of the children of the original document node (each copied according to 
  the rules for its own node kind).</P>
  <LI>
  <P>If the item is an attribute or namespace node, or a text node, a comment, 
  or a processing instruction, the same rules apply as with <A 
  href="REC-xslt20-20070123.htm#element-copy"><CODE>xsl:copy</CODE></A> 
  (see <A 
  href="REC-xslt20-20070123.htm#shallow-copy"><I>11.9.1 
  Shallow Copy</I></A>).</P>
  <LI>
  <P>If the item is an atomic value, the value is appended to the result 
  sequence, as with <A 
  href="REC-xslt20-20070123.htm#element-sequence"><CODE>xsl:sequence</CODE></A>.</P></LI></UL>
<P>The optional attributes <CODE>type</CODE> and <CODE>validation</CODE> may be 
used on the <A 
href="REC-xslt20-20070123.htm#element-copy-of"><CODE>xsl:copy-of</CODE></A> 
instruction to validate the contents of an element, attribute or document node 
against a type definition, element declaration, or attribute declaration in a 
schema and thus to determine the <A title="type annotation" 
href="REC-xslt20-20070123.htm#dt-annotation">type 
annotation</A> that the new copy of an element or attribute node will carry. 
These attributes are applied individually to each element, attribute, and 
document node that is selected by the expression in the <CODE>select</CODE> 
attribute. These attributes are ignored when copying an item that is not an 
element, attribute or document node.</P>
<P>The specified <CODE>type</CODE> and <CODE>validation</CODE> apply directly 
only to elements, attributes and document nodes created as copies of nodes 
actually selected by the <CODE>select</CODE> expression, they do not apply to 
nodes that are implicitly copied because they have selected nodes as an 
ancestor. However, these attributes do indirectly affect the <A 
title="type annotation" 
href="REC-xslt20-20070123.htm#dt-annotation">type 
annotation</A> carried by such implicitly copied nodes, as a consequence of the 
validation process.</P>
<P>These two attributes are both optional, and if one is specified then the 
other <SPAN class=verb>must</SPAN> be omitted. The permitted values of these 
attributes and their semantics are described in <A 
href="REC-xslt20-20070123.htm#validation"><I>19.2 
Validation</I></A>.</P>
<P>Errors may occur when copying namespace-sensitive elements or attributes 
using <CODE>validation="preserve"</CODE>. <SPAN class=error>[see <A 
href="REC-xslt20-20070123.htm#err-XTTE0950">ERR 
XTTE0950</A>]</SPAN>.</P>
<P>The base URI of a node is copied<SPAN>, except in the case of an element node 
having an <CODE>xml:base</CODE> attribute, in which case the base URI of the new 
node is taken as the value of the <CODE>xml:base</CODE> attribute, resolved if 
it is relative against the base URI of the <A 
href="REC-xslt20-20070123.htm#element-copy-of"><CODE>xsl:copy-of</CODE></A> 
instruction</SPAN>. If the copied node is subsequently attached as a child to a 
new element <SPAN>or document node</SPAN>, the final copy of the node inherits 
its base URI from its parent node, unless this is overridden using an 
<CODE>xml:base</CODE> attribute.</P></DIV></DIV>
<DIV class=div2>
<H3><A id=constructing-sequences name=constructing-sequences></A>11.10 
Constructing Sequences</H3>
<P class=element-syntax><A id=element-sequence 
name=element-sequence></A><CODE>&lt;!-- Category: instruction 
--&gt;<BR>&lt;xsl:sequence<BR>&nbsp;&nbsp;<B>select</B> = 
<VAR>expression</VAR>&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: <A 
href="REC-xslt20-20070123.htm#element-fallback">xsl:fallback</A>* 
--&gt;<BR>&lt;/xsl:sequence&gt;</CODE></P>
<P>The <A 
href="REC-xslt20-20070123.htm#element-sequence"><CODE>xsl:sequence</CODE></A> 
instruction may be used within a <A title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A> to construct a sequence of nodes and/or atomic values. This 
sequence is returned as the result of the instruction. Unlike most other 
instructions, <A 
href="REC-xslt20-20070123.htm#element-sequence"><CODE>xsl:sequence</CODE></A> 
can return a sequence containing existing nodes, rather than constructing new 
nodes. When <A 
href="REC-xslt20-20070123.htm#element-sequence"><CODE>xsl:sequence</CODE></A> 
is used to add atomic values to a sequence, the effect is very similar to the <A 
href="REC-xslt20-20070123.htm#element-copy-of"><CODE>xsl:copy-of</CODE></A> 
instruction.</P>
<P>The items comprising the result sequence are selected using the 
<CODE>select</CODE> attribute.</P>
<P>Any contained <A 
href="REC-xslt20-20070123.htm#element-fallback"><CODE>xsl:fallback</CODE></A> 
instructions are ignored by an XSLT 2.0 processor, but can be used to define 
fallback behavior for an XSLT 1.0 processor running in forwards compatibility 
mode.</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e18039 name=d5e18039></A>Example: Constructing 
a Sequence of Integers </DIV>
<P>For example, the following code:</P>
<DIV class=exampleInner><PRE>&lt;xsl:variable name="values" as="xs:integer*"&gt;
    &lt;xsl:sequence select="(1,2,3,4)"/&gt;
    &lt;xsl:sequence select="(8,9,10)"/&gt;
&lt;/xsl:variable&gt;
&lt;xsl:value-of select="sum($values)"/&gt;
</PRE></DIV>
<P>produces the output: <CODE>37</CODE></P></DIV>
<P>&nbsp;</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e18050 name=d5e18050></A>Example: Using 
<CODE>xsl:for-each</CODE> to Construct a Sequence </DIV>
<P>The following code constructs a sequence containing the value of the 
<CODE>@price</CODE> attribute for selected elements (which we assume to be typed 
as <CODE>xs:decimal</CODE>), or a computed price for those elements that have no 
<CODE>@price</CODE> attribute. It then returns the average price:</P>
<DIV class=exampleInner><PRE>&lt;xsl:variable name="prices" as="xs:decimal*"&gt;
  &lt;xsl:for-each select="//product"&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="@price"&gt;
        &lt;xsl:sequence select="@price"/&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:sequence select="@cost * 1.5"/&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:variable&gt;
&lt;xsl:value-of select="avg($prices)"/&gt;
</PRE></DIV>
<P>Note that the existing <CODE>@price</CODE> attributes could equally have been 
added to the <CODE>$prices</CODE> sequence using <A 
href="REC-xslt20-20070123.htm#element-copy-of"><CODE>xsl:copy-of</CODE></A> 
or <A 
href="REC-xslt20-20070123.htm#element-value-of"><CODE>xsl:value-of</CODE></A>. 
However, <A 
href="REC-xslt20-20070123.htm#element-copy-of"><CODE>xsl:copy-of</CODE></A> 
would create a copy of the attribute node, which is not needed in this 
situation, while <A 
href="REC-xslt20-20070123.htm#element-value-of"><CODE>xsl:value-of</CODE></A> 
would create a new text node, which then has to be converted to an 
<CODE>xs:decimal</CODE>. Using <A 
href="REC-xslt20-20070123.htm#element-sequence"><CODE>xsl:sequence</CODE></A>, 
which in this case atomizes the existing attribute node and adds an 
<CODE>xs:decimal</CODE> atomic value to the result sequence, is a more direct 
way of achieving the same result.</P>
<P>This example could alternatively be solved at the XPath level:</P>
<DIV class=exampleInner><PRE>&lt;xsl:value-of select="avg(//product/(+@price, @cost*1.5)[1])"/&gt;
</PRE></DIV>
<P>(The apparently redundant <CODE>+</CODE> operator is there to atomize the 
attribute value: the expression on the right hand side of the <CODE>/</CODE> 
operator must not return a mixture of nodes and atomic 
values.)</P></DIV></DIV></DIV>
<DIV class=div1>
<H2><A id=number name=number></A>12 Numbering</H2>
<P class=element-syntax><A id=element-number 
name=element-number></A><CODE>&lt;!-- Category: instruction 
--&gt;<BR>&lt;xsl:number<BR>&nbsp;&nbsp;value? = 
<VAR>expression</VAR><BR>&nbsp;&nbsp;select? = 
<VAR>expression</VAR><BR>&nbsp;&nbsp;level? = "single" | "multiple" | 
"any"<BR>&nbsp;&nbsp;count? = <VAR>pattern</VAR><BR>&nbsp;&nbsp;from? = 
<VAR>pattern</VAR><BR>&nbsp;&nbsp;format? = { <VAR>string</VAR> 
}<BR>&nbsp;&nbsp;lang? = { <VAR>nmtoken</VAR> }<BR>&nbsp;&nbsp;letter-value? = { 
"alphabetic" | "traditional" }<BR>&nbsp;&nbsp;ordinal? = { <VAR>string</VAR> 
}<BR>&nbsp;&nbsp;grouping-separator? = { <VAR>char</VAR> 
}<BR>&nbsp;&nbsp;grouping-size? = { <VAR>number</VAR> }&nbsp;/&gt;</CODE></P>
<P>The <A 
href="REC-xslt20-20070123.htm#element-number"><CODE>xsl:number</CODE></A> 
instruction is used to create a formatted number. The result of the instruction 
is a newly constructed text node containing the formatted number as its <A 
title="string value" 
href="REC-xslt20-20070123.htm#dt-string-value">string 
value</A>.</P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-place-marker 
title="place marker" name=dt-place-marker></A>The <A 
href="REC-xslt20-20070123.htm#element-number"><CODE>xsl:number</CODE></A> 
instruction performs two tasks: firstly, determining a <B>place marker</B> (this 
is a sequence of integers, to allow for hierarchic numbering schemes such as 
<CODE>1.12.2</CODE> or <CODE>3(c)ii</CODE>), and secondly, formatting the place 
marker for output as a text node in the result sequence.<SPAN 
class=definition>]</SPAN> The place marker to be formatted can either be 
supplied directly, in the <CODE>value</CODE> attribute, or it can be computed 
based on the position of <SPAN>a selected node</SPAN> within the tree that 
contains it.</P>
<P><A id=err-XTSE0975 name=err-XTSE0975><SPAN class=error>[ERR 
XTSE0975]</SPAN></A> It is a <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A> if the <CODE>value</CODE> attribute of <A 
href="REC-xslt20-20070123.htm#element-number"><CODE>xsl:number</CODE></A> 
is present unless the <CODE>select</CODE>, <CODE>level</CODE>, 
<CODE>count</CODE>, and <CODE>from</CODE> attributes are all absent.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>The facilities described in this section are specifically designed to enable 
the calculation and formatting of section numbers, paragraph numbers, and the 
like. For formatting of other numeric quantities, the <A 
href="REC-xslt20-20070123.htm#function-format-number"><CODE>format-number</CODE></A> 
function may be more suitable: see <A 
href="REC-xslt20-20070123.htm#format-number"><I>16.4 
Number Formatting</I></A>.</P></DIV>
<DIV class=div2>
<H3><A id=formatting-supplied-number name=formatting-supplied-number></A>12.1 
Formatting a Supplied Number</H3>
<P>The <A title="place marker" 
href="REC-xslt20-20070123.htm#dt-place-marker">place 
marker</A> to be formatted may be specified by an expression. The 
<CODE>value</CODE> attribute contains the <A title=expression 
href="REC-xslt20-20070123.htm#dt-expression">expression</A>. 
The value of this expression is <A title=atomize 
href="REC-xslt20-20070123.htm#dt-atomization">atomized</A> 
using the procedure defined in <A 
href="REC-xslt20-20070123.htm#xpath20">[XPath 2.0]</A>, 
and each value <SPAN><VAR>$V</VAR> in the atomized sequence is then converted to 
the integer value returned by the XPath expression 
<CODE>xs:integer(round(number($V)))</CODE>.</SPAN> The resulting sequence of 
integers is used as the place marker to be formatted.</P>
<P>If <A title="backwards compatible behavior" 
href="REC-xslt20-20070123.htm#dt-backwards-compatible-behavior">backwards 
compatible behavior</A> is enabled for the instruction, then:</P>
<UL>
  <LI>
  <P>all items in the <A title=atomize 
  href="REC-xslt20-20070123.htm#dt-atomization">atomized</A> 
  sequence after the first are discarded;</P>
  <LI>
  <P>If the atomized sequence is empty, it is replaced by a sequence containing 
  the <CODE>xs:double</CODE> value <CODE>NaN</CODE> as its only item;</P>
  <LI>
  <P>If any value in the sequence cannot be converted to an integer (this 
  includes the case where the sequence contains a <CODE>NaN</CODE> value) then 
  the string <CODE>NaN</CODE> is inserted into the formatted result string in 
  its proper position. The error described in the following paragraph does not 
  apply in this case.</P></LI></UL>
<P><A id=err-XTDE0980 name=err-XTDE0980><SPAN class=error>[ERR 
XTDE0980]</SPAN></A> It is a <A title="non-recoverable dynamic error" 
href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
dynamic error</A> if any undiscarded item in the atomized sequence supplied as 
the value of the <CODE>value</CODE> attribute of <A 
href="REC-xslt20-20070123.htm#element-number"><CODE>xsl:number</CODE></A> 
cannot be converted to an integer, or if the resulting integer is less than 0 
(zero).</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>The value zero does not arise when numbering nodes in a source document, but 
it can arise in other numbering sequences. It is permitted specifically because 
the rules of the <A 
href="REC-xslt20-20070123.htm#element-number"><CODE>xsl:number</CODE></A> 
instruction are also invoked by functions such as <A 
href="REC-xslt20-20070123.htm#function-format-time"><CODE>format-time</CODE></A>: 
the minutes and seconds component of a time value can legitimately be 
zero.</P></DIV>
<P>The resulting sequence is formatted as a string using the <A 
title="effective value" 
href="REC-xslt20-20070123.htm#dt-effective-value">effective 
values</A> of the attributes specified in <A 
href="REC-xslt20-20070123.htm#convert"><I>12.3 Number to 
String Conversion Attributes</I></A>; each of these attributes is interpreted as 
an <A title="attribute value template" 
href="REC-xslt20-20070123.htm#dt-attribute-value-template">attribute 
value template</A>. After conversion, the <A 
href="REC-xslt20-20070123.htm#element-number"><CODE>xsl:number</CODE></A> 
element constructs a new text node containing the resulting string, and returns 
this node.</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e18312 name=d5e18312></A>Example: Numbering a 
Sorted List </DIV>
<P>The following example numbers a sorted list:</P>
<DIV class=exampleInner><PRE>&lt;xsl:template match="items"&gt;
  &lt;xsl:for-each select="item"&gt;
    &lt;xsl:sort select="."/&gt;
    &lt;p&gt;
      &lt;xsl:number value="position()" format="1. "/&gt;
      &lt;xsl:value-of select="."/&gt;
    &lt;/p&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;
</PRE></DIV></DIV></DIV>
<DIV class=div2>
<H3><A id=numbering-based-on-position name=numbering-based-on-position></A>12.2 
Numbering based on Position in a Document</H3>
<P>If no <CODE>value</CODE> attribute is specified, then the <A 
href="REC-xslt20-20070123.htm#element-number"><CODE>xsl:number</CODE></A> 
instruction returns a new text node containing a formatted <A 
title="place marker" 
href="REC-xslt20-20070123.htm#dt-place-marker">place 
marker</A> that is based on the position of <SPAN>a selected node within its 
containing document. If the <CODE>select</CODE> attribute is present, then the 
expression contained in the <CODE>select</CODE> attribute is evaluated to 
determine the selected node. If the <CODE>select</CODE> attribute is omitted, 
then the selected node is the <A title="context node" 
href="REC-xslt20-20070123.htm#dt-context-node">context 
node</A>.</SPAN></P>
<P><A id=err-XTTE0990 name=err-XTTE0990><SPAN class=error>[ERR 
XTTE0990]</SPAN></A> It is a <A title="type errors" 
href="REC-xslt20-20070123.htm#dt-type-error">type 
error</A> if the <A 
href="REC-xslt20-20070123.htm#element-number"><CODE>xsl:number</CODE></A> 
instruction is evaluated, with no <CODE>value</CODE> or <CODE>select</CODE> 
attribute, when the <A title="context item" 
href="REC-xslt20-20070123.htm#dt-context-item">context 
item</A> is not a node.</P>
<P><A id=err-XTTE1000 name=err-XTTE1000><SPAN class=error>[ERR 
XTTE1000]</SPAN></A> It is a <A title="type errors" 
href="REC-xslt20-20070123.htm#dt-type-error">type 
error</A> if the result of evaluating the <CODE>select</CODE> attribute of the 
<A 
href="REC-xslt20-20070123.htm#element-number"><CODE>xsl:number</CODE></A> 
instruction is anything other than a single node.</P>
<P>The following attributes control how the selected node is to be numbered:</P>
<UL>
  <LI>
  <P>The <CODE>level</CODE> attribute specifies rules for selecting the nodes 
  that are taken into account in allocating a number; it has the values 
  <CODE>single</CODE>, <CODE>multiple</CODE> or <CODE>any</CODE>. The default is 
  <CODE>single</CODE>.</P>
  <LI>
  <P>The <CODE>count</CODE> attribute is a <A title=pattern 
  href="REC-xslt20-20070123.htm#dt-pattern">pattern</A> 
  that specifies which nodes are to be counted at those levels. If 
  <CODE>count</CODE> attribute is not specified, then it defaults to the pattern 
  that matches any node with the same node <SPAN>kind</SPAN> as the 
  <SPAN>selected</SPAN> node and, if the <SPAN>selected</SPAN> node has an <A 
  title=expanded-QName 
  href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded-QName</A>, 
  with the same <A title=expanded-QName 
  href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded-QName</A> 
  as the <SPAN>selected</SPAN> node.</P>
  <LI>
  <P>The <CODE>from</CODE> attribute is a <A title=pattern 
  href="REC-xslt20-20070123.htm#dt-pattern">pattern</A> 
  that specifies where counting starts.</P></LI></UL>
<P>In addition, the attributes specified in <A 
href="REC-xslt20-20070123.htm#convert"><I>12.3 Number to 
String Conversion Attributes</I></A> are used for number to string conversion, 
as in the case when the <CODE>value</CODE> attribute is specified.</P>
<P>The <A 
href="REC-xslt20-20070123.htm#element-number"><CODE>xsl:number</CODE></A> 
element first constructs a sequence of positive integers using the 
<CODE>level</CODE>, <CODE>count</CODE> and <CODE>from</CODE> attributes. Where 
<CODE>level</CODE> is <CODE>single</CODE> or <CODE>any</CODE>, this sequence 
will either be empty or contain a single number; where <CODE>level</CODE> is 
<CODE>multiple</CODE>, the sequence may be of any length. The sequence is 
constructed as follows:</P>
<P>Let <CODE>matches-count($node)</CODE> be a function that returns true if and 
only if the given node <CODE>$node</CODE> matches the pattern given in the 
<CODE>count</CODE> attribute, or the implied pattern (according to the rules 
given above) if the <CODE>count</CODE> attribute is omitted.</P>
<P>Let <CODE>matches-from($node)</CODE> be a function that returns true if and 
only if the given node <CODE>$node</CODE> matches the pattern given in the 
<CODE>from</CODE> attribute, <SPAN>or if <CODE>$node</CODE> is the root node of 
a tree. If the <CODE>from</CODE> attribute is omitted, then the function returns 
true if and only if <CODE>$node</CODE> is the root node of a tree</SPAN>.</P>
<P>Let <CODE>$S</CODE> be the selected node.</P>
<P>When <CODE>level="single"</CODE>:</P>
<UL>
  <LI>
  <P>Let <CODE>$A</CODE> be the node sequence selected by the following 
  expression:</P>
  <P><CODE>&nbsp;&nbsp;&nbsp;$S/ancestor-or-self::node()[matches-count(.)][1]</CODE></P>
  <P>(this selects the innermost ancestor-or-self node that matches the 
  <CODE>count</CODE> pattern)</P>
  <LI>
  <P>Let <CODE>$F</CODE> be the node sequence selected by the expression</P>
  <P><CODE>&nbsp;&nbsp;&nbsp;$S/ancestor-or-self::node()[matches-from(.)][1]</CODE></P>
  <P>(this selects the innermost ancestor-or-self node that matches the 
  <CODE>from</CODE> pattern):</P>
  <LI>
  <P>Let <CODE>$AF</CODE> be the value of:</P>
  <P><CODE>&nbsp;&nbsp;&nbsp;$A[ancestor-or-self::node()[. is $F]]</CODE></P>
  <P>(this selects $A if it is in the subtree rooted at $F, or the empty 
  sequence otherwise)</P>
  <LI>
  <P>If <CODE>$AF</CODE> is empty, return the empty sequence, 
<CODE>()</CODE></P>
  <LI>
  <P>Otherwise return the value of:</P>
  <P><CODE>&nbsp;&nbsp;&nbsp;1 + 
  count($AF/preceding-sibling::node()[matches-count(.)])</CODE></P>
  <P>(the number of preceding siblings of the counted node that match the 
  <CODE>count</CODE> pattern, plus one).</P></LI></UL>
<P>When <CODE>level="multiple"</CODE>:</P>
<UL>
  <LI>
  <P>Let <CODE>$A</CODE> be the node sequence selected by the expression</P>
  <P><CODE>&nbsp;&nbsp;&nbsp;$S/ancestor-or-self::node()[matches-count(.)]</CODE></P>
  <P>(the set of ancestor-or-self nodes that match the <CODE>count</CODE> 
  pattern)</P>
  <LI>
  <P>Let <CODE>$F</CODE> be the node sequence selected by the expression</P>
  <P><CODE>&nbsp;&nbsp;&nbsp;$S/ancestor-or-self::node()[matches-from(.)][1]</CODE></P>
  <P>(the innermost ancestor-or-self node that matches the <CODE>from</CODE> 
  pattern)</P>
  <LI>
  <P>Let <CODE>$AF</CODE> be the value of</P>
  <P><CODE>&nbsp;&nbsp;&nbsp;$A[ancestor-or-self::node()[. is $F]]</CODE></P>
  <P>(the nodes selected in the first step that are in the subtree rooted at the 
  node selected in the second step)</P>
  <LI>
  <P>Return the result of the expression</P>
  <P><CODE>&nbsp;&nbsp;&nbsp;for $af in $AF return 
  1+count($af/preceding-sibling::node()[matches-count(.)])</CODE></P>
  <P>(a sequence of integers containing, for each of these nodes, one plus the 
  number of preceding siblings that match the <CODE>count</CODE> 
  pattern)</P></LI></UL>
<P>When <CODE>level="any"</CODE>:</P>
<UL>
  <LI>
  <P>Let <CODE>$A</CODE> be the node sequence selected by the expression</P>
  <P><CODE>&nbsp;&nbsp;&nbsp;$S/(preceding::node()|ancestor-or-self::node())[matches-count(.)]</CODE></P>
  <P>(the set of nodes consisting of the selected node together with all nodes, 
  other than attributes and namespaces, that precede the selected node in 
  document order, provided that they match the <CODE>count</CODE> pattern)</P>
  <LI>
  <P>Let <CODE>$F</CODE> be the node sequence selected by the expression</P>
  <P><CODE>&nbsp;&nbsp;&nbsp;$S/(preceding::node()|ancestor::node())[matches-from(.)][last()]</CODE></P>
  <P>(the last node in document order that matches the <CODE>from</CODE> pattern 
  and that precedes the selected node, using the same definition)</P>
  <LI>
  <P>Let <CODE>$AF</CODE> be the node sequence <CODE>$A[. is $F or . &gt;&gt; 
  $F]</CODE>.</P>
  <P>(the nodes selected in the first step, excluding those that precede the 
  node selected in the second step)</P>
  <LI>
  <P>If <CODE>$AF</CODE> is empty, return the empty sequence, 
<CODE>()</CODE></P>
  <LI>
  <P>Otherwise return the value of the expression 
  <CODE>count($AF)</CODE></P></LI></UL>
<P>The sequence of numbers (the <A title="place marker" 
href="REC-xslt20-20070123.htm#dt-place-marker">place 
marker</A>) is then converted into a string using the <A title="effective value" 
href="REC-xslt20-20070123.htm#dt-effective-value">effective 
values</A> of the attributes specified in <A 
href="REC-xslt20-20070123.htm#convert"><I>12.3 Number to 
String Conversion Attributes</I></A>; each of these attributes is interpreted as 
an <A title="attribute value template" 
href="REC-xslt20-20070123.htm#dt-attribute-value-template">attribute 
value template</A>. After conversion, the resulting string is <SPAN>used to 
create a text node, which forms the result of the <A 
href="REC-xslt20-20070123.htm#element-number"><CODE>xsl:number</CODE></A> 
instruction</SPAN>.</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e18740 name=d5e18740></A>Example: Numbering the 
Items in an Ordered List </DIV>
<P>The following will number the items in an ordered list:</P>
<DIV class=exampleInner><PRE>&lt;xsl:template match="ol/item"&gt;
  &lt;fo:block&gt;
    &lt;xsl:number/&gt;
    &lt;xsl:text&gt;. &lt;/xsl:text&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;
</PRE></DIV></DIV>
<P>&nbsp;</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e18747 name=d5e18747></A>Example: Multi-Level 
Numbering </DIV>
<P>The following two rules will number <CODE>title</CODE> elements. This is 
intended for a document that contains a sequence of chapters followed by a 
sequence of appendices, where both chapters and appendices contain sections, 
which in turn contain subsections. Chapters are numbered 1, 2, 3; appendices are 
numbered A, B, C; sections in chapters are numbered 1.1, 1.2, 1.3; sections in 
appendices are numbered A.1, A.2, A.3. <SPAN>Subsections within a chapter are 
numbered 1.1.1, 1.1.2, 1.1.3; subsections within an appendix are numbered A.1.1, 
A.1.2, A.1.3.</SPAN></P>
<DIV class=exampleInner><PRE>&lt;xsl:template match="title"&gt;
  &lt;fo:block&gt;
     &lt;xsl:number level="multiple"
                 count="chapter|section|subsection"
                 format="1.1 "/&gt;
     &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="appendix//title" priority="1"&gt;
  &lt;fo:block&gt;
     &lt;xsl:number level="multiple"
                 count="appendix|section|subsection"
                 format="A.1 "/&gt;
     &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;
</PRE></DIV></DIV>
<P>&nbsp;</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e18759 name=d5e18759></A>Example: Numbering 
Notes within a Chapter </DIV>
<P>This example numbers notes sequentially within a chapter:</P>
<DIV class=exampleInner><PRE>&lt;xsl:template match="note"&gt;
  &lt;fo:block&gt;
     &lt;xsl:number level="any" from="chapter" format="(1) "/&gt;
     &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;
</PRE></DIV></DIV></DIV>
<DIV class=div2>
<H3><A id=convert name=convert></A>12.3 Number to String Conversion 
Attributes</H3>
<P>The following attributes are used to control conversion of a sequence of 
numbers into a string. The numbers are integers greater than <SPAN>or equal 
to</SPAN> 0 (zero). The attributes are all optional.</P>
<P>The main attribute is <CODE>format</CODE>. The default value for the 
<CODE>format</CODE> attribute is <CODE>1</CODE>. The <CODE>format</CODE> 
attribute is split into a sequence of tokens where each token is a maximal 
sequence of alphanumeric characters or a maximal sequence of non-alphanumeric 
characters. <EM>Alphanumeric</EM> means any character that has a Unicode 
category of Nd, Nl, No, Lu, Ll, Lt, Lm or Lo. The alphanumeric tokens 
(<EM>format tokens</EM>) indicate the format to be used for each number in the 
sequence; in most cases the format token is the same as the required 
representation of the number 1 (one).</P>
<P>Each non-alphanumeric token is either a prefix, a separator, or a suffix. 
<SPAN>If there is a non-alphanumeric token but no format token, then the single 
non-alphanumeric token is used as both the prefix and the suffix.</SPAN> The 
prefix, if it exists, is the non-alphanumeric token that precedes the first 
format token: the prefix always appears exactly once in the constructed string, 
at the start. The suffix, if it exists, is the non-alphanumeric token that 
follows the last format token: the suffix always appears exactly once in the 
constructed string, at the end. All other non-alphanumeric tokens (those that 
occur between two format tokens) are <EM>separator tokens</EM> and are used to 
separate numbers in the sequence.</P>
<P>The <VAR>n</VAR>th format token is used to format the <VAR>n</VAR>th number 
in the sequence. If there are more numbers than format tokens, then the last 
format token is used to format remaining numbers. If there are no format tokens, 
then a format token of <CODE>1</CODE> is used to format all numbers. Each number 
after the first is separated from the preceding number by the separator token 
preceding the format token used to format that number, or, if <SPAN>that is the 
first format token</SPAN>, then by <CODE>.</CODE> (dot).</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e18820 name=d5e18820></A>Example: Formatting a 
List of Numbers </DIV>
<P>Given the sequence of numbers <CODE>5, 13, 7</CODE> and the format token 
<CODE>A-001(i)</CODE>, the output will be the string 
<CODE>E-013(vii)</CODE></P></DIV>
<P>Format tokens are interpreted as follows:</P>
<UL>
  <LI>
  <P>Any token where the last character has a decimal digit value of 1 (as 
  specified in the Unicode character property database), and the Unicode value 
  of preceding characters is one less than the Unicode value of the last 
  character generates a decimal representation of the number where each number 
  is at least as long as the format token. <SPAN>The digits used in the decimal 
  representation are the set of digits containing the digit character used in 
  the format token.</SPAN> Thus, a format token <CODE>1</CODE> generates the 
  sequence <CODE>0 1 2 ... 10 11 12 ...</CODE>, and a format token 
  <CODE>01</CODE> generates the sequence <CODE>00 01 02 ... 09 10 11 12 ... 99 
  100 101</CODE>. <SPAN>A format token of <CODE>&amp;#x661;</CODE> (Arabic-Indic 
  digit one) generates the sequence <CODE>١</CODE> then <CODE>٢</CODE> then 
  <CODE>٣</CODE> ...</SPAN></P>
  <LI>
  <P>A format token <CODE>A</CODE> generates the sequence <CODE>A B C ... Z AA 
  AB AC...</CODE>.</P>
  <LI>
  <P>A format token <CODE>a</CODE> generates the sequence <CODE>a b c ... z aa 
  ab ac...</CODE>.</P>
  <LI>
  <P>A format token <CODE>i</CODE> generates the sequence <CODE>i ii iii iv v vi 
  vii viii ix x ...</CODE>.</P>
  <LI>
  <P>A format token <CODE>I</CODE> generates the sequence <CODE>I II III IV V VI 
  VII VIII IX X ...</CODE>.</P>
  <LI>
  <P>A format token <CODE>w</CODE> generates numbers written as lower-case 
  words, for example in English, <CODE>one two three four ...</CODE></P>
  <LI>
  <P>A format token <CODE>W</CODE> generates numbers written as upper-case 
  words, for example in English, <CODE>ONE TWO THREE FOUR ...</CODE></P>
  <LI>
  <P>A format token <CODE>Ww</CODE> generates numbers written as title-case 
  words, for example in English, <CODE>One Two Three Four ...</CODE></P>
  <LI>
  <P>Any other format token indicates a numbering sequence <SPAN>in which that 
  token represents the number 1 (one)</SPAN> (but see the note below). It is <A 
  title=implementation-defined 
  href="REC-xslt20-20070123.htm#dt-implementation-defined">implementation-defined</A> 
  which numbering sequences, additional to those listed above, are supported. If 
  an implementation does not support a numbering sequence represented by the 
  given token, it <SPAN class=verb>must</SPAN> use a format token of 
  <CODE>1</CODE>.</P>
  <DIV class=note>
  <P class=prefix><B>Note:</B></P>
  <P>In some traditional numbering sequences additional signs are added to 
  denote that the letters should be interpreted as numbers; these are not 
  included in the format token. An example, see also the example below, is 
  classical Greek where a <EM>dexia keraia</EM> and sometimes an <EM>aristeri 
  keraia</EM> is added.</P></DIV></LI></UL>
<P>For all format tokens other than the first kind above (one that consists of 
decimal digits), there <SPAN class=verb>may</SPAN> be <A 
title=implementation-defined 
href="REC-xslt20-20070123.htm#dt-implementation-defined">implementation-defined</A> 
<SPAN>lower and</SPAN> upper bounds on the range of numbers that can be 
formatted using this format token; indeed, for some numbering sequences there 
may be intrinsic limits. <SPAN>For example, the formatting token 
<CODE>&amp;#x2460;</CODE> (circled digit one) has a range of 1 to 20 imposed by 
the Unicode character repertoire.</SPAN> For the numbering sequences described 
above <SPAN>any upper bound imposed by the implementation <SPAN class=verb>must 
not</SPAN> be less than 1000 (one thousand) and any lower bound must not be 
greater than 1. Numbers that fall outside this range <SPAN 
class=verb>must</SPAN> be formatted using the format token <CODE>1</CODE>. The 
numbering sequence associated with the format token <CODE>1</CODE> has a lower 
bound of 0 (zero)</SPAN>.</P>
<P>The above expansions of numbering sequences for format tokens such as 
<CODE>a</CODE> and <CODE>i</CODE> are indicative but not prescriptive. There are 
various conventions in use for how alphabetic sequences continue when the 
alphabet is exhausted, and differing conventions for how roman numerals are 
written (for example, <CODE>IV</CODE> versus <CODE>IIII</CODE> as the 
representation of the number 4). Sometimes alphabetic sequences are used that 
omit letters such as <CODE>i</CODE> and <CODE>o</CODE>. This specification does 
not prescribe the detail of any sequence other than those sequences consisting 
entirely of decimal digits.</P>
<P>Many numbering sequences are language-sensitive. This applies especially to 
the sequence selected by the tokens <CODE>w</CODE>, <CODE>W</CODE> and 
<CODE>Ww</CODE>. It also applies to other sequences, for example different 
languages using the Cyrillic alphabet use different sequences of characters, 
each starting with the letter #x410 (Cyrillic capital letter A). In such cases, 
the <CODE>lang</CODE> attribute specifies which language's conventions are to be 
used; it has the same range of values as <CODE>xml:lang</CODE> (see <A 
href="REC-xslt20-20070123.htm#REC-xml">[XML 1.0]</A>). If 
no <CODE>lang</CODE> value is specified, the language that is used is <A 
title=implementation-defined 
href="REC-xslt20-20070123.htm#dt-implementation-defined">implementation-defined</A>. 
The set of languages for which numbering is supported is <A 
title=implementation-defined 
href="REC-xslt20-20070123.htm#dt-implementation-defined">implementation-defined</A>. 
If a language is requested that is not supported, the processor uses the 
language that it would use if the <CODE>lang</CODE> attribute were omitted.</P>
<P>If the optional <CODE>ordinal</CODE> attribute is present, and if its value 
is not a zero-length string, this indicates a request to output ordinal numbers 
rather than cardinal numbers. For example, in English, the value 
<CODE>ordinal="yes"</CODE> when used with the format token <CODE>1</CODE> 
outputs the sequence <CODE>1st 2nd 3rd 4th ...</CODE>, and when used with the 
format token <CODE>w</CODE> outputs the sequence <CODE>first second third fourth 
...</CODE>. In some languages, ordinal numbers vary depending on the grammatical 
context, for example they may have different genders and may decline with the 
noun that they qualify. In such cases the value of the <CODE>ordinal</CODE> 
attribute may be used to indicate the variation of the ordinal number required. 
The way in which the variation is indicated will depend on the conventions of 
the language. For inflected languages that vary the ending of the word, the 
preferred approach is to indicate the required ending, preceded by a hyphen: for 
example in German, appropriate values are <CODE>-e, -er, -es, -en</CODE>. 
<SPAN>It is <A title=implementation-defined 
href="REC-xslt20-20070123.htm#dt-implementation-defined">implementation-defined</A> 
what combinations of values of the format token, the language, and the 
<CODE>ordinal</CODE> attribute are supported.</SPAN> If ordinal numbering is not 
supported for the combination of the format token, the language, and the actual 
value of the <CODE>ordinal</CODE> attribute, the request is ignored and cardinal 
numbers are generated instead.</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e19098 name=d5e19098></A>Example: Ordinal 
Numbering in Italian </DIV>
<P>The specification <CODE>format="1" ordinal="-º" lang="it"</CODE>, if 
supported, should produce the sequence:</P>
<DIV class=exampleInner><PRE>1º 2º 3º 4º ...
</PRE></DIV>
<P>The specification <CODE>format="Ww" ordinal="-o" lang="it"</CODE>, if 
supported, should produce the sequence:</P>
<DIV class=exampleInner><PRE>Primo Secondo Terzo Quarto Quinto ...
</PRE></DIV></DIV>
<P>The <CODE>letter-value</CODE> attribute disambiguates between numbering 
sequences that use letters. In many languages there are two commonly used 
numbering sequences that use letters. One numbering sequence assigns numeric 
values to letters in alphabetic sequence, and the other assigns numeric values 
to each letter in some other manner traditional in that language. In English, 
these would correspond to the numbering sequences specified by the format tokens 
<CODE>a</CODE> and <CODE>i</CODE>. In some languages, the first member of each 
sequence is the same, and so the format token alone would be ambiguous. A value 
of <CODE>alphabetic</CODE> specifies the alphabetic sequence; a value of 
<CODE>traditional</CODE> specifies the other sequence. If the 
<CODE>letter-value</CODE> attribute is not specified, then it is <A 
title=implementation-dependent 
href="REC-xslt20-20070123.htm#dt-implementation-dependent">implementation-dependent</A> 
how any ambiguity is resolved.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>Implementations may use <SPAN><A title="extension attribute" 
href="REC-xslt20-20070123.htm#dt-extension-attribute">extension 
attributes</A></SPAN> on <A 
href="REC-xslt20-20070123.htm#element-number"><CODE>xsl:number</CODE></A> 
to provide additional control over the way in which numbers are 
formatted.</P></DIV>
<P>The <CODE>grouping-separator</CODE> attribute gives the separator used as a 
grouping (for example, thousands) separator in decimal numbering sequences, and 
the optional <CODE>grouping-size</CODE> specifies the size (normally 3) of the 
grouping. For example, <CODE>grouping-separator=","</CODE> and 
<CODE>grouping-size="3"</CODE> would produce numbers of the form 
<CODE>1,000,000</CODE> while <CODE>grouping-separator="."</CODE> and 
<CODE>grouping-size="2"</CODE> would produce numbers of the form 
<CODE>1.00.00.00</CODE>. If only one of the <CODE>grouping-separator</CODE> and 
<CODE>grouping-size</CODE> attributes is specified, then it is ignored.</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e19182 name=d5e19182></A>Example: Format Tokens 
and the Resulting Sequences </DIV>
<P>These examples use non-Latin characters which might not display correctly in 
all browsers, depending on the system configuration.</P>
<TABLE cellPadding=5 border=1>
  <THEAD>
  <TR>
    <TH align=left>Description</TH>
    <TH align=left>Format Token</TH>
    <TH align=left>Sequence</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD>French cardinal words</TD>
    <TD><CODE>format="Ww" lang="fr"</CODE></TD>
    <TD>Un, Deux, Trois, Quatre</TD></TR>
  <TR>
    <TD>German ordinal words</TD>
    <TD><CODE>format="w" ordinal="-e" lang="de"</CODE></TD>
    <TD>erste, zweite, dritte, vierte</TD></TR>
  <TR>
    <TD>Katakana numbering</TD>
    <TD><CODE>format="&amp;#x30A2;"</CODE></TD>
    <TD>ア, イ, ウ, エ, オ, カ, キ, ク, ケ, コ, サ, シ, ス, セ, ソ, タ, チ, ツ, テ, ト, ナ, ニ, ヌ, 
      ネ, ノ, ハ, ヒ, フ, ヘ, ホ, マ, ミ, ム, メ, モ, ヤ, ユ, ヨ, ラ, リ, ル, レ, ロ, ワ, ヰ, ヱ, ヲ, 
    ン</TD></TR>
  <TR>
    <TD>Katakana numbering in iroha order</TD>
    <TD><CODE>format="&amp;#x30A4;"</CODE></TD>
    <TD>イ, ロ, ハ, ニ, ホ, ヘ, ト, チ, リ, ヌ, ル, ヲ, ワ, カ, ヨ, タ, レ, ソ, ツ, ネ, ナ, ラ, ム, 
      ウ, ヰ, ノ, オ, ク, ヤ, マ, ケ, フ, コ, エ, テ, ア, サ, キ, ユ, メ, ミ, シ, ヱ, ヒ, モ, セ, 
  ス</TD></TR>
  <TR>
    <TD>Thai numbering</TD>
    <TD><CODE>format="&amp;#x0E51;"</CODE></TD>
    <TD>๑, ๒, ๓, ๔, ๕, ๖, ๗, ๘, ๙, ๑๐, ๑๑, ๑๒, ๑๓, ๑๔, ๑๕, ๑๖, ๑๗, ๑๘, ๑๙, 
    ๒๐</TD></TR>
  <TR>
    <TD>Traditional Hebrew numbering</TD>
    <TD><CODE>format="&amp;#x05D0;" letter-value="traditional"</CODE></TD>
    <TD>א, ב, ג, ד, ה, ו, ז, ח, ט, י, יא, יב, יג, יד, טו, טז, יז, יח, יט, 
  כ</TD></TR>
  <TR>
    <TD>Traditional Georgian numbering</TD>
    <TD><CODE>format="&amp;#x10D0;" letter-value="traditional"</CODE></TD>
    <TD>ა, ბ, გ, დ, ე, ვ, ზ, ჱ, თ, ი, ია, იბ, იგ, იდ, იე, ივ, იზ, იჱ, ით, 
  კ</TD></TR>
  <TR>
    <TD>Classical Greek numbering (see note)</TD>
    <TD><CODE>format="&amp;#x03B1;" letter-value="traditional"</CODE></TD>
    <TD>αʹ, βʹ, γʹ, δʹ, εʹ, ϛʹ, ζʹ, ηʹ, θʹ, ιʹ, ιαʹ, ιβʹ, ιγʹ, ιδʹ, ιεʹ, ιϛʹ, 
      ιζʹ, ιηʹ, ιθʹ, κʹ</TD></TR>
  <TR>
    <TD>Old Slavic numbering</TD>
    <TD><CODE>format="&amp;#x0430;" letter-value="traditional"</CODE></TD>
    <TD>А, В, Г, Д, Е, Ѕ, З, И, Ѳ, Ӏ, АӀ, ВӀ, ГӀ, ДӀ, ЕӀ, ЅӀ, ЗӀ, ИӀ, ѲӀ, 
  К</TD></TR></TBODY></TABLE>
<P>Note that Glassical Greek is an example where the format token is not the 
same as the representation of the number 1.</P></DIV></DIV></DIV>
<DIV class=div1>
<H2><A id=sorting name=sorting></A>13 Sorting</H2>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A 
id=dt-sort-key-specification title="sort key specification" 
name=dt-sort-key-specification></A>A <B>sort key specification</B> is a sequence 
of one or more adjacent <A 
href="REC-xslt20-20070123.htm#element-sort"><CODE>xsl:sort</CODE></A> 
elements which together define rules for sorting the items in an input sequence 
to form a sorted sequence.<SPAN class=definition>]</SPAN></P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-sort-key-component 
title="sort key component" name=dt-sort-key-component></A>Within a <A 
title="sort key specification" 
href="REC-xslt20-20070123.htm#dt-sort-key-specification">sort 
key specification</A>, each <A 
href="REC-xslt20-20070123.htm#element-sort"><CODE>xsl:sort</CODE></A> 
element defines one <B>sort key component</B>.<SPAN class=definition>]</SPAN> 
The first <A 
href="REC-xslt20-20070123.htm#element-sort"><CODE>xsl:sort</CODE></A> 
element specifies the primary component of the sort key specification, the 
second <A 
href="REC-xslt20-20070123.htm#element-sort"><CODE>xsl:sort</CODE></A> 
element specifies the secondary component of the sort key specification and so 
on.</P>
<P>A sort key specification may occur immediately within an <A 
href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-for-each"><CODE>xsl:for-each</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-perform-sort"><CODE>xsl:perform-sort</CODE></A>, 
or <A 
href="REC-xslt20-20070123.htm#element-for-each-group"><CODE>xsl:for-each-group</CODE></A> 
element.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>When used within <A 
href="REC-xslt20-20070123.htm#element-for-each"><CODE>xsl:for-each</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-for-each-group"><CODE>xsl:for-each-group</CODE></A>, 
or <A 
href="REC-xslt20-20070123.htm#element-perform-sort"><CODE>xsl:perform-sort</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-sort"><CODE>xsl:sort</CODE></A> 
elements must occur before any other children.</P></DIV>
<DIV class=div2>
<H3><A id=xsl-sort name=xsl-sort></A>13.1 The <A 
href="REC-xslt20-20070123.htm#element-sort"><CODE>xsl:sort</CODE></A> 
Element</H3>
<P class=element-syntax><A id=element-sort 
name=element-sort></A><CODE>&lt;xsl:sort<BR>&nbsp;&nbsp;select? = 
<VAR>expression</VAR><BR>&nbsp;&nbsp;lang? = { <VAR>nmtoken</VAR> 
}<BR>&nbsp;&nbsp;order? = { "ascending" | "descending" 
}<BR>&nbsp;&nbsp;collation? = { <VAR>uri</VAR> }<BR>&nbsp;&nbsp;stable? = { 
"yes" | "no" }<BR>&nbsp;&nbsp;case-order? = { "upper-first" | "lower-first" 
}<BR>&nbsp;&nbsp;data-type? = { "text" | "number" | 
<VAR>qname-but-not-ncname</VAR> }&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: 
<VAR>sequence-constructor</VAR> --&gt;<BR>&lt;/xsl:sort&gt;</CODE></P>
<P>The <A 
href="REC-xslt20-20070123.htm#element-sort"><CODE>xsl:sort</CODE></A> 
element defines a <A title="sort key component" 
href="REC-xslt20-20070123.htm#dt-sort-key-component">sort 
key component</A>. A sort key component specifies how a <A 
title="sort key value" 
href="REC-xslt20-20070123.htm#dt-sort-key-value">sort key 
value</A> is to be computed for each item in the sequence being sorted, and also 
how two sort key values are to be compared.</P>
<P>The value of a <A title="sort key component" 
href="REC-xslt20-20070123.htm#dt-sort-key-component">sort 
key component</A> is determined either by its <CODE>select</CODE> attribute, or 
by the contained <A title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A>. If neither is present, the default is <CODE>select="."</CODE>, 
which has the effect of sorting on the actual value of the item if it is an 
atomic value, or on the typed-value of the item if it is a node. If a 
<CODE>select</CODE> attribute is present, its value <SPAN class=verb>must</SPAN> 
be an XPath <A title=expression 
href="REC-xslt20-20070123.htm#dt-expression">expression</A>.</P>
<P><A id=err-XTSE1015 name=err-XTSE1015><SPAN class=error>[ERR 
XTSE1015]</SPAN></A> It is a <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A> if an <A 
href="REC-xslt20-20070123.htm#element-sort"><CODE>xsl:sort</CODE></A> 
element with a <CODE>select</CODE> attribute has non-empty content.</P>
<P>Those attributes of the <A 
href="REC-xslt20-20070123.htm#element-sort"><CODE>xsl:sort</CODE></A> 
elements whose values are <A title="attribute value template" 
href="REC-xslt20-20070123.htm#dt-attribute-value-template">attribute 
value templates</A> are evaluated using the same <A title=focus 
href="REC-xslt20-20070123.htm#dt-focus">focus</A> as is 
used to evaluate the <CODE>select</CODE> attribute of the containing instruction 
(specifically, <A 
href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-for-each"><CODE>xsl:for-each</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-for-each-group"><CODE>xsl:for-each-group</CODE></A>, 
or <A 
href="REC-xslt20-20070123.htm#element-perform-sort"><CODE>xsl:perform-sort</CODE></A>).</P>
<P>The <CODE>stable</CODE> attribute is permitted only on the first <A 
href="REC-xslt20-20070123.htm#element-sort"><CODE>xsl:sort</CODE></A> 
element within a <A title="sort key specification" 
href="REC-xslt20-20070123.htm#dt-sort-key-specification">sort 
key specification</A></P>
<P><A id=err-XTSE1017 name=err-XTSE1017><SPAN class=error>[ERR 
XTSE1017]</SPAN></A> It is a <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A> if an <A 
href="REC-xslt20-20070123.htm#element-sort"><CODE>xsl:sort</CODE></A> 
element other than the first in a sequence of sibling <A 
href="REC-xslt20-20070123.htm#element-sort"><CODE>xsl:sort</CODE></A> 
elements has a <CODE>stable</CODE> attribute.</P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-stable title=stable 
name=dt-stable></A>A <A title="sort key specification" 
href="REC-xslt20-20070123.htm#dt-sort-key-specification">sort 
key specification</A> is said to be <B>stable</B> if its first <A 
href="REC-xslt20-20070123.htm#element-sort"><CODE>xsl:sort</CODE></A> 
element has no <CODE>stable</CODE> attribute, or has a <CODE>stable</CODE> 
attribute whose <A title="effective value" 
href="REC-xslt20-20070123.htm#dt-effective-value">effective 
value</A> is <CODE>yes</CODE>.<SPAN class=definition>]</SPAN></P>
<DIV class=div3>
<H4><A id=sorting-process name=sorting-process></A>13.1.1 The Sorting 
Process</H4>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-initial-sequence 
title="initial sequence" name=dt-initial-sequence></A>The sequence to be sorted 
is referred to as the <B>initial sequence</B>.<SPAN 
class=definition>]</SPAN></P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-sorted-sequence 
title="sorted sequence" name=dt-sorted-sequence></A>The sequence after sorting 
as defined by the <A 
href="REC-xslt20-20070123.htm#element-sort"><CODE>xsl:sort</CODE></A> 
elements is referred to as the <B>sorted sequence</B>.<SPAN 
class=definition>]</SPAN></P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-sort-key-value 
title="sort key value" name=dt-sort-key-value></A> For each item in the <A 
title="initial sequence" 
href="REC-xslt20-20070123.htm#dt-initial-sequence">initial 
sequence</A>, a value is computed for each <A title="sort key component" 
href="REC-xslt20-20070123.htm#dt-sort-key-component">sort 
key component</A> within the <A title="sort key specification" 
href="REC-xslt20-20070123.htm#dt-sort-key-specification">sort 
key specification</A>. The value computed for an item by using the 
<VAR>N</VAR>th sort key component is referred to as the <VAR>N</VAR>th <B>sort 
key value</B> of that item.<SPAN class=definition>]</SPAN></P>
<P>The items in the <A title="initial sequence" 
href="REC-xslt20-20070123.htm#dt-initial-sequence">initial 
sequence</A> are ordered into a <A title="sorted sequence" 
href="REC-xslt20-20070123.htm#dt-sorted-sequence">sorted 
sequence</A> by comparing their <A title="sort key value" 
href="REC-xslt20-20070123.htm#dt-sort-key-value">sort key 
values</A>. The relative position of two items <VAR>A</VAR> and <VAR>B</VAR> in 
the sorted sequence is determined as follows. The first sort key value of 
<VAR>A</VAR> is compared with the first sort key value of <VAR>B</VAR>, 
according to the rules of the first <A title="sort key component" 
href="REC-xslt20-20070123.htm#dt-sort-key-component">sort 
key component</A>. If, under these rules, <VAR>A</VAR> is less than 
<VAR>B</VAR>, then <VAR>A</VAR> will precede <VAR>B</VAR> in the sorted 
sequence, unless the <CODE>order</CODE> attribute of this <A 
title="sort key component" 
href="REC-xslt20-20070123.htm#dt-sort-key-component">sort 
key component</A> specifies <CODE>descending</CODE>, in which case <VAR>B</VAR> 
will precede <VAR>A</VAR> in the sorted sequence. If, however, the relevant sort 
key values compare equal, then the second sort key value of <VAR>A</VAR> is 
compared with the second sort key value of <VAR>B</VAR>, according to the rules 
of the second <A title="sort key component" 
href="REC-xslt20-20070123.htm#dt-sort-key-component">sort 
key component</A>. This continues until two sort key values are found that 
compare unequal. If all the sort key values compare equal, <SPAN>and the <A 
title="sort key specification" 
href="REC-xslt20-20070123.htm#dt-sort-key-specification">sort 
key specification</A> is <A title=stable 
href="REC-xslt20-20070123.htm#dt-stable">stable</A>,</SPAN> 
then <VAR>A</VAR> will precede <VAR>B</VAR> in the <A title="sorted sequence" 
href="REC-xslt20-20070123.htm#dt-sorted-sequence">sorted 
sequence</A> if and only if <VAR>A</VAR> preceded <VAR>B</VAR> in the <A 
title="initial sequence" 
href="REC-xslt20-20070123.htm#dt-initial-sequence">initial 
sequence</A>. <SPAN>If all the sort key values compare equal, and the <A 
title="sort key specification" 
href="REC-xslt20-20070123.htm#dt-sort-key-specification">sort 
key specification</A> is not <A title=stable 
href="REC-xslt20-20070123.htm#dt-stable">stable</A>, then 
the relative order of <VAR>A</VAR> and <VAR>B</VAR> in the <A 
title="sorted sequence" 
href="REC-xslt20-20070123.htm#dt-sorted-sequence">sorted 
sequence</A> is <A title=implementation-dependent 
href="REC-xslt20-20070123.htm#dt-implementation-dependent">implementation-dependent</A>.</SPAN></P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>If two items have equal <A title="sort key value" 
href="REC-xslt20-20070123.htm#dt-sort-key-value">sort key 
values</A>, <SPAN>and the sort is <A title=stable 
href="REC-xslt20-20070123.htm#dt-stable">stable</A>,</SPAN> 
then their order in the <A title="sorted sequence" 
href="REC-xslt20-20070123.htm#dt-sorted-sequence">sorted 
sequence</A> will be the same as their order in the <A title="initial sequence" 
href="REC-xslt20-20070123.htm#dt-initial-sequence">initial 
sequence</A>, regardless of whether <CODE>order="descending"</CODE> was 
specified on any or all of the <A title="sort key component" 
href="REC-xslt20-20070123.htm#dt-sort-key-component">sort 
key components</A>.</P></DIV>
<P>The <VAR>N</VAR>th sort key value is computed by evaluating either the 
<CODE>select</CODE> attribute or the contained <A title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A> of the <VAR>N</VAR>th <A 
href="REC-xslt20-20070123.htm#element-sort"><CODE>xsl:sort</CODE></A> 
element, or the expression <CODE>.</CODE> (dot) if neither is present. This 
evaluation is done with the <A title=focus 
href="REC-xslt20-20070123.htm#dt-focus">focus</A> set as 
follows:</P>
<UL>
  <LI>
  <P>The <A title="context item" 
  href="REC-xslt20-20070123.htm#dt-context-item">context 
  item</A> is the item in the <A title="initial sequence" 
  href="REC-xslt20-20070123.htm#dt-initial-sequence">initial 
  sequence</A> whose <A title="sort key value" 
  href="REC-xslt20-20070123.htm#dt-sort-key-value">sort 
  key value</A> is being computed.</P>
  <LI>
  <P>The <A title="context position" 
  href="REC-xslt20-20070123.htm#dt-context-position">context 
  position</A> is the position of that item in the initial sequence.</P>
  <LI>
  <P>The <A title="context size" 
  href="REC-xslt20-20070123.htm#dt-context-size">context 
  size</A> is the size of the initial sequence.</P></LI></UL>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>As in any other XPath expression, the <A 
href="REC-xslt20-20070123.htm#function-current"><CODE>current</CODE></A> 
function may be used within the <CODE>select</CODE> expression of <A 
href="REC-xslt20-20070123.htm#element-sort"><CODE>xsl:sort</CODE></A> 
to refer to the item that is the context item for the expression as a whole; 
that is, the item whose <A title="sort key value" 
href="REC-xslt20-20070123.htm#dt-sort-key-value">sort key 
value</A> is being computed.</P></DIV>
<P>The <A title="sort key value" 
href="REC-xslt20-20070123.htm#dt-sort-key-value">sort key 
values</A> are <A title=atomize 
href="REC-xslt20-20070123.htm#dt-atomization">atomized</A>, 
and are then compared. The way they are compared depends on their data type, as 
described in the next section.</P></DIV>
<DIV class=div3>
<H4><A id=comparing-sort-keys name=comparing-sort-keys></A>13.1.2 Comparing Sort 
Key Values</H4>
<P>It is possible to force the system to compare <A title="sort key value" 
href="REC-xslt20-20070123.htm#dt-sort-key-value">sort key 
values</A> using the rules for a particular data type by including a cast as 
part of the <A title="sort key component" 
href="REC-xslt20-20070123.htm#dt-sort-key-component">sort 
key component</A>. For example, <CODE>&lt;xsl:sort 
select="xs:date(@dob)"/&gt;</CODE> will force the attributes to be compared as 
dates. In the absence of such a cast, the sort key values are compared using the 
rules appropriate to their data type. Any values of type 
<SPAN><CODE>xs:untypedAtomic</CODE></SPAN> are cast to 
<CODE>xs:string</CODE>.</P>
<P>For backwards compatibility with XSLT 1.0, the <CODE>data-type</CODE> 
attribute <SPAN>remains available. If this has the <A title="effective value" 
href="REC-xslt20-20070123.htm#dt-effective-value">effective 
value</A> <CODE>text</CODE>, the atomized <A title="sort key value" 
href="REC-xslt20-20070123.htm#dt-sort-key-value">sort key 
values</A> are converted to strings before being compared. If it has the 
effective value <CODE>number</CODE>, the atomized sort key values are converted 
to doubles before being compared. The conversion is done by using the <A 
href="http://www.w3.org/TR/xpath-functions/#func-string"><CODE>string</CODE></A><SUP><SMALL>FO</SMALL></SUP> 
or <A 
href="http://www.w3.org/TR/xpath-functions/#func-number"><CODE>number</CODE></A><SUP><SMALL>FO</SMALL></SUP> 
function as appropriate.</SPAN> If the <CODE>data-type</CODE> attribute has any 
other <A title="effective value" 
href="REC-xslt20-20070123.htm#dt-effective-value">effective 
value</A>, then the value <SPAN class=verb>must</SPAN> be a <SPAN><A 
title="lexical QName" 
href="REC-xslt20-20070123.htm#dt-lexical-qname">lexical 
QName</A> with a non-empty prefix</SPAN>, and the effect of the attribute is <A 
title=implementation-defined 
href="REC-xslt20-20070123.htm#dt-implementation-defined">implementation-defined</A>.</P>
<P><A id=err-XTTE1020 name=err-XTTE1020><SPAN class=error>[ERR 
XTTE1020]</SPAN></A> If any <A title="sort key value" 
href="REC-xslt20-20070123.htm#dt-sort-key-value">sort key 
value</A>, after <A title=atomize 
href="REC-xslt20-20070123.htm#dt-atomization">atomization</A> 
and any type conversion <SPAN class=verb>required</SPAN> by the 
<CODE>data-type</CODE> attribute, is a sequence containing more than one item, 
then the effect depends on whether the <A 
href="REC-xslt20-20070123.htm#element-sort"><CODE>xsl:sort</CODE></A> 
element is evaluated with <A title="backwards compatible behavior" 
href="REC-xslt20-20070123.htm#dt-backwards-compatible-behavior">backwards 
compatible behavior</A>. With backwards compatible behavior, the effective sort 
key value is the first item in the sequence. In other cases, this is a <A 
title="type errors" 
href="REC-xslt20-20070123.htm#dt-type-error">type 
error</A>.</P>
<P>The set of <A title="sort key value" 
href="REC-xslt20-20070123.htm#dt-sort-key-value">sort key 
values</A> (after any conversion) is first divided into <SPAN>two categories: 
empty values, and ordinary values.</SPAN> The empty sort key values represent 
those items where the sort key value is an empty sequence. These values are 
considered for sorting purposes to be equal to each other, but less than any 
other value. The remaining values are classified as ordinary values.</P>
<P><A id=err-XTDE1030 name=err-XTDE1030><SPAN class=error>[ERR 
XTDE1030]</SPAN></A> It is a <A title="non-recoverable dynamic error" 
href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
dynamic error</A> if, for any <A title="sort key component" 
href="REC-xslt20-20070123.htm#dt-sort-key-component">sort 
key component</A>, the set of <A title="sort key value" 
href="REC-xslt20-20070123.htm#dt-sort-key-value">sort key 
values</A> evaluated for all the items in the <A title="initial sequence" 
href="REC-xslt20-20070123.htm#dt-initial-sequence">initial 
sequence</A>, after any type conversion requested, contains a pair of ordinary 
values for which the result of the XPath <CODE>lt</CODE> operator is an 
error.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>The above error condition may occur if the values to be sorted are of a type 
that does not support ordering (for example, <CODE>xs:QName</CODE>) or if the 
sequence is heterogeneous (for example, if it contains both strings and 
numbers). The error can generally be prevented by invoking a cast or constructor 
function within the sort key component.</P>
<P>The error condition is subject to the usual caveat that a processor is not 
required to evaluate any expression solely in order to determine whether it 
raises an error. For example, if there are several sort key components, then a 
processor is not required to evaluate or compare minor sort key values unless 
the corresponding major sort key values are equal.</P></DIV>
<P>In general, comparison of two ordinary values is performed according to the 
rules of the XPath <CODE>lt</CODE> operator. <SPAN>To ensure a total ordering, 
the same implementation of the <CODE>lt</CODE> operator <SPAN 
class=verb>must</SPAN> be used for all the comparisons: the one that is chosen 
is the one appropriate to the most specific type to which all the values can be 
converted by subtype substitution and/or type promotion. For example, if the 
sequence contains both <CODE>xs:decimal</CODE> and <CODE>xs:double</CODE> 
values, then the values are compared using <CODE>xs:double</CODE> comparison, 
even when comparing two <CODE>xs:decimal</CODE> values.</SPAN> NaN values, for 
sorting purposes, are considered to be equal to each other, and less than any 
other numeric value. Special rules also apply to the <CODE>xs:string</CODE> 
<SPAN>and <CODE>xs:anyURI</CODE> types, and types derived by restriction 
therefrom,</SPAN>, as described in the next section.</P></DIV>
<DIV class=div3>
<H4><A id=collating-sequences name=collating-sequences></A>13.1.3 Sorting Using 
Collations</H4>
<P>The rules given in this section apply when comparing values whose type is 
<CODE>xs:string</CODE> or a type derived by restriction from 
<CODE>xs:string</CODE><SPAN>, or whose type is <CODE>xs:anyURI</CODE> or a type 
derived by restriction from <CODE>xs:anyURI</CODE></SPAN>.</P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-collation 
title=collation name=dt-collation></A>Facilities in XSLT 2.0 and XPath 2.0 that 
require strings to be ordered rely on the concept of a named <B>collation</B>. A 
collation is a set of rules that determine whether two strings are equal, and if 
not, which of them is to be sorted before the other.<SPAN 
class=definition>]</SPAN> A collation is identified by a URI, but the manner in 
which this URI is associated with an actual rule or algorithm is <A 
title=implementation-defined 
href="REC-xslt20-20070123.htm#dt-implementation-defined">implementation-defined</A>.</P>
<P>The one collation URI that must be recognized by every implementation is 
<CODE>http://www.w3.org/2005/xpath-functions/collation/codepoint</CODE>, which 
provides the ability to compare strings based on the Unicode codepoint values of 
the characters in the string.</P>
<P>For more information about collations, see <A 
href="http://www.w3.org/TR/xpath-functions/#string-compare">Section 7.3 Equality 
and Comparison of Strings</A><SUP><SMALL>FO</SMALL></SUP> in <A 
href="REC-xslt20-20070123.htm#xpath-functions">[Functions 
and Operators]</A>. Some specifications, for example <A 
href="REC-xslt20-20070123.htm#UNICODE-TR10">[UNICODE 
TR10]</A>, use the term "collation" to describe rules that can be tailored or 
parameterized for various purposes. In this specification, a collation URI 
refers to a collation in which all such parameters have already been fixed. 
Therefore, if a collation URI is specified, other attributes such as 
<CODE>case-order</CODE> and <CODE>lang</CODE> are ignored.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>The reason XSLT does not provide detailed mechanisms for defining collating 
sequences is that many implementations will re-use collating mechanisms 
available from the underlying implementation platform (for example, from the 
operating system or from the run-time library of a chosen programming language). 
These will inevitably differ from one XSLT implementation to another.</P></DIV>
<P>If the <A 
href="REC-xslt20-20070123.htm#element-sort"><CODE>xsl:sort</CODE></A> 
element has a <CODE>collation</CODE> attribute, then the strings are compared 
according to the rules for the named <A title=collation 
href="REC-xslt20-20070123.htm#dt-collation">collation</A>: 
that is, they are compared using the XPath function call <CODE>compare($a, $b, 
$collation)</CODE>.</P>
<P>If the <A title="effective value" 
href="REC-xslt20-20070123.htm#dt-effective-value">effective 
value</A> of the <CODE>collation</CODE> attribute of <A 
href="REC-xslt20-20070123.htm#element-sort"><CODE>xsl:sort</CODE></A> 
is a relative URI, then it is resolved against the base URI of the <A 
href="REC-xslt20-20070123.htm#element-sort"><CODE>xsl:sort</CODE></A> 
element.</P>
<P><A id=err-XTDE1035 name=err-XTDE1035><SPAN class=error>[ERR 
XTDE1035]</SPAN></A> It is a <A title="non-recoverable dynamic error" 
href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
dynamic error</A> if the <CODE>collation</CODE> attribute of <A 
href="REC-xslt20-20070123.htm#element-sort"><CODE>xsl:sort</CODE></A> 
(after resolving against the base URI) is not a URI that is recognized by the 
implementation as referring to a collation.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>It is entirely for the implementation to determine whether it recognizes a 
particular collation URI. For example, if the implementation allows collation 
URIs to contain parameters in the query part of the URI, it is the 
implementation that determines whether a URI containing an unknown or invalid 
parameter is or is not a recognized collation URI. <SPAN>The fact that this 
error is described as non-recoverable thus does not prevent an implementation 
applying a fallback collation if it chooses to do so.</SPAN></P></DIV>
<P>The <CODE>lang</CODE> and <CODE>case-order</CODE> attributes are ignored if a 
<CODE>collation</CODE> attribute is present. But in the absence of a 
<CODE>collation</CODE> attribute, these attributes provide input to an <A 
title=implementation-defined 
href="REC-xslt20-20070123.htm#dt-implementation-defined">implementation-defined</A> 
algorithm to <SPAN>locate</SPAN> a suitable collation:</P>
<UL>
  <LI>
  <P>The <CODE>lang</CODE> attribute indicates that a collation suitable for a 
  particular natural language <SPAN class=verb>should</SPAN> be used. The <A 
  title="effective value" 
  href="REC-xslt20-20070123.htm#dt-effective-value">effective 
  value</A> of the attribute <SPAN class=verb>must</SPAN> be a value that would 
  be valid for the <CODE>xml:lang</CODE> attribute (see <A 
  href="REC-xslt20-20070123.htm#REC-xml">[XML 
  1.0]</A>).</P>
  <LI>
  <P>The <CODE>case-order</CODE> attribute indicates whether the desired 
  collation <SPAN class=verb>should</SPAN> sort upper-case letters before 
  lower-case or vice versa. The <A title="effective value" 
  href="REC-xslt20-20070123.htm#dt-effective-value">effective 
  value</A> of the attribute <SPAN class=verb>must</SPAN> be either 
  <CODE>lower-first</CODE> (indicating that lower-case letters precede 
  upper-case letters in the collating sequence) or <CODE>upper-first</CODE> 
  (indicating that upper-case letters precede lower-case).</P></LI></UL>
<P>If none of the <CODE>collation</CODE>, <CODE>lang</CODE> or 
<CODE>case-order</CODE> attributes is present, the collation is chosen in an <A 
title=implementation-defined 
href="REC-xslt20-20070123.htm#dt-implementation-defined">implementation-defined</A> 
way. It is not <SPAN class=verb>required</SPAN> that the default collation for 
sorting should be the same as the <A title="default collation" 
href="REC-xslt20-20070123.htm#dt-default-collation">default 
collation</A> used when evaluating XPath expressions, as described in <A 
href="REC-xslt20-20070123.htm#static-context"><I>5.4.1 
Initializing the Static Context</I></A> and <A 
href="REC-xslt20-20070123.htm#default-collation-attribute"><I>3.6.1 
The default-collation attribute</I></A>.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>It is usually appropriate, when sorting, to use a strong collation, that is, 
one that takes account of secondary differences (accents) and tertiary 
differences (case) between strings that are otherwise equal. A weak collation, 
which ignores such differences, may be more suitable when comparing strings for 
equality.</P>
<P>Useful background information on international sorting is provided in <A 
href="REC-xslt20-20070123.htm#UNICODE-TR10">[UNICODE 
TR10]</A>. The <CODE>case-order</CODE> attribute may be interpreted as described 
in section 6.6 of <A 
href="REC-xslt20-20070123.htm#UNICODE-TR10">[UNICODE 
TR10]</A>.</P></DIV></DIV></DIV>
<DIV class=div2>
<H3><A id=creating-sorted-sequence name=creating-sorted-sequence></A>13.2 
Creating a Sorted Sequence</H3>
<P class=element-syntax><A id=element-perform-sort 
name=element-perform-sort></A><CODE>&lt;!-- Category: instruction 
--&gt;<BR>&lt;xsl:perform-sort<BR>&nbsp;&nbsp;select? = 
<VAR>expression</VAR>&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: (<A 
href="REC-xslt20-20070123.htm#element-sort">xsl:sort</A>+, 
<VAR>sequence-constructor</VAR>) --&gt;<BR>&lt;/xsl:perform-sort&gt;</CODE></P>
<P>The <A 
href="REC-xslt20-20070123.htm#element-perform-sort"><CODE>xsl:perform-sort</CODE></A> 
instruction is used to return a <A title="sorted sequence" 
href="REC-xslt20-20070123.htm#dt-sorted-sequence">sorted 
sequence</A>.</P>
<P>The <A title="initial sequence" 
href="REC-xslt20-20070123.htm#dt-initial-sequence">initial 
sequence</A> is obtained either by evaluating the <CODE>select</CODE> attribute 
or by evaluating the contained sequence constructor (but not both). If there is 
no <CODE>select</CODE> attribute and no sequence constructor then the <A 
title="initial sequence" 
href="REC-xslt20-20070123.htm#dt-initial-sequence">initial 
sequence</A> (and therefore, the <A title="sorted sequence" 
href="REC-xslt20-20070123.htm#dt-sorted-sequence">sorted 
sequence</A>) is an empty sequence.</P>
<P><A id=err-XTSE1040 name=err-XTSE1040><SPAN class=error>[ERR 
XTSE1040]</SPAN></A> It is a <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A> if an <A 
href="REC-xslt20-20070123.htm#element-perform-sort"><CODE>xsl:perform-sort</CODE></A> 
instruction with a <CODE>select</CODE> attribute has any content other than <A 
href="REC-xslt20-20070123.htm#element-sort"><CODE>xsl:sort</CODE></A> 
and <A 
href="REC-xslt20-20070123.htm#element-fallback"><CODE>xsl:fallback</CODE></A> 
instructions.</P>
<P>The result of the <A 
href="REC-xslt20-20070123.htm#element-perform-sort"><CODE>xsl:perform-sort</CODE></A> 
instruction is the result of sorting its <A title="initial sequence" 
href="REC-xslt20-20070123.htm#dt-initial-sequence">initial 
sequence</A> using its contained <A title="sort key specification" 
href="REC-xslt20-20070123.htm#dt-sort-key-specification">sort 
key specification</A>.</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e20205 name=d5e20205></A>Example: Sorting a 
Sequence of Atomic Values </DIV>
<P>The following stylesheet function sorts a sequence of atomic values using the 
value itself as the sort key.</P>
<DIV class=exampleInner><PRE>&lt;xsl:function name="local:sort" as="xs:anyAtomicType*"&gt;
  &lt;xsl:param name="in" as="xs:anyAtomicType*"/&gt;
  &lt;xsl:perform-sort select="$in"&gt;
    &lt;xsl:sort select="."/&gt;
  &lt;/xsl:perform-sort&gt;
&lt;/xsl:function&gt;
</PRE></DIV></DIV>
<P>&nbsp;</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e20212 name=d5e20212></A>Example: Writing a 
Function to Perform a Sort </DIV>
<P>The following example defines a function that sorts books by price, and uses 
this function to output the five books that have the lowest prices:</P>
<DIV class=exampleInner><PRE>&lt;xsl:function name="bib:books-by-price" as="schema-element(bib:book)*"&gt;
  &lt;xsl:param name="in" as="schema-element(bib:book)*"/&gt;
  &lt;xsl:perform-sort select="$in"&gt;
    &lt;xsl:sort select="xs:decimal(bib:price)"/&gt;
  &lt;/xsl:perform-sort&gt;
&lt;/xsl:function&gt;
   ...
   &lt;xsl:copy-of select="bib:books-by-price(//bib:book)[position() = 1 to 5]"/&gt;

 
</PRE></DIV></DIV></DIV>
<DIV class=div2>
<H3><A id=sorted-iteration name=sorted-iteration></A>13.3 Processing a Sequence 
in Sorted Order</H3>
<P>When used within <A 
href="REC-xslt20-20070123.htm#element-for-each"><CODE>xsl:for-each</CODE></A> 
or <A 
href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A>, 
a <A title="sort key specification" 
href="REC-xslt20-20070123.htm#dt-sort-key-specification">sort 
key specification</A> indicates that the sequence of items selected by that 
instruction is to be processed in sorted order, not in the order of the supplied 
sequence.</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e20233 name=d5e20233></A>Example: Processing 
Elements in Sorted Order </DIV>
<P>For example, suppose an employee database has the form</P>
<DIV class=exampleInner><PRE>&lt;employees&gt;
  &lt;employee&gt;
    &lt;name&gt;
      &lt;given&gt;James&lt;/given&gt;
      &lt;family&gt;Clark&lt;/family&gt;
    &lt;/name&gt;
    ...
  &lt;/employee&gt;
&lt;/employees&gt;
</PRE></DIV>
<P>Then a list of employees sorted by name could be generated using:</P>
<DIV class=exampleInner><PRE>&lt;xsl:template match="employees"&gt;
  &lt;ul&gt;
    &lt;xsl:apply-templates select="employee"&gt;
      &lt;xsl:sort select="name/family"/&gt;
      &lt;xsl:sort select="name/given"/&gt;
    &lt;/xsl:apply-templates&gt;
  &lt;/ul&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="employee"&gt;
  &lt;li&gt;
    &lt;xsl:value-of select="name/given"/&gt;
    &lt;xsl:text&gt; &lt;/xsl:text&gt;
    &lt;xsl:value-of select="name/family"/&gt;
  &lt;/li&gt;
&lt;/xsl:template&gt;
</PRE></DIV></DIV>
<P>When used within <A 
href="REC-xslt20-20070123.htm#element-for-each-group"><CODE>xsl:for-each-group</CODE></A>, 
a <A title="sort key specification" 
href="REC-xslt20-20070123.htm#dt-sort-key-specification">sort 
key specification</A> indicates the order in which the groups are to be 
processed. For the effect of <A 
href="REC-xslt20-20070123.htm#element-for-each-group"><CODE>xsl:for-each-group</CODE></A>, 
see <A href="REC-xslt20-20070123.htm#grouping"><I>14 
Grouping</I></A>.</P></DIV></DIV>
<DIV class=div1>
<H2><A id=grouping name=grouping></A>14 Grouping</H2>
<P>The facilities described in this section are designed to allow items in a 
sequence to be grouped based on common values; for example it allows grouping of 
elements having the same value for a particular attribute, or elements with the 
same name, or elements with common values for any other <A title=expression 
href="REC-xslt20-20070123.htm#dt-expression">expression</A>. 
Since grouping identifies items with duplicate values, the same facilities also 
allow selection of the distinct values in a sequence of items, that is, the 
elimination of duplicates.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>Simple elimination of duplicates can also be achieved using the function <A 
href="http://www.w3.org/TR/xpath-functions/#func-distinct-values"><CODE>distinct-values</CODE></A><SUP><SMALL>FO</SMALL></SUP> 
in the <A title="core function" 
href="REC-xslt20-20070123.htm#dt-core-function">core 
function</A> library: see <A 
href="REC-xslt20-20070123.htm#xpath-functions">[Functions 
and Operators]</A>.</P></DIV>
<P>In addition these facilities allow grouping based on sequential position, for 
example selecting groups of adjacent <CODE>para</CODE> elements. The facilities 
also provide an easy way to do fixed-size grouping, for example identifying 
groups of three adjacent nodes, which is useful when arranging data in multiple 
columns.</P>
<P>For each group of items identified, it is possible to evaluate a <A 
title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A> for the group. Grouping is nestable to multiple levels so that 
groups of distinct items can be identified, then from among the distinct groups 
selected, further sub-grouping of distinct items in the current group can be 
done.</P>
<P>It is also possible for one item to participate in more than one group.</P>
<DIV class=div2>
<H3><A id=current-group name=current-group></A>14.1 The Current Group</H3><A 
id=function-current-group name=function-current-group></A>
<DIV class=proto><CODE class=function>current-group</CODE>()<CODE 
class=as>&nbsp;as&nbsp;</CODE><CODE class=return-type>item()*</CODE> </DIV>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-current-group 
title="current group" name=dt-current-group></A>The evaluation context for XPath 
<A title=expression 
href="REC-xslt20-20070123.htm#dt-expression">expressions</A> 
includes a <SPAN>component</SPAN> called the <B>current group</B>, which is a 
sequence. The current group is the collection of related items that are 
processed collectively in one iteration of the <A 
href="REC-xslt20-20070123.htm#element-for-each-group"><CODE>xsl:for-each-group</CODE></A> 
element.<SPAN class=definition>]</SPAN></P>
<P>While an <A 
href="REC-xslt20-20070123.htm#element-for-each-group"><CODE>xsl:for-each-group</CODE></A> 
instruction is being evaluated, the <A title="current group" 
href="REC-xslt20-20070123.htm#dt-current-group">current 
group</A> will be non-empty. At other times, it will be an empty sequence.</P>
<P>The function <A 
href="REC-xslt20-20070123.htm#function-current-group"><CODE>current-group</CODE></A> 
returns the current group.</P>
<P>The function takes no arguments.</P>
<P><A id=err-XTSE1060 name=err-XTSE1060><SPAN class=error>[ERR 
XTSE1060]</SPAN></A> It is a <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A> if the <A 
href="REC-xslt20-20070123.htm#function-current-group"><CODE>current-group</CODE></A> 
function is used within a <A title=pattern 
href="REC-xslt20-20070123.htm#dt-pattern">pattern</A>.</P></DIV>
<DIV class=div2>
<H3><A id=current-grouping-key name=current-grouping-key></A>14.2 The Current 
Grouping Key</H3><A id=function-current-grouping-key 
name=function-current-grouping-key></A>
<DIV class=proto><CODE class=function>current-grouping-key</CODE>()<CODE 
class=as>&nbsp;as&nbsp;</CODE><CODE class=return-type>xs:anyAtomicType?</CODE> 
</DIV>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-current-grouping-key 
title="current grouping key" name=dt-current-grouping-key></A>The evaluation 
context for XPath <A title=expression 
href="REC-xslt20-20070123.htm#dt-expression">expressions</A> 
includes a component called the <B>current grouping key</B>, which is an atomic 
value. The current grouping key is <SPAN>the <A title="grouping key" 
href="REC-xslt20-20070123.htm#dt-grouping-key">grouping 
key</A></SPAN> shared in common by all the items within the <A 
title="current group" 
href="REC-xslt20-20070123.htm#dt-current-group">current 
group</A>.<SPAN class=definition>]</SPAN></P>
<P>While an <A 
href="REC-xslt20-20070123.htm#element-for-each-group"><CODE>xsl:for-each-group</CODE></A> 
instruction with a <CODE>group-by</CODE> or <CODE>group-adjacent</CODE> 
attribute is being evaluated, the <A title="current grouping key" 
href="REC-xslt20-20070123.htm#dt-current-grouping-key">current 
grouping key</A> will be <SPAN>a single atomic value</SPAN>. At other times, it 
will be the empty sequence.</P>
<P>The function <A 
href="REC-xslt20-20070123.htm#function-current-grouping-key"><CODE>current-grouping-key</CODE></A> 
returns the <A title="current grouping key" 
href="REC-xslt20-20070123.htm#dt-current-grouping-key">current 
grouping key</A>.</P>
<P>Although the <A title="grouping key" 
href="REC-xslt20-20070123.htm#dt-grouping-key">grouping 
keys</A> of all items in a group are by definition equal, they are not 
necessarily identical. For example, one might be an <CODE>xs:float</CODE> while 
another is an <CODE>xs:decimal</CODE>. The <A 
href="REC-xslt20-20070123.htm#function-current-grouping-key"><CODE>current-grouping-key</CODE></A> 
function is defined to return the grouping key of the <A title="initial item" 
href="REC-xslt20-20070123.htm#dt-initial-item">initial 
item</A> in the group, after atomization and casting of 
<CODE>xs:untypedAtomic</CODE> to <CODE>xs:string</CODE>.</P>
<P>The function takes no arguments.</P>
<P><A id=err-XTSE1070 name=err-XTSE1070><SPAN class=error>[ERR 
XTSE1070]</SPAN></A> It is a <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A> if the <A 
href="REC-xslt20-20070123.htm#function-current-grouping-key"><CODE>current-grouping-key</CODE></A> 
function is used within a <A title=pattern 
href="REC-xslt20-20070123.htm#dt-pattern">pattern</A>.</P></DIV>
<DIV class=div2>
<H3><A id=xsl-for-each-group name=xsl-for-each-group></A>14.3 The 
<CODE>xsl:for-each-group</CODE> Element</H3>
<P class=element-syntax><A id=element-for-each-group 
name=element-for-each-group></A><CODE>&lt;!-- Category: instruction 
--&gt;<BR>&lt;xsl:for-each-group<BR>&nbsp;&nbsp;<B>select</B> = 
<VAR>expression</VAR><BR>&nbsp;&nbsp;group-by? = 
<VAR>expression</VAR><BR>&nbsp;&nbsp;group-adjacent? = 
<VAR>expression</VAR><BR>&nbsp;&nbsp;group-starting-with? = 
<VAR>pattern</VAR><BR>&nbsp;&nbsp;group-ending-with? = 
<VAR>pattern</VAR><BR>&nbsp;&nbsp;collation? = { <VAR>uri</VAR> 
}&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: (<A 
href="REC-xslt20-20070123.htm#element-sort">xsl:sort</A>*, 
<VAR>sequence-constructor</VAR>) 
--&gt;<BR>&lt;/xsl:for-each-group&gt;</CODE></P>
<P>This element is an <A title=instruction 
href="REC-xslt20-20070123.htm#dt-instruction">instruction</A> 
that may be used anywhere within a <A title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A>.</P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-group title=group 
name=dt-group></A>The <A 
href="REC-xslt20-20070123.htm#element-for-each-group"><CODE>xsl:for-each-group</CODE></A> 
instruction <SPAN>allocates the items in an input sequence</SPAN> into 
<B>groups</B> of items (that is, it establishes a collection of sequences) based 
either on common values of a grouping key, or on a <A title=pattern 
href="REC-xslt20-20070123.htm#dt-pattern">pattern</A> 
that the initial or final node in a group must match.<SPAN 
class=definition>]</SPAN> The <A title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A> that forms the content of the <A 
href="REC-xslt20-20070123.htm#element-for-each-group"><CODE>xsl:for-each-group</CODE></A> 
instruction is evaluated once for each of these groups.</P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-population 
title=population name=dt-population></A>The sequence of items to be grouped, 
which is referred to as the <B>population</B>, is determined by evaluating the 
XPath <A title=expression 
href="REC-xslt20-20070123.htm#dt-expression">expression</A> 
contained in the <CODE>select</CODE> attribute.<SPAN 
class=definition>]</SPAN></P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-population-order 
title="population order" name=dt-population-order></A>The population is treated 
as a sequence; the order of items in this sequence is referred to as 
<B>population order</B><SPAN class=definition>]</SPAN>.</P>
<P>A group is never empty. If the population is empty, the number of groups will 
be zero. The assignment of items to groups depends on the <CODE>group-by</CODE>, 
<CODE>group-adjacent</CODE>, <CODE>group-starting-with</CODE>, and 
<CODE>group-ending-with</CODE> attributes.</P>
<P><A id=err-XTSE1080 name=err-XTSE1080><SPAN class=error>[ERR 
XTSE1080]</SPAN></A> These four attributes are mutually exclusive: it is a <A 
title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A> if none of these four attributes is present, or if more than one of 
them is present.</P>
<P><A id=err-XTSE1090 name=err-XTSE1090><SPAN class=error>[ERR 
XTSE1090]</SPAN></A> It is an error to specify the <CODE>collation</CODE> 
attribute if neither the <CODE>group-by</CODE> attribute nor 
<CODE>group-adjacent</CODE> attribute is specified.</P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-grouping-key 
title="grouping key" name=dt-grouping-key></A>If either of the 
<CODE>group-by</CODE> attribute or <CODE>group-adjacent</CODE> attributes is 
present, then <B>grouping keys</B> are calculated for each item in the <A 
title=population 
href="REC-xslt20-20070123.htm#dt-population">population</A>. 
<SPAN>The grouping keys are the items in the sequence obtained by evaluating the 
expression contained in the <CODE>group-by</CODE> attribute or 
<CODE>group-adjacent</CODE> attribute, atomizing the result, and then casting an 
<CODE>xs:untypedAtomic</CODE> value to <CODE>xs:string</CODE>.</SPAN><SPAN 
class=definition>]</SPAN></P>
<P><SPAN>When calculating grouping keys for an item in the population,</SPAN> 
the <A title=expression 
href="REC-xslt20-20070123.htm#dt-expression">expression</A> 
contained in the <CODE>group-by</CODE> or <CODE>group-adjacent</CODE> attribute 
is evaluated with that item as the <A title="context item" 
href="REC-xslt20-20070123.htm#dt-context-item">context 
item</A>, with its position in <A title="population order" 
href="REC-xslt20-20070123.htm#dt-population-order">population 
order</A> as the <A title="context position" 
href="REC-xslt20-20070123.htm#dt-context-position">context 
position</A>, and with the size of the population as the <A title="context size" 
href="REC-xslt20-20070123.htm#dt-context-size">context 
size</A>. The resulting sequence is <A title=atomize 
href="REC-xslt20-20070123.htm#dt-atomization">atomized</A>, 
and each atomic value in the atomized sequence acts as a <A title="grouping key" 
href="REC-xslt20-20070123.htm#dt-grouping-key">grouping 
key</A> for that item in the population.</P>
<P>If the <CODE>group-by</CODE> attribute is present, then an item in the 
population may have multiple grouping keys: that is, the <CODE>group-by</CODE> 
expression evaluates to a sequence. The item is included in as many groups as 
there are distinct grouping keys (which may be zero). If the 
<CODE>group-adjacent</CODE> attribute is used, then each item in the population 
<SPAN class=verb>must</SPAN> have exactly one grouping key value.</P>
<P><A id=err-XTTE1100 name=err-XTTE1100><SPAN class=error>[ERR 
XTTE1100]</SPAN></A> It is a <A title="type errors" 
href="REC-xslt20-20070123.htm#dt-type-error">type 
error</A> if the <SPAN>grouping key evaluated using</SPAN> the 
<CODE>group-adjacent</CODE> attribute is an empty sequence, or a sequence 
containing more than one item.</P>
<P><A title="grouping key" 
href="REC-xslt20-20070123.htm#dt-grouping-key">Grouping 
keys</A> are compared using the rules for the <CODE>eq</CODE> operator 
appropriate to their dynamic type. <SPAN>Values of type</SPAN> 
<CODE>xs:untypedAtomic</CODE> are cast to <CODE>xs:string</CODE> before the 
comparison. Two items that are not comparable using the <CODE>eq</CODE> operator 
are considered to be not equal, that is, they are allocated to different groups. 
If the values are strings, or untyped atomic values, <SPAN>then if there is a 
<CODE>collation</CODE> attribute the values are compared using the collation 
specified as the <A title="effective value" 
href="REC-xslt20-20070123.htm#dt-effective-value">effective 
value</A> of the <CODE>collation</CODE> attribute, resolved if relative against 
the base URI of the <A 
href="REC-xslt20-20070123.htm#element-for-each-group"><CODE>xsl:for-each-group</CODE></A> 
element. If there is no <CODE>collation</CODE> attribute then the <A 
title="default collation" 
href="REC-xslt20-20070123.htm#dt-default-collation">default 
collation</A> is used.</SPAN></P>
<P>For the purposes of grouping, the value <CODE>NaN</CODE> is considered equal 
to itself.</P>
<P><A id=err-XTDE1110 name=err-XTDE1110><SPAN class=error>[ERR 
XTDE1110]</SPAN></A> It is a <A title="non-recoverable dynamic error" 
href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
dynamic error</A> if the collation URI specified to <A 
href="REC-xslt20-20070123.htm#element-for-each-group"><CODE>xsl:for-each-group</CODE></A> 
<SPAN>(after resolving against the base URI)</SPAN> is a collation that is not 
recognized by the implementation. (For notes, <SPAN class=error>[see <A 
href="REC-xslt20-20070123.htm#err-XTDE1035">ERR 
XTDE1035</A>]</SPAN>.)</P>
<P>For more information on collations, see <A 
href="REC-xslt20-20070123.htm#collating-sequences"><I>13.1.3 
Sorting Using Collations</I></A>.</P>
<P><A id=err-XTTE1120 name=err-XTTE1120><SPAN class=error>[ERR 
XTTE1120]</SPAN></A> When the <CODE>group-starting-with</CODE> or 
<CODE>group-ending-with</CODE> attribute is used, it is a <A title="type errors" 
href="REC-xslt20-20070123.htm#dt-type-error">type 
error</A> if the result of evaluating the <CODE>select</CODE> expression 
contains an item that is not a node.</P>
<UL>
  <LI>
  <P>If the <CODE>group-by</CODE> attribute is present, the items in the <A 
  title=population 
  href="REC-xslt20-20070123.htm#dt-population">population</A> 
  are examined, in population order. For each item <VAR>J</VAR>, the expression 
  in the <CODE>group-by</CODE> attribute is evaluated to produce a sequence of 
  zero or more <A title="grouping key" 
  href="REC-xslt20-20070123.htm#dt-grouping-key">grouping 
  key</A> values. For each one of these <A title="grouping key" 
  href="REC-xslt20-20070123.htm#dt-grouping-key">grouping 
  keys</A>, if there is already a group created to hold items having that 
  grouping key value, <VAR>J</VAR> is added to that group; otherwise a new group 
  is created for items with that grouping key value, and <VAR>J</VAR> becomes 
  its first member.</P>
  <P>An item in the population may thus be assigned to zero, one, or many 
  groups. An item will never be assigned more than once to the same group; if 
  two or more grouping keys for the same item are equal, then the duplicates are 
  ignored. An <EM>item</EM> here means the item at a particular position within 
  the population—if the population contains the same node at several different 
  positions in the sequence then a group may indeed contain duplicate nodes.</P>
  <P>The number of groups will be the same as the number of distinct grouping 
  key values present in the <A title=population 
  href="REC-xslt20-20070123.htm#dt-population">population</A>.</P>
  <LI>
  <P>If the <CODE>group-adjacent</CODE> attribute is present, the items in the 
  <A title=population 
  href="REC-xslt20-20070123.htm#dt-population">population</A> 
  are examined, in population order. If an item has the same value for the <A 
  title="grouping key" 
  href="REC-xslt20-20070123.htm#dt-grouping-key">grouping 
  key</A> as its preceding item within the <A title=population 
  href="REC-xslt20-20070123.htm#dt-population">population</A> 
  (in <A title="population order" 
  href="REC-xslt20-20070123.htm#dt-population-order">population 
  order</A>), then it is assigned to the same group as its preceding item; 
  otherwise a new group is created and the item becomes its first member.</P>
  <LI>
  <P>If the <CODE>group-starting-with</CODE> attribute is present, then its 
  value <SPAN class=verb>must</SPAN> be a <A 
  href="REC-xslt20-20070123.htm#NT-Pattern">pattern</A>. 
  In this case, the items in the population <SPAN class=verb>must</SPAN> all be 
  nodes.</P>
  <P>The nodes in the <A title=population 
  href="REC-xslt20-20070123.htm#dt-population">population</A> 
  are examined in <A title="population order" 
  href="REC-xslt20-20070123.htm#dt-population-order">population 
  order</A>. If a node matches the pattern, or is the first node in the 
  population, then a new group is created and the node becomes its first member. 
  Otherwise, the node is assigned to the same group as its preceding node within 
  the population.</P>
  <LI>
  <P>If the <CODE>group-ending-with</CODE> attribute is present, then its value 
  <SPAN class=verb>must</SPAN> be a <A 
  href="REC-xslt20-20070123.htm#NT-Pattern">pattern</A>. 
  In this case, the items in the population <SPAN class=verb>must</SPAN> all be 
  nodes.</P>
  <P>The nodes in the <A title=population 
  href="REC-xslt20-20070123.htm#dt-population">population</A> 
  are examined in <A title="population order" 
  href="REC-xslt20-20070123.htm#dt-population-order">population 
  order</A>. If a node is the first node in the population, or if the previous 
  node in the population matches the pattern, then a new group is created and 
  the node becomes its first member. Otherwise, the node is assigned to the same 
  group as its preceding node within the population.</P></LI></UL>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-initial-item 
title="initial item" name=dt-initial-item></A>For each <A title=group 
href="REC-xslt20-20070123.htm#dt-group">group</A>, the 
item within the group that is first in <A title="population order" 
href="REC-xslt20-20070123.htm#dt-population-order">population 
order</A> is known as the <B>initial item</B> of the group.<SPAN 
class=definition>]</SPAN></P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-first-appearance 
title="order of first appearance" name=dt-first-appearance></A>There is an 
ordering among <A title=group 
href="REC-xslt20-20070123.htm#dt-group">groups</A> 
referred to as the <B>order of first appearance</B>. A group <VAR>G</VAR> is 
defined to precede a group <VAR>H</VAR> in order of first appearance if the <A 
title="initial item" 
href="REC-xslt20-20070123.htm#dt-initial-item">initial 
item</A> of <VAR>G</VAR> precedes the initial item of <VAR>H</VAR> in population 
order. <SPAN>If two groups <VAR>G</VAR> and <VAR>H</VAR> have the same initial 
item (because the item is in both groups) then <VAR>G</VAR> precedes 
<VAR>H</VAR> if the <A title="grouping key" 
href="REC-xslt20-20070123.htm#dt-grouping-key">grouping 
key</A> of <VAR>G</VAR> precedes the grouping key of <VAR>H</VAR> in the 
sequence that results from evaluating the <CODE>group-by</CODE> expression of 
this initial item.</SPAN><SPAN class=definition>]</SPAN></P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-processing-order 
title="processing order" name=dt-processing-order></A>There is another ordering 
among groups referred to as <B>processing order</B>. <SPAN>If group <VAR>R</VAR> 
precedes group <VAR>S</VAR> in processing order, then in the result sequence 
returned by the <A 
href="REC-xslt20-20070123.htm#element-for-each-group"><CODE>xsl:for-each-group</CODE></A> 
instruction the items generated by processing group <VAR>R</VAR> will precede 
the items generated by processing group <VAR>S</VAR>.</SPAN><SPAN 
class=definition>]</SPAN></P>
<P>If there are no <A 
href="REC-xslt20-20070123.htm#element-sort"><CODE>xsl:sort</CODE></A> 
elements immediately within the <A 
href="REC-xslt20-20070123.htm#element-for-each-group"><CODE>xsl:for-each-group</CODE></A> 
element, the <A title="processing order" 
href="REC-xslt20-20070123.htm#dt-processing-order">processing 
order</A> of the <A title=group 
href="REC-xslt20-20070123.htm#dt-group">groups</A> is the 
<A title="order of first appearance" 
href="REC-xslt20-20070123.htm#dt-first-appearance">order 
of first appearance</A>.</P>
<P>Otherwise, the <A 
href="REC-xslt20-20070123.htm#element-sort"><CODE>xsl:sort</CODE></A> 
elements immediately within the <A 
href="REC-xslt20-20070123.htm#element-for-each-group"><CODE>xsl:for-each-group</CODE></A> 
element define the processing order of the <A title=group 
href="REC-xslt20-20070123.htm#dt-group">groups</A> (see 
<A href="REC-xslt20-20070123.htm#sorting"><I>13 
Sorting</I></A>). They do not affect the order of items within each group. 
Multiple <A title="sort key component" 
href="REC-xslt20-20070123.htm#dt-sort-key-component">sort 
key components</A> are allowed, and are evaluated in major-to-minor order. If 
two groups have the same values for all their sort key components, they are 
processed in order of first appearance.</P>
<P>The <CODE>select</CODE> <A title=expression 
href="REC-xslt20-20070123.htm#dt-expression">expression</A> 
of an <A 
href="REC-xslt20-20070123.htm#element-sort"><CODE>xsl:sort</CODE></A> 
element is evaluated once for each <A title=group 
href="REC-xslt20-20070123.htm#dt-group">group</A>. During 
this evaluation, the <A title="context item" 
href="REC-xslt20-20070123.htm#dt-context-item">context 
item</A> is the <A title="initial item" 
href="REC-xslt20-20070123.htm#dt-initial-item">initial 
item</A> of the group, the <A title="context position" 
href="REC-xslt20-20070123.htm#dt-context-position">context 
position</A> is the position of this item within the set of initial items (that 
is, one item for each group in the <A title=population 
href="REC-xslt20-20070123.htm#dt-population">population</A>) 
in <A title="population order" 
href="REC-xslt20-20070123.htm#dt-population-order">population 
order</A>, the <A title="context size" 
href="REC-xslt20-20070123.htm#dt-context-size">context 
size</A> is the number of groups, the <A title="current group" 
href="REC-xslt20-20070123.htm#dt-current-group">current 
group</A> is the group whose <A title="sort key value" 
href="REC-xslt20-20070123.htm#dt-sort-key-value">sort key 
value</A> is being determined, <SPAN>and the <A title="current grouping key" 
href="REC-xslt20-20070123.htm#dt-current-grouping-key">current 
grouping key</A> is the grouping key for that group. If the <A 
href="REC-xslt20-20070123.htm#element-for-each-group"><CODE>xsl:for-each-group</CODE></A> 
instruction uses the <CODE>group-starting-with</CODE> or 
<CODE>group-ending-with</CODE> attributes, then the current grouping key is the 
empty sequence.</SPAN></P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e21018 name=d5e21018></A>Example: Sorting 
Groups </DIV>
<P>For example, this means that if the <A title="grouping key" 
href="REC-xslt20-20070123.htm#dt-grouping-key">grouping 
key</A> is <CODE>@category</CODE>, you can sort the groups in order of their 
grouping key by writing <CODE>&lt;xsl:sort 
select="current-grouping-key()"/&gt;</CODE>; or you can sort the groups in order 
of size by writing <CODE>&lt;xsl:sort 
select="count(current-group())"/&gt;</CODE></P></DIV>
<P>The <A title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A> contained in the <A 
href="REC-xslt20-20070123.htm#element-for-each-group"><CODE>xsl:for-each-group</CODE></A> 
element is evaluated once for each of the <A title=group 
href="REC-xslt20-20070123.htm#dt-group">groups</A>, in <A 
title="processing order" 
href="REC-xslt20-20070123.htm#dt-processing-order">processing 
order</A>. The sequences that result are concatenated, in <A 
title="processing order" 
href="REC-xslt20-20070123.htm#dt-processing-order">processing 
order</A>, to form the result of the <A 
href="REC-xslt20-20070123.htm#element-for-each-group"><CODE>xsl:for-each-group</CODE></A> 
element. Within the <A title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A>, the <A title="context item" 
href="REC-xslt20-20070123.htm#dt-context-item">context 
item</A> is the <A title="initial item" 
href="REC-xslt20-20070123.htm#dt-initial-item">initial 
item</A> of the relevant group, the <A title="context position" 
href="REC-xslt20-20070123.htm#dt-context-position">context 
position</A> is the position of this item among the sequence of initial items 
(one item for each group) arranged in <A title="processing order" 
href="REC-xslt20-20070123.htm#dt-processing-order">processing 
order</A> of the groups, the <A title="context size" 
href="REC-xslt20-20070123.htm#dt-context-size">context 
size</A> is the number of groups, the <A title="current group" 
href="REC-xslt20-20070123.htm#dt-current-group">current 
group</A> is the <A title=group 
href="REC-xslt20-20070123.htm#dt-group">group</A> being 
processed, <SPAN>and the <A title="current grouping key" 
href="REC-xslt20-20070123.htm#dt-current-grouping-key">current 
grouping key</A> is the grouping key for that group. If the <A 
href="REC-xslt20-20070123.htm#element-for-each-group"><CODE>xsl:for-each-group</CODE></A> 
instruction uses the <CODE>group-starting-with</CODE> or 
<CODE>group-ending-with</CODE> attributes, then the current grouping key is the 
empty sequence.</SPAN> This has the effect that within the <A 
title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A>, a call on <CODE>position()</CODE> takes successive values 
<CODE>1, 2, ... last()</CODE>.</P>
<P>During the evaluation of a <A title="stylesheet function" 
href="REC-xslt20-20070123.htm#dt-stylesheet-function">stylesheet 
function</A>, the <A title="current group" 
href="REC-xslt20-20070123.htm#dt-current-group">current 
group</A> and <A title="current grouping key" 
href="REC-xslt20-20070123.htm#dt-current-grouping-key">current 
grouping key</A> are set to the empty sequence, and revert to their previous 
values on completion of evaluation of the stylesheet function.</P>
<P>On completion of the evaluation of the <A 
href="REC-xslt20-20070123.htm#element-for-each-group"><CODE>xsl:for-each-group</CODE></A> 
instruction, the <A title="current group" 
href="REC-xslt20-20070123.htm#dt-current-group">current 
group</A> <SPAN>and <A title="current grouping key" 
href="REC-xslt20-20070123.htm#dt-current-grouping-key">current 
grouping key</A></SPAN> revert to their previous value.</P></DIV>
<DIV class=div2>
<H3><A id=grouping-examples name=grouping-examples></A>14.4 Examples of 
Grouping</H3>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e21133 name=d5e21133></A>Example: Grouping 
Nodes based on Common Values </DIV>
<P>The following example groups a list of nodes based on common values. The 
resulting groups are numbered but unsorted, and a total is calculated for each 
group.</P>
<P>Source XML document:</P>
<DIV class=exampleInner><PRE>&lt;cities&gt;
  &lt;city name="Milano"  country="Italia"      pop="5"/&gt;
  &lt;city name="Paris"   country="France"      pop="7"/&gt;
  &lt;city name="München" country="Deutschland" pop="4"/&gt;
  &lt;city name="Lyon"    country="France"      pop="2"/&gt;
  &lt;city name="Venezia" country="Italia"      pop="1"/&gt;
&lt;/cities&gt;
</PRE></DIV>
<P>More specifically, the aim is to produce a four-column table, containing one 
row for each distinct country. The four columns are to contain first, a sequence 
number giving the number of the row; second, the name of the country, third, a 
comma-separated alphabetical list of the city names within that country, and 
fourth, the sum of the <CODE>pop</CODE> attribute for the cities in that 
country.</P>
<P>Desired output:</P>
<DIV class=exampleInner><PRE>&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;Position&lt;/th&gt;
    &lt;th&gt;Country&lt;/th&gt;
    &lt;th&gt;List of Cities&lt;/th&gt;
    &lt;th&gt;Population&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;1&lt;/td&gt;
    &lt;td&gt;Italia&lt;/td&gt;
    &lt;td&gt;Milano, Venezia&lt;/td&gt;
    &lt;td&gt;6&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;2&lt;/td&gt;
    &lt;td&gt;France&lt;/td&gt;
    &lt;td&gt;Lyon, Paris&lt;/td&gt;
    &lt;td&gt;9&lt;/td&gt;
  &lt;/tr&gt;  
  &lt;tr&gt;
    &lt;td&gt;3&lt;/td&gt;
    &lt;td&gt;Deutschland&lt;/td&gt;
    &lt;td&gt;München&lt;/td&gt;
    &lt;td&gt;4&lt;/td&gt;
  &lt;/tr&gt;  
&lt;/table&gt;
</PRE></DIV>
<P>Solution:</P>
<DIV class=exampleInner><PRE>&lt;table xsl:version="2.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;tr&gt;
    &lt;th&gt;Position&lt;/th&gt;
    &lt;th&gt;Country&lt;/th&gt;
    &lt;th&gt;City List&lt;/th&gt;
    &lt;th&gt;Population&lt;/th&gt;
  &lt;/tr&gt;
  &lt;xsl:for-each-group select="cities/city" group-by="@country"&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;xsl:value-of select="position()"/&gt;&lt;/td&gt;
      &lt;td&gt;&lt;xsl:value-of select="@country"/&gt;&lt;/td&gt;
      &lt;td&gt;
        &lt;xsl:value-of select="current-group()/@name" separator=", "/&gt;
      &lt;/td&gt;
      &lt;td&gt;&lt;xsl:value-of select="sum(current-group()/@pop)"/&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/xsl:for-each-group&gt;
&lt;/table&gt;
</PRE></DIV></DIV>
<P>&nbsp;</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e21156 name=d5e21156></A>Example: A Composite 
Grouping Key </DIV>
<P>Sometimes it is necessary to use a composite grouping key: for example, 
suppose the source document is similar to the one used in the previous examples, 
but allows multiple entries for the same country and city, such as:</P>
<DIV class=exampleInner><PRE>&lt;cities&gt;
  &lt;city name="Milano"  country="Italia"  year="1950"   pop="5.23"/&gt;
  &lt;city name="Milano"  country="Italia"  year="1960"   pop="5.29"/&gt;  
  &lt;city name="Padova"  country="Italia"  year="1950"   pop="0.69"/&gt;
  &lt;city name="Padova"  country="Italia"  year="1960"   pop="0.93"/&gt;    
  &lt;city name="Paris"   country="France"  year="1951"   pop="7.2"/&gt;
  &lt;city name="Paris"   country="France"  year="1961"   pop="7.6"/&gt;
&lt;/cities&gt;
</PRE></DIV>
<P>Now suppose we want to list the average value of <CODE>@pop</CODE> for each 
(country, name) combination. One way to handle this is to concatenate the parts 
of the key, for example <CODE>&lt;xsl:for-each-group select="concat(@country, 
'/', @name)"&gt;</CODE>. A more flexible solution is to nest one <A 
href="REC-xslt20-20070123.htm#element-for-each-group"><CODE>xsl:for-each-group</CODE></A> 
element directly inside another:</P>
<DIV class=exampleInner><PRE>&lt;xsl:for-each-group select="cities/city" group-by="@country"&gt;
  &lt;xsl:for-each-group select="current-group()" group-by="@name"&gt;
    &lt;p&gt;&lt;xsl:value-of select="@name"/&gt;, &lt;xsl:value-of select="@country"/&gt;:
        &lt;xsl:value-of select="avg(current-group()/@pop)"/&gt;&lt;/p&gt;
  &lt;/xsl:for-each-group&gt;
&lt;/xsl:for-each-group&gt;
</PRE></DIV>
<P>The two approaches are not precisely equivalent. If the code were changed to 
output the value of <CODE>position()</CODE> alongside <CODE>@name</CODE> then 
the first approach (a single <A 
href="REC-xslt20-20070123.htm#element-for-each-group"><CODE>xsl:for-each-group</CODE></A> 
element with a compound key) would number the groups (1, 2, 3), while the second 
approach (two nested <A 
href="REC-xslt20-20070123.htm#element-for-each-group"><CODE>xsl:for-each-group</CODE></A> 
elements) would number them (1, 2, 1).</P></DIV>
<P>&nbsp;</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e21190 name=d5e21190></A>Example: Identifying a 
Group by its Initial Element </DIV>
<P>The next example identifies a group not by the presence of a common value, 
but rather by adjacency in document order. A group consists of an 
<CODE>h2</CODE> element, followed by all the <CODE>p</CODE> elements up to the 
next <CODE>h2</CODE> element.</P>
<P>Source XML document:</P>
<DIV class=exampleInner><PRE>&lt;body&gt;
  &lt;h2&gt;Introduction&lt;/h2&gt;
  &lt;p&gt;XSLT is used to write stylesheets.&lt;/p&gt;
  &lt;p&gt;XQuery is used to query XML databases.&lt;/p&gt;
  &lt;h2&gt;What is a stylesheet?&lt;/h2&gt;
  &lt;p&gt;A stylesheet is an XML document used to define a transformation.&lt;/p&gt;
  &lt;p&gt;Stylesheets may be written in XSLT.&lt;/p&gt;
  &lt;p&gt;XSLT 2.0 introduces new grouping constructs.&lt;/p&gt;
&lt;/body&gt;
</PRE></DIV>
<P>Desired output:</P>
<DIV class=exampleInner><PRE>&lt;chapter&gt;
  &lt;section title="Introduction"&gt;
    &lt;para&gt;XSLT is used to write stylesheets.&lt;/para&gt;
    &lt;para&gt;XQuery is used to query XML databases.&lt;/para&gt;
  &lt;/section&gt; 
  &lt;section title="What is a stylesheet?"&gt;
    &lt;para&gt;A stylesheet is an XML document used to define a transformation.&lt;/para&gt;
    &lt;para&gt;Stylesheets may be written in XSLT.&lt;/para&gt;
    &lt;para&gt;XSLT 2.0 introduces new grouping constructs.&lt;/para&gt;
  &lt;/section&gt;
&lt;/chapter&gt;
</PRE></DIV>
<P>Solution:</P>
<DIV class=exampleInner><PRE>&lt;xsl:template match="body"&gt;
  &lt;chapter&gt;
        &lt;xsl:for-each-group select="*" group-starting-with="h2"      &gt;
          &lt;section title="{self::h2}"&gt;
            &lt;xsl:for-each select="current-group()[self::p]"&gt;
              &lt;para&gt;&lt;xsl:value-of select="."/&gt;&lt;/para&gt;
            &lt;/xsl:for-each&gt; 
          &lt;/section&gt;
        &lt;/xsl:for-each-group&gt;
  &lt;/chapter&gt;
&lt;/xsl:template&gt;
</PRE></DIV>
<P>The use of <CODE>title="{self::h2}"</CODE> rather than 
<CODE>title="{.}"</CODE> is to handle the case where the first element is not an 
<CODE>h2</CODE> element.</P></DIV>
<P>&nbsp;</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e21227 name=d5e21227></A>Example: Identifying a 
Group by its Final Element </DIV>
<P>The next example illustrates how a group of related elements can be 
identified by the last element in the group, rather than the first. Here the 
absence of the attribute <CODE>continued="yes"</CODE> indicates the end of the 
group.</P>
<P>Source XML document:</P>
<DIV class=exampleInner><PRE>&lt;doc&gt;
  &lt;page continued="yes"&gt;Some text&lt;/page&gt;
  &lt;page continued="yes"&gt;More text&lt;/page&gt;    
  &lt;page&gt;Yet more text&lt;/page&gt;
  &lt;page continued="yes"&gt;Some words&lt;/page&gt;
  &lt;page continued="yes"&gt;More words&lt;/page&gt;    
  &lt;page&gt;Yet more words&lt;/page&gt;        
&lt;/doc&gt;
</PRE></DIV>
<P>Desired output:</P>
<DIV class=exampleInner><PRE>&lt;doc&gt;
  &lt;pageset&gt;
    &lt;page&gt;Some text&lt;/page&gt;
    &lt;page&gt;More text&lt;/page&gt;    
    &lt;page&gt;Yet more text&lt;/page&gt;
  &lt;/pageset&gt;
  &lt;pageset&gt;
    &lt;page&gt;Some words&lt;/page&gt;
    &lt;page&gt;More words&lt;/page&gt;    
    &lt;page&gt;Yet more words&lt;/page&gt;
  &lt;/pageset&gt;
&lt;/doc&gt;
</PRE></DIV>
<P>Solution:</P>
<DIV class=exampleInner><PRE>&lt;xsl:template match="doc"&gt;
&lt;doc&gt;
  &lt;xsl:for-each-group select="*" 
                      group-ending-with="page[not(@continued='yes')]"&gt;
    &lt;pageset&gt;
      &lt;xsl:for-each select="current-group()"&gt;
        &lt;page&gt;&lt;xsl:value-of select="."/&gt;&lt;/page&gt;
      &lt;/xsl:for-each&gt; 
    &lt;/pageset&gt;
  &lt;/xsl:for-each-group&gt;
&lt;/doc&gt;
&lt;/xsl:template&gt;
</PRE></DIV></DIV>
<P>&nbsp;</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e21247 name=d5e21247></A>Example: Adding an 
Element to Several Groups </DIV>
<P>The next example shows how an item can be added to multiple groups. Book 
titles will be added to one group for each indexing term marked up within the 
title.</P>
<P>Source XML document:</P>
<DIV class=exampleInner><PRE>&lt;titles&gt;
    &lt;title&gt;A Beginner's Guide to &lt;ix&gt;Java&lt;/ix&gt;&lt;/title&gt;
    &lt;title&gt;Learning &lt;ix&gt;XML&lt;/ix&gt;&lt;/title&gt;
    &lt;title&gt;Using &lt;ix&gt;XML&lt;/ix&gt; with &lt;ix&gt;Java&lt;/ix&gt;&lt;/title&gt;
&lt;/titles&gt;
</PRE></DIV>
<P>Desired output:</P>
<DIV class=exampleInner><PRE>&lt;h2&gt;Java&lt;/h2&gt;
    &lt;p&gt;A Beginner's Guide to Java&lt;/p&gt;
    &lt;p&gt;Using XML with Java&lt;/p&gt;
&lt;h2&gt;XML&lt;/h2&gt;
    &lt;p&gt;Learning XML&lt;/p&gt;
    &lt;p&gt;Using XML with Java&lt;/p&gt;
</PRE></DIV>
<P>Solution:</P>
<DIV class=exampleInner><PRE>&lt;xsl:template match="titles"&gt;
    &lt;xsl:for-each-group select="title" group-by="ix"&gt;
      &lt;h2&gt;&lt;xsl:value-of select="current-grouping-key()"/&gt;&lt;/h2&gt;
      &lt;xsl:for-each select="current-group()"&gt;
        &lt;p&gt;&lt;xsl:value-of select="."/&gt;&lt;/p&gt;
      &lt;/xsl:for-each&gt;
    &lt;/xsl:for-each-group&gt;
&lt;/xsl:template&gt;
</PRE></DIV></DIV>
<P>&nbsp;</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e21264 name=d5e21264></A>Example: Grouping 
Alternating Sequences of Elements </DIV>
<P>In the final example, the membership of a node within a group is based both 
on adjacency of the nodes in document order, and on common values. In this case, 
the grouping key is a boolean condition, true or false, so the effect is that a 
grouping establishes a maximal sequence of nodes for which the condition is 
true, followed by a maximal sequence for which it is false, and so on.</P>
<P>Source XML document:</P>
<DIV class=exampleInner><PRE>&lt;p&gt;Do &lt;em&gt;not&lt;/em&gt;:
    &lt;ul&gt;
    &lt;li&gt;talk,&lt;/li&gt;
    &lt;li&gt;eat, or&lt;/li&gt;
    &lt;li&gt;use your mobile telephone&lt;/li&gt;
    &lt;/ul&gt;
    while you are in the cinema.&lt;/p&gt;
</PRE></DIV>
<P>Desired output:</P>
<DIV class=exampleInner><PRE>&lt;p&gt;Do &lt;em&gt;not&lt;/em&gt;:&lt;/p&gt;
    &lt;ul&gt;
    &lt;li&gt;talk,&lt;/li&gt;
    &lt;li&gt;eat, or&lt;/li&gt;
    &lt;li&gt;use your mobile telephone&lt;/li&gt;
    &lt;/ul&gt;
    &lt;p&gt;while you are in the cinema.&lt;/p&gt;
</PRE></DIV>
<P>Solution:</P>
<P>This requires creating a <CODE>p</CODE> element around the maximal sequence 
of sibling nodes that does not include a <CODE>ul</CODE> or <CODE>ol</CODE> 
element.</P>
<P>This can be done by using <CODE>group-adjacent</CODE>, with a grouping key 
that is true if the element is a <CODE>ul</CODE> or <CODE>ol</CODE> element, and 
false otherwise:</P>
<DIV class=exampleInner><PRE>&lt;xsl:template match="p"&gt;
    &lt;xsl:for-each-group select="node()" 
            group-adjacent="self::ul or self::ol"&gt;
        &lt;xsl:choose&gt;
            &lt;xsl:when test="current-grouping-key()"&gt;
                &lt;xsl:copy-of select="current-group()"/&gt;  
            &lt;/xsl:when&gt;
            &lt;xsl:otherwise&gt;
                &lt;p&gt;
                    &lt;xsl:copy-of select="current-group()"/&gt;
                &lt;/p&gt;
            &lt;/xsl:otherwise&gt;  
        &lt;/xsl:choose&gt;
    &lt;/xsl:for-each-group&gt;
&lt;/xsl:template&gt;
</PRE></DIV></DIV></DIV></DIV>
<DIV class=div1>
<H2><A id=regular-expressions name=regular-expressions></A>15 Regular 
Expressions</H2>
<P>The <A title="core function" 
href="REC-xslt20-20070123.htm#dt-core-function">core 
function</A> library for XPath 2.0 defines three functions that make use of 
regular expressions:</P>
<UL>
  <LI>
  <P><A 
  href="http://www.w3.org/TR/xpath-functions/#func-matches"><CODE>matches</CODE></A><SUP><SMALL>FO</SMALL></SUP> 
  returns a boolean result that indicates whether or not a string matches a 
  given regular expression.</P>
  <LI>
  <P><A 
  href="http://www.w3.org/TR/xpath-functions/#func-replace"><CODE>replace</CODE></A><SUP><SMALL>FO</SMALL></SUP> 
  takes a string as input and returns a string obtained by replacing all 
  substrings that match a given regular expression with a replacement 
string.</P>
  <LI>
  <P><A 
  href="http://www.w3.org/TR/xpath-functions/#func-tokenize"><CODE>tokenize</CODE></A><SUP><SMALL>FO</SMALL></SUP> 
  returns a sequence of strings formed by breaking a supplied input string at 
  any separator that matches a given regular expression.</P></LI></UL>
<P>These functions are described in <A 
href="REC-xslt20-20070123.htm#xpath-functions">[Functions 
and Operators]</A>.</P>
<P>For more complex string processing than is possible using these functions, 
XSLT provides an instruction <A 
href="REC-xslt20-20070123.htm#element-analyze-string"><CODE>xsl:analyze-string</CODE></A>, 
which is defined in this section.</P>
<P>The regular expressions used by this instruction, and the flags that control 
the interpretation of these regular expressions, <SPAN class=verb>must</SPAN> 
conform to the syntax defined in <A 
href="REC-xslt20-20070123.htm#xpath-functions">[Functions 
and Operators]</A> (see <A 
href="http://www.w3.org/TR/xpath-functions/#regex-syntax">Section 7.6.1 Regular 
Expression Syntax</A><SUP><SMALL>FO</SMALL></SUP>), which is itself based on the 
syntax defined in <A 
href="REC-xslt20-20070123.htm#xmlschema-2">[XML Schema 
Part 2]</A>.</P>
<DIV class=div2>
<H3><A id=analyze-string name=analyze-string></A>15.1 The 
<CODE>xsl:analyze-string</CODE> instruction</H3>
<P class=element-syntax><A id=element-analyze-string 
name=element-analyze-string></A><CODE>&lt;!-- Category: instruction 
--&gt;<BR>&lt;xsl:analyze-string<BR>&nbsp;&nbsp;<B>select</B> = 
<VAR>expression</VAR><BR>&nbsp;&nbsp;<B>regex</B> = { <VAR>string</VAR> 
}<BR>&nbsp;&nbsp;flags? = { <VAR>string</VAR> }&gt;<BR>&nbsp;&nbsp;&lt;!-- 
Content: (<A 
href="REC-xslt20-20070123.htm#element-matching-substring">xsl:matching-substring</A>?, 
<A 
href="REC-xslt20-20070123.htm#element-non-matching-substring">xsl:non-matching-substring</A>?, 
<A 
href="REC-xslt20-20070123.htm#element-fallback">xsl:fallback</A>*) 
--&gt;<BR>&lt;/xsl:analyze-string&gt;</CODE></P>
<P class=element-syntax><A id=element-matching-substring 
name=element-matching-substring></A><CODE>&lt;xsl:matching-substring&gt;<BR>&nbsp;&nbsp;&lt;!-- 
Content: <VAR>sequence-constructor</VAR> 
--&gt;<BR>&lt;/xsl:matching-substring&gt;</CODE></P>
<P class=element-syntax><A id=element-non-matching-substring 
name=element-non-matching-substring></A><CODE>&lt;xsl:non-matching-substring&gt;<BR>&nbsp;&nbsp;&lt;!-- 
Content: <VAR>sequence-constructor</VAR> 
--&gt;<BR>&lt;/xsl:non-matching-substring&gt;</CODE></P>
<P>The <A 
href="REC-xslt20-20070123.htm#element-analyze-string"><CODE>xsl:analyze-string</CODE></A> 
instruction takes as input a string (the result of evaluating the expression in 
the <CODE>select</CODE> attribute) and a regular expression (the effective value 
of the <CODE>regex</CODE> attribute).</P>
<P>If the result of evaluating the <CODE>select</CODE> expression is not a 
string, it is converted to a string by applying the <A 
title="function conversion rules" 
href="REC-xslt20-20070123.htm#dt-function-conversion-rules">function 
conversion rules</A>.</P>
<P>The <CODE>flags</CODE> attribute may be used to control the interpretation of 
the regular expression. If the attribute is omitted, the effect is the same as 
supplying a zero-length string. This is interpreted in the same way as the 
<CODE>$flags</CODE> attribute of the functions <A 
href="http://www.w3.org/TR/xpath-functions/#func-matches"><CODE>matches</CODE></A><SUP> 
<SMALL>FO</SMALL></SUP>, <A 
href="http://www.w3.org/TR/xpath-functions/#func-replace"><CODE>replace</CODE></A><SUP> 
<SMALL>FO</SMALL></SUP>, and <A 
href="http://www.w3.org/TR/xpath-functions/#func-tokenize"><CODE>tokenize</CODE></A><SUP><SMALL>FO</SMALL></SUP>. 
<SPAN>Specifically, if it contains the letter <CODE>m</CODE>, the match operates 
in multiline mode. If it contains the letter <CODE>s</CODE>, it operates in 
dot-all mode. If it contains the letter <CODE>i</CODE>, it operates in 
case-insensitive mode. If it contains the letter <CODE>x</CODE>, then whitespace 
within the regular expression is ignored. For more detailed specifications of 
these modes, see <A 
href="REC-xslt20-20070123.htm#xpath-functions">[Functions 
and Operators]</A> (<A 
href="http://www.w3.org/TR/xpath-functions/#flags">Section 7.6.1.1 
Flags</A><SUP><SMALL>FO</SMALL></SUP>).</SPAN></P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>Because the <CODE>regex</CODE> attribute is an attribute value template, 
curly brackets within the regular expression must be doubled. For example, to 
match a sequence of one to five characters, write <CODE>regex=".{{1,5}}"</CODE>. 
<SPAN>For regular expressions containing many curly brackets it may be more 
convenient to use a notation such as 
<CODE>regex="{'[0-9]{1,5}[a-z]{3}[0-9]{1,2}'}"</CODE>, or to use a 
variable.</SPAN></P></DIV>
<P>The content of the <A 
href="REC-xslt20-20070123.htm#element-analyze-string"><CODE>xsl:analyze-string</CODE></A> 
instruction must take one of the following forms:</P>
<OL class=enumar>
  <LI>
  <P>A single <A 
  href="REC-xslt20-20070123.htm#element-matching-substring"><CODE>xsl:matching-substring</CODE></A> 
  instruction, followed by zero or more <A 
  href="REC-xslt20-20070123.htm#element-fallback"><CODE>xsl:fallback</CODE></A> 
  instructions</P>
  <LI>
  <P>A single <A 
  href="REC-xslt20-20070123.htm#element-non-matching-substring"><CODE>xsl:non-matching-substring</CODE></A> 
  instruction, followed by zero or more <A 
  href="REC-xslt20-20070123.htm#element-fallback"><CODE>xsl:fallback</CODE></A> 
  instructions</P>
  <LI>
  <P>A single <A 
  href="REC-xslt20-20070123.htm#element-matching-substring"><CODE>xsl:matching-substring</CODE></A> 
  instruction, followed by a single <A 
  href="REC-xslt20-20070123.htm#element-non-matching-substring"><CODE>xsl:non-matching-substring</CODE></A> 
  instruction, followed by zero or more <A 
  href="REC-xslt20-20070123.htm#element-fallback"><CODE>xsl:fallback</CODE></A> 
  instructions</P></LI></OL>
<P><A id=err-XTSE1130 name=err-XTSE1130><SPAN class=error>[ERR 
XTSE1130]</SPAN></A> It is a <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A> if the <A 
href="REC-xslt20-20070123.htm#element-analyze-string"><CODE>xsl:analyze-string</CODE></A> 
instruction contains neither an <A 
href="REC-xslt20-20070123.htm#element-matching-substring"><CODE>xsl:matching-substring</CODE></A> 
nor an <A 
href="REC-xslt20-20070123.htm#element-non-matching-substring"><CODE>xsl:non-matching-substring</CODE></A> 
element.</P>
<P><SPAN>Any <A 
href="REC-xslt20-20070123.htm#element-fallback"><CODE>xsl:fallback</CODE></A> 
elements among the children of the <A 
href="REC-xslt20-20070123.htm#element-analyze-string"><CODE>xsl:analyze-string</CODE></A> 
instruction</SPAN> are ignored by an XSLT 2.0 processor, but allow fallback 
behavior to be defined when the stylesheet is used with an XSLT 1.0 processor 
operating in forwards-compatible mode.</P>
<P>This instruction is designed to process all the non-overlapping substrings of 
the input string that match the regular expression supplied.</P>
<P><A id=err-XTDE1140 name=err-XTDE1140><SPAN class=error>[ERR 
XTDE1140]</SPAN></A> It is a <A title="non-recoverable dynamic error" 
href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
dynamic error</A> if the <A title="effective value" 
href="REC-xslt20-20070123.htm#dt-effective-value">effective 
value</A> of the <CODE>regex</CODE> attribute does not conform to the <SPAN 
class=verb>required</SPAN> syntax for regular expressions, as specified in <A 
href="REC-xslt20-20070123.htm#xpath-functions">[Functions 
and Operators]</A>. If the regular expression is known statically (for example, 
if the attribute does not contain any <A title=expression 
href="REC-xslt20-20070123.htm#dt-expression">expressions</A> 
enclosed in curly brackets) then the processor <SPAN class=verb>may</SPAN> 
signal the error as a <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A>.</P>
<P><A id=err-XTDE1145 name=err-XTDE1145><SPAN class=error>[ERR 
XTDE1145]</SPAN></A> It is a <A title="non-recoverable dynamic error" 
href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
dynamic error</A> if the <A title="effective value" 
href="REC-xslt20-20070123.htm#dt-effective-value">effective 
value</A> of the <CODE>flags</CODE> attribute has a value other than the values 
defined in <A 
href="REC-xslt20-20070123.htm#xpath-functions">[Functions 
and Operators]</A>. If the value of the attribute is known statically (for 
example, if the attribute does not contain any <A title=expression 
href="REC-xslt20-20070123.htm#dt-expression">expressions</A> 
enclosed in curly brackets) then the processor <SPAN class=verb>may</SPAN> 
signal the error as a <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A>.</P>
<P><A id=err-XTDE1150 name=err-XTDE1150><SPAN class=error>[ERR 
XTDE1150]</SPAN></A> It is a <A title="non-recoverable dynamic error" 
href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
dynamic error</A> if the <A title="effective value" 
href="REC-xslt20-20070123.htm#dt-effective-value">effective 
value</A> of the <CODE>regex</CODE> attribute is a regular expression that 
matches a zero-length string: or more specifically, if the regular expression 
<CODE>$r</CODE> and flags <CODE>$f</CODE> are such that <CODE>matches("", $r, 
$f)</CODE> returns true. If the regular expression is known statically (for 
example, if the attribute does not contain any <A title=expression 
href="REC-xslt20-20070123.htm#dt-expression">expressions</A> 
enclosed in curly brackets) then the processor <SPAN class=verb>may</SPAN> 
signal the error as a <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A>.</P>
<P>The <A 
href="REC-xslt20-20070123.htm#element-analyze-string"><CODE>xsl:analyze-string</CODE></A> 
instruction starts at the beginning of the input string and attempts to find the 
first substring that matches the regular expression. If there are several 
matches, the first match is defined to be the one whose starting position comes 
first in the string. If several alternatives within the regular expression both 
match at the same position in the input string, then the match that is chosen is 
the first alternative that matches. For example, if the input string is 
<CODE>The quick brown fox jumps</CODE> and the regular expression is 
<CODE>jump|jumps</CODE>, then the match that is chosen is <CODE>jump</CODE>.</P>
<P>Having found the first match, the instruction proceeds to find the second and 
subsequent matches by repeating the search, starting at the first character that 
was not included in the previous match.</P>
<P>The input string is thus partitioned into a sequence of substrings, some of 
which match the regular expression, others which do not match it. Each substring 
will contain at least one character. This sequence of substrings is processed 
using the <A 
href="REC-xslt20-20070123.htm#element-matching-substring"><CODE>xsl:matching-substring</CODE></A> 
and <A 
href="REC-xslt20-20070123.htm#element-non-matching-substring"><CODE>xsl:non-matching-substring</CODE></A> 
child instructions. A matching substring is processed using the <A 
href="REC-xslt20-20070123.htm#element-matching-substring"><CODE>xsl:matching-substring</CODE></A> 
element, a non-matching substring using the <A 
href="REC-xslt20-20070123.htm#element-non-matching-substring"><CODE>xsl:non-matching-substring</CODE></A> 
element. Each of these elements takes a sequence constructor as its content. If 
the element is absent, the effect is the same as if it were present with empty 
content. In processing each substring, the contents of the substring will be the 
<A title="context item" 
href="REC-xslt20-20070123.htm#dt-context-item">context 
item</A> (as a value of type <CODE>xs:string</CODE>); the position of the 
substring within the sequence of matching and non-matching substrings will be 
the <A title="context position" 
href="REC-xslt20-20070123.htm#dt-context-position">context 
position</A>; and the number of matching and non-matching substrings will be the 
<A title="context size" 
href="REC-xslt20-20070123.htm#dt-context-size">context 
size</A>.</P>
<P>If the input is a zero-length string, the number of substrings will be zero, 
so neither the <A 
href="REC-xslt20-20070123.htm#element-matching-substring"><CODE>xsl:matching-substring</CODE></A> 
nor <A 
href="REC-xslt20-20070123.htm#element-non-matching-substring"><CODE>xsl:non-matching-substring</CODE></A> 
elements will be evaluated.</P></DIV>
<DIV class=div2>
<H3><A id=regex-group name=regex-group></A>15.2 Captured Substrings</H3><A 
id=function-regex-group name=function-regex-group></A>
<DIV class=proto><CODE class=function>regex-group</CODE>(<CODE 
class=arg>$group-number</CODE><CODE class=as>&nbsp;as&nbsp;</CODE><CODE 
class=type>xs:integer</CODE>)<CODE class=as>&nbsp;as&nbsp;</CODE><CODE 
class=return-type>xs:string</CODE> </DIV>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A 
id=dt-current-captured-substrings title="current captured substrings" 
name=dt-current-captured-substrings></A>While the <A 
href="REC-xslt20-20070123.htm#element-matching-substring"><CODE>xsl:matching-substring</CODE></A> 
instruction is active, a set of <B>current captured substrings</B> is available, 
corresponding to the parenthesized sub-expressions of the regular 
expression.<SPAN class=definition>]</SPAN> These captured substrings are 
accessible using the function <A 
href="REC-xslt20-20070123.htm#function-regex-group"><CODE>regex-group</CODE></A>. 
This function takes an integer argument to identify the group, and returns a 
string representing the captured substring.</P>
<P>The <VAR>N</VAR>th captured substring (where <VAR>N</VAR> &gt; 0) is the 
string matched by the subexpression contained by the <VAR>N</VAR>th left 
parenthesis in the regex. The zeroeth captured substring is the string that 
matches the entire regex. This means that the value of 
<CODE>regex-group(0)</CODE> is initially the same as the value of <CODE>.</CODE> 
(dot).</P>
<P>The function returns the zero-length string if there is no captured substring 
with the relevant number. This can occur for a number of reasons:</P>
<OL class=enumar>
  <LI>
  <P>The number is negative.</P>
  <LI>
  <P>The regular expression does not contain a parenthesized sub-expression with 
  the given number.</P>
  <LI>
  <P>The parenthesized sub-expression exists, and did not match any part of the 
  input string.</P>
  <LI>
  <P>The parenthesized sub-expression exists, and matched a zero-length 
  substring of the input string.</P></LI></OL>
<P>The set of captured substrings is a context variable with dynamic scope. It 
is initially an empty sequence. During the evaluation of an <A 
href="REC-xslt20-20070123.htm#element-matching-substring"><CODE>xsl:matching-substring</CODE></A> 
instruction it is set to the sequence of matched substrings for that regex 
match. During the evaluation of an <A 
href="REC-xslt20-20070123.htm#element-non-matching-substring"><CODE>xsl:non-matching-substring</CODE></A> 
instruction or a <A title=pattern 
href="REC-xslt20-20070123.htm#dt-pattern">pattern</A> or 
a <A title="stylesheet function" 
href="REC-xslt20-20070123.htm#dt-stylesheet-function">stylesheet 
function</A> it is set to an empty sequence. On completion of an instruction 
that changes the value, the variable reverts to its previous value.</P>
<P>The value of the <A title="current captured substrings" 
href="REC-xslt20-20070123.htm#dt-current-captured-substrings">current 
captured substrings</A> is unaffected through calls of <A 
href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-call-template"><CODE>xsl:call-template</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-apply-imports"><CODE>xsl:apply-imports</CODE></A> 
or <A 
href="REC-xslt20-20070123.htm#element-next-match"><CODE>xsl:next-match</CODE></A>, 
or by expansion of named <A title="attribute set" 
href="REC-xslt20-20070123.htm#dt-attribute-set">attribute 
sets</A>.</P></DIV>
<DIV class=div2>
<H3><A id=regex-examples name=regex-examples></A>15.3 Examples of Regular 
Expression Matching</H3>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e21776 name=d5e21776></A>Example: Replacing 
Characters by Elements </DIV>
<P>Problem: replace all newline characters in the <CODE>abstract</CODE> element 
by empty <CODE>br</CODE> elements:</P>
<P>Solution:</P>
<DIV class=exampleInner><PRE>&lt;xsl:analyze-string select="abstract" regex="\n"&gt;
  &lt;xsl:matching-substring&gt;
    &lt;br/&gt;
  &lt;/xsl:matching-substring&gt;
  &lt;xsl:non-matching-substring&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:non-matching-substring&gt;
&lt;/xsl:analyze-string&gt;
</PRE></DIV></DIV>
<P>&nbsp;</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e21791 name=d5e21791></A>Example: Recognizing 
non-XML Markup Structure </DIV>
<P>Problem: replace all occurrences of <CODE>[...]</CODE> in the 
<CODE>body</CODE> by <CODE>cite</CODE> elements, retaining the content between 
the square brackets as the content of the new element.</P>
<P>Solution:</P>
<DIV class=exampleInner><PRE>&lt;xsl:analyze-string select="body" regex="\[(.*?)\]"&gt;
  &lt;xsl:matching-substring&gt;
    &lt;cite&gt;&lt;xsl:value-of select="regex-group(1)"/&gt;&lt;/cite&gt;
  &lt;/xsl:matching-substring&gt;
  &lt;xsl:non-matching-substring&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:non-matching-substring&gt;
&lt;/xsl:analyze-string&gt;
</PRE></DIV>
<P>Note that this simple approach fails if the <CODE>body</CODE> element 
contains markup that needs to be retained. In this case it is necessary to apply 
the regular expression processing to each text node individually. If the 
<CODE>[...]</CODE> constructs span multiple text nodes (for example, because 
there are elements within the square brackets) then it probably becomes 
necessary to make two or more passes over the data.</P></DIV>
<P>&nbsp;</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e21817 name=d5e21817></A>Example: Parsing a 
Date </DIV>
<P>Problem: the input string contains a date such as <CODE>23 March 2002</CODE>. 
Convert it to the form <CODE>2002-03-23</CODE>.</P>
<P>Solution (with no error handling if the input format is incorrect):</P>
<DIV class=exampleInner><PRE>&lt;xsl:variable name="months" select="'January', 'February', 'March', ..."/&gt;

&lt;xsl:analyze-string select="normalize-space($input)" 
    regex="([0-9]{{1,2}})\s([A-Z][a-z]+)\s([0-9]{{4}})"&gt;
    &lt;xsl:matching-substring&gt;
        &lt;xsl:number value="regex-group(3)" format="0001"/&gt;          
        &lt;xsl:text&gt;-&lt;/xsl:text&gt;
        &lt;xsl:number value="index-of($months, regex-group(2))" format="01"/&gt;
        &lt;xsl:text&gt;-&lt;/xsl:text&gt;
        &lt;xsl:number value="regex-group(1)" format="01"/&gt;
    &lt;/xsl:matching-substring&gt;
&lt;/xsl:analyze-string&gt;
</PRE></DIV>
<P>Note the use of <CODE>normalize-space</CODE> to simplify the work done by the 
regular expression, and the use of doubled curly brackets because the 
<CODE>regex</CODE> attribute is an attribute value 
template.</P></DIV></DIV></DIV>
<DIV class=div1>
<H2><A id=add-func name=add-func></A>16 Additional Functions</H2>
<P>This section describes XSLT-specific additions to the <A 
title="core function" 
href="REC-xslt20-20070123.htm#dt-core-function">core 
function</A> library. Some of these additional functions also make use of 
information specified by <A title=declaration 
href="REC-xslt20-20070123.htm#dt-declaration">declarations</A> 
in the stylesheet; this section also describes these declarations.</P>
<DIV class=div2>
<H3><A id=document name=document></A>16.1 Multiple Source Documents</H3><A 
id=function-document name=function-document></A>
<DIV class=proto><CODE class=function>document</CODE>(<CODE 
class=arg>$uri-sequence</CODE><CODE class=as>&nbsp;as&nbsp;</CODE><CODE 
class=type>item()*</CODE>)<CODE class=as>&nbsp;as&nbsp;</CODE><CODE 
class=return-type>node()*</CODE> </DIV>
<DIV class=proto><CODE class=function>document</CODE>(<CODE 
class=arg>$uri-sequence</CODE><CODE class=as>&nbsp;as&nbsp;</CODE><CODE 
class=type>item()*</CODE>, <CODE class=arg>$base-node</CODE><CODE 
class=as>&nbsp;as&nbsp;</CODE><CODE class=type>node()</CODE>)<CODE 
class=as>&nbsp;as&nbsp;</CODE><CODE class=return-type>node()*</CODE> </DIV>
<P>The <A 
href="REC-xslt20-20070123.htm#function-document"><CODE>document</CODE></A> 
function allows access to XML documents identified by a URI.</P>
<P>The first argument contains a sequence of URI references. The second 
argument, if present, is a node whose base URI is used to resolve any relative 
URI references contained in the first argument.</P>
<P>A sequence of absolute URI references is obtained as follows.</P>
<UL>
  <LI>
  <P>For an item in <CODE>$uri-sequence</CODE> that is an instance of 
  <CODE>xs:string</CODE>, <CODE>xs:anyURI</CODE>, or 
  <SPAN><CODE>xs:untypedAtomic</CODE></SPAN>, the value is cast to 
  <CODE>xs:anyURI</CODE>. If the resulting URI reference is an absolute URI 
  reference then it is used <EM>as is</EM>. If it is a relative URI reference, 
  then it is resolved against the base URI of <CODE>$base-node</CODE> if 
  supplied, or against the base URI from the static context otherwise (this will 
  usually be the base URI of the stylesheet module). A relative URI is resolved 
  against a base URI using the rules defined in <A 
  href="REC-xslt20-20070123.htm#RFC3986">[RFC3986]</A>.</P>
  <LI>
  <P>For an item in <CODE>$uri-sequence</CODE> that is a node, the node is <A 
  title=atomize 
  href="REC-xslt20-20070123.htm#dt-atomization">atomized</A>. 
  The result <SPAN class=verb>must</SPAN> be a sequence whose items are all 
  instances of <CODE>xs:string</CODE>, <CODE>xs:anyURI</CODE>, or 
  <SPAN><CODE>xs:untypedAtomic</CODE></SPAN>. Each of these values is cast to 
  <CODE>xs:anyURI</CODE>, and if the resulting URI reference is an absolute URI 
  reference then it is used <EM>as is</EM>. If it is a relative URI reference, 
  then it is resolved against the base URI of <CODE>$base-node</CODE> if 
  supplied, or against the base URI of the node that contained it 
  otherwise.</P></LI></UL>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>The XPath rules for function calling ensure that it is a type error if the 
supplied value of the second argument is anything other than a single node. If 
<A title="XPath 1.0 compatibility mode" 
href="REC-xslt20-20070123.htm#dt-compatibility-mode">XPath 
1.0 compatibility mode</A> is enabled, then a sequence of nodes may be supplied, 
and the first node in the sequence will be used.</P></DIV>
<P>Each of these absolute URI references is then processed as follows. Any 
fragment identifier that is present in the URI reference is removed, and the 
resulting absolute URI is cast to a string and then passed to the <A 
href="http://www.w3.org/TR/xpath-functions/#func-doc"><CODE>doc</CODE></A><SUP> 
<SMALL>FO</SMALL></SUP> function defined in <A 
href="REC-xslt20-20070123.htm#xpath-functions">[Functions 
and Operators]</A>. This returns a document node. If an error occurs during 
evaluation of the <A 
href="http://www.w3.org/TR/xpath-functions/#func-doc"><CODE>doc</CODE></A><SUP> 
<SMALL>FO</SMALL></SUP> function, the processor <SPAN class=verb>may</SPAN> 
either signal this error in the normal way, or <SPAN class=verb>may</SPAN> 
recover by ignoring the failure, in which case the failing URI will not 
contribute any nodes to the result of the <A 
href="REC-xslt20-20070123.htm#function-document"><CODE>document</CODE></A> 
function.</P>
<P>If the URI reference contained no fragment identifier, then this document 
node is included in the sequence of nodes returned by the <A 
href="REC-xslt20-20070123.htm#function-document"><CODE>document</CODE></A> 
function.</P>
<P>If the URI reference contained a fragment identifier, then the fragment 
identifier is interpreted according to the rules for the media type of the 
resource <SPAN>representation</SPAN> identified by the URI, and is used to 
select zero or more nodes that are descendant-or-self nodes of the returned 
document node. As described in <A 
href="REC-xslt20-20070123.htm#initiating"><I>2.3 
Initiating a Transformation</I></A>, the media type is available as part of the 
evaluation context for a transformation.</P>
<P><A id=err-XTRE1160 name=err-XTRE1160><SPAN class=error>[ERR 
XTRE1160]</SPAN></A> When a URI reference contains a fragment identifier, it is 
a <A title="recoverable error" 
href="REC-xslt20-20070123.htm#dt-recoverable-error">recoverable 
dynamic error</A> if the media type is not one that is recognized by the 
processor, or if the fragment identifier does not conform to the rules for 
fragment identifiers for that media type, or if the fragment identifier selects 
something other than a sequence of nodes (for example, if it selects a range of 
characters within a text node). The <A title="optional recovery action" 
href="REC-xslt20-20070123.htm#dt-optional-recovery-action">optional 
recovery action</A> is to ignore the fragment identifier and return the document 
node. The set of media types recognized by a processor is <A 
title=implementation-defined 
href="REC-xslt20-20070123.htm#dt-implementation-defined">implementation-defined</A>.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>The recovery action here is different from XSLT 1.0</P></DIV>
<P>The sequence of nodes returned by the function is in document order, with no 
duplicates. This order has no necessary relationship to the order in which URIs 
were supplied in the <CODE>$uri-sequence</CODE> argument.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>One effect of these rules is that unless XML entities or 
<CODE>xml:base</CODE> are used, and provided that the base URI of the stylesheet 
module is known, <CODE>document("")</CODE> refers to the document node of the 
containing stylesheet module (the definitive rules are in <SPAN><A 
href="REC-xslt20-20070123.htm#RFC3986">[RFC3986]</A></SPAN>). 
The XML resource containing the stylesheet module is processed exactly as if it 
were any other XML document, for example there is no special recognition of <A 
href="REC-xslt20-20070123.htm#element-text"><CODE>xsl:text</CODE></A> 
elements, and no special treatment of comments and processing 
instructions.</P></DIV></DIV>
<DIV class=div2>
<H3><A id=unparsed-text name=unparsed-text></A>16.2 Reading Text Files</H3><A 
id=function-unparsed-text name=function-unparsed-text></A>
<DIV class=proto><CODE class=function>unparsed-text</CODE>(<CODE 
class=arg>$href</CODE><CODE class=as>&nbsp;as&nbsp;</CODE><CODE 
class=type>xs:string?</CODE>)<CODE class=as>&nbsp;as&nbsp;</CODE><CODE 
class=return-type>xs:string?</CODE> </DIV>
<DIV class=proto><CODE class=function>unparsed-text</CODE>(<CODE 
class=arg>$href</CODE><CODE class=as>&nbsp;as&nbsp;</CODE><CODE 
class=type>xs:string?</CODE>, <CODE class=arg>$encoding</CODE><CODE 
class=as>&nbsp;as&nbsp;</CODE><CODE class=type>xs:string</CODE>)<CODE 
class=as>&nbsp;as&nbsp;</CODE><CODE class=return-type>xs:string?</CODE> </DIV>
<P>The <A 
href="REC-xslt20-20070123.htm#function-unparsed-text"><CODE>unparsed-text</CODE></A> 
function reads an external resource (for example, a file) and returns its 
contents as a string.</P>
<P>The <CODE>$href</CODE> argument <SPAN class=verb>must</SPAN> be <SPAN>a 
string in the form of a URI</SPAN>. The URI <SPAN class=verb>must</SPAN> contain 
no fragment identifier, and <SPAN class=verb>must</SPAN> identify a resource 
that can be read as text. If the URI is a relative URI, then it is resolved 
relative to the base URI from the static context.</P>
<P>If the value of the <CODE>$href</CODE> argument is an empty sequence, the 
function returns an empty sequence.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>If a different base URI is appropriate (for example, when resolving a 
relative URI read from a source document) then the relative URI should be 
resolved using the <A 
href="http://www.w3.org/TR/xpath-functions/#func-resolve-uri"><CODE>resolve-uri</CODE></A><SUP><SMALL>FO</SMALL></SUP> 
function before passing it to the <A 
href="REC-xslt20-20070123.htm#function-unparsed-text"><CODE>unparsed-text</CODE></A> 
function.</P></DIV>
<P>The <CODE>$encoding</CODE> argument, if present, is the name of an encoding. 
The values for this attribute follow the same rules as for the 
<CODE>encoding</CODE> attribute in an XML declaration. The only values which 
every <A title=implementation 
href="REC-xslt20-20070123.htm#dt-implementation">implementation</A> 
is <SPAN class=verb>required</SPAN> to recognize are <CODE>utf-8</CODE> and 
<CODE>utf-16</CODE>.</P>
<P>The encoding of the external resource is determined as follows:</P>
<OL class=enumar>
  <LI>
  <P>external encoding information is used if available, otherwise</P>
  <LI>
  <P>if the media type of the resource is <CODE>text/xml</CODE> or 
  <CODE>application/xml</CODE> (see <A 
  href="REC-xslt20-20070123.htm#RFC2376">[RFC2376]</A>), 
  or if it matches the conventions <CODE>text/*+xml</CODE> or 
  <CODE>application/*+xml</CODE> (see <A 
  href="REC-xslt20-20070123.htm#RFC3023">[RFC3023]</A> 
  <SPAN>and/or its successors</SPAN>), then the encoding is recognized as 
  specified in <A 
  href="REC-xslt20-20070123.htm#REC-xml">[XML 1.0]</A>, 
  otherwise</P>
  <LI>
  <P>the value of the <CODE>$encoding</CODE> argument is used if present, 
  otherwise</P>
  <LI>
  <P>the processor <SPAN class=verb>may</SPAN> use <A 
  title=implementation-defined 
  href="REC-xslt20-20070123.htm#dt-implementation-defined">implementation-defined</A> 
  heuristics to determine the likely encoding, otherwise</P>
  <LI>
  <P>UTF-8 is assumed.</P></LI></OL>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>The above rules are chosen for consistency with <A 
href="REC-xslt20-20070123.htm#xinclude">[XInclude]</A>. 
Files with an XML media type are treated specially because there are use cases 
for this function where the retrieved text is to be included as unparsed XML 
within a CDATA section of a containing document, and because processors are 
likely to be able to reuse the code that performs encoding detection for XML 
external entities.</P></DIV>
<P><A id=err-XTDE1170 name=err-XTDE1170><SPAN class=error>[ERR 
XTDE1170]</SPAN></A> It is a <A title="non-recoverable dynamic error" 
href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
dynamic error</A> if a URI <SPAN>contains a fragment identifier,</SPAN> or if it 
cannot be used to retrieve a resource containing text.</P>
<P><A id=err-XTDE1190 name=err-XTDE1190><SPAN class=error>[ERR 
XTDE1190]</SPAN></A> It is a <A title="non-recoverable dynamic error" 
href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
dynamic error</A> if a resource contains octets that cannot be decoded into 
Unicode characters using the specified encoding, or if the resulting characters 
are not permitted XML characters. This includes the case where the <A 
title=processor 
href="REC-xslt20-20070123.htm#dt-processor">processor</A> 
does not support the requested encoding.</P>
<P><A id=err-XTDE1200 name=err-XTDE1200><SPAN class=error>[ERR 
XTDE1200]</SPAN></A> It is a <A title="non-recoverable dynamic error" 
href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
dynamic error</A> if the second argument of the <A 
href="REC-xslt20-20070123.htm#function-unparsed-text"><CODE>unparsed-text</CODE></A> 
function is omitted and the <A title=processor 
href="REC-xslt20-20070123.htm#dt-processor">processor</A> 
cannot infer the encoding using external information and the encoding is not 
UTF-8.</P>
<P>The result is a string containing the text of the resource retrieved using 
the URI.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>If the text file contains characters such as <CODE>&lt;</CODE> and 
<CODE>&amp;</CODE>, these will typically be output as <CODE>&amp;lt;</CODE> and 
<CODE>&amp;amp;</CODE> when the string is written to a <A 
title="final result tree" 
href="REC-xslt20-20070123.htm#dt-final-result-tree">final 
result tree</A> and serialized as XML or HTML. If these characters actually 
represent markup (for example, if the text file contains HTML), then the 
stylesheet can attempt to write them as markup to the output file using the 
<CODE>disable-output-escaping</CODE> attribute of the <A 
href="REC-xslt20-20070123.htm#element-value-of"><CODE>xsl:value-of</CODE></A> 
instruction (see <A 
href="REC-xslt20-20070123.htm#disable-output-escaping"><I>20.2 
Disabling Output Escaping</I></A>). Note, however, that implementations are not 
required to support this feature.</P></DIV>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e22242 name=d5e22242></A>Example: Copying 
Unparsed HTML Boilerplate </DIV>
<P>This example attempts to read an HTML file and copy it, as HTML, to the 
serialized output file:</P>
<DIV class=exampleInner><PRE>&lt;xsl:output method="html"/&gt;

&lt;xsl:template match="/"&gt;
  &lt;xsl:value-of select="unparsed-text('header.html', 'iso-8859-1')"
                disable-output-escaping="yes"/&gt;
  &lt;xsl:apply-templates/&gt;
  &lt;xsl:value-of select="unparsed-text('footer.html', 'iso-8859-1')"
                disable-output-escaping="yes"/&gt;
&lt;/xsl:template&gt;
</PRE></DIV></DIV>
<P>&nbsp;</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e22249 name=d5e22249></A>Example: Splitting an 
Input File into a Sequence of Lines </DIV>
<P>Often it is necessary to split a text file into a sequence of lines, 
representing each line as a string. This can be achieved by using the <A 
href="REC-xslt20-20070123.htm#function-unparsed-text"><CODE>unparsed-text</CODE></A> 
function in conjunction with the XPath <A 
href="http://www.w3.org/TR/xpath-functions/#func-tokenize"><CODE>tokenize</CODE></A><SUP><SMALL>FO</SMALL></SUP> 
function. For example:</P>
<DIV class=exampleInner><PRE>&lt;xsl:for-each select="tokenize(unparsed-text($in), '\r?\n')"&gt;
 ...
&lt;/xsl:for-each&gt;
</PRE></DIV>
<P>Note that the <A 
href="REC-xslt20-20070123.htm#function-unparsed-text"><CODE>unparsed-text</CODE></A> 
function does not normalize line endings. This example has therefore been 
written to recognize both Unix and Windows conventions for end-of-line, namely a 
single newline (#x0A) character or a carriage return / line feed pair (#x0D 
#x0A).</P></DIV>
<P>Because errors in evaluating the <A 
href="REC-xslt20-20070123.htm#function-unparsed-text"><CODE>unparsed-text</CODE></A> 
function are non-recoverable, two functions are provided to allow a stylesheet 
to determine whether a call with particular arguments would succeed:</P><A 
id=function-unparsed-text-available name=function-unparsed-text-available></A>
<DIV class=proto><CODE class=function>unparsed-text-available</CODE>(<CODE 
class=arg>$href</CODE><CODE class=as>&nbsp;as&nbsp;</CODE><CODE 
class=type>xs:string?</CODE>)<CODE class=as>&nbsp;as&nbsp;</CODE><CODE 
class=return-type>xs:boolean</CODE> </DIV>
<DIV class=proto>
<TABLE cellSpacing=0 cellPadding=0 border=0>
  <TBODY>
  <TR>
    <TD vAlign=baseline rowSpan=2><CODE 
      class=function>unparsed-text-available</CODE>(</TD>
    <TD vAlign=baseline><CODE class=arg>$href</CODE></TD>
    <TD vAlign=baseline><CODE class=as>&nbsp;as&nbsp;</CODE><CODE 
      class=type>xs:string?</CODE>,</TD></TR>
  <TR>
    <TD vAlign=baseline><CODE class=arg>$encoding</CODE></TD>
    <TD vAlign=baseline><CODE class=as>&nbsp;as&nbsp;</CODE><CODE 
      class=type>xs:string?</CODE>)<CODE class=as>&nbsp;as&nbsp;</CODE><CODE 
      class=return-type>xs:boolean</CODE></TD></TR></TBODY></TABLE></DIV>
<P>The <A 
href="REC-xslt20-20070123.htm#function-unparsed-text-available"><CODE>unparsed-text-available</CODE></A> 
function determines whether a call on the <A 
href="REC-xslt20-20070123.htm#function-unparsed-text"><CODE>unparsed-text</CODE></A> 
function with identical arguments would <SPAN>return a string</SPAN>.</P>
<P>If the first argument is an empty sequence, the function returns false. If 
the second argument is an empty sequence, the function behaves as if the second 
argument were omitted.</P>
<P>In other cases, the function returns true if a call on <A 
href="REC-xslt20-20070123.htm#function-unparsed-text"><CODE>unparsed-text</CODE></A> 
with the same arguments would succeed, and false if a call on <A 
href="REC-xslt20-20070123.htm#function-unparsed-text"><CODE>unparsed-text</CODE></A> 
with the same arguments would fail with a non-recoverable dynamic error.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>This requires that the <A 
href="REC-xslt20-20070123.htm#function-unparsed-text-available"><CODE>unparsed-text-available</CODE></A> 
function should actually attempt to read the resource identified by the URI, and 
check that it is correctly encoded and contains no characters that are invalid 
in XML. Implementations may avoid the cost of repeating these checks for example 
by caching the validated contents of the resource, to anticipate a subsequent 
call on the <A 
href="REC-xslt20-20070123.htm#function-unparsed-text"><CODE>unparsed-text</CODE></A> 
function. Alternatively, implementations may be able to rewrite an expression 
such as <CODE>if (unparsed-text-available(A)) then unparsed-text(A) else 
...</CODE> to generate a single call internally.</P></DIV>
<P>The functions <A 
href="REC-xslt20-20070123.htm#function-unparsed-text"><CODE>unparsed-text</CODE></A> 
and <A 
href="REC-xslt20-20070123.htm#function-unparsed-text-available"><CODE>unparsed-text-available</CODE></A> 
have the same requirement for stability as the functions <A 
href="http://www.w3.org/TR/xpath-functions/#func-doc"><CODE>doc</CODE></A><SUP> 
<SMALL>FO</SMALL></SUP> and <A 
href="http://www.w3.org/TR/xpath-functions/#func-doc-available"><CODE>doc-available</CODE></A><SUP><SMALL>FO</SMALL></SUP> 
defined in <A 
href="REC-xslt20-20070123.htm#xpath-functions">[Functions 
and Operators]</A>. This means that unless the user has explicitly stated a 
requirement for a reduced level of stability, either of these functions if 
called twice with the same arguments during the course of a transformation <SPAN 
class=verb>must</SPAN> return the same results each time; moreover, the results 
of a call on <A 
href="REC-xslt20-20070123.htm#function-unparsed-text-available"><CODE>unparsed-text-available</CODE></A> 
<SPAN class=verb>must</SPAN> be consistent with the results of a subsequent call 
on <A 
href="REC-xslt20-20070123.htm#function-unparsed-text"><CODE>unparsed-text</CODE></A> 
with the same arguments.</P></DIV>
<DIV class=div2>
<H3><A id=key name=key></A>16.3 Keys</H3>
<P>Keys provide a way to work with documents that contain an implicit 
cross-reference structure. They make it easier to locate the nodes within a 
document that have a given value for a given attribute or child element, and 
they provide a hint to the implementation that certain access paths in the 
document need to be efficient.</P>
<DIV class=div3>
<H4><A id=xsl-key name=xsl-key></A>16.3.1 The <A 
href="REC-xslt20-20070123.htm#element-key"><CODE>xsl:key</CODE></A> 
Declaration</H4>
<P class=element-syntax><A id=element-key name=element-key></A><CODE>&lt;!-- 
Category: declaration --&gt;<BR>&lt;xsl:key<BR>&nbsp;&nbsp;<B>name</B> = 
<VAR>qname</VAR><BR>&nbsp;&nbsp;<B>match</B> = 
<VAR>pattern</VAR><BR>&nbsp;&nbsp;use? = 
<VAR>expression</VAR><BR>&nbsp;&nbsp;collation? = 
<VAR>uri</VAR>&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: 
<VAR>sequence-constructor</VAR> --&gt;<BR>&lt;/xsl:key&gt;</CODE></P>
<P>The <A 
href="REC-xslt20-20070123.htm#element-key"><CODE>xsl:key</CODE></A> 
<A title=declaration 
href="REC-xslt20-20070123.htm#dt-declaration">declaration</A> 
is used to declare <A title=key 
href="REC-xslt20-20070123.htm#dt-key">keys</A>. The 
<CODE>name</CODE> attribute specifies the name of the key. The value of the 
<CODE>name</CODE> attribute is a <A title=QName 
href="REC-xslt20-20070123.htm#dt-qname">QName</A>, which 
is expanded as described in <A 
href="REC-xslt20-20070123.htm#qname"><I>5.1 Qualified 
Names</I></A>. The <CODE>match</CODE> attribute is a <A 
href="REC-xslt20-20070123.htm#NT-Pattern">Pattern</A>; an 
<A 
href="REC-xslt20-20070123.htm#element-key"><CODE>xsl:key</CODE></A> 
element applies to all nodes that match the pattern specified in the 
<CODE>match</CODE> attribute.</P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-key title=key 
name=dt-key></A>A <B>key</B> is defined as a set of <A 
href="REC-xslt20-20070123.htm#element-key"><CODE>xsl:key</CODE></A> 
declarations in the <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
that share the same name.<SPAN class=definition>]</SPAN></P>
<P>The value of the key may be specified either using the <CODE>use</CODE> 
attribute or by means of the contained <A title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A>.</P>
<P><A id=err-XTSE1205 name=err-XTSE1205><SPAN class=error>[ERR 
XTSE1205]</SPAN></A> It is a <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A> if an <A 
href="REC-xslt20-20070123.htm#element-key"><CODE>xsl:key</CODE></A> 
declaration has a <CODE>use</CODE> attribute and has non-empty content, or if it 
has empty content and no <CODE>use</CODE> attribute.</P>
<P>If the <CODE>use</CODE> attribute is present, its value is an <A 
title=expression 
href="REC-xslt20-20070123.htm#dt-expression">expression</A> 
specifying the values of the key. The expression will be evaluated with the node 
that matches the pattern as the context node. The result of evaluating the 
expression is <A title=atomize 
href="REC-xslt20-20070123.htm#dt-atomization">atomized</A>.</P>
<P>Similarly, if a <A title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A> is present, it is used to determine the values of the key. The 
sequence constructor will be evaluated with the node that matches the pattern as 
the context node. <SPAN>The result of evaluating the sequence constructor is <A 
title=atomize 
href="REC-xslt20-20070123.htm#dt-atomization">atomized</A>.</SPAN></P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-key-specifier 
title="key specifier" name=dt-key-specifier></A>The expression in the 
<CODE>use</CODE> attribute and the <A title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A> within an <A 
href="REC-xslt20-20070123.htm#element-key"><CODE>xsl:key</CODE></A> 
declaration are referred to collectively as the <B>key specifier</B>. The key 
specifier determines the values that may be used to find a node using this <A 
title=key 
href="REC-xslt20-20070123.htm#dt-key">key</A>.<SPAN 
class=definition>]</SPAN></P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>There is no requirement that all the values of a key should have the same 
type.</P></DIV>
<P>The presence of an <A 
href="REC-xslt20-20070123.htm#element-key"><CODE>xsl:key</CODE></A> 
declaration makes it easy to find a node that matches the <CODE>match</CODE> 
pattern if any of the values of the <SPAN><A title="key specifier" 
href="REC-xslt20-20070123.htm#dt-key-specifier">key 
specifier</A></SPAN> (when applied to that node) are known. It also provides a 
hint to the implementation that access to the nodes by means of these values 
needs to be efficient (many implementations are likely to construct an index or 
hash table to achieve this). Note that the <SPAN><A title="key specifier" 
href="REC-xslt20-20070123.htm#dt-key-specifier">key 
specifier</A></SPAN> in general returns a sequence of values, and any one of 
these may be used to locate the node.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>An <A 
href="REC-xslt20-20070123.htm#element-key"><CODE>xsl:key</CODE></A> 
declaration is not bound to a specific source document. The source document to 
which it applies is determined only when the <A 
href="REC-xslt20-20070123.htm#function-key"><CODE>key</CODE></A> 
function is used to locate nodes using the key. Keys can be used to locate nodes 
within any source document (including temporary trees), but each use of the <A 
href="REC-xslt20-20070123.htm#function-key"><CODE>key</CODE></A> 
function searches one document only.</P></DIV>
<P>The optional <CODE>collation</CODE> attribute is used only when deciding 
whether two strings are equal for the purposes of key matching. Specifically, 
two values <CODE>$a</CODE> and <CODE>$b</CODE> are considered equal if the 
result of the function call <CODE>compare($a, $b, $collation)</CODE> is zero. 
The effective collation for an <A 
href="REC-xslt20-20070123.htm#element-key"><CODE>xsl:key</CODE></A> 
declaration is the collation specified in its <CODE>collation</CODE> attribute 
if present, <SPAN>resolved against the base URI of the <A 
href="REC-xslt20-20070123.htm#element-key"><CODE>xsl:key</CODE></A> 
element</SPAN>, or the <A title="default collation" 
href="REC-xslt20-20070123.htm#dt-default-collation">default 
collation</A> that is in scope for the <A 
href="REC-xslt20-20070123.htm#element-key"><CODE>xsl:key</CODE></A> 
declaration otherwise; the effective collation must be the same for all the <A 
href="REC-xslt20-20070123.htm#element-key"><CODE>xsl:key</CODE></A> 
declarations making up a <A title=key 
href="REC-xslt20-20070123.htm#dt-key">key</A>.</P>
<P><A id=err-XTSE1210 name=err-XTSE1210><SPAN class=error>[ERR 
XTSE1210]</SPAN></A> It is a static error if the <A 
href="REC-xslt20-20070123.htm#element-key"><CODE>xsl:key</CODE></A> 
declaration has a <CODE>collation</CODE> attribute whose value <SPAN>(after 
resolving against the base URI)</SPAN> is not a URI recognized by the 
implementation as referring to a collation.</P>
<P><A id=err-XTSE1220 name=err-XTSE1220><SPAN class=error>[ERR 
XTSE1220]</SPAN></A> It is a static error if there are several <A 
href="REC-xslt20-20070123.htm#element-key"><CODE>xsl:key</CODE></A> 
declarations in the <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
with the same key name and different effective collations. Two collations are 
the same if their URIs are equal under the rules for comparing 
<CODE>xs:anyURI</CODE> values, or if the implementation can determine that they 
are different URIs referring to the same collation.</P>
<P>It is possible to have:</P>
<UL>
  <LI>
  <P>multiple <A 
  href="REC-xslt20-20070123.htm#element-key"><CODE>xsl:key</CODE></A> 
  declarations with the same name;</P>
  <LI>
  <P>a node that matches the <CODE>match</CODE> patterns of several different <A 
  href="REC-xslt20-20070123.htm#element-key"><CODE>xsl:key</CODE></A> 
  declarations<SPAN>, whether these have the same key name or different key 
  names;</SPAN></P>
  <LI>
  <P>a node that returns more than one value from its <SPAN><A 
  title="key specifier" 
  href="REC-xslt20-20070123.htm#dt-key-specifier">key 
  specifier</A></SPAN>;</P>
  <LI>
  <P>a key value that identifies more than one node (the key values for 
  different nodes do not need to be unique).</P></LI></UL>
<P>An <A 
href="REC-xslt20-20070123.htm#element-key"><CODE>xsl:key</CODE></A> 
declaration with higher <A title="import precedence" 
href="REC-xslt20-20070123.htm#dt-import-precedence">import 
precedence</A> does not override another of lower import precedence; all the <A 
href="REC-xslt20-20070123.htm#element-key"><CODE>xsl:key</CODE></A> 
declarations in the stylesheet are effective regardless of their import 
precedence.</P></DIV>
<DIV class=div3>
<H4><A id=keys name=keys></A>16.3.2 The <A 
href="REC-xslt20-20070123.htm#function-key"><CODE>key</CODE></A> 
Function</H4><A id=function-key name=function-key></A>
<DIV class=proto><CODE class=function>key</CODE>(<CODE 
class=arg>$key-name</CODE><CODE class=as>&nbsp;as&nbsp;</CODE><CODE 
class=type>xs:string</CODE>, <CODE class=arg>$key-value</CODE><CODE 
class=as>&nbsp;as&nbsp;</CODE><CODE class=type>xs:anyAtomicType*</CODE>)<CODE 
class=as>&nbsp;as&nbsp;</CODE><CODE class=return-type>node()*</CODE> </DIV>
<DIV class=proto>
<TABLE cellSpacing=0 cellPadding=0 border=0>
  <TBODY>
  <TR>
    <TD vAlign=baseline rowSpan=3><CODE class=function>key</CODE>(</TD>
    <TD vAlign=baseline><CODE class=arg>$key-name</CODE></TD>
    <TD vAlign=baseline><CODE class=as>&nbsp;as&nbsp;</CODE><CODE 
      class=type>xs:string</CODE>,</TD></TR>
  <TR>
    <TD vAlign=baseline><CODE class=arg>$key-value</CODE></TD>
    <TD vAlign=baseline><CODE class=as>&nbsp;as&nbsp;</CODE><CODE 
      class=type>xs:anyAtomicType*</CODE>,</TD></TR>
  <TR>
    <TD vAlign=baseline><CODE class=arg>$top</CODE></TD>
    <TD vAlign=baseline><CODE class=as>&nbsp;as&nbsp;</CODE><CODE 
      class=type>node()</CODE>)<CODE class=as>&nbsp;as&nbsp;</CODE><CODE 
      class=return-type>node()*</CODE></TD></TR></TBODY></TABLE></DIV>
<P>The <A 
href="REC-xslt20-20070123.htm#function-key"><CODE>key</CODE></A> 
function does for keys what the <A 
href="http://www.w3.org/TR/xpath-functions/#func-id"><CODE>id</CODE></A><SUP> 
<SMALL>FO</SMALL></SUP> function does for IDs.</P>
<P>The <CODE>$key-name</CODE> argument specifies the name of the <A title=key 
href="REC-xslt20-20070123.htm#dt-key">key</A>. The value 
of the argument <SPAN class=verb>must</SPAN> be a <A title="lexical QName" 
href="REC-xslt20-20070123.htm#dt-lexical-qname">lexical 
QName</A>, which is expanded as described in <A 
href="REC-xslt20-20070123.htm#qname"><I>5.1 Qualified 
Names</I></A>.</P>
<P><A id=err-XTDE1260 name=err-XTDE1260><SPAN class=error>[ERR 
XTDE1260]</SPAN></A> It is a <A title="non-recoverable dynamic error" 
href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
dynamic error</A> if the value is not a valid QName, or if there is no namespace 
declaration in scope for the prefix of the QName, or if the name obtained by 
expanding the QName is not the same as the expanded name of any <A 
href="REC-xslt20-20070123.htm#element-key"><CODE>xsl:key</CODE></A> 
declaration in the <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A>. 
If the processor is able to detect the error statically (for example, when the 
argument is supplied as a string literal), then the processor <SPAN 
class=verb>may</SPAN> optionally signal this as a <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A>.</P>
<P>The <CODE>$key-value</CODE> argument to the <A 
href="REC-xslt20-20070123.htm#function-key"><CODE>key</CODE></A> 
function is considered as a sequence. The set of requested key values is formed 
by atomizing the supplied value of the argument, using the standard <A 
title="function conversion rules" 
href="REC-xslt20-20070123.htm#dt-function-conversion-rules">function 
conversion rules</A>. Each of the resulting atomic values is considered as a 
requested key value. The result of the function is a sequence of nodes, in 
document order and with duplicates removed, comprising those nodes in the 
selected <SPAN>subtree</SPAN> (see below) that are matched by an <A 
href="REC-xslt20-20070123.htm#element-key"><CODE>xsl:key</CODE></A> 
declaration whose name is the same as the supplied key name, where the result of 
evaluating the <A title="key specifier" 
href="REC-xslt20-20070123.htm#dt-key-specifier">key 
specifier</A> contains a value that is equal to one of these requested key 
values, under the rules appropriate to the XPath <CODE>eq</CODE> operator for 
the two values in question, using the <CODE>collation</CODE> attributes of the 
<A 
href="REC-xslt20-20070123.htm#element-key"><CODE>xsl:key</CODE></A> 
declaration when comparing strings. No error is reported if two values are 
encountered that are not comparable; they are regarded for the purposes of this 
function as being not equal.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>Under the rules for the <CODE>eq</CODE> operator, untyped atomic values are 
converted to strings, not to the type of the other operand. This means, for 
example, that if the expression in the <CODE>use</CODE> attribute returns a 
date, supplying an untyped atomic value in the call to the <A 
href="REC-xslt20-20070123.htm#function-key"><CODE>key</CODE></A> 
function will return an empty sequence.</P></DIV>
<P>If the second argument is an empty sequence, the result of the function will 
be an empty sequence.</P>
<P>Different rules apply when <A title="backwards compatible behavior" 
href="REC-xslt20-20070123.htm#dt-backwards-compatible-behavior">backwards 
compatible</A> behavior is enabled. Specifically, if any of the <A 
href="REC-xslt20-20070123.htm#element-key"><CODE>xsl:key</CODE></A> 
elements in the definition of the <A title=key 
href="REC-xslt20-20070123.htm#dt-key">key</A> enables 
backwards compatible behavior, then the value of the <A title="key specifier" 
href="REC-xslt20-20070123.htm#dt-key-specifier">key 
specifier</A> and the value of the second argument of the <A 
href="REC-xslt20-20070123.htm#function-key"><CODE>key</CODE></A> 
function are both converted after atomization to a sequence of strings, by 
applying a cast to each item in the sequence, before performing the 
comparison.</P>
<P>The third argument is used to identify the selected subtree. If the argument 
is present, the selected subtree is the set of nodes that have <VAR>$top</VAR> 
as an ancestor-or-self node. If the argument is omitted, the selected subtree is 
the document containing the context node. This means that the third argument 
effectively defaults to <CODE>/</CODE>.</P>
<P><A id=err-XTDE1270 name=err-XTDE1270><SPAN class=error>[ERR 
XTDE1270]</SPAN></A> It is a <A title="non-recoverable dynamic error" 
href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
dynamic error</A> to call the <A 
href="REC-xslt20-20070123.htm#function-key"><CODE>key</CODE></A> 
function with two arguments if there is no <A title="context node" 
href="REC-xslt20-20070123.htm#dt-context-node">context 
node</A>, <SPAN>or if the root of the tree containing the context node is not a 
document node</SPAN>; or to call the function with three arguments if the root 
of the tree containing the node supplied in the third argument is not a document 
node.</P>
<P>The result of the <A 
href="REC-xslt20-20070123.htm#function-key"><CODE>key</CODE></A> 
function can be described more specifically as follows. The result is a sequence 
containing every node <VAR>$N</VAR> that satisfies the following conditions:</P>
<UL>
  <LI>
  <P><CODE>$N/ancestor-or-self::node() intersect $top</CODE> is non-empty. (If 
  the third argument is omitted, <CODE>$top</CODE> defaults to 
  <CODE>/</CODE>)</P>
  <LI>
  <P><VAR>$N</VAR> matches the pattern specified in the <CODE>match</CODE> 
  attribute of an <A 
  href="REC-xslt20-20070123.htm#element-key"><CODE>xsl:key</CODE></A> 
  declaration whose <CODE>name</CODE> attribute matches the name specified in 
  the <CODE>$key-name</CODE> argument.</P>
  <LI>
  <P>When the <A title="key specifier" 
  href="REC-xslt20-20070123.htm#dt-key-specifier">key 
  specifier</A> of that <A 
  href="REC-xslt20-20070123.htm#element-key"><CODE>xsl:key</CODE></A> 
  declaration is evaluated with a <A title="singleton focus" 
  href="REC-xslt20-20070123.htm#dt-singleton-focus">singleton 
  focus</A> based on <VAR>$N</VAR>, the <A title=atomize 
  href="REC-xslt20-20070123.htm#dt-atomization">atomized</A> 
  value of the resulting sequence includes a value that compares equal to at 
  least one item in the atomized value of the sequence supplied as 
  <CODE>$key-value</CODE>, under the rules of the <CODE>eq</CODE> operator with 
  the collation selected as described above.</P></LI></UL>
<P>The sequence returned by the <A 
href="REC-xslt20-20070123.htm#function-key"><CODE>key</CODE></A> 
function will be in document order, with duplicates (that is, nodes having the 
same identity) removed.</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e22835 name=d5e22835></A>Example: Using a Key 
to Follow Cross-References </DIV>
<P>For example, given a declaration</P>
<DIV class=exampleInner><PRE>&lt;xsl:key name="idkey" match="div" use="@id"/&gt;
</PRE></DIV>
<P>an expression <CODE>key("idkey",@ref)</CODE> will return the same nodes as 
<CODE>id(@ref)</CODE>, assuming that the only ID attribute declared in the XML 
source document is:</P>
<DIV class=exampleInner><PRE>&lt;!ATTLIST div id ID #IMPLIED&gt;
</PRE></DIV>
<P>and that the <CODE>ref</CODE> attribute of the context node contains no 
whitespace.</P>
<P>Suppose a document describing a function library uses a 
<CODE>prototype</CODE> element to define functions</P>
<DIV class=exampleInner><PRE>&lt;prototype name="sqrt" return-type="xs:double"&gt;
  &lt;arg type="xs:double"/&gt;
&lt;/prototype&gt;
</PRE></DIV>
<P>and a <CODE>function</CODE> element to refer to function names</P>
<DIV class=exampleInner><PRE>&lt;function&gt;sqrt&lt;/function&gt;
</PRE></DIV>
<P>Then the stylesheet could generate hyperlinks between the references and 
definitions as follows:</P>
<DIV class=exampleInner><PRE>&lt;xsl:key name="func" match="prototype" use="@name"/&gt;

&lt;xsl:template match="function"&gt;
&lt;b&gt;
  &lt;a href="#{generate-id(key('func',.))}"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/a&gt;
&lt;/b&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="prototype"&gt;
  &lt;p&gt;
    &lt;a name="{generate-id()}"&gt;
      &lt;b&gt;Function: &lt;/b&gt;
      ...
    &lt;/a&gt;
  &lt;/p&gt;
&lt;/xsl:template&gt;
</PRE></DIV></DIV>
<P>When called with two arguments, the <A 
href="REC-xslt20-20070123.htm#function-key"><CODE>key</CODE></A> 
function always returns nodes that are in the same document as the context node. 
To retrieve a node from any other document, it is necessary either to change the 
context node, or to supply a third argument.</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e22881 name=d5e22881></A>Example: Using Keys to 
Reference other Documents </DIV>
<P>For example, suppose a document contains bibliographic references in the form 
<CODE>&lt;bibref&gt;XSLT&lt;/bibref&gt;</CODE>, and there is a separate XML 
document <CODE>bib.xml</CODE> containing a bibliographic database with entries 
in the form:</P>
<DIV class=exampleInner><PRE>&lt;entry name="XSLT"&gt;...&lt;/entry&gt;
</PRE></DIV>
<P>Then the stylesheet could use the following to transform the 
<CODE>bibref</CODE> elements:</P>
<DIV class=exampleInner><PRE>&lt;xsl:key name="bib" match="entry" use="@name"/&gt;

&lt;xsl:template match="bibref"&gt;
  &lt;xsl:variable name="name" select="."/&gt;
  &lt;xsl:apply-templates select="document('bib.xml')/key('bib',$name)"/&gt;
&lt;/xsl:template&gt;
</PRE></DIV>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>This relies on the ability in XPath 2.0 to have a function call on the 
right-hand side of the <CODE>/</CODE> operator in a path expression.</P></DIV>
<P>The following code would also work:</P>
<DIV class=exampleInner><PRE>&lt;xsl:key name="bib" match="entry" use="@name"/&gt;

&lt;xsl:template match="bibref"&gt;
  &lt;xsl:apply-templates select="key('bib', ., document('bib.xml'))"/&gt;
&lt;/xsl:template&gt;
</PRE></DIV></DIV></DIV></DIV>
<DIV class=div2>
<H3><A id=format-number name=format-number></A>16.4 Number Formatting</H3><A 
id=function-format-number name=function-format-number></A>
<DIV class=proto><CODE class=function>format-number</CODE>(<CODE 
class=arg>$value</CODE><CODE class=as>&nbsp;as&nbsp;</CODE><CODE 
class=type>numeric?</CODE>, <CODE class=arg>$picture</CODE><CODE 
class=as>&nbsp;as&nbsp;</CODE><CODE class=type>xs:string</CODE>)<CODE 
class=as>&nbsp;as&nbsp;</CODE><CODE class=return-type>xs:string</CODE> </DIV>
<DIV class=proto>
<TABLE cellSpacing=0 cellPadding=0 border=0>
  <TBODY>
  <TR>
    <TD vAlign=baseline rowSpan=3><CODE 
class=function>format-number</CODE>(</TD>
    <TD vAlign=baseline><CODE class=arg>$value</CODE></TD>
    <TD vAlign=baseline><CODE class=as>&nbsp;as&nbsp;</CODE><CODE 
      class=type>numeric?</CODE>,</TD></TR>
  <TR>
    <TD vAlign=baseline><CODE class=arg>$picture</CODE></TD>
    <TD vAlign=baseline><CODE class=as>&nbsp;as&nbsp;</CODE><CODE 
      class=type>xs:string</CODE>,</TD></TR>
  <TR>
    <TD vAlign=baseline><CODE class=arg>$decimal-format-name</CODE></TD>
    <TD vAlign=baseline><CODE class=as>&nbsp;as&nbsp;</CODE><CODE 
      class=type>xs:string</CODE>)<CODE class=as>&nbsp;as&nbsp;</CODE><CODE 
      class=return-type>xs:string</CODE></TD></TR></TBODY></TABLE></DIV>
<P>The <A 
href="REC-xslt20-20070123.htm#function-format-number"><CODE>format-number</CODE></A> 
function formats <CODE>$value</CODE> as a string using the <A 
title="picture string" 
href="REC-xslt20-20070123.htm#dt-picture-string">picture 
string</A> specified by the <CODE>$picture</CODE> argument and the 
decimal-format named by the <CODE>$decimal-format-name</CODE> argument, or the 
default decimal-format, if there is no <CODE>$decimal-format-name</CODE> 
argument. <SPAN>The syntax of the picture string is described in <A 
href="REC-xslt20-20070123.htm#processing-picture-string"><I>16.4.2 
Processing the Picture String</I></A>.</SPAN></P>
<P>The <CODE>$value</CODE> argument may be of any numeric data type 
(<CODE>xs:double</CODE>, <CODE>xs:float</CODE>, <CODE>xs:decimal</CODE>, or 
their subtypes including <CODE>xs:integer</CODE>). Note that if an 
<CODE>xs:decimal</CODE> is supplied, it is not automatically promoted to an 
<CODE>xs:double</CODE>, as such promotion can involve a loss of precision.</P>
<P>If the supplied value of the <CODE>$value</CODE> argument is an empty 
sequence, the function behaves as if the supplied value were the 
<CODE>xs:double</CODE> value <CODE>NaN</CODE>.</P>
<P>The value of <CODE>$decimal-format-name</CODE> <SPAN class=verb>must</SPAN> 
be a <A title="lexical QName" 
href="REC-xslt20-20070123.htm#dt-lexical-qname">lexical 
QName</A>, which is expanded as described in <A 
href="REC-xslt20-20070123.htm#qname"><I>5.1 Qualified 
Names</I></A>. The result of the function is the formatted string representation 
of the supplied number.</P>
<P><A id=err-XTDE1280 name=err-XTDE1280><SPAN class=error>[ERR 
XTDE1280]</SPAN></A> It is a <A title="non-recoverable dynamic error" 
href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
dynamic error</A> if the name specified as the <CODE>$decimal-format-name</CODE> 
argument <SPAN>is not a valid <A title=QName 
href="REC-xslt20-20070123.htm#dt-qname">QName</A>, or if 
its prefix has not been declared in an in-scope namespace declaration</SPAN>, or 
if the <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
does not contain a declaration of a decimal-format with a matching <A 
title=expanded-QName 
href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded-QName</A>. 
If the processor is able to detect the error statically (for example, when the 
argument is supplied as a string literal), then the processor <SPAN 
class=verb>may</SPAN> optionally signal this as a <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A>.</P>
<DIV class=div3>
<H4><A id=defining-decimal-format name=defining-decimal-format></A>16.4.1 
Defining a Decimal Format</H4>
<P class=element-syntax><A id=element-decimal-format 
name=element-decimal-format></A><CODE>&lt;!-- Category: declaration 
--&gt;<BR>&lt;xsl:decimal-format<BR>&nbsp;&nbsp;name? = 
<VAR>qname</VAR><BR>&nbsp;&nbsp;decimal-separator? = 
<VAR>char</VAR><BR>&nbsp;&nbsp;grouping-separator? = 
<VAR>char</VAR><BR>&nbsp;&nbsp;infinity? = 
<VAR>string</VAR><BR>&nbsp;&nbsp;minus-sign? = 
<VAR>char</VAR><BR>&nbsp;&nbsp;NaN? = <VAR>string</VAR><BR>&nbsp;&nbsp;percent? 
= <VAR>char</VAR><BR>&nbsp;&nbsp;per-mille? = 
<VAR>char</VAR><BR>&nbsp;&nbsp;zero-digit? = 
<VAR>char</VAR><BR>&nbsp;&nbsp;digit? = 
<VAR>char</VAR><BR>&nbsp;&nbsp;pattern-separator? = 
<VAR>char</VAR>&nbsp;/&gt;</CODE></P>
<P>The <A 
href="REC-xslt20-20070123.htm#element-decimal-format"><CODE>xsl:decimal-format</CODE></A> 
element controls the interpretation of a <A title="picture string" 
href="REC-xslt20-20070123.htm#dt-picture-string">picture 
string</A> used by the <A 
href="REC-xslt20-20070123.htm#function-format-number"><CODE>format-number</CODE></A> 
function.</P>
<P>A <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
may contain multiple <A 
href="REC-xslt20-20070123.htm#element-decimal-format"><CODE>xsl:decimal-format</CODE></A> 
declarations and may include or import <A title="stylesheet module" 
href="REC-xslt20-20070123.htm#dt-stylesheet-module">stylesheet 
modules</A> that also contain <A 
href="REC-xslt20-20070123.htm#element-decimal-format"><CODE>xsl:decimal-format</CODE></A> 
declarations. The name of an <A 
href="REC-xslt20-20070123.htm#element-decimal-format"><CODE>xsl:decimal-format</CODE></A> 
declaration is the value of its <CODE>name</CODE> attribute, if any.</P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-decimal-format 
title="decimal format" name=dt-decimal-format></A>All the <A 
href="REC-xslt20-20070123.htm#element-decimal-format"><CODE>xsl:decimal-format</CODE></A> 
declarations in a stylesheet that share the same name are grouped into a named 
<B>decimal format</B>; those that have no name are grouped into a single unnamed 
decimal format.<SPAN class=definition>]</SPAN></P>
<P>If a <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
does not contain a declaration of the unnamed decimal format, a declaration 
equivalent to an <A 
href="REC-xslt20-20070123.htm#element-decimal-format"><CODE>xsl:decimal-format</CODE></A> 
element with no attributes is implied.</P>
<P>The attributes of the <A 
href="REC-xslt20-20070123.htm#element-decimal-format"><CODE>xsl:decimal-format</CODE></A> 
declaration establish values for a number of variables used as input to the 
algorithm followed by the <A 
href="REC-xslt20-20070123.htm#function-format-number"><CODE>format-number</CODE></A> 
function. An outline of the purpose of each attribute is given below; however, 
the definitive explanations are given later, as part of the description of this 
algorithm.</P>
<P>For any named <A title="decimal format" 
href="REC-xslt20-20070123.htm#dt-decimal-format">decimal 
format</A>, the effective value of each attribute is taken from an <A 
href="REC-xslt20-20070123.htm#element-decimal-format"><CODE>xsl:decimal-format</CODE></A> 
declaration that has that name, and that specifies an explicit value for the 
required attribute. If there is no such declaration, the default value of the 
attribute is used. If there is more than one such declaration, the one with 
highest <A title="import precedence" 
href="REC-xslt20-20070123.htm#dt-import-precedence">import 
precedence</A> is used.</P>
<P>For any unnamed <A title="decimal format" 
href="REC-xslt20-20070123.htm#dt-decimal-format">decimal 
format</A>, the effective value of each attribute is taken from an <A 
href="REC-xslt20-20070123.htm#element-decimal-format"><CODE>xsl:decimal-format</CODE></A> 
declaration that is unnamed, and that specifies an explicit value for the 
required attribute. If there is no such declaration, the default value of the 
attribute is used. If there is more than one such declaration, the one with 
highest <A title="import precedence" 
href="REC-xslt20-20070123.htm#dt-import-precedence">import 
precedence</A> is used.</P>
<P><A id=err-XTSE1290 name=err-XTSE1290><SPAN class=error>[ERR 
XTSE1290]</SPAN></A> It is a <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A> if a named or unnamed <A title="decimal format" 
href="REC-xslt20-20070123.htm#dt-decimal-format">decimal 
format</A> contains two conflicting values for the same attribute in different 
<A 
href="REC-xslt20-20070123.htm#element-decimal-format"><CODE>xsl:decimal-format</CODE></A> 
declarations having the same <A title="import precedence" 
href="REC-xslt20-20070123.htm#dt-import-precedence">import 
precedence</A>, unless there is another definition of the same attribute with 
higher import precedence.</P>
<P>The following attributes control the interpretation of characters in the <A 
title="picture string" 
href="REC-xslt20-20070123.htm#dt-picture-string">picture 
string</A> supplied to the <A 
href="REC-xslt20-20070123.htm#function-format-number"><CODE>format-number</CODE></A> 
function, and also specify characters that may appear in the result of 
formatting the number. In each case the value <SPAN class=verb>must</SPAN> be a 
single character <SPAN><SPAN class=error>[see <A 
href="REC-xslt20-20070123.htm#err-XTSE0020">ERR 
XTSE0020</A>]</SPAN></SPAN>.</P>
<UL>
  <LI>
  <P><CODE>decimal-separator</CODE> specifies the character used for the 
  <VAR>decimal-separator-sign</VAR>; the default value is the period character 
  (<CODE>.</CODE>)</P>
  <LI>
  <P><CODE>grouping-separator</CODE> specifies the character used for the 
  <VAR>grouping-sign</VAR>, which is typically used as a thousands separator; 
  the default value is the comma character (<CODE>,</CODE>)</P>
  <LI>
  <P><CODE>percent</CODE> specifies the character used for the 
  <VAR>percent-sign</VAR>; the default value is the percent character 
  (<CODE>%</CODE>)</P>
  <LI>
  <P><CODE>per-mille</CODE> specifies the character used for the 
  <VAR>per-mille-sign</VAR>; the default value is the Unicode per-mille 
  character (#x2030)</P>
  <LI>
  <P><CODE>zero-digit</CODE> specifies the character used for the 
  <VAR>digit-zero-sign</VAR>; the default value is the digit zero 
  (<CODE>0</CODE>). This character <SPAN class=verb>must</SPAN> be a digit 
  (category Nd in the Unicode property database), and it <SPAN 
  class=verb>must</SPAN> have the numeric value zero. <SPAN>This attribute 
  implicitly defines the Unicode character that is used to represent each of the 
  values 0 to 9 in the final result string: Unicode is organized so that each 
  set of decimal digits forms a contiguous block of characters in numerical 
  sequence.</SPAN></P></LI></UL>
<P><A id=err-XTSE1295 name=err-XTSE1295><SPAN class=error>[ERR 
XTSE1295]</SPAN></A> It is a <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A> if the character specified in the <CODE>zero-digit</CODE> attribute is 
not a digit or is a digit that does not have the numeric value zero.</P>
<P>The following attributes control the interpretation of characters in the <A 
title="picture string" 
href="REC-xslt20-20070123.htm#dt-picture-string">picture 
string</A> supplied to the <A 
href="REC-xslt20-20070123.htm#function-format-number"><CODE>format-number</CODE></A> 
function. In each case the value <SPAN class=verb>must</SPAN> be a single 
character <SPAN><SPAN class=error>[see <A 
href="REC-xslt20-20070123.htm#err-XTSE0020">ERR 
XTSE0020</A>]</SPAN></SPAN>.</P>
<UL>
  <LI>
  <P><CODE>digit</CODE> specifies the character used for the 
  <VAR>digit-sign</VAR> in the <A title="picture string" 
  href="REC-xslt20-20070123.htm#dt-picture-string">picture 
  string</A>; the default value is the number sign character 
(<CODE>#</CODE>)</P>
  <LI>
  <P><CODE>pattern-separator</CODE> specifies the character used for the 
  <VAR>pattern-separator-sign</VAR>, which separates positive and negative 
  sub-pictures in a <A title="picture string" 
  href="REC-xslt20-20070123.htm#dt-picture-string">picture 
  string</A>; the default value is the semi-colon character 
  (<CODE>;</CODE>)</P></LI></UL>
<P>The following attributes specify characters or strings that may appear in the 
result of formatting the number:</P>
<UL>
  <LI>
  <P><CODE>infinity</CODE> specifies the string used for the 
  <VAR>infinity-symbol</VAR>; the default value is the string 
  <CODE>Infinity</CODE></P>
  <LI>
  <P><CODE>NaN</CODE> specifies the string used for the <VAR>NaN-symbol</VAR>, 
  which is used to represent the value NaN (not-a-number); the default value is 
  the string <CODE>NaN</CODE></P>
  <LI>
  <P><CODE>minus-sign</CODE> specifies the character used for the 
  <VAR>minus-symbol</VAR>; the default value is the hyphen-minus character 
  (<CODE>-</CODE>, #x2D). The value <SPAN class=verb>must</SPAN> be a single 
  character.</P></LI></UL>
<P><A id=err-XTSE1300 name=err-XTSE1300><SPAN class=error>[ERR 
XTSE1300]</SPAN></A> It is a <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A> if, for any named or unnamed decimal format, the variables 
representing characters used in a <A title="picture string" 
href="REC-xslt20-20070123.htm#dt-picture-string">picture 
string</A> do not each have distinct values. These variables are 
<VAR>decimal-separator-sign</VAR>, <VAR>grouping-sign</VAR>, 
<VAR>percent-sign</VAR>, <VAR>per-mille-sign</VAR>, <VAR>digit-zero-sign</VAR>, 
<VAR>digit-sign</VAR>, and <VAR>pattern-separator-sign</VAR>.</P></DIV>
<DIV class=div3>
<H4><A id=processing-picture-string name=processing-picture-string></A>16.4.2 
Processing the Picture String</H4>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-picture-string 
title="picture string" name=dt-picture-string></A>The formatting of a number is 
controlled by a <B>picture string</B>. The picture string is a sequence of 
characters, in which the characters assigned to the variables 
<VAR>decimal-separator-sign</VAR>, <VAR>grouping-sign</VAR>, 
<VAR>zero-digit-sign</VAR>, <VAR>digit-sign</VAR> and 
<VAR>pattern-separator-sign</VAR> are classified as active characters, and all 
other characters (including the <VAR>percent-sign</VAR> and 
<VAR>per-mille-sign</VAR>) are classified as passive characters.<SPAN 
class=definition>]</SPAN></P>
<P>The <VAR>integer part</VAR> of the sub-picture is defined as the part that 
appears to the left of the <VAR>decimal-separator-sign</VAR> if there is one, or 
the entire sub-picture otherwise. The <VAR>fractional part</VAR> of the 
sub-picture is defined as the part that appears to the right of the 
<VAR>decimal-separator-sign</VAR> if there is one; it is a zero-length string 
otherwise.</P>
<P><A id=err-XTDE1310 name=err-XTDE1310><SPAN class=error>[ERR 
XTDE1310]</SPAN></A> The <A title="picture string" 
href="REC-xslt20-20070123.htm#dt-picture-string">picture 
string</A> <SPAN class=verb>must</SPAN> conform to the following rules. It is a 
<A title="non-recoverable dynamic error" 
href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
dynamic error</A> if the picture string does not satisfy these rules.</P>
<P>Note that in these rules the words "preceded" and "followed" refer to 
characters anywhere in the string, they are not to be read as "immediately 
preceded" and "immediately followed".</P>
<UL>
  <LI>
  <P>A picture-string consists either of a sub-picture, or of two sub-pictures 
  separated by a <VAR>pattern-separator-sign</VAR>. A picture-string <SPAN 
  class=verb>must not</SPAN> contain more than one 
  <VAR>pattern-separator-sign</VAR>. If the picture-string contains two 
  sub-pictures, the first is used for positive values and the second for 
  negative values.</P>
  <LI>
  <P>A sub-picture <SPAN class=verb>must not</SPAN> contain more than one 
  <VAR>decimal-separator-sign</VAR>.</P>
  <LI>
  <P>A sub-picture <SPAN class=verb>must not</SPAN> contain more than one 
  <VAR>percent-sign</VAR> or <VAR>per-mille-sign</VAR>, and it <SPAN 
  class=verb>must not</SPAN> contain one of each.</P>
  <LI>
  <P>A sub-picture <SPAN class=verb>must</SPAN> contain at least one 
  <VAR>digit-sign</VAR> or <VAR>zero-digit-sign</VAR>.</P>
  <LI>
  <P>A sub-picture <SPAN class=verb>must not</SPAN> contain a passive character 
  that is preceded by an active character and that is followed by another active 
  character.</P>
  <LI>
  <P>A sub-picture <SPAN class=verb>must not</SPAN> contain a 
  <VAR>grouping-separator-sign</VAR> adjacent to a 
  <VAR>decimal-separator-sign</VAR>.</P>
  <LI>
  <P>The integer part of a sub-picture <SPAN class=verb>must not</SPAN> contain 
  a <VAR>zero-digit-sign</VAR> that is followed by a <VAR>digit-sign</VAR>. The 
  fractional part of a sub-picture <SPAN class=verb>must not</SPAN> contain a 
  <VAR>digit-sign</VAR> that is followed by a 
  <VAR>zero-digit-sign</VAR>.</P></LI></UL>
<P>The evaluation of the <A 
href="REC-xslt20-20070123.htm#function-format-number"><CODE>format-number</CODE></A> 
function is described below in two phases, an analysis phase and a formatting 
phase. The analysis phase takes as its inputs the <A title="picture string" 
href="REC-xslt20-20070123.htm#dt-picture-string">picture 
string</A> and the variables derived from the relevant <A 
href="REC-xslt20-20070123.htm#element-decimal-format"><CODE>xsl:decimal-format</CODE></A> 
declaration, and produces as its output a number of variables with defined 
values. The formatting phase takes as its inputs the number to be formatted and 
the variables produced by the analysis phase, and produces as its output a 
string containing a formatted representation of the number.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>Numbers will always be formatted with the most significant digit on the 
left.</P></DIV></DIV>
<DIV class=div3>
<H4><A id=analysing-picture-string name=analysing-picture-string></A>16.4.3 
Analysing the Picture String</H4>
<P>This phase of the algorithm analyses the <A title="picture string" 
href="REC-xslt20-20070123.htm#dt-picture-string">picture 
string</A> and the attribute settings of the <A 
href="REC-xslt20-20070123.htm#element-decimal-format"><CODE>xsl:decimal-format</CODE></A> 
declaration, and has the effect of setting the values of various variables, 
which are used in the subsequent formatting phase. These variables are listed 
below. Each is shown with its initial setting and its data type.</P>
<P>Several variables are associated with each sub-picture. If there are two 
sub-pictures, then these rules are applied to one sub-picture to obtain the 
values that apply to positive numbers, and to the other to obtain the values 
that apply to negative numbers. If there is only one sub-picture, then the 
values for both cases are derived from this sub-picture.</P>
<P>The variables are as follows:</P>
<UL>
  <LI>
  <P>The <VAR>integer-part-grouping-positions</VAR> is a sequence of integers 
  representing the positions of grouping separators within the integer part of 
  the sub-picture. For each <VAR>grouping-separator-sign</VAR> that appears 
  within the integer part of the sub-picture, this sequence contains an integer 
  that is equal to the total number of <VAR>digit-sign</VAR> and 
  <VAR>zero-digit-sign</VAR> characters that appear within the integer part of 
  the sub-picture and to the right of the <VAR>grouping-separator-sign</VAR>. In 
  addition, if these <VAR>integer-part-grouping-positions</VAR> are at regular 
  intervals (that is, if they <SPAN>form a sequence <VAR>N</VAR>, <VAR>2N</VAR>, 
  <VAR>3N</VAR>, ... for some integer value <VAR>N</VAR>,</SPAN> including the 
  case where there is only one number in the list), then the sequence contains 
  all integer multiples of <VAR>N</VAR> as far as necessary to accommodate the 
  largest possible number.</P>
  <LI>
  <P>The <VAR>minimum-integer-part-size</VAR> is an integer indicating the 
  minimum number of digits that will appear to the left of the 
  <VAR>decimal-separator-sign</VAR>. It is normally set to the number of 
  <VAR>zero-digit-sign</VAR> characters found in the integer part of the 
  sub-picture. But if the sub-picture contains no <VAR>zero-digit-sign</VAR> and 
  no <VAR>decimal-separator-sign</VAR>, it is set to one.</P>
  <DIV class=note>
  <P class=prefix><B>Note:</B></P>
  <P>There is no maximum integer part size. All significant digits in the 
  integer part of the number will be displayed, even if this exceeds the number 
  of <VAR>digit-sign</VAR> and <VAR>zero-digit-sign</VAR> characters in the 
  subpicture.</P></DIV>
  <LI>
  <P>The <VAR>prefix</VAR> is set to contain all passive characters in the 
  sub-picture to the left of the leftmost active character. <SPAN>If the picture 
  string contains only one sub-picture</SPAN>, the <VAR>prefix</VAR> for the 
  negative sub-picture is set by concatenating the <VAR>minus-sign</VAR> 
  character and the <VAR>prefix</VAR> for the positive sub-picture (if any), in 
  that order.</P>
  <LI>
  <P>The <VAR>fractional-part-grouping-positions</VAR> is a sequence of integers 
  representing the positions of grouping separators within the fractional part 
  of the sub-picture. For each <VAR>grouping-separator-sign</VAR> that appears 
  within the fractional part of the sub-picture, this sequence contains an 
  integer that is equal to the total number of <VAR>digit-sign</VAR> and 
  <VAR>zero-digit-sign</VAR> characters that appear within the fractional part 
  of the sub-picture and to the left of the 
  <VAR>grouping-separator-sign</VAR>.</P>
  <LI>
  <P>The <VAR>minimum-fractional-part-size</VAR> is set to the number of 
  <VAR>zero-digit-sign</VAR> characters found in the fractional part of the 
  sub-picture.</P>
  <LI>
  <P>The <VAR>maximum-fractional-part-size</VAR> is set to the total number of 
  <VAR>digit-sign</VAR> and <VAR>zero-digit-sign</VAR> characters found in the 
  fractional part of the sub-picture.</P>
  <LI>
  <P>The <VAR>suffix</VAR> is set to contain all passive characters to the right 
  of the rightmost active character in the fractional part of the 
  sub-picture.</P></LI></UL>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>If there is only one sub-picture, then all variables for positive numbers and 
negative numbers will be the same, except for <VAR>prefix</VAR>: the prefix for 
negative numbers will <SPAN>be preceded by the <VAR>minus-sign</VAR> 
character</SPAN>.</P></DIV></DIV>
<DIV class=div3>
<H4><A id=formatting-the-number name=formatting-the-number></A>16.4.4 Formatting 
the Number</H4>
<P>This section describes the second phase of processing of the <A 
href="REC-xslt20-20070123.htm#function-format-number"><CODE>format-number</CODE></A> 
function. This phase takes as input a number to be formatted (referred to as the 
<EM>input number</EM>), and the variables set up by analysing the <A 
href="REC-xslt20-20070123.htm#element-decimal-format"><CODE>xsl:decimal-format</CODE></A> 
declaration and the <A title="picture string" 
href="REC-xslt20-20070123.htm#dt-picture-string">picture 
string</A>, as described above. The result of this phase is a string, which 
forms the return value of the <A 
href="REC-xslt20-20070123.htm#function-format-number"><CODE>format-number</CODE></A> 
function.</P>
<P>The algorithm for this second stage of processing is as follows:</P>
<OL class=enumar>
  <LI>
  <P>If the input number is NaN (not a number), the result is the specified 
  <VAR>NaN-symbol</VAR> (with no <VAR>prefix</VAR> or <VAR>suffix</VAR>).</P>
  <LI>
  <P>In the rules below, the positive sub-picture and its associated variables 
  are used if the input number is positive, and the negative sub-picture and its 
  associated variables are used otherwise. Negative zero is taken as negative, 
  positive zero as positive.</P>
  <LI>
  <P>If the input number is positive or negative infinity, the result is the 
  concatenation of the appropriate <VAR>prefix</VAR>, the 
  <VAR>infinity-symbol</VAR>, and the appropriate <VAR>suffix</VAR>.</P>
  <LI>
  <P>If the sub-picture contains a <VAR>percent-sign</VAR>, the number is 
  multiplied by 100. If the sub-picture contains a <VAR>per-mille-sign</VAR>, 
  the number is multiplied by 1000. The resulting number is referred to below as 
  the <VAR>adjusted number</VAR>.</P>
  <LI>
  <P>The <VAR>adjusted number</VAR> is converted (if necessary) to an 
  <CODE>xs:decimal</CODE> value, using an implementation of 
  <CODE>xs:decimal</CODE> that imposes no limits on the <CODE>totalDigits</CODE> 
  or <CODE>fractionDigits</CODE> facets. If there are several such values that 
  are numerically equal to the <VAR>adjusted number</VAR> (bearing in mind that 
  if the <VAR>adjusted number</VAR> is an <CODE>xs:double</CODE> or 
  <CODE>xs:float</CODE>, the comparison will be done by converting the decimal 
  value back to an <CODE>xs:double</CODE> or <CODE>xs:float</CODE>), the one 
  that is chosen <SPAN class=verb>should</SPAN> be one with the smallest 
  possible number of digits not counting leading or trailing zeroes 
  <SPAN>(whether significant or insignificant)</SPAN>. For example, 1.0 is 
  preferred to 0.9999999999, and 100000000 is preferred to 100000001. This value 
  is then rounded so that it uses no more than 
  <CODE>maximum-fractional-part-size</CODE> digits in its fractional part. The 
  <VAR>rounded number</VAR> is defined to be the result of converting the 
  <VAR>adjusted number</VAR> to an <CODE>xs:decimal</CODE> value, as described 
  above, and then calling the function <A 
  href="http://www.w3.org/TR/xpath-functions/#func-round-half-to-even"><CODE>round-half-to-even</CODE></A><SUP><SMALL>FO</SMALL></SUP> 
  with this converted number as the first argument and the 
  <CODE>maximum-fractional-part-size</CODE> as the second argument, again with 
  no limits on the <CODE>totalDigits</CODE> or <CODE>fractionDigits</CODE> in 
  the result.</P>
  <LI>
  <P>The absolute value of the <VAR>rounded number</VAR> is converted to a 
  string in decimal notation, with no insignificant leading or trailing zeroes, 
  using the characters implied by the choice of <VAR>zero-digit-sign</VAR> to 
  represent the ten decimal digits, and the <VAR>decimal-separator-sign</VAR> to 
  separate the integer part and the fractional part. (The value zero will at 
  this stage be represented by a <VAR>decimal-separator-sign</VAR> on its 
  own.)</P>
  <LI>
  <P>If the number of digits to the left of the 
  <VAR>decimal-separator-sign</VAR> is less than 
  <VAR>minimum-integer-part-size</VAR>, leading <VAR>zero-digit-sign</VAR> 
  characters are added to pad out to that size.</P>
  <LI>
  <P>If the number of digits to the right of the 
  <VAR>decimal-separator-sign</VAR> is less than 
  <VAR>minimum-fractional-part-size</VAR>, trailing <VAR>zero-digit-sign</VAR> 
  characters are added to pad out to that size.</P>
  <LI>
  <P>For each integer <VAR>N</VAR> in the 
  <VAR>integer-part-grouping-positions</VAR> list, a 
  <VAR>grouping-separator-sign</VAR> character is inserted into the string 
  immediately after that digit that appears in the integer part of the number 
  and has <VAR>N</VAR> digits between it and the 
  <VAR>decimal-separator-sign</VAR>, if there is such a digit.</P>
  <LI>
  <P>For each integer <VAR>N</VAR> in the 
  <VAR>fractional-part-grouping-positions</VAR> list, a 
  <VAR>grouping-separator-sign</VAR> character is inserted into the string 
  immediately before that digit that appears in the fractional part of the 
  number and has <VAR>N</VAR> digits between it and the 
  <VAR>decimal-separator-sign</VAR>, if there is such a digit.</P>
  <LI>
  <P>If there is no <VAR>decimal-separator-sign</VAR> in the sub-picture, 
  <SPAN>or if there are no digits to the right of the 
  <VAR>decimal-separator-sign</VAR> character in the string, then</SPAN> the 
  <VAR>decimal-separator-sign</VAR> character is removed from the string (it 
  will be the rightmost character in the string).</P>
  <LI>
  <P>The result of the function is the concatenation of the appropriate 
  <VAR>prefix</VAR>, the string conversion of the number as obtained above, and 
  the appropriate <VAR>suffix</VAR>.</P></LI></OL></DIV></DIV>
<DIV class=div2>
<H3><A id=format-date name=format-date></A>16.5 Formatting Dates and Times</H3>
<P>Three functions are provided to represent dates and times as a string, using 
the conventions of a selected calendar, language, and country. Each has two 
variants.</P><A id=function-format-dateTime name=function-format-dateTime></A>
<DIV class=proto>
<TABLE cellSpacing=0 cellPadding=0 border=0>
  <TBODY>
  <TR>
    <TD vAlign=baseline rowSpan=5><CODE 
    class=function>format-dateTime</CODE>(</TD>
    <TD vAlign=baseline><CODE class=arg>$value</CODE></TD>
    <TD vAlign=baseline><CODE class=as>&nbsp;as&nbsp;</CODE><CODE 
      class=type>xs:dateTime?</CODE>,</TD></TR>
  <TR>
    <TD vAlign=baseline><CODE class=arg>$picture</CODE></TD>
    <TD vAlign=baseline><CODE class=as>&nbsp;as&nbsp;</CODE><CODE 
      class=type>xs:string</CODE>,</TD></TR>
  <TR>
    <TD vAlign=baseline><CODE class=arg>$language</CODE></TD>
    <TD vAlign=baseline><CODE class=as>&nbsp;as&nbsp;</CODE><CODE 
      class=type>xs:string?</CODE>,</TD></TR>
  <TR>
    <TD vAlign=baseline><CODE class=arg>$calendar</CODE></TD>
    <TD vAlign=baseline><CODE class=as>&nbsp;as&nbsp;</CODE><CODE 
      class=type>xs:string?</CODE>,</TD></TR>
  <TR>
    <TD vAlign=baseline><CODE class=arg>$country</CODE></TD>
    <TD vAlign=baseline><CODE class=as>&nbsp;as&nbsp;</CODE><CODE 
      class=type>xs:string?</CODE>)<CODE class=as>&nbsp;as&nbsp;</CODE><CODE 
      class=return-type>xs:string?</CODE></TD></TR></TBODY></TABLE></DIV>
<DIV class=proto><CODE class=function>format-dateTime</CODE>(<CODE 
class=arg>$value</CODE><CODE class=as> &nbsp;as&nbsp;</CODE><CODE 
class=type>xs:dateTime?</CODE>, <CODE class=arg>$picture</CODE><CODE 
class=as>&nbsp;as&nbsp;</CODE><CODE class=type>xs:string</CODE>)<CODE 
class=as>&nbsp;as&nbsp;</CODE><CODE class=return-type>xs:string?</CODE> </DIV><A 
id=function-format-date name=function-format-date></A>
<DIV class=proto>
<TABLE cellSpacing=0 cellPadding=0 border=0>
  <TBODY>
  <TR>
    <TD vAlign=baseline rowSpan=5><CODE class=function>format-date</CODE>(</TD>
    <TD vAlign=baseline><CODE class=arg>$value</CODE></TD>
    <TD vAlign=baseline><CODE class=as>&nbsp;as&nbsp;</CODE><CODE 
      class=type>xs:date?</CODE>,</TD></TR>
  <TR>
    <TD vAlign=baseline><CODE class=arg>$picture</CODE></TD>
    <TD vAlign=baseline><CODE class=as>&nbsp;as&nbsp;</CODE><CODE 
      class=type>xs:string</CODE>,</TD></TR>
  <TR>
    <TD vAlign=baseline><CODE class=arg>$language</CODE></TD>
    <TD vAlign=baseline><CODE class=as>&nbsp;as&nbsp;</CODE><CODE 
      class=type>xs:string?</CODE>,</TD></TR>
  <TR>
    <TD vAlign=baseline><CODE class=arg>$calendar</CODE></TD>
    <TD vAlign=baseline><CODE class=as>&nbsp;as&nbsp;</CODE><CODE 
      class=type>xs:string?</CODE>,</TD></TR>
  <TR>
    <TD vAlign=baseline><CODE class=arg>$country</CODE></TD>
    <TD vAlign=baseline><CODE class=as>&nbsp;as&nbsp;</CODE><CODE 
      class=type>xs:string?</CODE>)<CODE class=as>&nbsp;as&nbsp;</CODE><CODE 
      class=return-type>xs:string?</CODE></TD></TR></TBODY></TABLE></DIV>
<DIV class=proto><CODE class=function>format-date</CODE>(<CODE 
class=arg>$value</CODE><CODE class=as>&nbsp;as&nbsp;</CODE><CODE 
class=type>xs:date?</CODE>, <CODE class=arg>$picture</CODE><CODE 
class=as>&nbsp;as&nbsp;</CODE><CODE class=type>xs:string</CODE>)<CODE 
class=as>&nbsp;as&nbsp;</CODE><CODE class=return-type>xs:string?</CODE> </DIV><A 
id=function-format-time name=function-format-time></A>
<DIV class=proto>
<TABLE cellSpacing=0 cellPadding=0 border=0>
  <TBODY>
  <TR>
    <TD vAlign=baseline rowSpan=5><CODE class=function>format-time</CODE>(</TD>
    <TD vAlign=baseline><CODE class=arg>$value</CODE></TD>
    <TD vAlign=baseline><CODE class=as>&nbsp;as&nbsp;</CODE><CODE 
      class=type>xs:time?</CODE>,</TD></TR>
  <TR>
    <TD vAlign=baseline><CODE class=arg>$picture</CODE></TD>
    <TD vAlign=baseline><CODE class=as>&nbsp;as&nbsp;</CODE><CODE 
      class=type>xs:string</CODE>,</TD></TR>
  <TR>
    <TD vAlign=baseline><CODE class=arg>$language</CODE></TD>
    <TD vAlign=baseline><CODE class=as>&nbsp;as&nbsp;</CODE><CODE 
      class=type>xs:string?</CODE>,</TD></TR>
  <TR>
    <TD vAlign=baseline><CODE class=arg>$calendar</CODE></TD>
    <TD vAlign=baseline><CODE class=as>&nbsp;as&nbsp;</CODE><CODE 
      class=type>xs:string?</CODE>,</TD></TR>
  <TR>
    <TD vAlign=baseline><CODE class=arg>$country</CODE></TD>
    <TD vAlign=baseline><CODE class=as>&nbsp;as&nbsp;</CODE><CODE 
      class=type>xs:string?</CODE>)<CODE class=as>&nbsp;as&nbsp;</CODE><CODE 
      class=return-type>xs:string?</CODE></TD></TR></TBODY></TABLE></DIV>
<DIV class=proto><CODE class=function>format-time</CODE>(<CODE 
class=arg>$value</CODE><CODE class=as>&nbsp;as&nbsp;</CODE><CODE 
class=type>xs:time?</CODE>, <CODE class=arg>$picture</CODE><CODE 
class=as>&nbsp;as&nbsp;</CODE><CODE class=type>xs:string</CODE>)<CODE 
class=as>&nbsp;as&nbsp;</CODE><CODE class=return-type>xs:string?</CODE> </DIV>
<P>The <A 
href="REC-xslt20-20070123.htm#function-format-dateTime"><CODE>format-dateTime</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#function-format-date"><CODE>format-date</CODE></A>, 
and <A 
href="REC-xslt20-20070123.htm#function-format-time"><CODE>format-time</CODE></A> 
functions format <CODE>$value</CODE> as a string using the picture string 
specified by the <CODE>$picture</CODE> argument, the calendar specified by the 
<CODE>$calendar</CODE> argument, the language specified by the 
<CODE>$language</CODE> argument, and the country specified by the 
<CODE>$country</CODE> argument. The result of the function is the formatted 
string representation of the supplied <CODE>dateTime</CODE>, <CODE>date</CODE>, 
or <CODE>time</CODE> value.</P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A 
id=dt-date-formatting-function title="date formatting function" 
name=dt-date-formatting-function></A>The three functions <A 
href="REC-xslt20-20070123.htm#function-format-date"><CODE>format-date</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#function-format-time"><CODE>format-time</CODE></A>, 
and <A 
href="REC-xslt20-20070123.htm#function-format-dateTime"><CODE>format-dateTime</CODE></A> 
are referred to collectively as the <B>date formatting functions</B>.<SPAN 
class=definition>]</SPAN></P>
<P>If <CODE>$value</CODE> is the empty sequence, the empty sequence is 
returned.</P>
<P>Calling the two-argument form of each of the three functions is equivalent to 
calling the five-argument form with each of the last three arguments set to an 
empty sequence.</P>
<P>For details of the <CODE>language</CODE>, <CODE>calendar</CODE>, and 
<CODE>country</CODE> arguments, see <A 
href="REC-xslt20-20070123.htm#lang-cal-country"><I>16.5.2 
The Language, Calendar, and Country Arguments</I></A>.</P>
<P>In general, the use of an invalid <CODE>picture</CODE>, 
<CODE>language</CODE>, <CODE>calendar</CODE>, or <CODE>country</CODE> argument 
is classified as a <SPAN><A title="non-recoverable dynamic error" 
href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
dynamic error</A>. By contrast,</SPAN> use of an option in any of these 
arguments that is valid but not supported by the implementation is not an error, 
and in these cases the implementation is required to output the value in a 
fallback representation.</P>
<DIV class=div3>
<H4><A id=date-picture-string name=date-picture-string></A>16.5.1 The Picture 
String</H4>
<P>The picture consists of a sequence of variable markers and literal 
substrings. A substring enclosed in square brackets is interpreted as a variable 
marker; substrings not enclosed in square brackets are taken as literal 
substrings. The literal substrings are optional and if present are rendered 
unchanged, including any whitespace. If an opening or closing square bracket is 
required within a literal substring, it <SPAN class=verb>must</SPAN> be doubled. 
The variable markers are replaced in the result by strings representing aspects 
of the date and/or time to be formatted. These are described in detail 
below.</P>
<P>A variable marker consists of a component specifier followed optionally by 
one or two presentation modifiers and/or optionally by a width modifier. 
Whitespace within a variable marker is ignored.</P>
<P>The <EM>component specifier</EM> indicates the component of the date or time 
that is required, and takes the following values:</P>
<TABLE cellPadding=5 border=1>
  <THEAD>
  <TR>
    <TH align=left>Specifier</TH>
    <TH align=left>Meaning</TH>
    <TH align=left>Default Presentation Modifier</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD vAlign=top>Y</TD>
    <TD>year <SPAN>(absolute value)</SPAN></TD>
    <TD vAlign=top>1</TD></TR>
  <TR>
    <TD vAlign=top>M</TD>
    <TD>month in year</TD>
    <TD vAlign=top>1</TD></TR>
  <TR>
    <TD vAlign=top>D</TD>
    <TD>day in month</TD>
    <TD vAlign=top>1</TD></TR>
  <TR>
    <TD vAlign=top>d</TD>
    <TD>day in year</TD>
    <TD vAlign=top>1</TD></TR>
  <TR>
    <TD vAlign=top>F</TD>
    <TD>day of week</TD>
    <TD vAlign=top>n</TD></TR>
  <TR>
    <TD vAlign=top>W</TD>
    <TD>week in year</TD>
    <TD vAlign=top>1</TD></TR>
  <TR>
    <TD vAlign=top>w</TD>
    <TD>week in month</TD>
    <TD vAlign=top>1</TD></TR>
  <TR>
    <TD vAlign=top>H</TD>
    <TD>hour in day (24 hours)</TD>
    <TD vAlign=top>1</TD></TR>
  <TR>
    <TD vAlign=top>h</TD>
    <TD>hour in half-day (12 hours)</TD>
    <TD vAlign=top>1</TD></TR>
  <TR>
    <TD vAlign=top>P</TD>
    <TD>am/pm marker</TD>
    <TD vAlign=top>n</TD></TR>
  <TR>
    <TD vAlign=top>m</TD>
    <TD>minute in hour</TD>
    <TD vAlign=top><SPAN>01</SPAN></TD></TR>
  <TR>
    <TD vAlign=top>s</TD>
    <TD>second in minute</TD>
    <TD vAlign=top><SPAN>01</SPAN></TD></TR>
  <TR>
    <TD vAlign=top>f</TD>
    <TD>fractional seconds</TD>
    <TD vAlign=top>1</TD></TR>
  <TR>
    <TD vAlign=top>Z</TD>
    <TD>timezone as a time offset from UTC, or if an alphabetic modifier is 
      present the conventional name of a timezone (such as PST)</TD>
    <TD vAlign=top>1</TD></TR>
  <TR>
    <TD vAlign=top>z</TD>
    <TD>timezone as a time offset using GMT, for example GMT+1</TD>
    <TD vAlign=top>1</TD></TR>
  <TR>
    <TD vAlign=top>C</TD>
    <TD>calendar: the name or abbreviation of a calendar name</TD>
    <TD vAlign=top>n</TD></TR>
  <TR>
    <TD vAlign=top>E</TD>
    <TD>era: the name of a baseline for the numbering of years, for example 
      the reign of a monarch</TD>
    <TD vAlign=top>n</TD></TR></TBODY></TABLE>
<P><A id=err-XTDE1340 name=err-XTDE1340><SPAN class=error>[ERR 
XTDE1340]</SPAN></A> It is a <A title="non-recoverable dynamic error" 
href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
dynamic error</A> if the syntax of the picture is incorrect.</P>
<P><A id=err-XTDE1350 name=err-XTDE1350><SPAN class=error>[ERR 
XTDE1350]</SPAN></A> It is a <A title="non-recoverable dynamic error" 
href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
dynamic error</A> if a component specifier within the picture refers to 
components that are not available in the given type of <CODE>$value</CODE>, for 
example if the picture supplied to the <A 
href="REC-xslt20-20070123.htm#function-format-time"><CODE>format-time</CODE></A> 
refers to the year, month, or day component.</P>
<P>It is not an error to include a timezone component when the supplied value 
has no timezone. In these circumstances the timezone component will be 
ignored.</P>
<P>The first <EM>presentation modifier</EM> indicates the style in which the 
value of a component is to be represented. Its value may be either:</P>
<UL>
  <LI>
  <P>any format token permitted in the <CODE>format</CODE> string of the <A 
  href="REC-xslt20-20070123.htm#element-number"><CODE>xsl:number</CODE></A> 
  instruction (see <A 
  href="REC-xslt20-20070123.htm#number"><I>12 
  Numbering</I></A>), indicating that the value of the component is to be output 
  numerically using the specified number format (for example, <CODE>1</CODE>, 
  <CODE>01</CODE>, <CODE>i</CODE>, <CODE>I</CODE>, <CODE>w</CODE>, 
  <CODE>W</CODE>, or <CODE>Ww</CODE>) or</P>
  <LI>
  <P>the format token <CODE>n</CODE>, <CODE>N</CODE>, or <CODE>Nn</CODE>, 
  indicating that the value of the component is to be output by name, in 
  lower-case, upper-case, or title-case respectively. Components that can be 
  output by name include (but are not limited to) months, days of the week, 
  timezones, and eras. If the processor cannot output these components by name 
  for the chosen calendar and language then it must use an 
  implementation-defined fallback representation.</P></LI></UL>
<P>If the implementation does not support the use of the requested format token, 
it <SPAN class=verb>must</SPAN> use the default presentation modifier for that 
component.</P>
<P>If the first presentation modifier is present, then it may optionally be 
followed by a second presentation modifier as follows:</P>
<TABLE cellPadding=5 border=1>
  <THEAD>
  <TR>
    <TH align=left>Modifier</TH>
    <TH align=left>Meaning</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD vAlign=top>t</TD>
    <TD vAlign=top>traditional numbering. This has the same meaning as 
      <CODE>letter-value="traditional"</CODE> in <A 
      href="REC-xslt20-20070123.htm#element-number"><CODE>xsl:number</CODE></A>.</TD></TR>
  <TR>
    <TD vAlign=top>o</TD>
    <TD vAlign=top>ordinal form of a number, for example <CODE>8th</CODE> or 
      <CODE>8º</CODE>. The actual representation of the ordinal form of a number 
      may depend not only on the language, but also on the grammatical context 
      (for example, in some languages it must agree in 
gender).</TD></TR></TBODY></TABLE>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>Although the formatting rules are expressed in terms of the rules for format 
tokens in <A 
href="REC-xslt20-20070123.htm#element-number"><CODE>xsl:number</CODE></A>, 
the formats actually used may be specialized to the numbering of date components 
where appropriate. For example, in Italian, it is conventional to use an ordinal 
number (<CODE>primo</CODE>) for the first day of the month, and cardinal numbers 
(<CODE>due, tre, quattro ...</CODE>) for the remaining days. A processor may 
therefore use this convention to number days of the month, ignoring the presence 
or absence of the ordinal presentation modifier.</P></DIV>
<P>Whether or not a presentation modifier is included, a width modifier may be 
supplied. This indicates the number of characters or digits to be included in 
the representation of the value.</P>
<P>The width modifier, if present, is introduced by a comma. It takes the 
form:</P>
<P><CODE>&nbsp;&nbsp;&nbsp;,&nbsp;&nbsp;min-width ("-" max-width)?</CODE></P>
<P>where <CODE>min-width</CODE> is either an unsigned integer indicating the 
minimum number of characters to be output, or <CODE>*</CODE> indicating that 
there is no explicit minimum, and <CODE>max-width</CODE> is either an unsigned 
integer indicating the maximum number of characters to be output, or 
<CODE>*</CODE> indicating that there is no explicit maximum; if 
<CODE>max-width</CODE> is omitted then <CODE>*</CODE> is assumed. Both integers, 
if present, <SPAN class=verb>must</SPAN> be greater than zero.</P>
<P>A format token containing leading zeroes, such as <CODE>001</CODE>, sets the 
minimum and maximum width to the number of digits appearing in the format token; 
if a width modifier is also present, then the width modifier takes 
precedence.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>A format token consisting of a one-digit on its own, such as <CODE>1</CODE>, 
does not constrain the number of digits in the output. In the case of fractional 
seconds in particular, <CODE>[f001]</CODE> requests three decimal digits, 
<CODE>[f01]</CODE> requests two digits, but <CODE>[f1]</CODE> will produce an 
implementation-defined number of digits. If exactly one digit is required, this 
can be achieved using the component specifier <CODE>[f1,1-1]</CODE>.</P></DIV>
<P>If the minumum and maximum width are unspecified, then the output uses as 
many characters as are required to represent the value of the component without 
truncation and without padding: this is referred to below as the <EM>full 
representation</EM> of the value.</P>
<P>If the full representation of the value exceeds the specified maximum width, 
then the processor <SPAN class=verb>should</SPAN> attempt to use an alternative 
shorter representation that fits within the maximum width. Where the 
presentation modifier is <CODE>N</CODE>, <CODE>n</CODE>, or <CODE>Nn</CODE>, 
this is done by abbreviating the name, using either conventional abbreviations 
if available, or crude right-truncation if not. For example, setting 
<CODE>max-width</CODE> to <CODE>4</CODE> indicates that four-letter 
abbreviations <SPAN class=verb>should</SPAN> be used, though it would be 
acceptable to use a three-letter abbreviation if this is in conventional use. 
(For example, "Tuesday" might be abbreviated to "Tues", and "Friday" to "Fri".) 
In the case of the year component, setting <CODE>max-width</CODE> requests 
omission of high-order digits from the year, for example, if 
<CODE>max-width</CODE> is set to <CODE>2</CODE> then the year 2003 will be 
output as <CODE>03</CODE>. <SPAN>In the case of the fractional seconds 
component, the value is rounded to the specified size as if by applying the 
function <CODE>round-half-to-even(fractional-seconds, max-width)</CODE>.</SPAN> 
If no mechanism is available for fitting the value within the specified maximum 
width (for example, when roman numerals are used), then the value <SPAN 
class=verb>should</SPAN> be output in its full representation.</P>
<P>If the full representation of the value is shorter than the specified minimum 
width, then the processor <SPAN class=verb>should</SPAN> pad the value to the 
specified width. For decimal representations of numbers, this <SPAN 
class=verb>should</SPAN> be done by prepending zero digits from the appropriate 
set of digit characters, or appending zero digits in the case of the fractional 
seconds component. In other cases, it <SPAN class=verb>should</SPAN> be done by 
appending spaces.</P></DIV>
<DIV class=div3>
<H4><A id=lang-cal-country name=lang-cal-country></A>16.5.2 The Language, 
Calendar, and Country Arguments</H4>
<P>The set of languages, calendars, and countries that are supported in the <A 
title="date formatting function" 
href="REC-xslt20-20070123.htm#dt-date-formatting-function">date 
formatting functions</A> is <A title=implementation-defined 
href="REC-xslt20-20070123.htm#dt-implementation-defined">implementation-defined</A>. 
When any of these arguments is omitted or is an empty sequence, an <A 
title=implementation-defined 
href="REC-xslt20-20070123.htm#dt-implementation-defined">implementation-defined</A> 
default value is used.</P>
<P>If the fallback representation uses a different calendar from that requested, 
the output string <SPAN class=verb>must</SPAN> be prefixed with <CODE>[Calendar: 
X]</CODE> where <CODE>X</CODE> identifies the calendar actually used. The string 
<CODE>Calendar</CODE> <SPAN class=verb>should</SPAN> be localized using the 
requested language if available. If the fallback representation uses a different 
language from that requested, the output string should be prefixed with 
<CODE>[Language: Y]</CODE> where <CODE>Y</CODE> identifies the language actually 
used. The string <CODE>Language</CODE> <SPAN class=verb>may</SPAN> be localized 
in an <A title=implementation-dependent 
href="REC-xslt20-20070123.htm#dt-implementation-dependent">implementation-dependent</A> 
way. If a particular component of the value cannot be output in the requested 
format, it <SPAN class=verb>should</SPAN> be output in the default format for 
that component.</P>
<P>The <CODE>language</CODE> argument specifies the language to be used for the 
result string of the function. The value of the argument <SPAN 
class=verb>must</SPAN> be either the empty sequence or a value that would be 
valid for the <CODE>xml:lang</CODE> attribute (see [XML]). Note that this 
permits the identification of sublanguages based on country codes (from <A 
href="REC-xslt20-20070123.htm#ISO3166">[ISO 3166-1]</A>) 
as well as identification of dialects and of regions within a country.</P>
<P>If the <CODE>language</CODE> argument is omitted or is set to an empty 
sequence, or if it is set to an invalid value or a value that the implementation 
does not recognize, then the processor uses an <A title=implementation-defined 
href="REC-xslt20-20070123.htm#dt-implementation-defined">implementation-defined</A> 
language.</P>
<P>The language is used to select the appropriate language-dependent forms 
of:</P>
<BLOCKQUOTE>
  <P>names (for example, of months)<BR>numbers expressed as words or as ordinals 
  (<CODE>twenty, 20th, twentieth</CODE>)<BR>hour convention (0-23 vs 1-24, 0-11 
  vs 1-12)<BR>first day of week, first week of year</P></BLOCKQUOTE>
<P>Where appropriate this choice may also take into account the value of the 
<CODE>country</CODE> argument, though this <SPAN class=verb>should</SPAN> not be 
used to override the language or any sublanguage that is specified as part of 
the <CODE>language</CODE> argument.</P>
<P>The choice of the names and abbreviations used in any given language is <A 
title=implementation-defined 
href="REC-xslt20-20070123.htm#dt-implementation-defined">implementation-defined</A>. 
For example, one implementation might abbreviate July as <CODE>Jul</CODE> while 
another uses <CODE>Jly</CODE>. In German, one implementation might represent 
Saturday as <CODE>Samstag</CODE> while another uses <CODE>Sonnabend</CODE>. 
Implementations <SPAN class=verb>may</SPAN> provide mechanisms allowing users to 
control such choices.</P>
<P>Where ordinal numbers are used, the selection of the correct representation 
of the ordinal (for example, the linguistic gender) <SPAN class=verb>may</SPAN> 
depend on the component being formatted and on its textual context in the 
picture string.</P>
<P>The <CODE>calendar</CODE> attribute specifies that the <CODE>dateTime</CODE>, 
<CODE>date</CODE>, or <CODE>time</CODE> supplied in the <CODE>$value</CODE> 
argument <SPAN class=verb>must</SPAN> be converted to a value in the specified 
calendar and then converted to a string using the conventions of that 
calendar.</P>
<P>A calendar value <SPAN class=verb>must</SPAN> be a valid <A title=QName 
href="REC-xslt20-20070123.htm#dt-qname">QName</A>. If the 
QName does not have a prefix, then it identifies a calendar with the designator 
specified below. If the QName has a prefix, then the QName is expanded into an 
expanded-QName as described in <A 
href="REC-xslt20-20070123.htm#qname"><I>5.1 Qualified 
Names</I></A>; the expanded-QName identifies the calendar; the behavior in this 
case is <A title=implementation-defined 
href="REC-xslt20-20070123.htm#dt-implementation-defined">implementation-defined</A>.</P>
<P>If the calendar attribute is omitted an <A title=implementation-defined 
href="REC-xslt20-20070123.htm#dt-implementation-defined">implementation-defined</A> 
value is used.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>The calendars listed below were known to be in use during the last hundred 
years. Many other calendars have been used in the past.</P>
<P>This specification does not define any of these calendars, nor the way that 
they map to the value space of the <CODE>xs:date</CODE> data type in <A 
href="REC-xslt20-20070123.htm#xmlschema-2">[XML Schema 
Part 2]</A>. There may be ambiguities when dates are recorded using different 
calendars. For example, the start of a new day is not simultaneous in different 
calendars, and may also vary geographically (for example, based on the time of 
sunrise or sunset). Translation of dates is therefore more reliable when the 
time of day is also known, and when the geographic location is known. When 
translating dates between one calendar and another, the processor may take 
account of the values of the <CODE>country</CODE> and/or <CODE>language</CODE> 
arguments, with the <CODE>country</CODE> argument taking precedence.</P>
<P>Information about some of these calendars, and algorithms for converting 
between them, may be found in <A 
href="REC-xslt20-20070123.htm#CALCALC">[Calendrical 
Calculations]</A>.</P></DIV>
<TABLE cellPadding=5 border=1>
  <THEAD>
  <TR>
    <TH vAlign=top align=left>Designator</TH>
    <TH vAlign=top align=left>Calendar</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD>AD</TD>
    <TD>Anno Domini (Christian Era)</TD></TR>
  <TR>
    <TD>AH</TD>
    <TD>Anno Hegirae (Muhammedan Era)</TD></TR>
  <TR>
    <TD>AME</TD>
    <TD>Mauludi Era (solar years since Mohammed's birth)</TD></TR>
  <TR>
    <TD>AM</TD>
    <TD>Anno Mundi (Jewish Calendar)</TD></TR>
  <TR>
    <TD>AP</TD>
    <TD>Anno Persici</TD></TR>
  <TR>
    <TD>AS</TD>
    <TD>Aji Saka Era (Java)</TD></TR>
  <TR>
    <TD>BE</TD>
    <TD>Buddhist Era</TD></TR>
  <TR>
    <TD>CB</TD>
    <TD>Cooch Behar Era</TD></TR>
  <TR>
    <TD>CE</TD>
    <TD>Common Era</TD></TR>
  <TR>
    <TD>CL</TD>
    <TD>Chinese Lunar Era</TD></TR>
  <TR>
    <TD>CS</TD>
    <TD>Chula Sakarat Era</TD></TR>
  <TR>
    <TD>EE</TD>
    <TD>Ethiopian Era</TD></TR>
  <TR>
    <TD>FE</TD>
    <TD>Fasli Era</TD></TR>
  <TR>
    <TD>ISO</TD>
    <TD>ISO 8601 calendar</TD></TR>
  <TR>
    <TD>JE</TD>
    <TD>Japanese Calendar</TD></TR>
  <TR>
    <TD>KE</TD>
    <TD>Khalsa Era (Sikh calendar)</TD></TR>
  <TR>
    <TD>KY</TD>
    <TD>Kali Yuga</TD></TR>
  <TR>
    <TD>ME</TD>
    <TD>Malabar Era</TD></TR>
  <TR>
    <TD>MS</TD>
    <TD>Monarchic Solar Era</TD></TR>
  <TR>
    <TD>NS</TD>
    <TD>Nepal Samwat Era</TD></TR>
  <TR>
    <TD>OS</TD>
    <TD>Old Style (Julian Calendar)</TD></TR>
  <TR>
    <TD>RS</TD>
    <TD>Rattanakosin (Bangkok) Era</TD></TR>
  <TR>
    <TD>SE</TD>
    <TD>Saka Era</TD></TR>
  <TR>
    <TD>SH</TD>
    <TD>Mohammedan Solar Era (Iran)</TD></TR>
  <TR>
    <TD>SS</TD>
    <TD>Saka Samvat</TD></TR>
  <TR>
    <TD>TE</TD>
    <TD>Tripurabda Era</TD></TR>
  <TR>
    <TD>VE</TD>
    <TD>Vikrama Era</TD></TR>
  <TR>
    <TD>VS</TD>
    <TD>Vikrama Samvat Era</TD></TR></TBODY></TABLE>
<P>At least one of the above calendars <SPAN class=verb>must</SPAN> be 
supported. It is <A title=implementation-defined 
href="REC-xslt20-20070123.htm#dt-implementation-defined">implementation-defined</A> 
which calendars are supported.</P>
<P>The ISO 8601 calendar (<A 
href="REC-xslt20-20070123.htm#ISO8601">[ISO 8601]</A>), 
which is included in the above list and designated <CODE>ISO</CODE>, is very 
similar to the Gregorian calendar designated <CODE>AD</CODE>, but it differs in 
several ways. The ISO calendar is intended to ensure that date and time formats 
can be read easily by other software, as well as being legible for human users. 
The ISO calendar prescribes the use of particular numbering conventions as 
defined in ISO 8601, rather than allowing these to be localized on a 
per-language basis. In particular it provides a numeric 'week date' format which 
identifies dates by year, week of the year, and day in the week; in the ISO 
calendar the days of the week are numbered from 1 (Monday) to 7 (Sunday), and 
week 1 in any calendar year is the week (from Monday to Sunday) that includes 
the first Thursday of that year. The numeric values of the components year, 
month, day, hour, minute, and second are the same in the ISO calendar as the 
values used in the lexical representation of the date and time as defined in <A 
href="REC-xslt20-20070123.htm#xmlschema-2">[XML Schema 
Part 2]</A>. The era ("E" component) with this calendar is either a minus sign 
(for negative years) or a zero-length string (for positive years). For dates 
before 1 January, AD 1, year numbers in the ISO and AD calendars are off by one 
from each other: ISO year 0000 is 1 BC, -0001 is 2 BC, etc.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>The value space of the date and time data types, as defined in XML Schema, is 
based on absolute points in time. The lexical space of these data types defines 
a representation of these absolute points in time using the proleptic Gregorian 
calendar, that is, the modern Western calendar extrapolated into the past and 
the future; but the value space is calendar-neutral. The <A 
title="date formatting function" 
href="REC-xslt20-20070123.htm#dt-date-formatting-function">date 
formatting functions</A> produce a representation of this absolute point in 
time, but denoted in a possibly different calendar. So, for example, the date 
whose lexical representation in XML Schema is <CODE>1502-01-11</CODE> (the day 
on which Pope Gregory XIII was born) might be formatted using the Old Style 
(Julian) calendar as <CODE>1 January 1502</CODE>. This reflects the fact that 
there was at that time a ten-day difference between the two calendars. It would 
be incorrect, and would produce incorrect results, to represent this date in an 
element or attribute of type <CODE>xs:date</CODE> as <CODE>1502-01-01</CODE>, 
even though this might reflect the way the date was recorded in contemporary 
documents.</P>
<P>When referring to years occurring in antiquity, modern historians generally 
use a numbering system in which there is no year zero (the year before 1 CE is 
thus 1 BCE). This is the convention that <SPAN class=verb>should</SPAN> be used 
when the requested calendar is OS (Julian) or AD (Gregorian). When the requested 
calendar is ISO, however, the conventions of ISO 8601 <SPAN 
class=verb>should</SPAN> be followed: here the year before +0001 is numbered 
zero. In <A 
href="REC-xslt20-20070123.htm#xmlschema-2">[XML Schema 
Part 2]</A> (version 1.0), the value space for <CODE>xs:date</CODE> and 
<CODE>xs:dateTime</CODE> does not include a year zero: however, a future edition 
is expected to endorse the ISO 8601 convention. This means that the date on 
which Julius Caesar was assassinated has the ISO 8601 lexical representation 
-0043-03-13, but will be formatted as 15 March 44 BCE in the Julian calendar or 
13 March 44 BCE in the Gregorian calendar (dependant on the chosen localization 
of the names of months and eras).</P></DIV>
<P>The intended use of the <CODE>country</CODE> argument is to identify the 
place where an event represented by the <CODE>dateTime</CODE>, 
<CODE>date</CODE>, or <CODE>time</CODE> supplied in the <CODE>$value</CODE> 
argument took place or will take place. If the value is supplied, and is not the 
empty sequence, then it <SPAN class=verb>should</SPAN> be a country code defined 
in <A href="REC-xslt20-20070123.htm#ISO3166">[ISO 
3166-1]</A>. Implementations <SPAN class=verb>may</SPAN> also allow the use of 
codes representing subdivisions of a country from ISO 3166-2, or codes 
representing formerly used names of countries from ISO 3166-3. This argument is 
not intended to identify the location of the user for whom the date or time is 
being formatted; that should be done by means of the <CODE>language</CODE> 
attribute. This information <SPAN class=verb>may</SPAN> be used to provide 
additional information when converting dates between calendars or when deciding 
how individual components of the date and time are to be formatted. For example, 
different countries using the Old Style (Julian) calendar started the new year 
on different days, and some countries used variants of the calendar that were 
out of synchronization as a result of differences in calculating leap years. 
<SPAN>The geographical area identified by a country code is defined by the 
boundaries as they existed at the time of the date to be formatted, or the 
present-day boundaries for dates in the future.</SPAN></P></DIV>
<DIV class=div3>
<H4><A id=date-time-examples name=date-time-examples></A>16.5.3 Examples of Date 
and Time Formatting</H4>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e24888 name=d5e24888></A>Example: Gregorian 
Calendar </DIV>
<P>The following examples show a selection of dates and times and the way they 
might be formatted. These examples assume the use of the Gregorian calendar as 
the default calendar.</P>
<TABLE cellPadding=5 border=1>
  <THEAD>
  <TR>
    <TH align=left>Required Output</TH>
    <TH align=left>Expression</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD><CODE>2002-12-31</CODE></TD>
    <TD><CODE>format-date($d, "[Y0001]-[M01]-[D01]")</CODE></TD></TR>
  <TR>
    <TD><CODE>12-31-2002</CODE></TD>
    <TD><CODE>format-date($d, "[M]-[D]-[Y]")</CODE></TD></TR>
  <TR>
    <TD><CODE>31-12-2002</CODE></TD>
    <TD><CODE>format-date($d, "[D]-[M]-[Y]")</CODE></TD></TR>
  <TR>
    <TD><CODE>31 XII 2002</CODE></TD>
    <TD><CODE>format-date($d, "[D1] [MI] [Y]")</CODE></TD></TR>
  <TR>
    <TD><CODE>31st December, 2002</CODE></TD>
    <TD><CODE>format-date($d, "[D1o] [MNn], [Y]", "en", (), ())</CODE></TD></TR>
  <TR>
    <TD><CODE>31 DEC 2002</CODE></TD>
    <TD><CODE>format-date($d, "[D01] [MN,*-3] [Y0001]", "en", (), 
  ())</CODE></TD></TR>
  <TR>
    <TD><CODE>December 31, 2002</CODE></TD>
    <TD><CODE>format-date($d, "[MNn] [D], [Y]", "en", (), ())</CODE></TD></TR>
  <TR>
    <TD><CODE>31 Dezember, 2002</CODE></TD>
    <TD><CODE>format-date($d, "[D] [MNn], [Y]", "de", (), ())</CODE></TD></TR>
  <TR>
    <TD><CODE>Tisdag 31 December 2002</CODE></TD>
    <TD><CODE>format-date($d, "[FNn] [D] [MNn] [Y]", "sv", (), 
())</CODE></TD></TR>
  <TR>
    <TD><CODE>[2002-12-31]</CODE></TD>
    <TD><CODE>format-date($d, "[[[Y0001]-[M01]-[D01]]]")</CODE></TD></TR>
  <TR>
    <TD><CODE>Two Thousand and Three</CODE></TD>
    <TD><CODE>format-date($d, "[YWw]", "en", (), ())</CODE></TD></TR>
  <TR>
    <TD><CODE>einunddreißigste Dezember</CODE></TD>
    <TD><CODE>format-date($d, "[Dwo] [MNn]", "de", (), ())</CODE></TD></TR>
  <TR>
    <TD><CODE>3:58 PM</CODE></TD>
    <TD><CODE>format-time($t, "[h]:[m01] [PN]", "en", (), ())</CODE></TD></TR>
  <TR>
    <TD><CODE>3:58:45 pm</CODE></TD>
    <TD><CODE>format-time($t, "[h]:[m01]:[s01] [Pn]", "en", (), 
  ())</CODE></TD></TR>
  <TR>
    <TD><CODE>3:58:45 PM PDT</CODE></TD>
    <TD><CODE>format-time($t, "[h]:[m01]:[s01] [PN] [ZN,*-3]", "en", (), 
      ())</CODE></TD></TR>
  <TR>
    <TD><CODE>3:58:45 o'clock PM PDT</CODE></TD>
    <TD><CODE>format-time($t, "[h]:[m01]:[s01] o'clock [PN] [ZN,*-3]", 
      "en")</CODE></TD></TR>
  <TR>
    <TD><CODE>15:58</CODE></TD>
    <TD><CODE>format-time($t,"[H01]:[m01]")</CODE></TD></TR>
  <TR>
    <TD><CODE>15:58:45.762</CODE></TD>
    <TD><CODE>format-time($t,"[H01]:[m01]:[s01].[f001]")</CODE></TD></TR>
  <TR>
    <TD><CODE>15:58:45 GMT+02:00</CODE></TD>
    <TD><CODE>format-time($t,"[H01]:[m01]:[s01] [z]", "en", (), 
  ())</CODE></TD></TR>
  <TR>
    <TD><CODE>15.58 Uhr GMT+02:00</CODE></TD>
    <TD><CODE>format-time($t,"[H01]:[m01] Uhr [z]", "de", (), ())</CODE></TD></TR>
  <TR>
    <TD><CODE>3.58pm on Tuesday, 31st December</CODE></TD>
    <TD><CODE>format-dateTime($dt, "[h].[m01][Pn] on [FNn], [D1o] 
      [MNn]")</CODE></TD></TR>
  <TR>
    <TD><SPAN><CODE>12/31/2002 at 15:58:45</CODE></SPAN></TD>
    <TD><CODE>format-dateTime($dt, "[M01]/[D01]/[Y0001] at 
      [H01]:[m01]:[s01]")</CODE></TD></TR></TBODY></TABLE></DIV>
<P>&nbsp;</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e25057 name=d5e25057></A>Example: Non-Gregorian 
Calendars </DIV>
<P>The following examples use calendars other than the Gregorian calendar.</P>
<P>These examples use non-Latin characters which might not display correctly in 
all browsers, depending on the system configuration.</P>
<TABLE cellPadding=5 border=1>
  <THEAD>
  <TR>
    <TH align=left>Description</TH>
    <TH align=left>Request</TH>
    <TH align=left>Result</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD vAlign=top>Islamic</TD>
    <TD vAlign=top><CODE>format-date($d, "[D&amp;#x0661;] [Mn] 
      [Y&amp;#x0661;]", "Islamic", "ar", "AH", ())</CODE></TD>
    <TD vAlign=top>٢٦ ﺸﻭّﺍﻝ ١٤٢٣</TD></TR>
  <TR>
    <TD vAlign=top>Jewish (with Western numbering)</TD>
    <TD vAlign=top><CODE>format-date($d, "[D] [Mn] [Y]", "he", "AM", 
    ())</CODE></TD>
    <TD vAlign=top>‏26 טבת 5763</TD></TR>
  <TR>
    <TD vAlign=top>Jewish (with traditional numbering)</TD>
    <TD vAlign=top><CODE>format-date($d, "[D&amp;#x05D0;t] [Mn] 
      [Y&amp;#x05D0;t]", "he", "AM", ())</CODE></TD>
    <TD vAlign=top>כ״ו טבת תשס״ג</TD></TR>
  <TR>
    <TD vAlign=top>Julian (Old Style)</TD>
    <TD vAlign=top><CODE>format-date($d, "[D] [MNn] [Y]", "en", "OS", 
      ())</CODE></TD>
    <TD vAlign=top>18 December 2002</TD></TR>
  <TR>
    <TD vAlign=top>Thai</TD>
    <TD vAlign=top><CODE>format-date($d, "[D&amp;#x0E51;] [Mn] 
      [Y&amp;#x0E51;]", "th", "BE", ())</CODE></TD>
    <TD vAlign=top>๓๑ ธันวาคม ๒๕๔๕</TD></TR></TBODY></TABLE></DIV></DIV></DIV>
<DIV class=div2>
<H3><A id=misc-func name=misc-func></A>16.6 Miscellaneous Additional 
Functions</H3>
<DIV class=div3>
<H4><A id=current-function name=current-function></A>16.6.1 current</H4><A 
id=function-current name=function-current></A>
<DIV class=proto><CODE class=function>current</CODE>()<CODE 
class=as>&nbsp;as&nbsp;</CODE><CODE class=return-type>item()</CODE> </DIV>
<P>The <A 
href="REC-xslt20-20070123.htm#function-current"><CODE>current</CODE></A> 
function, used within an XPath <A title=expression 
href="REC-xslt20-20070123.htm#dt-expression">expression</A>, 
returns the item that was the <A title="context item" 
href="REC-xslt20-20070123.htm#dt-context-item">context 
item</A> at the point where the expression was invoked from the XSLT <A 
title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A>. 
This is referred to as the current item. For an outermost expression (an 
expression not occurring within another expression), the current item is always 
the same as the context item. Thus,</P>
<DIV class=exampleInner><PRE>&lt;xsl:value-of select="current()"/&gt;
</PRE></DIV>
<P>means the same as</P>
<DIV class=exampleInner><PRE>&lt;xsl:value-of select="."/&gt;
</PRE></DIV>
<P>However, within square brackets, or on the right-hand side of the 
<CODE>/</CODE> operator, the current item is generally different from the 
context item.</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e25146 name=d5e25146></A>Example: Using the 
<CODE>current</CODE> Function </DIV>
<P>For example,</P>
<DIV class=exampleInner><PRE>&lt;xsl:apply-templates select="//glossary/entry[@name=current()/@ref]"/&gt;
</PRE></DIV>
<P>will process all <CODE>entry</CODE> elements that have a 
<CODE>glossary</CODE> parent element and that have a <CODE>name</CODE> attribute 
with value equal to the value of the current item's <CODE>ref</CODE> attribute. 
This is different from</P>
<DIV class=exampleInner><PRE>&lt;xsl:apply-templates select="//glossary/entry[@name=./@ref]"/&gt;
</PRE></DIV>
<P>which means the same as</P>
<DIV class=exampleInner><PRE>&lt;xsl:apply-templates select="//glossary/entry[@name=@ref]"/&gt;
</PRE></DIV>
<P>and so would process all <CODE>entry</CODE> elements that have a 
<CODE>glossary</CODE> parent element and that have a <CODE>name</CODE> attribute 
and a <CODE>ref</CODE> attribute with the same value.</P></DIV>
<P>If the <A 
href="REC-xslt20-20070123.htm#function-current"><CODE>current</CODE></A> 
function is used within a <A title=pattern 
href="REC-xslt20-20070123.htm#dt-pattern">pattern</A>, 
its value is the node that is being matched against the pattern.</P>
<P><A id=err-XTDE1360 name=err-XTDE1360><SPAN class=error>[ERR 
XTDE1360]</SPAN></A> If the <A 
href="REC-xslt20-20070123.htm#function-current"><CODE>current</CODE></A> 
function is evaluated within an expression that is evaluated when the context 
item is undefined, a <A title="non-recoverable dynamic error" 
href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
dynamic error</A> occurs.</P></DIV>
<DIV class=div3>
<H4><A id=unparsed-entity-uri name=unparsed-entity-uri></A>16.6.2 
unparsed-entity-uri</H4><A id=function-unparsed-entity-uri 
name=function-unparsed-entity-uri></A>
<DIV class=proto><CODE class=function>unparsed-entity-uri</CODE>(<CODE 
class=arg>$entity-name</CODE><CODE class=as>&nbsp;as&nbsp;</CODE><CODE 
class=type>xs:string</CODE>)<CODE class=as>&nbsp;as&nbsp;</CODE><CODE 
class=return-type>xs:anyURI</CODE> </DIV>
<P>The <A 
href="REC-xslt20-20070123.htm#function-unparsed-entity-uri"><CODE>unparsed-entity-uri</CODE></A> 
function returns the URI of the unparsed entity whose name is given by the value 
of the <CODE>$entity-name</CODE> argument, in the document containing the <A 
title="context node" 
href="REC-xslt20-20070123.htm#dt-context-node">context 
node</A>. It returns the zero-length <SPAN><CODE>xs:anyURI</CODE></SPAN> if 
there is no such entity. <SPAN>This function maps to the 
<CODE>dm:unparsed-entity-system-id</CODE> accessor defined in <A 
href="REC-xslt20-20070123.htm#xpath-datamodel">[Data 
Model]</A>.</SPAN></P>
<P><A id=err-XTDE1370 name=err-XTDE1370><SPAN class=error>[ERR 
XTDE1370]</SPAN></A> It is a <A title="non-recoverable dynamic error" 
href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
dynamic error</A> if the <A 
href="REC-xslt20-20070123.htm#function-unparsed-entity-uri"><CODE>unparsed-entity-uri</CODE></A> 
function is called when there is no <A title="context node" 
href="REC-xslt20-20070123.htm#dt-context-node">context 
node</A>, or when the root of the tree containing the context node is not a 
document node.</P></DIV>
<DIV class=div3>
<H4><A id=unparsed-entity-public-id name=unparsed-entity-public-id></A>16.6.3 
unparsed-entity-public-id</H4><A id=function-unparsed-entity-public-id 
name=function-unparsed-entity-public-id></A>
<DIV class=proto><CODE class=function>unparsed-entity-public-id</CODE>(<CODE 
class=arg> $entity-name</CODE><CODE class=as>&nbsp;as&nbsp;</CODE><CODE 
class=type>xs:string</CODE>)<CODE class=as>&nbsp;as&nbsp;</CODE><CODE 
class=return-type>xs:string</CODE> </DIV>
<P>The <A 
href="REC-xslt20-20070123.htm#function-unparsed-entity-public-id"><CODE>unparsed-entity-public-id</CODE></A> 
function returns the public identifier of the unparsed entity whose name is 
given by the value of the <CODE>$entity-name</CODE> argument, in the document 
containing the <A title="context node" 
href="REC-xslt20-20070123.htm#dt-context-node">context 
node</A>. It returns the zero-length string if there is no such entity<SPAN>, or 
if the entity has no public identifier</SPAN>. <SPAN>This function maps to the 
<CODE>dm:unparsed-entity-public-id</CODE> accessor defined in <A 
href="REC-xslt20-20070123.htm#xpath-datamodel">[Data 
Model]</A>.</SPAN></P>
<P><A id=err-XTDE1380 name=err-XTDE1380><SPAN class=error>[ERR 
XTDE1380]</SPAN></A> It is a <A title="non-recoverable dynamic error" 
href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
dynamic error</A> if the <A 
href="REC-xslt20-20070123.htm#function-unparsed-entity-public-id"><CODE>unparsed-entity-public-id</CODE></A> 
function is called when there is no <A title="context node" 
href="REC-xslt20-20070123.htm#dt-context-node">context 
node</A>, or when the root of the tree containing the context node is not a 
document node.</P></DIV>
<DIV class=div3>
<H4><A id=generate-id name=generate-id></A>16.6.4 generate-id</H4><A 
id=function-generate-id name=function-generate-id></A>
<DIV class=proto><CODE class=function>generate-id</CODE>()<CODE 
class=as>&nbsp;as&nbsp;</CODE><CODE class=return-type>xs:string</CODE> </DIV>
<DIV class=proto><CODE class=function>generate-id</CODE>(<CODE 
class=arg>$node</CODE><CODE class=as>&nbsp;as&nbsp;</CODE><CODE 
class=type>node()?</CODE>)<CODE class=as>&nbsp;as&nbsp;</CODE><CODE 
class=return-type>xs:string</CODE> </DIV>
<P>The <A 
href="REC-xslt20-20070123.htm#function-generate-id"><CODE>generate-id</CODE></A> 
function returns a string that uniquely identifies a given node. The unique 
identifier <SPAN class=verb>must</SPAN> consist of ASCII alphanumeric characters 
and <SPAN class=verb>must</SPAN> start with an alphabetic character. Thus, the 
string is syntactically an XML name. An implementation is free to generate an 
identifier in any convenient way provided that it always generates the same 
identifier for the same node and that different identifiers are always generated 
from different nodes. An implementation is under no obligation to generate the 
same identifiers each time a document is transformed. There is no guarantee that 
a generated unique identifier will be distinct from any unique IDs specified in 
the source document. If the argument is the empty sequence, the result is the 
<SPAN>zero-length string</SPAN>. If the argument is omitted, it defaults to the 
<A title="context node" 
href="REC-xslt20-20070123.htm#dt-context-node">context 
node</A>.</P></DIV>
<DIV class=div3>
<H4><A id=system-property name=system-property></A>16.6.5 system-property</H4><A 
id=function-system-property name=function-system-property></A>
<DIV class=proto><CODE class=function>system-property</CODE>(<CODE 
class=arg>$property-name</CODE><CODE class=as>&nbsp;as&nbsp;</CODE><CODE 
class=type>xs:string</CODE>)<CODE class=as>&nbsp;as&nbsp;</CODE><CODE 
class=return-type>xs:string</CODE> </DIV>
<P>The <CODE>$property-name</CODE> argument <SPAN class=verb>must</SPAN> 
evaluate to a <A title="lexical QName" 
href="REC-xslt20-20070123.htm#dt-lexical-qname">lexical 
QName</A>. The <A title="lexical QName" 
href="REC-xslt20-20070123.htm#dt-lexical-qname">lexical 
QName</A> is expanded as described in <A 
href="REC-xslt20-20070123.htm#qname"><I>5.1 Qualified 
Names</I></A>.</P>
<P><A id=err-XTDE1390 name=err-XTDE1390><SPAN class=error>[ERR 
XTDE1390]</SPAN></A> It is a <A title="non-recoverable dynamic error" 
href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
dynamic error</A> if the value is not a valid QName, or if there is no namespace 
declaration in scope for the prefix of the QName. If the processor is able to 
detect the error statically (for example, when the argument is supplied as a 
string literal), then the processor <SPAN class=verb>may</SPAN> optionally 
signal this as a <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A>.</P>
<P>The <A 
href="REC-xslt20-20070123.htm#function-system-property"><CODE>system-property</CODE></A> 
function returns a string representing the value of the system property 
identified by the name. If there is no such system property, the zero-length 
string <SPAN>is</SPAN> returned.</P>
<P>Implementations <SPAN class=verb>must</SPAN> provide the following system 
properties, which are all in the <A title="XSLT namespace" 
href="REC-xslt20-20070123.htm#dt-xslt-namespace">XSLT 
namespace</A>:</P>
<UL>
  <LI>
  <P><CODE>xsl:version</CODE>, a number giving the version of XSLT implemented 
  by the <A title=processor 
  href="REC-xslt20-20070123.htm#dt-processor">processor</A>; 
  for implementations conforming to the version of XSLT specified by this 
  document, this is the string <CODE>"2.0"</CODE>. The value will always be a 
  string in the lexical space of the decimal data type defined in XML Schema 
  (see <A href="REC-xslt20-20070123.htm#xmlschema-2">[XML 
  Schema Part 2]</A>). This allows the value to be converted to a number for the 
  purpose of magnitude comparisons.</P>
  <LI>
  <P><CODE>xsl:vendor</CODE>, a string identifying the implementer of the <A 
  title=processor 
  href="REC-xslt20-20070123.htm#dt-processor">processor</A></P>
  <LI>
  <P><CODE>xsl:vendor-url</CODE>, a string containing a URL identifying the 
  implementer of the <A title=processor 
  href="REC-xslt20-20070123.htm#dt-processor">processor</A>; 
  typically this is the host page (home page) of the implementer's Web site.</P>
  <LI>
  <P><CODE>xsl:product-name</CODE>, a string containing the name of the 
  implementation, as defined by the implementer. This <SPAN 
  class=verb>should</SPAN> normally remain constant from one release of the 
  product to the next. It <SPAN class=verb>should</SPAN> also be constant across 
  platforms in cases where the same source code is used to produce compatible 
  products for multiple execution platforms.</P>
  <LI>
  <P><CODE>xsl:product-version</CODE>, a string identifying the version of the 
  implementation, as defined by the implementer. This <SPAN 
  class=verb>should</SPAN> normally vary from one release of the product to the 
  next, and at the discretion of the implementer it <SPAN class=verb>may</SPAN> 
  also vary across different execution platforms.</P>
  <LI>
  <P><CODE>xsl:is-schema-aware</CODE>, returns the string <CODE>"yes"</CODE> in 
  the case of a processor that claims conformance as a <A 
  title="schema-aware XSLT processor" 
  href="REC-xslt20-20070123.htm#dt-schema-aware-xslt-processor">schema-aware 
  XSLT processor</A>, or <CODE>"no"</CODE> in the case of a <A 
  title="basic XSLT processor" 
  href="REC-xslt20-20070123.htm#dt-basic-xslt-processor">basic 
  XSLT processor</A>.</P>
  <LI>
  <P><CODE>xsl:supports-serialization</CODE>, returns the string 
  <CODE>"yes"</CODE> in the case of a processor that offers the <A 
  title="serialization feature" 
  href="REC-xslt20-20070123.htm#dt-serialization-feature">serialization 
  feature</A>, or <CODE>"no"</CODE> otherwise.</P>
  <LI>
  <P><CODE>xsl:supports-backwards-compatibility</CODE>, returns the string 
  <CODE>"yes"</CODE> in the case of a processor that offers the <A 
  title="backwards compatibility feature" 
  href="REC-xslt20-20070123.htm#dt-backwards-compatibility-feature">backwards 
  compatibility feature</A>, or <CODE>"no"</CODE> otherwise.</P></LI></UL>
<P>Some of these properties relate to the conformance levels and features 
offered by the <A title=processor 
href="REC-xslt20-20070123.htm#dt-processor">processor</A>: 
these options are described in <A 
href="REC-xslt20-20070123.htm#conformance"><I>21 
Conformance</I></A>.</P>
<P>The actual values returned for the above properties are <A 
title=implementation-defined 
href="REC-xslt20-20070123.htm#dt-implementation-defined">implementation-defined</A>.</P>
<P>The set of system properties that are supported, in addition to those listed 
above, is also <A title=implementation-defined 
href="REC-xslt20-20070123.htm#dt-implementation-defined">implementation-defined</A>. 
Implementations <SPAN class=verb>must not</SPAN> define additional system 
properties in the XSLT namespace.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>An implementation must not return the value <CODE>2.0</CODE> as the value of 
the <CODE>xsl:version</CODE> system property unless it is conformant to XSLT 
2.0.</P>
<P>It is recognized that vendors who are enhancing XSLT 1.0 processors may wish 
to release interim implementations before all the mandatory features of this 
specification are implemented. Since such products are not conformant to XSLT 
2.0, this specification cannot define their behavior. However, implementers of 
such products are encouraged to return a value for the <CODE>xsl:version</CODE> 
system property that is intermediate between 1.0 and 2.0, and to provide the <A 
href="REC-xslt20-20070123.htm#function-element-available"><CODE>element-available</CODE></A> 
and <A 
href="REC-xslt20-20070123.htm#function-function-available"><CODE>function-available</CODE></A> 
functions to allow users to test which features have been fully 
implemented.</P></DIV></DIV></DIV></DIV>
<DIV class=div1>
<H2><A id=message name=message></A>17 Messages</H2>
<P class=element-syntax><A id=element-message 
name=element-message></A><CODE>&lt;!-- Category: instruction 
--&gt;<BR>&lt;xsl:message<BR>&nbsp;&nbsp;select? = 
<VAR>expression</VAR><BR>&nbsp;&nbsp;terminate? = { "yes" | "no" 
}&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: <VAR>sequence-constructor</VAR> 
--&gt;<BR>&lt;/xsl:message&gt;</CODE></P>
<P>The <A 
href="REC-xslt20-20070123.htm#element-message"><CODE>xsl:message</CODE></A> 
instruction sends a message in an <A title=implementation-defined 
href="REC-xslt20-20070123.htm#dt-implementation-defined">implementation-defined</A> 
way. The <A 
href="REC-xslt20-20070123.htm#element-message"><CODE>xsl:message</CODE></A> 
instruction causes the creation of a new document, which is typically serialized 
and output to an <A title=implementation-defined 
href="REC-xslt20-20070123.htm#dt-implementation-defined">implementation-defined</A> 
destination. The result of the <A 
href="REC-xslt20-20070123.htm#element-message"><CODE>xsl:message</CODE></A> 
instruction is an empty sequence.</P>
<P>The content of the message may be specified by using either or both of the 
optional <CODE>select</CODE> attribute and the <A title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A> that forms the content of the <A 
href="REC-xslt20-20070123.htm#element-message"><CODE>xsl:message</CODE></A> 
instruction.</P>
<P>If the <A 
href="REC-xslt20-20070123.htm#element-message"><CODE>xsl:message</CODE></A> 
instruction contains a <A title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A>, then the sequence obtained by evaluating this sequence 
constructor is used to construct the content of the new document node, as 
described in <A 
href="REC-xslt20-20070123.htm#constructing-complex-content"><I>5.7.1 
Constructing Complex Content</I></A>.</P>
<P>If the <A 
href="REC-xslt20-20070123.htm#element-message"><CODE>xsl:message</CODE></A> 
instruction has a <CODE>select</CODE> attribute, then the value of the attribute 
<SPAN class=verb>must</SPAN> be an XPath expression. The effect of the <A 
href="REC-xslt20-20070123.htm#element-message"><CODE>xsl:message</CODE></A> 
instruction is then the same as if a single <A 
href="REC-xslt20-20070123.htm#element-copy-of"><CODE>xsl:copy-of</CODE></A> 
instruction with this <CODE>select</CODE> attribute were added to the start of 
the <A title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A>.</P>
<P>If the <A 
href="REC-xslt20-20070123.htm#element-message"><CODE>xsl:message</CODE></A> 
instruction has no content and no <CODE>select</CODE> attribute, then an empty 
message is produced.</P>
<P>The tree produced by the <A 
href="REC-xslt20-20070123.htm#element-message"><CODE>xsl:message</CODE></A> 
instruction is not technically a <A title="final result tree" 
href="REC-xslt20-20070123.htm#dt-final-result-tree">final 
result tree</A>. The tree has no URI and processors are not <SPAN 
class=verb>required</SPAN> to make the tree accessible to applications.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>In many cases, the XML document produced using <A 
href="REC-xslt20-20070123.htm#element-message"><CODE>xsl:message</CODE></A> 
will consist of a document node owning a single text node. However, it may 
contain a more complex structure.</P></DIV>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>An implementation might implement <A 
href="REC-xslt20-20070123.htm#element-message"><CODE>xsl:message</CODE></A> 
by popping up an alert box or by writing to a log file. <SPAN>Because the order 
of execution of instructions is implementation-defined, the order in which such 
messages appear is not predictable.</SPAN></P></DIV>
<P>The <CODE>terminate</CODE> attribute is interpreted as an <A 
title="attribute value template" 
href="REC-xslt20-20070123.htm#dt-attribute-value-template">attribute 
value template</A>.</P>
<P>If the <A title="effective value" 
href="REC-xslt20-20070123.htm#dt-effective-value">effective 
value</A> of the <CODE>terminate</CODE> attribute is <CODE>yes</CODE>, then the 
<A title=processor 
href="REC-xslt20-20070123.htm#dt-processor">processor</A> 
<SPAN class=verb>must</SPAN> terminate processing after sending the message. The 
default value is <CODE>no</CODE>. Note that because the order of evaluation of 
instructions is <A title=implementation-dependent 
href="REC-xslt20-20070123.htm#dt-implementation-dependent">implementation-dependent</A>, 
this gives no guarantee that any particular instruction will or will not be 
evaluated before processing terminates.</P>
<P><A id=err-XTMM9000 name=err-XTMM9000><SPAN class=error>[ERR 
XTMM9000]</SPAN></A> When a transformation is terminated by use of 
<CODE>xsl:message terminate="yes"</CODE>, the effect is the same as when a <A 
title="non-recoverable dynamic error" 
href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
dynamic error</A> occurs during the transformation.</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e25672 name=d5e25672></A>Example: Localizing 
Messages </DIV>
<P>One convenient way to do localization is to put the localized information 
(message text, etc.) in an XML document, which becomes an additional input file 
to the <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A>. 
For example, suppose messages for a language <CODE><VAR>L</VAR></CODE> are 
stored in an XML file <CODE>resources/<VAR>L</VAR>.xml</CODE> in the form:</P>
<DIV class=exampleInner><PRE>&lt;messages&gt;
  &lt;message name="problem"&gt;A problem was detected.&lt;/message&gt;
  &lt;message name="error"&gt;An error was detected.&lt;/message&gt;
&lt;/messages&gt;
</PRE></DIV>
<P>Then a stylesheet could use the following approach to localize messages:</P>
<DIV class=exampleInner><PRE>&lt;xsl:param name="lang" select="'en'"/&gt;
&lt;xsl:variable name="messages"
  select="document(concat('resources/', $lang, '.xml'))/messages"/&gt;

&lt;xsl:template name="localized-message"&gt;
  &lt;xsl:param name="name"/&gt;
  &lt;xsl:message select="string($messages/message[@name=$name])"/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template name="problem"&gt;
  &lt;xsl:call-template name="localized-message"&gt;
    &lt;xsl:with-param name="name"&gt;problem&lt;/xsl:with-param&gt;
  &lt;/xsl:call-template&gt;
&lt;/xsl:template&gt;
</PRE></DIV></DIV></DIV>
<DIV class=div1>
<H2><A id=extension name=extension></A>18 Extensibility and Fallback</H2>
<P>XSLT allows two kinds of extension, extension instructions and extension 
functions.</P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A 
id=dt-extension-instruction title="extension instruction" 
name=dt-extension-instruction></A>An <B>extension instruction</B> is an element 
within a <A title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A> that is in a namespace (not the <A title="XSLT namespace" 
href="REC-xslt20-20070123.htm#dt-xslt-namespace">XSLT 
namespace</A>) designated as an extension namespace.<SPAN 
class=definition>]</SPAN></P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-extension-function 
title="extension function" name=dt-extension-function></A>An <B>extension 
function</B> is a function that is available for use within an XPath <A 
title=expression 
href="REC-xslt20-20070123.htm#dt-expression">expression</A>, 
other than a <A title="core function" 
href="REC-xslt20-20070123.htm#dt-core-function">core 
function</A> defined in <A 
href="REC-xslt20-20070123.htm#xpath-functions">[Functions 
and Operators]</A>, an additional function defined in this XSLT specification, 
<SPAN>a constructor function named after an atomic type,</SPAN> or a <A 
title="stylesheet function" 
href="REC-xslt20-20070123.htm#dt-stylesheet-function">stylesheet 
function</A> defined using an <A 
href="REC-xslt20-20070123.htm#element-function"><CODE>xsl:function</CODE></A> 
declaration.<SPAN class=definition>]</SPAN>.</P>
<P>This specification does not define any mechanism for creating or binding 
implementations of <A title="extension instruction" 
href="REC-xslt20-20070123.htm#dt-extension-instruction">extension 
instructions</A> or <A title="extension function" 
href="REC-xslt20-20070123.htm#dt-extension-function">extension 
functions</A>, and it is not <SPAN class=verb>required</SPAN> that 
implementations support any such mechanism. Such mechanisms, if they exist, are 
<A title=implementation-defined 
href="REC-xslt20-20070123.htm#dt-implementation-defined">implementation-defined</A>. 
Therefore, an XSLT stylesheet that <SPAN class=verb>must</SPAN> be portable 
between XSLT implementations cannot rely on particular extensions being 
available. XSLT provides mechanisms that allow an XSLT stylesheet to determine 
whether the implementation makes particular extensions available, and to specify 
what happens if those extensions are not available. If an XSLT stylesheet is 
careful to make use of these mechanisms, it is possible for it to take advantage 
of extensions and still retain portability.</P>
<DIV class=div2>
<H3><A id=extension-functions name=extension-functions></A>18.1 Extension 
Functions</H3>
<P>The set of functions that can be called from a <A 
href="http://www.w3.org/TR/xpath20/#doc-xpath-FunctionCall">FunctionCall</A><SUP> 
<SMALL>XP</SMALL></SUP> within an XPath <A title=expression 
href="REC-xslt20-20070123.htm#dt-expression">expression</A> 
may include one or more <A title="extension function" 
href="REC-xslt20-20070123.htm#dt-extension-function">extension 
functions</A>. The <A title=expanded-QName 
href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded-QName</A> 
of an extension function always has a non-null namespace URI.</P>
<DIV class=div3>
<H4><A id=testing-function-availability 
name=testing-function-availability></A>18.1.1 Testing Availability of 
Functions</H4>
<P>The <A 
href="REC-xslt20-20070123.htm#function-function-available"><CODE>function-available</CODE></A> 
function can be used with the <CODE>[xsl:]use-when</CODE> attribute (see <A 
href="REC-xslt20-20070123.htm#conditional-inclusion"><I>3.12 
Conditional Element Inclusion</I></A>) to explicitly control how a stylesheet 
behaves if a particular extension function is not available.</P><A 
id=function-function-available name=function-function-available></A>
<DIV class=proto><CODE class=function>function-available</CODE>(<CODE 
class=arg>$function-name</CODE><CODE class=as>&nbsp;as&nbsp;</CODE><CODE 
class=type>xs:string</CODE>)<CODE class=as>&nbsp;as&nbsp;</CODE><CODE 
class=return-type>xs:boolean</CODE> </DIV>
<DIV class=proto>
<TABLE cellSpacing=0 cellPadding=0 border=0>
  <TBODY>
  <TR>
    <TD vAlign=baseline rowSpan=2><CODE 
      class=function>function-available</CODE>(</TD>
    <TD vAlign=baseline><CODE class=arg>$function-name</CODE></TD>
    <TD vAlign=baseline><CODE class=as>&nbsp;as&nbsp;</CODE><CODE 
      class=type>xs:string</CODE>,</TD></TR>
  <TR>
    <TD vAlign=baseline><CODE class=arg>$arity</CODE></TD>
    <TD vAlign=baseline><CODE class=as>&nbsp;as&nbsp;</CODE><CODE 
      class=type>xs:integer</CODE>)<CODE class=as>&nbsp;as&nbsp;</CODE><CODE 
      class=return-type>xs:boolean</CODE></TD></TR></TBODY></TABLE></DIV>
<P>A function is said to be available within an XPath expression if it is 
present in the <A 
href="http://www.w3.org/TR/xpath20/#dt-function-signature">in-scope 
functions</A><SUP><SMALL>XP</SMALL></SUP> for that expression (see <A 
href="REC-xslt20-20070123.htm#static-context"><I>5.4.1 
Initializing the Static Context</I></A>). Functions in the static context are 
uniquely identified by the name of the function (a QName) in combination with 
its <A title=arity 
href="REC-xslt20-20070123.htm#dt-arity">arity</A>.</P>
<P>The value of the <CODE>$function-name</CODE> argument <SPAN 
class=verb>must</SPAN> be a string containing a <A title="lexical QName" 
href="REC-xslt20-20070123.htm#dt-lexical-qname">lexical 
QName</A>. The lexical QName is expanded into an <A title=expanded-QName 
href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded-QName</A> 
using the namespace declarations in scope for the <A title=expression 
href="REC-xslt20-20070123.htm#dt-expression">expression</A>. 
If the lexical QName is unprefixed, then the <A 
title="standard function namespace" 
href="REC-xslt20-20070123.htm#dt-standard-function-namespace">standard 
function namespace</A> is used in the expanded QName.</P>
<P>The two-argument version of the <A 
href="REC-xslt20-20070123.htm#function-function-available"><CODE>function-available</CODE></A> 
function returns true if and only if there is an available function whose name 
matches the value of the <CODE>$function-name</CODE> argument and whose <A 
title=arity 
href="REC-xslt20-20070123.htm#dt-arity">arity</A> matches 
the value of the <CODE>$arity</CODE> argument.</P>
<P>The single-argument version of the <A 
href="REC-xslt20-20070123.htm#function-function-available"><CODE>function-available</CODE></A> 
function returns true if and only if there is at least one available function 
(with some arity) whose name matches the value of the 
<CODE>$function-name</CODE> argument.</P>
<P><A id=err-XTDE1400 name=err-XTDE1400><SPAN class=error>[ERR 
XTDE1400]</SPAN></A> It is a <A title="non-recoverable dynamic error" 
href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
dynamic error</A> if the argument does not evaluate to a string that is a valid 
<A title=QName 
href="REC-xslt20-20070123.htm#dt-qname">QName</A>, or if 
there is no namespace declaration in scope for the prefix of the <A title=QName 
href="REC-xslt20-20070123.htm#dt-qname">QName</A>. If the 
processor is able to detect the error statically (for example, when the argument 
is supplied as a string literal), then the processor <SPAN class=verb>may</SPAN> 
optionally signal this as a <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A>.</P>
<P>When <A title="backwards compatible behavior" 
href="REC-xslt20-20070123.htm#dt-backwards-compatible-behavior">backwards 
compatible behavior</A> is enabled, the <A 
href="REC-xslt20-20070123.htm#function-function-available"><CODE>function-available</CODE></A> 
function returns false in respect of a function name and arity for which no 
implementation is available (other than the fallback error function that raises 
a dynamic error whenever it is called). This means that it is possible (as in 
XSLT 1.0) to use logic such as the following to test whether a function is 
available before calling it:</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e25880 name=d5e25880></A>Example: Calling an 
extension function with backwards-compatibility enabled </DIV>
<DIV class=exampleInner><PRE>&lt;summary xsl:version="1.0"&gt;
  &lt;xsl:choose&gt;
    &lt;xsl:when test="function-available('my:summary')"&gt;
      &lt;xsl:value-of select="my:summary()"/&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;
      &lt;xsl:text&gt;Summary not available&lt;/xsl:text&gt;
    &lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
&lt;/summary&gt;
</PRE></DIV></DIV>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>The fact that a function with a given name is available gives no guarantee 
that any particular call on the function will be successful. For example, it is 
not possible to determine the types of the arguments expected.</P></DIV>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>In XSLT 2.0 <SPAN>(without backwards compatibility enabled)</SPAN> a static 
error occurs when an XPath expression references a function that is not 
available. This is true even in a part of the stylesheet that uses <A 
title="forwards-compatible behavior" 
href="REC-xslt20-20070123.htm#dt-forwards-compatible-behavior">forwards-compatible 
behavior</A>. Therefore, the conditional logic to test whether a function is 
available before calling it should normally be written in a 
<CODE>use-when</CODE> attribute (see <A 
href="REC-xslt20-20070123.htm#conditional-inclusion"><I>3.12 
Conditional Element Inclusion</I></A>).</P></DIV>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e25903 name=d5e25903></A>Example: Stylesheet 
portable between XSLT 1.0 and XSLT 2.0 </DIV>
<P>A stylesheet that is designed to use XSLT 2.0 facilities when they are 
available, but to fall back to XSLT 1.0 capabilities when not, might be written 
using the code:</P>
<DIV class=exampleInner><PRE>&lt;out xsl:version="2.0"&gt;
  &lt;xsl:choose&gt;
    &lt;xsl:when test="function-available('matches')"&gt;
      &lt;xsl:value-of select="matches($input, '[a-z]*')"/&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;
      &lt;xsl:value-of select="string-length(
                          translate($in, 'abcdefghijklmnopqrstuvwxyz', '')) = 0"/&gt;
    &lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
&lt;/out&gt;
</PRE></DIV>
<P>Here an XSLT 2.0 processor will always take the <A 
href="REC-xslt20-20070123.htm#element-when"><CODE>xsl:when</CODE></A> 
branch, while a 1.0 processor will follow the <A 
href="REC-xslt20-20070123.htm#element-otherwise"><CODE>xsl:otherwise</CODE></A> 
branch. The single-argument version of the <A 
href="REC-xslt20-20070123.htm#function-function-available"><CODE>function-available</CODE></A> 
function is used here, because that is the only version available in XSLT 1.0. 
Under the rules of XSLT 1.0, the call on the <CODE>matches</CODE> function is 
not an error, because it is never evaluated.</P></DIV>
<P>&nbsp;</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e25924 name=d5e25924></A>Example: Stylesheet 
portable between XSLT 2.0 and a future version of XSLT </DIV>
<P>A stylesheet that is designed to use facilities in some future XSLT version 
when they are available, but to fall back to XSLT 2.0 capabilities when not, 
might be written using code such as the following. This hypothesizes the 
availability in some future version of a function <CODE>pad</CODE> which pads a 
string to a fixed length with spaces:</P>
<DIV class=exampleInner><PRE> &lt;xsl:value-of select="pad($input, 10)" 
               use-when="function-available('pad', 2)"/&gt;
 &lt;xsl:value-of select="concat($input, string-join(
                          for $i in 1 to 10 - string-length($input) 
                                                  return ' ', ''))"
               use-when="not(function-available('pad', 2))"/&gt;
 
</PRE></DIV>
<P>In this case the two-argument version of <A 
href="REC-xslt20-20070123.htm#function-function-available"><CODE>function-available</CODE></A> 
is used, because there is no requirement for this code to run under XSLT 
1.0.</P></DIV></DIV>
<DIV class=div3>
<H4><A id=calling-extension-functions 
name=calling-extension-functions></A>18.1.2 Calling Extension Functions</H4>
<P>If the function name used in a <A 
href="http://www.w3.org/TR/xpath20/#doc-xpath-FunctionCall">FunctionCall</A><SUP> 
<SMALL>XP</SMALL></SUP> within an XPath <A title=expression 
href="REC-xslt20-20070123.htm#dt-expression">expression</A> 
identifies an extension function, then to evaluate the <A 
href="http://www.w3.org/TR/xpath20/#doc-xpath-FunctionCall">FunctionCall</A><SUP> 
<SMALL>XP</SMALL></SUP>, the processor will first evaluate each of the arguments 
in the <A 
href="http://www.w3.org/TR/xpath20/#doc-xpath-FunctionCall">FunctionCall</A><SUP> 
<SMALL>XP</SMALL></SUP>. If the processor has information about the data types 
expected by the extension function, then it <SPAN class=verb>may</SPAN> perform 
any necessary type conversions between the XPath data types and those defined by 
the implementation language. If multiple extension functions are available with 
the same name, the processor <SPAN class=verb>may</SPAN> decide which one to 
invoke based on the number of arguments, the types of the arguments, or any 
other criteria. The result returned by the implementation is returned as the 
result of the function call, again after any necessary conversions between the 
data types of the implementation language and those of XPath. The details of 
such type conversions are outside the scope of this specification.</P>
<P><A id=err-XTDE1420 name=err-XTDE1420><SPAN class=error>[ERR 
XTDE1420]</SPAN></A> It is a <A title="non-recoverable dynamic error" 
href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
dynamic error</A> if the arguments supplied to a call on an extension function 
do not satisfy the rules defined for that particular extension function, or if 
the extension function reports an error, or if the result of the extension 
function cannot be converted to an XPath value.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>Implementations may also provide mechanisms allowing extension functions to 
report recoverable dynamic errors, or to execute within an environment that 
treats some or all of the errors listed above as recoverable.</P></DIV>
<P><A id=err-XTDE1425 name=err-XTDE1425><SPAN class=error>[ERR 
XTDE1425]</SPAN></A> When <A title="backwards compatible behavior" 
href="REC-xslt20-20070123.htm#dt-backwards-compatible-behavior">backwards 
compatible behavior</A> is enabled, it is a <A 
title="non-recoverable dynamic error" 
href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
dynamic error</A> to evaluate an extension function call if no implementation of 
the extension function is available.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>When backwards-compatible behavior is not enabled, this is a static error 
[XPST0017].</P></DIV>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>There is no prohibition on calling extension functions that have side-effects 
(for example, an extension function that writes data to a file). However, the 
order of execution of XSLT instructions is not defined in this specification, so 
the effects of such functions are unpredictable.</P></DIV>
<P>Implementations are not <SPAN class=verb>required</SPAN> to perform full 
validation of values returned by extension functions. It is an error for an 
extension function to return a string containing characters that are not 
permitted in XML, but the consequences of this error are <A 
title=implementation-defined 
href="REC-xslt20-20070123.htm#dt-implementation-defined">implementation-defined</A>. 
The implementation <SPAN class=verb>may</SPAN> raise an error, <SPAN 
class=verb>may</SPAN> convert the string to a string containing valid characters 
only, or <SPAN class=verb>may</SPAN> treat the invalid characters as if they 
were permitted characters.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>The ability to execute extension functions represents a potential security 
weakness, since untrusted stylesheets may invoke code that has privileged access 
to resources on the machine where the <A title=processor 
href="REC-xslt20-20070123.htm#dt-processor">processor</A> 
executes. Implementations may therefore provide mechanisms that restrict the use 
of extension functions by untrusted stylesheets.</P></DIV>
<P>All observations in this section regarding the errors that can occur when 
invoking extension functions apply equally when invoking <A 
title="extension instruction" 
href="REC-xslt20-20070123.htm#dt-extension-instruction">extension 
instructions</A>.</P></DIV>
<DIV class=div3>
<H4><A id=external-objects name=external-objects></A>18.1.3 External 
Objects</H4>
<P>An implementation <SPAN class=verb>may</SPAN> allow an extension function to 
return an object that does not have any natural representation in the 
<SPAN>XDM</SPAN> data model, either as an atomic value or as a node. For 
example, an extension function <CODE>sql:connect</CODE> might return an object 
that represents a connection to a relational database; the resulting connection 
object might be passed as an argument to calls on other extension functions such 
as <CODE>sql:insert</CODE> and <CODE>sql:select</CODE>.</P>
<P>The way in which such objects are represented in the type system is <A 
title=implementation-defined 
href="REC-xslt20-20070123.htm#dt-implementation-defined">implementation-defined</A>. 
They might be represented by a completely new data type, or they might be mapped 
to existing data types such as <CODE>integer</CODE>, <CODE>string</CODE>, or 
<CODE>anyURI</CODE>.</P></DIV>
<DIV class=div3>
<H4><A id=testing-type-availability name=testing-type-availability></A>18.1.4 
Testing Availability of Types</H4>
<P>The <A 
href="REC-xslt20-20070123.htm#function-type-available"><CODE>type-available</CODE></A> 
function can be used, for example with the <CODE>[xsl:]use-when</CODE> attribute 
(see <A 
href="REC-xslt20-20070123.htm#conditional-inclusion"><I>3.12 
Conditional Element Inclusion</I></A>), to explicitly control how a stylesheet 
behaves if a particular schema type is not available in the static 
context.</P><A id=function-type-available name=function-type-available></A>
<DIV class=proto><CODE class=function>type-available</CODE>(<CODE 
class=arg>$type-name</CODE><CODE class=as>&nbsp;as&nbsp;</CODE><CODE 
class=type>xs:string</CODE>)<CODE class=as>&nbsp;as&nbsp;</CODE><CODE 
class=return-type>xs:boolean</CODE> </DIV>
<P>A schema type (that is, a simple type or a complex type) is said to be 
available within an XPath expression if it is a type definition that is present 
in the <A href="http://www.w3.org/TR/xpath20/#dt-is-types">in-scope schema 
types</A><SUP><SMALL>XP</SMALL></SUP> for that expression (see <A 
href="REC-xslt20-20070123.htm#static-context"><I>5.4.1 
Initializing the Static Context</I></A>). This includes built-in types, types 
imported using <A 
href="REC-xslt20-20070123.htm#element-import-schema"><CODE>xsl:import-schema</CODE></A>, 
and extension types defined by the implementation.</P>
<P>The value of the <CODE>$type-name</CODE> argument <SPAN 
class=verb>must</SPAN> be a string containing a <A title="lexical QName" 
href="REC-xslt20-20070123.htm#dt-lexical-qname">lexical 
QName</A>. The lexical QName is expanded into an <A title=expanded-QName 
href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded-QName</A> 
using the namespace declarations in scope for the <A title=expression 
href="REC-xslt20-20070123.htm#dt-expression">expression</A>. 
If the lexical QName is unprefixed, then the default namespace is used in the 
expanded QName.</P>
<P>The function returns true if and only if there is an available type whose 
name matches the value of the <CODE>$type-name</CODE> argument.</P>
<P><A id=err-XTDE1428 name=err-XTDE1428><SPAN class=error>[ERR 
XTDE1428]</SPAN></A> It is a <A title="non-recoverable dynamic error" 
href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
dynamic error</A> if the argument does not evaluate to a string that is a valid 
<A title=QName 
href="REC-xslt20-20070123.htm#dt-qname">QName</A>, or if 
there is no namespace declaration in scope for the prefix of the <A title=QName 
href="REC-xslt20-20070123.htm#dt-qname">QName</A>. If the 
processor is able to detect the error statically (for example, when the argument 
is supplied as a string literal), then the processor <SPAN class=verb>may</SPAN> 
optionally signal this as a <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A>.</P></DIV></DIV>
<DIV class=div2>
<H3><A id=extension-instruction name=extension-instruction></A>18.2 Extension 
Instructions</H3>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-extension-namespace 
title="extension namespace" name=dt-extension-namespace></A>The <A 
title="extension instruction" 
href="REC-xslt20-20070123.htm#dt-extension-instruction">extension 
instruction</A> mechanism allows namespaces to be designated as <B>extension 
namespaces</B>. When a namespace is designated as an extension namespace and an 
element with a name from that namespace occurs in a <A 
title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A>, then the element is treated as an <A title=instruction 
href="REC-xslt20-20070123.htm#dt-instruction">instruction</A> 
rather than as a <A title="literal result element" 
href="REC-xslt20-20070123.htm#dt-literal-result-element">literal 
result element</A>.<SPAN class=definition>]</SPAN> The namespace determines the 
semantics of the instruction.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>Since an element that is a child of an <A 
href="REC-xslt20-20070123.htm#element-stylesheet"><CODE>xsl:stylesheet</CODE></A> 
element is not occurring <EM>in a <A title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A></EM>, <A title="user-defined data element" 
href="REC-xslt20-20070123.htm#dt-data-element">user-defined 
data elements</A> (see <A 
href="REC-xslt20-20070123.htm#user-defined-top-level"><I>3.6.2 
User-defined Data Elements</I></A>) are not extension elements as defined here, 
and nothing in this section applies to them.</P></DIV>
<DIV class=div3>
<H4><A id=designating-extension-namespace 
name=designating-extension-namespace></A>18.2.1 Designating an Extension 
Namespace</H4>
<P>A namespace is designated as an extension namespace by using an 
<CODE>[xsl:]extension-element-prefixes</CODE> attribute on an element in the 
stylesheet (see <A 
href="REC-xslt20-20070123.htm#standard-attributes"><I>3.5 
Standard Attributes</I></A>). The attribute <SPAN class=verb>must</SPAN> be in 
the XSLT namespace only if its parent element is <EM>not</EM> in the XSLT 
namespace. The value of the attribute is a whitespace-separated list of 
namespace prefixes. The namespace bound to each of the prefixes is designated as 
an extension namespace.</P>
<P>The default namespace (as declared by <CODE>xmlns</CODE>) may be designated 
as an extension namespace by including <CODE>#default</CODE> in the list of 
namespace prefixes.</P>
<P><A id=err-XTSE1430 name=err-XTSE1430><SPAN class=error>[ERR 
XTSE1430]</SPAN></A> It is a <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A> if there is no namespace bound to the prefix on the element bearing 
the <CODE>[xsl:]extension-element-prefixes</CODE> attribute <SPAN>or, when 
<CODE>#default</CODE> is specified, if there is no default namespace</SPAN>.</P>
<P>The designation of a namespace as an extension namespace is effective for the 
element bearing the <CODE>[xsl:]extension-element-prefixes</CODE> attribute and 
for all descendants of that element within the same stylesheet module.</P></DIV>
<DIV class=div3>
<H4><A id=testing-instruction-available 
name=testing-instruction-available></A>18.2.2 Testing Availability of 
Instructions</H4>
<P>The <A 
href="REC-xslt20-20070123.htm#function-element-available"><CODE>element-available</CODE></A> 
function can be used with the <A 
href="REC-xslt20-20070123.htm#element-choose"><CODE>xsl:choose</CODE></A> 
and <A 
href="REC-xslt20-20070123.htm#element-if"><CODE>xsl:if</CODE></A> 
instructions<SPAN>, or with the <CODE>[xsl:]use-when</CODE> attribute (see <A 
href="REC-xslt20-20070123.htm#conditional-inclusion"><I>3.12 
Conditional Element Inclusion</I></A>) to explicitly control how a stylesheet 
behaves when a particular XSLT instruction or extension instruction is (or is 
not) available.</SPAN></P><A id=function-element-available 
name=function-element-available></A>
<DIV class=proto><CODE class=function>element-available</CODE>(<CODE 
class=arg>$element-name</CODE><CODE class=as>&nbsp;as&nbsp;</CODE><CODE 
class=type>xs:string</CODE>)<CODE class=as>&nbsp;as&nbsp;</CODE><CODE 
class=return-type>xs:boolean</CODE> </DIV>
<P>The value of the <CODE>$element-name</CODE> argument <SPAN 
class=verb>must</SPAN> be a string containing a <A title=QName 
href="REC-xslt20-20070123.htm#dt-qname">QName</A>. The <A 
title=QName 
href="REC-xslt20-20070123.htm#dt-qname">QName</A> is 
expanded into an <A title=expanded-QName 
href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded-QName</A> 
using the namespace declarations in scope for the <A title=expression 
href="REC-xslt20-20070123.htm#dt-expression">expression</A>. 
If there is a default namespace in scope, then it is used to expand an 
unprefixed <A title=QName 
href="REC-xslt20-20070123.htm#dt-qname">QName</A>. The <A 
href="REC-xslt20-20070123.htm#function-element-available"><CODE>element-available</CODE></A> 
function returns true if and only if the <A title=expanded-QName 
href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded-QName</A> 
is the name of an <A title=instruction 
href="REC-xslt20-20070123.htm#dt-instruction">instruction</A>. 
If the <A title=expanded-QName 
href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded-QName</A> 
has a namespace URI equal to the <A title="XSLT namespace" 
href="REC-xslt20-20070123.htm#dt-xslt-namespace">XSLT 
namespace</A> URI, then it refers to an element defined by XSLT. Otherwise, it 
refers to an <A title="extension instruction" 
href="REC-xslt20-20070123.htm#dt-extension-instruction">extension 
instruction</A>. If the <A title=expanded-QName 
href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded-QName</A> 
has a null namespace URI, the <A 
href="REC-xslt20-20070123.htm#function-element-available"><CODE>element-available</CODE></A> 
function will return false.</P>
<P><A id=err-XTDE1440 name=err-XTDE1440><SPAN class=error>[ERR 
XTDE1440]</SPAN></A> It is a <A title="non-recoverable dynamic error" 
href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
dynamic error</A> if the argument does not evaluate to a string that is a valid 
<A title=QName 
href="REC-xslt20-20070123.htm#dt-qname">QName</A>, or if 
there is no namespace declaration in scope for the prefix of the <A title=QName 
href="REC-xslt20-20070123.htm#dt-qname">QName</A>. If the 
processor is able to detect the error statically (for example, when the argument 
is supplied as a string literal), then the processor <SPAN class=verb>may</SPAN> 
optionally signal this as a <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A>.</P>
<P>If the <A title=expanded-QName 
href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded-QName</A> 
is in the <A title="XSLT namespace" 
href="REC-xslt20-20070123.htm#dt-xslt-namespace">XSLT 
namespace</A>, the function returns true if and only if the expanded QName is 
the name of an <A title="XSLT instruction" 
href="REC-xslt20-20070123.htm#dt-xslt-instruction">XSLT 
instruction</A>, that is, an <A title="XSLT element" 
href="REC-xslt20-20070123.htm#dt-xslt-element">XSLT 
element</A> whose syntax summary in this specification classifies it as an <A 
title=instruction 
href="REC-xslt20-20070123.htm#dt-instruction">instruction</A>.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>Although the result of applying this function to a name in the XSLT namespace 
when using a conformant XSLT 2.0 processor is entirely predictable, the function 
is useful in cases where the stylesheet might be executing under a processor 
that implements some other version of XSLT with different rules.</P></DIV>
<P>If the <A title=expanded-QName 
href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded-QName</A> 
is not in the <A title="XSLT namespace" 
href="REC-xslt20-20070123.htm#dt-xslt-namespace">XSLT 
namespace</A>, the function returns true if and only if the processor has an 
implementation available of an <A title="extension instruction" 
href="REC-xslt20-20070123.htm#dt-extension-instruction">extension 
instruction</A> with the given expanded QName. This applies whether or not the 
namespace has been designated as an <A title="extension namespace" 
href="REC-xslt20-20070123.htm#dt-extension-namespace">extension 
namespace</A>.</P>
<P>If the processor does not have an implementation of a particular extension 
instruction available, and such an extension instruction is evaluated, then the 
processor <SPAN class=verb>must</SPAN> perform fallback for the element as 
specified in <A 
href="REC-xslt20-20070123.htm#fallback"><I>18.2.3 
Fallback</I></A>. An implementation <SPAN class=verb>must not</SPAN> signal an 
error merely because the stylesheet contains an extension instruction for which 
no implementation is available.</P></DIV>
<DIV class=div3>
<H4><A id=fallback name=fallback></A>18.2.3 Fallback</H4>
<P class=element-syntax><A id=element-fallback 
name=element-fallback></A><CODE>&lt;!-- Category: instruction 
--&gt;<BR>&lt;xsl:fallback&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: 
<VAR>sequence-constructor</VAR> --&gt;<BR>&lt;/xsl:fallback&gt;</CODE></P>
<P>The content of an <A 
href="REC-xslt20-20070123.htm#element-fallback"><CODE>xsl:fallback</CODE></A> 
element is a <A title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A>, and when performing fallback, the value returned by the <A 
href="REC-xslt20-20070123.htm#element-fallback"><CODE>xsl:fallback</CODE></A> 
element is the result of evaluating this sequence constructor.</P>
<P>When not performing fallback, evaluating an <A 
href="REC-xslt20-20070123.htm#element-fallback"><CODE>xsl:fallback</CODE></A> 
element returns an empty sequence: the content of the <A 
href="REC-xslt20-20070123.htm#element-fallback"><CODE>xsl:fallback</CODE></A> 
element is ignored.</P>
<P>There are two situations where a <A title=processor 
href="REC-xslt20-20070123.htm#dt-processor">processor</A> 
performs fallback: when an extension instruction that is not available is 
evaluated, and when an instruction in the XSLT namespace, that is not defined in 
XSLT 2.0, is evaluated within a region of the stylesheet for which <A 
title="forwards-compatible behavior" 
href="REC-xslt20-20070123.htm#dt-forwards-compatible-behavior">forwards 
compatible behavior</A> is enabled.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>Fallback processing is not invoked in other situations, for example it is not 
invoked when an XPath expression uses unrecognized syntax or contains a call to 
an unknown function. To handle such situations dynamically, the stylesheet 
should call functions such as <A 
href="REC-xslt20-20070123.htm#function-system-property"><CODE>system-property</CODE></A> 
and <A 
href="REC-xslt20-20070123.htm#function-function-available"><CODE>function-available</CODE></A> 
to decide what capabilities are available.</P></DIV>
<P><A id=err-XTDE1450 name=err-XTDE1450><SPAN class=error>[ERR 
XTDE1450]</SPAN></A> When a <A title=processor 
href="REC-xslt20-20070123.htm#dt-processor">processor</A> 
performs fallback for an <A title="extension instruction" 
href="REC-xslt20-20070123.htm#dt-extension-instruction">extension 
instruction</A> that is not recognized, if the instruction element has one or 
more <A 
href="REC-xslt20-20070123.htm#element-fallback"><CODE>xsl:fallback</CODE></A> 
children, then the content of each of the <A 
href="REC-xslt20-20070123.htm#element-fallback"><CODE>xsl:fallback</CODE></A> 
children <SPAN class=verb>must</SPAN> be evaluated; it is a <A 
title="non-recoverable dynamic error" 
href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
dynamic error</A> if it has no <A 
href="REC-xslt20-20070123.htm#element-fallback"><CODE>xsl:fallback</CODE></A> 
children.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>This is different from the situation with unrecognized <A 
title="XSLT element" 
href="REC-xslt20-20070123.htm#dt-xslt-element">XSLT 
elements</A>. As explained in <A 
href="REC-xslt20-20070123.htm#forwards"><I>3.9 
Forwards-Compatible Processing</I></A>, an unrecognized XSLT element appearing 
within a <A title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A> is a static error unless (a) <A 
title="forwards-compatible behavior" 
href="REC-xslt20-20070123.htm#dt-forwards-compatible-behavior">forwards-compatible 
behavior</A> is enabled, and (b) the instruction has an <A 
href="REC-xslt20-20070123.htm#element-fallback"><CODE>xsl:fallback</CODE></A> 
child.</P></DIV></DIV></DIV></DIV>
<DIV class=div1>
<H2><A id=result-trees name=result-trees></A>19 Final Result Trees</H2>
<P>The output of a transformation is a set of <SPAN>one</SPAN> or more <A 
title="final result tree" 
href="REC-xslt20-20070123.htm#dt-final-result-tree">final 
result trees</A>.</P>
<P>A <A title="final result tree" 
href="REC-xslt20-20070123.htm#dt-final-result-tree">final 
result tree</A> can be created explicitly, by evaluating an <A 
href="REC-xslt20-20070123.htm#element-result-document"><CODE>xsl:result-document</CODE></A> 
instruction. <SPAN>As explained in <A 
href="REC-xslt20-20070123.htm#executing-a-transformation"><I>2.4 
Executing a Transformation</I></A>,</SPAN> a final result tree is also created 
implicitly if no <A 
href="REC-xslt20-20070123.htm#element-result-document"><CODE>xsl:result-document</CODE></A> 
instruction is evaluated, or if the result of evaluating the <A 
title="initial template" 
href="REC-xslt20-20070123.htm#dt-initial-template">initial 
template</A> is a non-empty sequence.</P>
<P>The way in which a <A title="final result tree" 
href="REC-xslt20-20070123.htm#dt-final-result-tree">final 
result tree</A> is delivered to an application is <A 
title=implementation-defined 
href="REC-xslt20-20070123.htm#dt-implementation-defined">implementation-defined</A>.</P>
<P>Serialization of <A title="final result tree" 
href="REC-xslt20-20070123.htm#dt-final-result-tree">final 
result trees</A> is described further in <A 
href="REC-xslt20-20070123.htm#serialization"><I>20 
Serialization</I></A></P>
<DIV class=div2>
<H3><A id=creating-result-trees name=creating-result-trees></A>19.1 Creating 
Final Result Trees</H3>
<P class=element-syntax><A id=element-result-document 
name=element-result-document></A><CODE>&lt;!-- Category: instruction 
--&gt;<BR>&lt;xsl:result-document<BR>&nbsp;&nbsp;format? = { <VAR>qname</VAR> 
}<BR>&nbsp;&nbsp;href? = { <VAR>uri-reference</VAR> }<BR>&nbsp;&nbsp;validation? 
= "strict" | "lax" | "preserve" | "strip"<BR>&nbsp;&nbsp;type? = 
<VAR>qname</VAR><BR>&nbsp;&nbsp;method? = { "xml" | "html" | "xhtml" | "text" | 
<VAR>qname-but-not-ncname</VAR> }<BR>&nbsp;&nbsp;byte-order-mark? = { "yes" | 
"no" }<BR>&nbsp;&nbsp;cdata-section-elements? = { <VAR>qnames</VAR> 
}<BR>&nbsp;&nbsp;doctype-public? = { <VAR>string</VAR> 
}<BR>&nbsp;&nbsp;doctype-system? = { <VAR>string</VAR> 
}<BR>&nbsp;&nbsp;encoding? = { <VAR>string</VAR> 
}<BR>&nbsp;&nbsp;escape-uri-attributes? = { "yes" | "no" 
}<BR>&nbsp;&nbsp;include-content-type? = { "yes" | "no" }<BR>&nbsp;&nbsp;indent? 
= { "yes" | "no" }<BR>&nbsp;&nbsp;media-type? = { <VAR>string</VAR> 
}<BR>&nbsp;&nbsp;normalization-form? = { "NFC" | "NFD" | "NFKC" | "NFKD" | 
"fully-normalized" | "none" | <VAR>nmtoken</VAR> 
}<BR>&nbsp;&nbsp;omit-xml-declaration? = { "yes" | "no" 
}<BR>&nbsp;&nbsp;standalone? = { "yes" | "no" | "omit" 
}<BR>&nbsp;&nbsp;undeclare-prefixes? = { "yes" | "no" 
}<BR>&nbsp;&nbsp;use-character-maps? = 
<VAR>qnames</VAR><BR>&nbsp;&nbsp;output-version? = { <VAR>nmtoken</VAR> 
}&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: <VAR>sequence-constructor</VAR> 
--&gt;<BR>&lt;/xsl:result-document&gt;</CODE></P>
<P>The <A 
href="REC-xslt20-20070123.htm#element-result-document"><CODE>xsl:result-document</CODE></A> 
instruction is used to create a <A title="final result tree" 
href="REC-xslt20-20070123.htm#dt-final-result-tree">final 
result tree</A>. The content of the <A 
href="REC-xslt20-20070123.htm#element-result-document"><CODE>xsl:result-document</CODE></A> 
element is a <A title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A> for the children of the document node of the tree. A document 
node is created, and the sequence obtained by evaluating the sequence 
constructor is used to construct the content of the document, as described in <A 
href="REC-xslt20-20070123.htm#constructing-complex-content"><I>5.7.1 
Constructing Complex Content</I></A>. The tree rooted at this document node 
forms the final result tree.</P>
<P>The <A 
href="REC-xslt20-20070123.htm#element-result-document"><CODE>xsl:result-document</CODE></A> 
instruction defines the URI of the result tree, and may optionally specify the 
output format to be used for serializing this tree.</P>
<P>The <SPAN><A title="effective value" 
href="REC-xslt20-20070123.htm#dt-effective-value">effective 
value</A></SPAN> of the <CODE>format</CODE> attribute, if specified, <SPAN 
class=verb>must</SPAN> be a <A title="lexical QName" 
href="REC-xslt20-20070123.htm#dt-lexical-qname">lexical 
QName</A>. The QName is expanded using the namespace declarations in scope for 
the <A 
href="REC-xslt20-20070123.htm#element-result-document"><CODE>xsl:result-document</CODE></A> 
element. The <A title=expanded-QName 
href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded-QName</A> 
<SPAN class=verb>must</SPAN> match the expanded QName of a named <A 
title="output definition" 
href="REC-xslt20-20070123.htm#dt-output-definition">output 
definition</A> in the <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A>. 
This identifies the <A 
href="REC-xslt20-20070123.htm#element-output"><CODE>xsl:output</CODE></A> 
declaration that will control the serialization of the <A 
title="final result tree" 
href="REC-xslt20-20070123.htm#dt-final-result-tree">final 
result tree</A> (see <A 
href="REC-xslt20-20070123.htm#serialization"><I>20 
Serialization</I></A>), if the result tree is serialized. If the 
<CODE>format</CODE> attribute is omitted, the unnamed <A 
title="output definition" 
href="REC-xslt20-20070123.htm#dt-output-definition">output 
definition</A> is used to control serialization of the result tree.</P>
<P><A id=err-XTDE1460 name=err-XTDE1460><SPAN class=error>[ERR 
XTDE1460]</SPAN></A> It is a <A title="non-recoverable dynamic error" 
href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
dynamic error</A> if the <A title="effective value" 
href="REC-xslt20-20070123.htm#dt-effective-value">effective 
value</A> of the <CODE>format</CODE> attribute is not a valid <A 
title="lexical QName" 
href="REC-xslt20-20070123.htm#dt-lexical-qname">lexical 
QName</A>, or if it does not match the <A title=expanded-QName 
href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded-QName</A> 
of an <A title="output definition" 
href="REC-xslt20-20070123.htm#dt-output-definition">output 
definition</A> in the <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A>. 
If the processor is able to detect the error statically (for example, when the 
<CODE>format</CODE> attribute contains no curly brackets), then the processor 
<SPAN class=verb>may</SPAN> optionally signal this as a <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A>.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>The only way to select the unnamed <A title="output definition" 
href="REC-xslt20-20070123.htm#dt-output-definition">output 
definition</A> is to omit the <CODE>format</CODE> attribute.</P></DIV>
<P>The attributes <CODE>method</CODE>, <CODE>byte-order-mark</CODE> 
<CODE>cdata-section-elements</CODE>, <CODE>doctype-public</CODE>, 
<CODE>doctype-system</CODE>, <CODE>encoding</CODE>, 
<CODE>escape-uri-attributes</CODE>, <CODE>indent</CODE>, 
<CODE>media-type</CODE>, <CODE>normalization-form</CODE>, 
<CODE>omit-xml-declaration</CODE>, <CODE>standalone</CODE>, 
<CODE>undeclare-prefixes</CODE>, <CODE>use-character-maps</CODE>, and 
<CODE>output-version</CODE> may be used to override attributes defined in the 
selected <A title="output definition" 
href="REC-xslt20-20070123.htm#dt-output-definition">output 
definition</A>.</P>
<P>With the exception of <CODE>use-character-maps</CODE>, these attributes are 
all defined as <A title="attribute value template" 
href="REC-xslt20-20070123.htm#dt-attribute-value-template">attribute 
value templates</A>, so their values may be set dynamically. For any of these 
attributes that is present on the <A 
href="REC-xslt20-20070123.htm#element-result-document"><CODE>xsl:result-document</CODE></A> 
instruction, the <A title="effective value" 
href="REC-xslt20-20070123.htm#dt-effective-value">effective 
value</A> of the attribute overrides or supplements the corresponding value from 
the output definition. This works in the same way as when one <A 
href="REC-xslt20-20070123.htm#element-output"><CODE>xsl:output</CODE></A> 
declaration overrides another:</P>
<UL>
  <LI>
  <P>In the case of <CODE>cdata-section-elements</CODE>, the value of the 
  serialization parameter is the union of the expanded names of the elements 
  named in this instruction and the elements named in the selected output 
  definition;</P>
  <LI>
  <P>In the case of <CODE>use-character-maps</CODE>, the character maps 
  referenced in this instruction supplement and take precedence over those 
  defined in the selected output definition;</P>
  <LI>
  <P>In all other cases, the effective value of an attribute actually present on 
  this instruction takes precedence over the value defined in the selected 
  output definition.</P></LI></UL>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>In the case of the attributes <CODE>method</CODE>, 
<CODE>cdata-section-elements</CODE>, <SPAN>and 
<CODE>use-character-maps</CODE>,</SPAN> the <A title="effective value" 
href="REC-xslt20-20070123.htm#dt-effective-value">effective 
value</A> of the attribute contains one or more lexical QNames. The prefix in 
such a QName is expanded using the in-scope namespaces for the 
<CODE>xsl:result-document</CODE> element. In the case of 
<CODE>cdata-section-elements</CODE>, an unprefixed element name is expanded 
using the default namespace.</P></DIV>
<P>The <CODE>output-version</CODE> attribute on the <A 
href="REC-xslt20-20070123.htm#element-result-document"><CODE>xsl:result-document</CODE></A> 
instruction overrides the <CODE>version</CODE> attribute on <A 
href="REC-xslt20-20070123.htm#element-output"><CODE>xsl:output</CODE></A> 
(it has been renamed because <CODE>version</CODE> is available with a different 
meaning as a standard attribute: see <A 
href="REC-xslt20-20070123.htm#standard-attributes"><I>3.5 
Standard Attributes</I></A>). In all other cases, attributes correspond if they 
have the same name.</P>
<P>There are some serialization parameters that apply to some output methods but 
not to others. For example, the <CODE>indent</CODE> attribute has no effect on 
the <CODE>text</CODE> output method. If a value is supplied for an attribute 
that is inapplicable to the output method, its value is <SPAN>not passed to the 
serializer</SPAN>. The processor <SPAN class=verb>may</SPAN> validate the value 
of such an attribute, but is not <SPAN class=verb>required</SPAN> to do so.</P>
<P>The <CODE>href</CODE> attribute is optional. The default value is the 
zero-length string. The <A title="effective value" 
href="REC-xslt20-20070123.htm#dt-effective-value">effective 
value</A> of the attribute <SPAN class=verb>must</SPAN> be a <A 
title="URI Reference" 
href="REC-xslt20-20070123.htm#dt-uri-reference">URI 
Reference</A>, which may be absolute or relative. There <SPAN 
class=verb>may</SPAN> be <A title=implementation-defined 
href="REC-xslt20-20070123.htm#dt-implementation-defined">implementation-defined</A> 
restrictions on the form of absolute URI that may be used, but the 
implementation is not <SPAN class=verb>required</SPAN> to enforce any 
restrictions. Any legal relative URI <SPAN class=verb>must</SPAN> be accepted. 
Note that the zero-length string is a legal relative URI.</P>
<P>The base URI of the document node at the root of the <A 
title="final result tree" 
href="REC-xslt20-20070123.htm#dt-final-result-tree">final 
result tree</A> is based on the <A title="effective value" 
href="REC-xslt20-20070123.htm#dt-effective-value">effective 
value</A> of the <CODE>href</CODE> attribute. If the <A title="effective value" 
href="REC-xslt20-20070123.htm#dt-effective-value">effective 
value</A> is a relative URI, then it is resolved relative to the <A 
title="base output URI" 
href="REC-xslt20-20070123.htm#dt-base-output-uri">base 
output URI</A>. If the implementation provides an API to access final result 
trees, then it <SPAN class=verb>must</SPAN> allow a final result tree to be 
identified by means of this base URI.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>The base URI of the <A title="final result tree" 
href="REC-xslt20-20070123.htm#dt-final-result-tree">final 
result tree</A> is not <SPAN>necessarily</SPAN> the same thing as the URI of its 
serialized representation on disk, if any. For example, a server (or browser 
client) might store final result trees only in memory, or in an internal disk 
cache. As long as <SPAN>the processor</SPAN> satisfies requests for those URIs, 
it is irrelevant where they are actually written on disk, if at all.</P></DIV>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>It will often be the case that one <A title="final result tree" 
href="REC-xslt20-20070123.htm#dt-final-result-tree">final 
result tree</A> contains links to another final result tree produced during the 
same transformation, in the form of a relative URI. The mechanism of associating 
a URI with a final result tree has been chosen to allow the integrity of such 
links to be preserved when the trees are serialized.</P>
<P>As well as being potentially significant in any API that provides access to 
final result trees, the base URI of the new document node is relevant if the 
final result tree, rather than being serialized, is supplied as input to a 
further transformation.</P></DIV>
<P>The optional attributes <CODE>type</CODE> and <CODE>validation</CODE> may be 
used on the <A 
href="REC-xslt20-20070123.htm#element-result-document"><CODE>xsl:result-document</CODE></A> 
instruction to validate the contents of the new document, and to determine the 
<A title="type annotation" 
href="REC-xslt20-20070123.htm#dt-annotation">type 
annotation</A> that elements and attributes within the <A 
title="final result tree" 
href="REC-xslt20-20070123.htm#dt-final-result-tree">final 
result tree</A> will carry. The permitted values and their semantics are 
described in <A 
href="REC-xslt20-20070123.htm#validating-document-nodes"><I>19.2.2 
Validating Document Nodes</I></A>.</P>
<P>A <A title=processor 
href="REC-xslt20-20070123.htm#dt-processor">processor</A> 
<SPAN class=verb>may</SPAN> allow a <A title="final result tree" 
href="REC-xslt20-20070123.htm#dt-final-result-tree">final 
result tree</A> to be serialized. Serialization is described in <A 
href="REC-xslt20-20070123.htm#serialization"><I>20 
Serialization</I></A>. However, an implementation (for example, a <A 
title=processor 
href="REC-xslt20-20070123.htm#dt-processor">processor</A> 
running in an environment with no access to writable filestore) is not <SPAN 
class=verb>required</SPAN> to support the serialization of <A 
title="final result tree" 
href="REC-xslt20-20070123.htm#dt-final-result-tree">final 
result trees</A>. An implementation that does not support the serialization of 
final result trees <SPAN class=verb>may</SPAN> ignore the <CODE>format</CODE> 
attribute <SPAN>and the serialization attributes</SPAN>. Such an implementation 
<SPAN class=verb>must</SPAN> provide the application with some means of access 
to the (un-serialized) result tree, using its URI to identify it.</P>
<P>Implementations may provide additional mechanisms, outside the scope of this 
specification, for defining the way in which <A title="final result tree" 
href="REC-xslt20-20070123.htm#dt-final-result-tree">final 
result trees</A> are processed. Such mechanisms <SPAN class=verb>may</SPAN> make 
use of the XSLT-defined attributes on the <A 
href="REC-xslt20-20070123.htm#element-result-document"><CODE>xsl:result-document</CODE></A> 
and/or <A 
href="REC-xslt20-20070123.htm#element-output"><CODE>xsl:output</CODE></A> 
elements, or they <SPAN class=verb>may</SPAN> use additional elements or 
attributes in an <A title=implementation-defined 
href="REC-xslt20-20070123.htm#dt-implementation-defined">implementation-defined</A> 
namespace.</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e27003 name=d5e27003></A>Example: Multiple 
Result Documents </DIV>
<P>The following example takes an XHTML document as input, and breaks it up so 
that the text following each &lt;h1&gt; element is included in a separate 
document. A new document <CODE>toc.html</CODE> is constructed to act as an 
index:</P>
<DIV class=exampleInner><PRE>&lt;xsl:stylesheet
        version="2.0"
        xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
        xmlns:xhtml="http://www.w3.org/1999/xhtml"&gt;
        
&lt;xsl:output name="toc-format" method="xhtml" indent="yes"
            doctype-system="http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"
            doctype-public="-//W3C//DTD XHTML 1.0 Strict//EN"/&gt;
            
&lt;xsl:output name="section-format" method="xhtml" indent="no"
            doctype-system="http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"
            doctype-public="-//W3C//DTD XHTML 1.0 Transitional//EN"/&gt;        
         
&lt;xsl:template match="/"&gt;
  &lt;xsl:result-document href="toc.html" format="toc-format" validation="strict"&gt;
    &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
      &lt;head&gt;&lt;title&gt;Table of Contents&lt;/title&gt;&lt;/head&gt;
      &lt;body&gt;
        &lt;h1&gt;Table of Contents&lt;/h1&gt;
        &lt;xsl:for-each select="/*/xhtml:body/(*[1] | xhtml:h1)"&gt;
          &lt;p&gt;&lt;a href="section{position()}.html"&gt;&lt;xsl:value-of select="."/&gt;&lt;/a&gt;&lt;/p&gt;
        &lt;/xsl:for-each&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  &lt;/xsl:result-document&gt;
  &lt;xsl:for-each-group select="/*/xhtml:body/*" group-starting-with="xhtml:h1"&gt;
    &lt;xsl:result-document href="section{position()}.html" 
                         format="section-format" validation="strip"&gt;         
      &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
        &lt;head&gt;&lt;title&gt;&lt;xsl:value-of select="."/&gt;&lt;/title&gt;&lt;/head&gt;
        &lt;body&gt;
          &lt;xsl:copy-of select="current-group()"/&gt;
        &lt;/body&gt;
      &lt;/html&gt;
    &lt;/xsl:result-document&gt;
  &lt;/xsl:for-each-group&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;
</PRE></DIV></DIV>
<P>There are restrictions on the use of the <A 
href="REC-xslt20-20070123.htm#element-result-document"><CODE>xsl:result-document</CODE></A> 
instruction, designed to ensure that the results are fully interoperable even 
when processors optimize the sequence in which instructions are evaluated. 
Informally, the restriction is that the <A 
href="REC-xslt20-20070123.htm#element-result-document"><CODE>xsl:result-document</CODE></A> 
instruction can only be used while writing a final result tree, not while 
writing to a temporary tree or a sequence. This restriction is defined formally 
as follows.</P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-output-state 
title="output state" name=dt-output-state></A>Each instruction in the <A 
title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
is evaluated in one of two possible <B>output states</B>: <A 
title="final output state" 
href="REC-xslt20-20070123.htm#dt-final-output-state">final 
output state</A> or <A title="temporary output state" 
href="REC-xslt20-20070123.htm#dt-temporary-output-state">temporary 
output state</A><SPAN class=definition>]</SPAN>.</P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-final-output-state 
title="final output state" name=dt-final-output-state></A>The first of the two 
<A title="output state" 
href="REC-xslt20-20070123.htm#dt-output-state">output 
states</A> is called <B>final output</B> state. This state applies when 
instructions are writing to a <A title="final result tree" 
href="REC-xslt20-20070123.htm#dt-final-result-tree">final 
result tree</A>.<SPAN class=definition>]</SPAN></P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A 
id=dt-temporary-output-state title="temporary output state" 
name=dt-temporary-output-state></A>The second of the two <A title="output state" 
href="REC-xslt20-20070123.htm#dt-output-state">output 
states</A> is called <B>temporary output</B> state. This state applies when 
instructions are writing to a <A title="temporary tree" 
href="REC-xslt20-20070123.htm#dt-temporary-tree">temporary 
tree</A> or any other non-final destination.<SPAN class=definition>]</SPAN></P>
<P>The instructions in the <A title="initial template" 
href="REC-xslt20-20070123.htm#dt-initial-template">initial 
template</A> are evaluated in <A title="final output state" 
href="REC-xslt20-20070123.htm#dt-final-output-state">final 
output state</A>. An instruction is evaluated in the same <A 
title="output state" 
href="REC-xslt20-20070123.htm#dt-output-state">output 
state</A> as its calling instruction, except that <A 
href="REC-xslt20-20070123.htm#element-variable"><CODE>xsl:variable</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-param"><CODE>xsl:param</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-with-param"><CODE>xsl:with-param</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-attribute"><CODE>xsl:attribute</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-comment"><CODE>xsl:comment</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-processing-instruction"><CODE>xsl:processing-instruction</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-namespace"><CODE>xsl:namespace</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-value-of"><CODE>xsl:value-of</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-function"><CODE>xsl:function</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-key"><CODE>xsl:key</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-sort"><CODE>xsl:sort</CODE></A>, 
and <A 
href="REC-xslt20-20070123.htm#element-message"><CODE>xsl:message</CODE></A> 
always evaluate the instructions in their contained <A 
title="sequence constructor" 
href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
constructor</A> in <A title="temporary output state" 
href="REC-xslt20-20070123.htm#dt-temporary-output-state">temporary 
output state</A>.</P>
<P><A id=err-XTDE1480 name=err-XTDE1480><SPAN class=error>[ERR 
XTDE1480]</SPAN></A> It is a <A title="non-recoverable dynamic error" 
href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
dynamic error</A> to evaluate the <A 
href="REC-xslt20-20070123.htm#element-result-document"><CODE>xsl:result-document</CODE></A> 
instruction in <A title="temporary output state" 
href="REC-xslt20-20070123.htm#dt-temporary-output-state">temporary 
output state</A>.</P>
<P><A id=err-XTDE1490 name=err-XTDE1490><SPAN class=error>[ERR 
XTDE1490]</SPAN></A> It is a <A title="non-recoverable dynamic error" 
href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
dynamic error</A> for a transformation to generate two or more <A 
title="final result tree" 
href="REC-xslt20-20070123.htm#dt-final-result-tree">final 
result trees</A> with the same URI.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>Note, this means that it is an error to evaluate more than one <A 
href="REC-xslt20-20070123.htm#element-result-document"><CODE>xsl:result-document</CODE></A> 
instruction that omits the <CODE>href</CODE> attribute, or to evaluate any <A 
href="REC-xslt20-20070123.htm#element-result-document"><CODE>xsl:result-document</CODE></A> 
instruction that omits the <CODE>href</CODE> attribute if an initial <A 
title="final result tree" 
href="REC-xslt20-20070123.htm#dt-final-result-tree">final 
result tree</A> is created implicitly.</P></DIV>
<P>Technically, the result of evaluating the <A 
href="REC-xslt20-20070123.htm#element-result-document"><CODE>xsl:result-document</CODE></A> 
instruction is an empty sequence. This means it does not contribute any nodes to 
the result of the <SPAN>sequence</SPAN> constructor it is part of.</P>
<P><A id=err-XTRE1495 name=err-XTRE1495><SPAN class=error>[ERR 
XTRE1495]</SPAN></A> It is a <A title="recoverable error" 
href="REC-xslt20-20070123.htm#dt-recoverable-error">recoverable 
dynamic error</A> for a transformation to generate two or more <A 
title="final result tree" 
href="REC-xslt20-20070123.htm#dt-final-result-tree">final 
result trees</A> with URIs that identify the same physical resource. The <A 
title="optional recovery action" 
href="REC-xslt20-20070123.htm#dt-optional-recovery-action">optional 
recovery action</A> is <A title=implementation-dependent 
href="REC-xslt20-20070123.htm#dt-implementation-dependent">implementation-dependent</A>, 
since it may be impossible for the processor to detect the error.</P>
<P><A id=err-XTRE1500 name=err-XTRE1500><SPAN class=error>[ERR 
XTRE1500]</SPAN></A> It is a <A title="recoverable error" 
href="REC-xslt20-20070123.htm#dt-recoverable-error">recoverable 
dynamic error</A> for a <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
to write to an external resource and read from the same resource during a single 
transformation, whether or not the same URI is used to access the resource in 
both cases. The <A title="optional recovery action" 
href="REC-xslt20-20070123.htm#dt-optional-recovery-action">optional 
recovery action</A> is <A title=implementation-dependent 
href="REC-xslt20-20070123.htm#dt-implementation-dependent">implementation-dependent</A>: 
implementations are not <SPAN class=verb>required</SPAN> to detect the error 
condition. <SPAN>Note that if the error is not detected, it is undefined whether 
the document that is read from the resource reflects its state before or after 
the result tree is written.</SPAN></P></DIV>
<DIV class=div2>
<H3><A id=validation name=validation></A>19.2 Validation</H3>
<P>It is possible to control the <A title="type annotation" 
href="REC-xslt20-20070123.htm#dt-annotation">type 
annotation</A> applied to individual element and attribute nodes as they are 
constructed. This is done using the <CODE>type</CODE> and 
<CODE>validation</CODE> attributes of the <A 
href="REC-xslt20-20070123.htm#element-element"><CODE>xsl:element</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-attribute"><CODE>xsl:attribute</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-copy"><CODE>xsl:copy</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-copy-of"><CODE>xsl:copy-of</CODE></A>, 
<SPAN><A 
href="REC-xslt20-20070123.htm#element-document"><CODE>xsl:document</CODE></A></SPAN>, 
and <A 
href="REC-xslt20-20070123.htm#element-result-document"><CODE>xsl:result-document</CODE></A> 
instructions, or the <CODE>xsl:type</CODE> and <CODE>xsl:validation</CODE> 
attributes of a <A title="literal result element" 
href="REC-xslt20-20070123.htm#dt-literal-result-element">literal 
result element</A>.</P>
<P>The <CODE>[xsl:]type</CODE> attribute is used to request validation of an 
element or attribute against a specific simple or complex type defined in a 
schema. The <CODE>[xsl:]validation</CODE> attribute is used to request 
validation against the global element or attribute declaration whose name 
matches the name of the element or attribute being validated.</P>
<P>The <CODE>[xsl:]type</CODE> and <CODE>[xsl:]validation</CODE> attributes are 
mutually exclusive. Both are optional, but if one is present then the other 
<SPAN class=verb>must</SPAN> be omitted. If both attributes are omitted, the 
effect is the same as specifying the <CODE>validation</CODE> attribute with the 
value specified in the <CODE>default-validation</CODE> attribute of the 
containing <A 
href="REC-xslt20-20070123.htm#element-stylesheet"><CODE>xsl:stylesheet</CODE></A> 
element; if this is not specified, the effect is the same as specifying 
<CODE>validation="strip"</CODE>.</P>
<P><A id=err-XTSE1505 name=err-XTSE1505><SPAN class=error>[ERR 
XTSE1505]</SPAN></A> It is a <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A> if both the <CODE>[xsl:]type</CODE> and <CODE>[xsl:]validation</CODE> 
attributes are present on the <A 
href="REC-xslt20-20070123.htm#element-element"><CODE>xsl:element</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-attribute"><CODE>xsl:attribute</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-copy"><CODE>xsl:copy</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-copy-of"><CODE>xsl:copy-of</CODE></A>, 
<SPAN><A 
href="REC-xslt20-20070123.htm#element-document"><CODE>xsl:document</CODE></A></SPAN>, 
or <A 
href="REC-xslt20-20070123.htm#element-result-document"><CODE>xsl:result-document</CODE></A> 
instructions, or on a <A title="literal result element" 
href="REC-xslt20-20070123.htm#dt-literal-result-element">literal 
result element</A>.</P>
<P>The detailed rules for validation vary depending on the kind of node being 
validated. The rules for element and attribute nodes are given in <A 
href="REC-xslt20-20070123.htm#validating-constructed-nodes"><I>19.2.1 
Validating Constructed Elements and Attributes</I></A>, while those for document 
nodes are given in <A 
href="REC-xslt20-20070123.htm#validating-document-nodes"><I>19.2.2 
Validating Document Nodes</I></A>.</P>
<DIV class=div3>
<H4><A id=validating-constructed-nodes 
name=validating-constructed-nodes></A>19.2.1 Validating Constructed Elements and 
Attributes</H4>
<DIV class=div4>
<H5><A id=validating-using-validation-attribute 
name=validating-using-validation-attribute></A>19.2.1.1 Validation using the 
<CODE>[xsl:]validation</CODE> Attribute</H5>
<P>The <CODE>[xsl:]validation</CODE> attribute defines the validation action to 
be taken. It determines not only the <A title="type annotation" 
href="REC-xslt20-20070123.htm#dt-annotation">type 
annotation</A> of the node that is constructed by the relevant instruction 
itself, but also the type annotations of all element and attribute nodes that 
have the constructed node as an ancestor. Conceptually, the validation requested 
for a child element or attribute node is applied before the validation requested 
for its parent element. For example, if the instruction that constructs a child 
element specifies <CODE>validation="strict"</CODE>, this will cause the child 
element to be checked against an element declaration, but if the instruction 
that constructs its parent element specifies <CODE>validation="strip"</CODE>, 
then the final effect will be that the child node is annotated as 
<SPAN><CODE>xs:untyped</CODE></SPAN>.</P>
<P>In the paragraphs below, the term <EM>contained nodes</EM> means the elements 
and attributes that have the newly constructed node as an ancestor.</P>
<UL>
  <LI>
  <P>The value <CODE>strip</CODE> indicates that the new node and each of the 
  contained nodes will have the <A title="type annotation" 
  href="REC-xslt20-20070123.htm#dt-annotation">type 
  annotation</A> <SPAN><CODE>xs:untyped</CODE></SPAN> if it is an element, or 
  <SPAN><CODE>xs:untypedAtomic</CODE></SPAN> if it is an attribute. Any previous 
  type annotation present on a contained element or attribute node (for example, 
  a type annotation that is present on an element copied from a source document) 
  is also replaced by <SPAN><CODE>xs:untyped</CODE></SPAN> or 
  <SPAN><CODE>xs:untypedAtomic</CODE></SPAN> as appropriate. <SPAN>The typed 
  value of the node is changed to be the same as its string value, as an 
  instance of <CODE>xs:untypedAtomic</CODE>. In the case of elements the 
  <CODE>nilled</CODE> property is set to <CODE>false</CODE>. The values of the 
  <CODE>is-id</CODE> and <CODE>is-idrefs</CODE> properties are unchanged.</SPAN> 
  Schema validation is not invoked.</P>
  <LI>
  <P>The value <CODE>preserve</CODE> indicates that nodes that are copied will 
  retain their <A title="type annotation" 
  href="REC-xslt20-20070123.htm#dt-annotation">type 
  annotations</A>, but nodes whose content is newly constructed will be 
  annotated as <CODE>xs:anyType</CODE> in the case of elements, or 
  <SPAN><CODE>xs:untypedAtomic</CODE></SPAN> in the case of attributes. Schema 
  validation is not invoked. The detailed effect depends on the instruction:</P>
  <UL>
    <LI>
    <P>In the case of <A 
    href="REC-xslt20-20070123.htm#element-element"><CODE>xsl:element</CODE></A> 
    and literal result elements, the new element has a <A 
    title="type annotation" 
    href="REC-xslt20-20070123.htm#dt-annotation">type 
    annotation</A> of <CODE>xs:anyType</CODE>, and the type annotations of 
    contained nodes are retained unchanged.</P>
    <LI>
    <P>In the case of <A 
    href="REC-xslt20-20070123.htm#element-attribute"><CODE>xsl:attribute</CODE></A>, 
    the effect is exactly the same as specifying 
    <CODE>validation="strip"</CODE>: that is, the new attribute will have the 
    type annotation <SPAN><CODE>xs:untypedAtomic</CODE></SPAN>.</P>
    <LI>
    <P>In the case of <A 
    href="REC-xslt20-20070123.htm#element-copy-of"><CODE>xsl:copy-of</CODE></A>, 
    all the nodes that are copied will retain their type annotations 
    unchanged.</P>
    <LI>
    <P>In the case of <A 
    href="REC-xslt20-20070123.htm#element-copy"><CODE>xsl:copy</CODE></A>, 
    the effect depends on the kind of node being copied.</P>
    <OL class=enumar>
      <LI>
      <P>Where the node being copied is an attribute, the copied attribute will 
      retain its <A title="type annotation" 
      href="REC-xslt20-20070123.htm#dt-annotation">type 
      annotation</A>.</P>
      <LI>
      <P>Where the node being copied is an element, the copied element will have 
      a <A title="type annotation" 
      href="REC-xslt20-20070123.htm#dt-annotation">type 
      annotation</A> of <SPAN><CODE>xs:anyType</CODE></SPAN> (because this 
      instruction does not copy the content of the element, it would be wrong to 
      assume that the type is unchanged); but any contained nodes will have 
      their type annotations retained in the same way as with <A 
      href="REC-xslt20-20070123.htm#element-element"><CODE>xsl:element</CODE></A>.</P></LI></OL></LI></UL>
  <LI>
  <P>The value <CODE>strict</CODE> indicates that <A title="type annotation" 
  href="REC-xslt20-20070123.htm#dt-annotation">type 
  annotations</A> are established by performing strict schema validity 
  assessment on the element or attribute node created by this instruction as 
  follows:</P>
  <UL>
    <LI>
    <P>In the case of an element, <SPAN>a top-level</SPAN> element declaration 
    is identified whose local name and namespace (if any) match the name of the 
    element, and schema-validity assessment is carried out according to the 
    rules defined in <A 
    href="REC-xslt20-20070123.htm#xmlschema-1">[XML 
    Schema Part 1]</A> (section 3.3.4 "Element Declaration Validation Rules", 
    validation rule "Schema-Validity Assessment (Element)", clauses 1.1 and 
    2<SPAN>, using the top-level element declaration as the "declaration 
    stipulated by the processor", which is mentioned in clause 1.1.1.1</SPAN>). 
    The element is considered valid if the result of the schema validity 
    assessment is a PSVI in which the relevant element node has a 
    <CODE>validity</CODE> property whose value is <CODE>valid</CODE>. If 
    <SPAN>there is no matching element declaration, or if</SPAN> the element is 
    not considered valid, the transformation fails <SPAN class=error>[see <A 
    href="REC-xslt20-20070123.htm#err-XTTE1510">ERR 
    XTTE1510</A>]</SPAN>, <SPAN class=error>[see <A 
    href="REC-xslt20-20070123.htm#err-XTTE1512">ERR 
    XTTE1512</A>]</SPAN>. In effect this means that the element being validated 
    <SPAN class=verb>must</SPAN> be declared using a top-level declaration in 
    the schema, and <SPAN class=verb>must</SPAN> conform to its declaration. The 
    process of validation applies recursively to contained elements and 
    attributes to the extent required by the schema definition.</P>
    <DIV class=note>
    <P class=prefix><B>Note:</B></P>
    <P>It is not an error if the identified type definition is a simple type, 
    although <A 
    href="REC-xslt20-20070123.htm#xmlschema-1">[XML 
    Schema Part 1]</A> does not define explicitly that this case is 
    permitted.</P></DIV>
    <LI>
    <P>In the case of an attribute, <SPAN>a top-level</SPAN> attribute 
    declaration is identified whose local name and namespace (if any) match the 
    name of the attribute, and schema-validity assessment is carried out 
    according to the rules defined in <A 
    href="REC-xslt20-20070123.htm#xmlschema-1">[XML 
    Schema Part 1]</A> (section 3.2.4 "Attribute Declaration Validation Rules", 
    validation rule "Schema-Validity Assessment (Attribute)"). The attribute is 
    considered valid if the result of the schema validity assessment is a PSVI 
    in which the relevant attribute node has a <CODE>validity</CODE> property 
    whose value is <CODE>valid</CODE>. If the attribute is not considered valid, 
    the transformation fails <SPAN><SPAN class=error>[see <A 
    href="REC-xslt20-20070123.htm#err-XTTE1510">ERR 
    XTTE1510</A>]</SPAN></SPAN>. In effect this means that the attribute being 
    validated <SPAN class=verb>must</SPAN> be declared using a top-level 
    declaration in the schema, and <SPAN class=verb>must</SPAN> conform to its 
    declaration.</P>
    <LI>
    <P>The schema components used to validate an element or attribute may be 
    located in any way <SPAN>described</SPAN> by <A 
    href="REC-xslt20-20070123.htm#xmlschema-1">[XML 
    Schema Part 1]</A> (see section 4.3.2, <EM>How schema documents are located 
    on the Web</EM>). The components in the schema constructed from the 
    synthetic schema document (see <A 
    href="REC-xslt20-20070123.htm#import-schema"><I>3.14 
    Importing Schema Components</I></A>) will always be available for validating 
    constructed nodes; if additional schema components are needed, they <SPAN 
    class=verb>may</SPAN> <SPAN>be located in other ways, for example implicitly 
    from knowledge of the namespace in which the elements and attributes appear, 
    or using the <CODE>xsi:schemaLocation</CODE> attribute of elements within 
    the tree being validated.</SPAN></P>
    <LI>
    <P>If no validation is performed for a node, which can happen when the 
    schema specifies <CODE>lax</CODE> or <CODE>skip</CODE> validation for that 
    node or for a subtree, then the node is annotated as 
    <SPAN><CODE>xs:anyType</CODE></SPAN> in the case of an element, and 
    <SPAN><CODE>xs:untypedAtomic</CODE></SPAN> in the case of an 
    attribute.</P></LI></UL>
  <LI>
  <P>The value <CODE>lax</CODE> has the same effect as the value 
  <CODE>strict</CODE>, except that whereas <CODE>strict</CODE> validation fails 
  <SPAN>if there is no matching top-level element declaration or</SPAN> if the 
  outcome of validity assessment is a <CODE>validity</CODE> property of 
  <CODE>invalid</CODE> or <CODE>notKnown</CODE>, <CODE>lax</CODE> validation 
  fails only if the outcome of validity assessment is a <CODE>validity</CODE> 
  property of <CODE>invalid</CODE>. That is, <CODE>lax</CODE> validation does 
  not cause a type error when the outcome is <CODE>notKnown</CODE>.</P>
  <P>In practice this means that the element or attribute being validated <SPAN 
  class=verb>must</SPAN> conform to its declaration if a top-level declaration 
  is available. If no such declaration is available, then the element or 
  attribute is not validated, but its attributes and children are validated, 
  again with lax validation. Any nodes whose validation outcome is a 
  <CODE>validity</CODE> property of <CODE>notKnown</CODE> are annotated as 
  <SPAN><CODE>xs:anyType</CODE></SPAN> in the case of an element, and 
  <SPAN><CODE>xs:untypedAtomic</CODE></SPAN> in the case of an attribute.</P>
  <DIV class=note>
  <P class=prefix><B>Note:</B></P>
  <P>When the parent element lacks a declaration, the XML Schema specification 
  defines the recursive checking of children and attributes as optional. For 
  this specification, this recursive checking is required.</P></DIV>
  <DIV class=note>
  <P class=prefix><B>Note:</B></P>
  <P>If an element that is being validated has an <CODE>xsi:type</CODE> 
  attribute, then the value of the <CODE>xsi:type</CODE> attribute will be taken 
  into account when performing the validation. However, the presence of an 
  <CODE>xsi:type</CODE> attribute will not of itself cause an element to be 
  validated: if validation against a named type is required, as distinct from 
  validation against a top-level element declaration, then it must be requested 
  using the XSLT <CODE>[xsl:]type</CODE> attribute on the instruction that 
  invokes the validation, as described in section <A 
  href="REC-xslt20-20070123.htm#validation-xsl-type"><I>19.2.1.2 
  Validation using the [xsl:]type Attribute</I></A></P></DIV></LI></UL>
<P><A id=err-XTTE1510 name=err-XTTE1510><SPAN class=error>[ERR 
XTTE1510]</SPAN></A> If the <CODE>validation</CODE> attribute of an <A 
href="REC-xslt20-20070123.htm#element-element"><CODE>xsl:element</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-attribute"><CODE>xsl:attribute</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-copy"><CODE>xsl:copy</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-copy-of"><CODE>xsl:copy-of</CODE></A>, 
or <A 
href="REC-xslt20-20070123.htm#element-result-document"><CODE>xsl:result-document</CODE></A> 
instruction, or the <CODE>xsl:validation</CODE> attribute of a literal result 
element, has the effective value <CODE>strict</CODE>, and schema validity 
assessment concludes that the validity of the element or attribute is invalid or 
unknown, a type error occurs. As with other type errors, the error <SPAN 
class=verb>may</SPAN> be signaled statically if it can be detected 
statically.</P>
<P><A id=err-XTTE1512 name=err-XTTE1512><SPAN class=error>[ERR 
XTTE1512]</SPAN></A> If the <CODE>validation</CODE> attribute of an <A 
href="REC-xslt20-20070123.htm#element-element"><CODE>xsl:element</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-attribute"><CODE>xsl:attribute</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-copy"><CODE>xsl:copy</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-copy-of"><CODE>xsl:copy-of</CODE></A>, 
or <A 
href="REC-xslt20-20070123.htm#element-result-document"><CODE>xsl:result-document</CODE></A> 
instruction, or the <CODE>xsl:validation</CODE> attribute of a literal result 
element, has the effective value <CODE>strict</CODE>, and there is no matching 
top-level declaration in the schema, then a type error occurs. As with other 
type errors, the error <SPAN class=verb>may</SPAN> be signaled statically if it 
can be detected statically.</P>
<P><A id=err-XTTE1515 name=err-XTTE1515><SPAN class=error>[ERR 
XTTE1515]</SPAN></A> If the <CODE>validation</CODE> attribute of an <A 
href="REC-xslt20-20070123.htm#element-element"><CODE>xsl:element</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-attribute"><CODE>xsl:attribute</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-copy"><CODE>xsl:copy</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-copy-of"><CODE>xsl:copy-of</CODE></A>, 
or <A 
href="REC-xslt20-20070123.htm#element-result-document"><CODE>xsl:result-document</CODE></A> 
instruction, or the <CODE>xsl:validation</CODE> attribute of a literal result 
element, has the effective value <CODE>lax</CODE>, and schema validity 
assessment concludes that the element or attribute is invalid, a type error 
occurs. As with other type errors, the error <SPAN class=verb>may</SPAN> be 
signaled statically if it can be detected statically.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>No mechanism is provided to validate an element or attribute against a local 
declaration in a schema. Such validation can usually be achieved by applying 
validation to a containing element for which a top-level element declaration 
exists.</P></DIV></DIV>
<DIV class=div4>
<H5><A id=validation-xsl-type name=validation-xsl-type></A>19.2.1.2 Validation 
using the <CODE>[xsl:]type</CODE> Attribute</H5>
<P>The <CODE>[xsl:]type</CODE> attribute takes as its value a 
<CODE>QName</CODE>. This <SPAN class=verb>must</SPAN> <SPAN>be the name of a 
type definition included in the <A title="in-scope schema component" 
href="REC-xslt20-20070123.htm#dt-in-scope-schema-component">in-scope 
schema components</A> for the stylesheet.</SPAN> If the QName has no prefix, it 
is expanded using the default namespace established using the effective 
<CODE>[xsl:]xpath-default-namespace</CODE> attribute if there is one; otherwise, 
it is taken as being a name in no namespace.</P>
<P>If the <CODE>[xsl:]type</CODE> attribute is present, then the newly 
constructed element or attribute is validated against the type definition 
identified by this attribute.</P>
<UL>
  <LI>
  <P>In the case of an element, schema-validity assessment is carried out 
  according to the rules defined in <A 
  href="REC-xslt20-20070123.htm#xmlschema-1">[XML Schema 
  Part 1]</A> (section 3.3.4 "Element Declaration Validation Rules", validation 
  rule "Schema-Validity Assessment (Element)", clauses 1.2 and 2), using this 
  type definition as the "processor-stipulated type definition". The element is 
  considered valid if the result of the schema validity assessment is a PSVI in 
  which the relevant element node has a <CODE>validity</CODE> property whose 
  value is <CODE>valid</CODE>.</P>
  <LI>
  <P>In the case of an attribute, the attribute is considered valid if (in the 
  terminology of XML Schema) the attribute's normalized value is locally valid 
  with respect to that type definition according to the rules for "String Valid" 
  (<A href="REC-xslt20-20070123.htm#xmlschema-1">[XML 
  Schema Part 1]</A>, section 3.14.4). (Normalization here refers to the process 
  of normalizing whitespace according to the rules of the 
  <CODE>whiteSpace</CODE> facet for the data type).</P>
  <LI>
  <P>If the element or attribute is not considered valid, <SPAN>as defined 
  above</SPAN>, the transformation fails <SPAN><SPAN class=error>[see <A 
  href="REC-xslt20-20070123.htm#err-XTTE1540">ERR 
  XTTE1540</A>]</SPAN></SPAN>.</P></LI></UL>
<P><A id=err-XTSE1520 name=err-XTSE1520><SPAN class=error>[ERR 
XTSE1520]</SPAN></A> It is a <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A> if the value of the <CODE>type</CODE> attribute of an <A 
href="REC-xslt20-20070123.htm#element-element"><CODE>xsl:element</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-attribute"><CODE>xsl:attribute</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-copy"><CODE>xsl:copy</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-copy-of"><CODE>xsl:copy-of</CODE></A>, 
<SPAN><A 
href="REC-xslt20-20070123.htm#element-document"><CODE>xsl:document</CODE></A>,</SPAN> 
or <A 
href="REC-xslt20-20070123.htm#element-result-document"><CODE>xsl:result-document</CODE></A> 
instruction, or the <CODE>xsl:type</CODE> attribute of a literal result element, 
is not a valid <CODE>QName</CODE>, or if it uses a prefix that is not defined in 
an in-scope namespace declaration, or if the QName is not the name of a type 
definition included in the <A title="in-scope schema component" 
href="REC-xslt20-20070123.htm#dt-in-scope-schema-component">in-scope 
schema components</A> for the stylesheet.</P>
<P><A id=err-XTSE1530 name=err-XTSE1530><SPAN class=error>[ERR 
XTSE1530]</SPAN></A> It is a <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A> if the value of the <CODE>type</CODE> attribute of an <A 
href="REC-xslt20-20070123.htm#element-attribute"><CODE>xsl:attribute</CODE></A> 
instruction refers to a complex type definition.</P>
<P><A id=err-XTTE1540 name=err-XTTE1540><SPAN class=error>[ERR 
XTTE1540]</SPAN></A> It is a <A title="type errors" 
href="REC-xslt20-20070123.htm#dt-type-error">type 
error</A> if an <CODE>[xsl:]type</CODE> attribute is defined for a constructed 
element or attribute, and the outcome of schema validity assessment against that 
type is that the <CODE>validity</CODE> property of that element or attribute 
information item is other than <CODE>valid</CODE>.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>Like other type errors, this error may be signaled statically if it can be 
detected statically. For example, the instruction <CODE>&lt;xsl:attribute 
name="dob" type="xs:date"&gt;1999-02-29&lt;/xsl:attribute&gt;</CODE> may result 
in a static error being signaled. If the error is not signaled statically, it 
will be signaled when the instruction is evaluated.</P></DIV></DIV>
<DIV class=div4>
<H5><A id=validation-process name=validation-process></A>19.2.1.3 The Validation 
Process</H5>
<P>As well as checking for validity against the schema, the validity assessment 
process causes <A title="type annotation" 
href="REC-xslt20-20070123.htm#dt-annotation">type 
annotations</A> to be associated with element and attribute nodes. If default 
values for elements or attributes are defined in the schema, the validation 
process will where necessary create new nodes containing these default 
values.</P>
<P>Validation of an element or attribute node only takes into account 
constraints on the content of the element or attribute. Validation rules 
affecting the document as a whole are not applied. Specifically, this means:</P>
<UL>
  <LI>
  <P>The validation rule "Validation Root Valid (ID/IDREF)" is not applied. This 
  means that validation will not fail if there are non-unique ID values or 
  dangling IDREF values in the subtree being validated.</P>
  <LI>
  <P>The validation rule "Validation Rule: Identity-constraint Satisfied" is not 
  applied.</P>
  <LI>
  <P>There is no check that the document contains unparsed entities whose names 
  match the values of nodes of type <CODE>xs:ENTITY</CODE> or 
  <CODE>xs:ENTITIES</CODE>. (XSLT 2.0 provides no facility to construct unparsed 
  entities within a tree.)</P>
  <LI>
  <P>There is no check that the document contains notations whose names match 
  the values of nodes of type <CODE>xs:NOTATION</CODE>. (The <SPAN>XDM</SPAN> 
  data model makes no provision for notations to be represented in the 
  tree.)</P></LI></UL>
<P>With these caveats, validating a newly constructed element, using strict or 
lax validation, is equivalent to the following steps:</P>
<OL class=enumar>
  <LI>
  <P>The element is serialized to textual XML form, according to the rules 
  defined in <A 
  href="REC-xslt20-20070123.htm#xslt-xquery-serialization">[XSLT 
  and XQuery Serialization]</A> using the XML output method, with all parameters 
  defaulted. Note that this process discards any existing <A 
  title="type annotation" 
  href="REC-xslt20-20070123.htm#dt-annotation">type 
  annotations</A>.</P>
  <LI>
  <P>The resulting XML document is parsed to create an XML Information Set (see 
  <A href="REC-xslt20-20070123.htm#xml-infoset">[XML 
  Information Set]</A>.)</P>
  <LI>
  <P>The Information Set produced in the previous step is validated according to 
  the rules in <A 
  href="REC-xslt20-20070123.htm#xmlschema-1">[XML Schema 
  Part 1]</A>. The result of this step is a Post-Schema Validation Infoset 
  (PSVI). If the validation process is not successful (as defined above), a type 
  error is raised.</P>
  <LI>
  <P>The PSVI produced in the previous step is converted back into the 
  <SPAN>XDM</SPAN> data model by the mapping described in <A 
  href="REC-xslt20-20070123.htm#xpath-datamodel">[Data 
  Model]</A> (<A href="http://www.w3.org/TR/xpath-datamodel/#PSVI2Types">Section 
  3.3.1 Mapping PSVI Additions to Node 
  Properties</A><SUP><SMALL>DM</SMALL></SUP>). This process creates nodes with 
  simple or complex <A title="type annotation" 
  href="REC-xslt20-20070123.htm#dt-annotation">type 
  annotations</A> based on the types established during schema 
  validation.</P></LI></OL>
<P>Validating an attribute using strict or lax validation requires a modified 
version of this procedure. A copy of the attribute is first added to an element 
node that is created for the purpose, and namespace fixup (see <A 
href="REC-xslt20-20070123.htm#namespace-fixup"><I>5.7.3 
Namespace Fixup</I></A>) is performed on this element node. The name of this 
element is of no consequence, but it must be the same as the name of a 
synthesized element declaration of the form:</P>
<DIV class=exampleInner><PRE>&lt;xs:element name="E"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:sequence/&gt;
    &lt;xs:attribute ref="A"/&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</PRE></DIV>
<P>where A is the name of the attribute being validated.</P>
<P>This synthetic element is then validated using the procedure given above for 
validating elements, and if it is found to be valid, a copy of the validated 
attribute is made, retaining its <A title="type annotation" 
href="REC-xslt20-20070123.htm#dt-annotation">type 
annotation</A>, but detaching it from the containing element (and thus, from any 
namespace nodes).</P>
<P>The <SPAN>XDM</SPAN> data model does not permit an attribute node with no 
parent to have a typed value that includes a namespace-qualified name, that is, 
a value whose type is derived from <CODE>xs:QName</CODE> or 
<CODE>xs:NOTATION</CODE>. This restriction is imposed because these types rely 
on the namespace nodes of a containing element to resolve namespace prefixes. 
Therefore, it is an error to validate a parentless attribute against such a 
type. This affects the instructions <A 
href="REC-xslt20-20070123.htm#element-attribute"><CODE>xsl:attribute</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-copy"><CODE>xsl:copy</CODE></A>, 
and <A 
href="REC-xslt20-20070123.htm#element-copy-of"><CODE>xsl:copy-of</CODE></A>.</P>
<P><A id=err-XTTE1545 name=err-XTTE1545><SPAN class=error>[ERR 
XTTE1545]</SPAN></A> A <A title="type errors" 
href="REC-xslt20-20070123.htm#dt-type-error">type 
error</A> occurs if a <CODE>type</CODE> or <CODE>validation</CODE> attribute is 
defined (explicitly or implicitly) for an instruction that constructs a new 
attribute node, if the effect of this is to cause the attribute value to be 
validated against a type that is derived from, or constructed by list or union 
from, the primitive types <CODE>xs:QName</CODE> or 
<CODE>xs:NOTATION</CODE>.</P></DIV></DIV>
<DIV class=div3>
<H4><A id=validating-document-nodes name=validating-document-nodes></A>19.2.2 
Validating Document Nodes</H4>
<P>It is possible to apply validation to a document node. <SPAN>This happens 
when a new document node is constructed by one of the instructions <A 
href="REC-xslt20-20070123.htm#element-document"><CODE>xsl:document</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-result-document"><CODE>xsl:result-document</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-copy"><CODE>xsl:copy</CODE></A>, 
or <A 
href="REC-xslt20-20070123.htm#element-copy-of"><CODE>xsl:copy-of</CODE></A>, 
and this instruction has a <CODE>type</CODE> attribute, or a 
<CODE>validation</CODE> attribute with the value <CODE>strict</CODE> or 
<CODE>lax</CODE></SPAN>.</P>
<P>Document-level validation is not applied to the document node that is created 
implicitly when a variable-binding element has no <CODE>select</CODE> attribute 
and no <CODE>as</CODE> attribute (see <A 
href="REC-xslt20-20070123.htm#temporary-trees"><I>9.4 
Creating implicit document nodes</I></A>). This is equivalent to using 
<CODE>validation="preserve"</CODE> on <A 
href="REC-xslt20-20070123.htm#element-document"><CODE>xsl:document</CODE></A>: 
nodes within such trees retain their <A title="type annotation" 
href="REC-xslt20-20070123.htm#dt-annotation">type 
annotation</A>. Similarly, validation is not applied to document nodes created 
using <A 
href="REC-xslt20-20070123.htm#element-message"><CODE>xsl:message</CODE></A>.</P>
<P>The values <CODE>validation="preserve"</CODE> and 
<CODE>validation="strip"</CODE> do not request validation. In the first case, 
all element and attribute nodes within the tree rooted at the new document node 
retain their <A title="type annotation" 
href="REC-xslt20-20070123.htm#dt-annotation">type 
annotations</A>. In the second case, elements within the tree have their type 
annotation set to <SPAN><CODE>xs:untyped</CODE></SPAN>, while attributes have 
their type annotation set to <SPAN><CODE>xs:untypedAtomic</CODE></SPAN>.</P>
<P>When validation is requested for a document node (that is, when 
<CODE>validation</CODE> is set to <CODE>strict</CODE> or <CODE>lax</CODE>, or 
when a <CODE>type</CODE> attribute is present), the following processing takes 
place:</P>
<UL>
  <LI>
  <P><A id=err-XTTE1550 name=err-XTTE1550><SPAN class=error>[ERR 
  XTTE1550]</SPAN></A> A <A title="type errors" 
  href="REC-xslt20-20070123.htm#dt-type-error">type 
  error</A> occurs unless the children of the document node comprise exactly one 
  element node, no text nodes, and zero or more comment and processing 
  instruction nodes, in any order.</P>
  <LI>
  <P>The single element node child is validated, using the supplied values of 
  the <CODE>validation</CODE> and <CODE>type</CODE> attributes, as described in 
  <A 
  href="REC-xslt20-20070123.htm#validating-constructed-nodes"><I>19.2.1 
  Validating Constructed Elements and Attributes</I></A>.</P>
  <DIV class=note>
  <P class=prefix><B>Note:</B></P>
  <P>The <CODE>type</CODE> attribute on <SPAN><A 
  href="REC-xslt20-20070123.htm#element-document"><CODE>xsl:document</CODE></A> 
  and</SPAN> <A 
  href="REC-xslt20-20070123.htm#element-result-document"><CODE>xsl:result-document</CODE></A>, 
  and on <A 
  href="REC-xslt20-20070123.htm#element-copy"><CODE>xsl:copy</CODE></A> 
  and <A 
  href="REC-xslt20-20070123.htm#element-copy-of"><CODE>xsl:copy-of</CODE></A> 
  when copying a document node, thus refers to the required type of the element 
  node that is the only element child of the document node. It does not refer to 
  the type of the document node itself.</P></DIV>
  <LI>
  <P>The validation rule "Validation Root Valid (ID/IDREF)" is applied to the 
  single element node child of the document node. This means that validation 
  will fail if there are non-unique ID values or dangling IDREF values in the 
  document tree.</P>
  <LI>
  <P>Identity constraints, as defined in section 3.11 of <A 
  href="REC-xslt20-20070123.htm#xmlschema-1">[XML Schema 
  Part 1]</A>, are checked. (This refers to constraints defined using 
  <CODE>xs:unique</CODE>, <CODE>xs:key</CODE>, and <CODE>xs:keyref</CODE>.)</P>
  <LI>
  <P>There is no check that the tree contains unparsed entities whose names 
  match the values of nodes of type <CODE>xs:ENTITY</CODE> or 
  <CODE>xs:ENTITIES</CODE>. This is because there is no facility in XSLT 2.0 to 
  create unparsed entities in a <A title="result tree" 
  href="REC-xslt20-20070123.htm#dt-result-tree">result 
  tree</A>. It is possible to add unparsed entity declarations to the result 
  document by referencing a suitable DOCTYPE during serialization.</P>
  <LI>
  <P>There is no check that the document contains notations whose names match 
  the values of nodes of type <CODE>xs:NOTATION</CODE>. This is because 
  notations are not part of the <SPAN>XDM</SPAN> data model. It is possible to 
  add notations to the result document by referencing a suitable DOCTYPE during 
  serialization.</P>
  <LI>
  <P>All other children of the document node (comments and processing 
  instructions) are copied unchanged.</P></LI></UL>
<P><A id=err-XTTE1555 name=err-XTTE1555><SPAN class=error>[ERR 
XTTE1555]</SPAN></A> It is a <A title="type errors" 
href="REC-xslt20-20070123.htm#dt-type-error">type 
error</A> if, when validating a document node, document-level constraints are 
not satisfied. These constraints include identity constraints 
(<CODE>xs:unique</CODE>, <CODE>xs:key</CODE>, and <CODE>xs:keyref</CODE>) and 
ID/IDREF constraints.</P></DIV></DIV></DIV>
<DIV class=div1>
<H2><A id=serialization name=serialization></A>20 Serialization</H2>
<P>A <A title=processor 
href="REC-xslt20-20070123.htm#dt-processor">processor</A> 
<SPAN class=verb>may</SPAN> output a <A title="final result tree" 
href="REC-xslt20-20070123.htm#dt-final-result-tree">final 
result tree</A> as a sequence of octets, although it is not <SPAN 
class=verb>required</SPAN> to be able to do so (see <A 
href="REC-xslt20-20070123.htm#conformance"><I>21 
Conformance</I></A>). <SPAN>Stylesheet authors can use <A 
href="REC-xslt20-20070123.htm#element-output"><CODE>xsl:output</CODE></A> 
declarations to specify how they wish result trees to be serialized. If a 
processor serializes a final result tree, it <SPAN class=verb>must</SPAN> do so 
as specified by these declarations.</SPAN></P>
<P>The rules governing the output of the serializer are defined in <A 
href="REC-xslt20-20070123.htm#xslt-xquery-serialization">[XSLT 
and XQuery Serialization]</A>. The serialization is controlled using a number of 
serialization parameters. The values of these serialization parameters may be 
set within the <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A>, 
using the <A 
href="REC-xslt20-20070123.htm#element-output"><CODE>xsl:output</CODE></A>, 
<A 
href="REC-xslt20-20070123.htm#element-result-document"><CODE>xsl:result-document</CODE></A>, 
and <A 
href="REC-xslt20-20070123.htm#element-character-map"><CODE>xsl:character-map</CODE></A> 
declarations.</P>
<P class=element-syntax><A id=element-output 
name=element-output></A><CODE>&lt;!-- Category: declaration 
--&gt;<BR>&lt;xsl:output<BR>&nbsp;&nbsp;name? = 
<VAR>qname</VAR><BR>&nbsp;&nbsp;method? = "xml" | "html" | "xhtml" | "text" | 
<VAR>qname-but-not-ncname</VAR><BR>&nbsp;&nbsp;byte-order-mark? = "yes" | 
"no"<BR>&nbsp;&nbsp;cdata-section-elements? = 
<VAR>qnames</VAR><BR>&nbsp;&nbsp;doctype-public? = 
<VAR>string</VAR><BR>&nbsp;&nbsp;doctype-system? = 
<VAR>string</VAR><BR>&nbsp;&nbsp;encoding? = 
<VAR>string</VAR><BR>&nbsp;&nbsp;escape-uri-attributes? = "yes" | 
"no"<BR>&nbsp;&nbsp;include-content-type? = "yes" | "no"<BR>&nbsp;&nbsp;indent? 
= "yes" | "no"<BR>&nbsp;&nbsp;media-type? = 
<VAR>string</VAR><BR>&nbsp;&nbsp;normalization-form? = "NFC" | "NFD" | "NFKC" | 
"NFKD" | "fully-normalized" | "none" | 
<VAR>nmtoken</VAR><BR>&nbsp;&nbsp;omit-xml-declaration? = "yes" | 
"no"<BR>&nbsp;&nbsp;standalone? = "yes" | "no" | 
"omit"<BR>&nbsp;&nbsp;undeclare-prefixes? = "yes" | 
"no"<BR>&nbsp;&nbsp;use-character-maps? = 
<VAR>qnames</VAR><BR>&nbsp;&nbsp;version? = 
<VAR>nmtoken</VAR>&nbsp;/&gt;</CODE></P>
<P>The <A 
href="REC-xslt20-20070123.htm#element-output"><CODE>xsl:output</CODE></A> 
declaration is optional; if used, it <SPAN class=verb>must</SPAN> always appear 
as a <A title=top-level 
href="REC-xslt20-20070123.htm#dt-top-level">top-level</A> 
element within a <SPAN>stylesheet module</SPAN>.</P>
<P>A <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
may contain multiple <A 
href="REC-xslt20-20070123.htm#element-output"><CODE>xsl:output</CODE></A> 
declarations and may include or import stylesheet modules that also contain <A 
href="REC-xslt20-20070123.htm#element-output"><CODE>xsl:output</CODE></A> 
declarations. The name of an <A 
href="REC-xslt20-20070123.htm#element-output"><CODE>xsl:output</CODE></A> 
declaration is the value of its <CODE>name</CODE> attribute, if any.</P>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-output-definition 
title="output definition" name=dt-output-definition></A>All the <A 
href="REC-xslt20-20070123.htm#element-output"><CODE>xsl:output</CODE></A> 
declarations in a stylesheet that share the same name are grouped into a named 
<B>output definition</B>; those that have no name are grouped into a single 
unnamed output definition.<SPAN class=definition>]</SPAN></P>
<P>A stylesheet always includes an unnamed <A title="output definition" 
href="REC-xslt20-20070123.htm#dt-output-definition">output 
definition</A>; in the absence of an unnamed <A 
href="REC-xslt20-20070123.htm#element-output"><CODE>xsl:output</CODE></A> 
declaration, the unnamed output definition is equivalent to the one that would 
be used if the stylesheet contained an <A 
href="REC-xslt20-20070123.htm#element-output"><CODE>xsl:output</CODE></A> 
declaration having no attributes.</P>
<P>A named <A title="output definition" 
href="REC-xslt20-20070123.htm#dt-output-definition">output 
definition</A> is used when its name matches the <CODE>format</CODE> attribute 
used in an <A 
href="REC-xslt20-20070123.htm#element-result-document"><CODE>xsl:result-document</CODE></A> 
element. The unnamed output definition is used when an <A 
href="REC-xslt20-20070123.htm#element-result-document"><CODE>xsl:result-document</CODE></A> 
element omits the <CODE>format</CODE> attribute. It is also used when 
serializing the <A title="final result tree" 
href="REC-xslt20-20070123.htm#dt-final-result-tree">final 
result tree</A> that is created implicitly in the absence of an <A 
href="REC-xslt20-20070123.htm#element-result-document"><CODE>xsl:result-document</CODE></A> 
element.</P>
<P>All the <A 
href="REC-xslt20-20070123.htm#element-output"><CODE>xsl:output</CODE></A> 
elements making up an <A title="output definition" 
href="REC-xslt20-20070123.htm#dt-output-definition">output 
definition</A> are effectively merged. <SPAN>For those attributes whose values 
are namespace-sensitive, the merging is done after <A title="lexical QName" 
href="REC-xslt20-20070123.htm#dt-lexical-qname">lexical 
QNames</A> have been converted into <A title=expanded-QName 
href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded 
QNames</A>.</SPAN> For the <CODE>cdata-section-elements</CODE> attribute, the 
output definition uses the union of the values from all the constituent <A 
href="REC-xslt20-20070123.htm#element-output"><CODE>xsl:output</CODE></A> 
declarations. <SPAN>For the <CODE>use-character-maps</CODE> attribute, the 
output definition uses the concatenation of the sequences of <A 
title=expanded-QName 
href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded 
QNames</A> values from all the constituent <A 
href="REC-xslt20-20070123.htm#element-output"><CODE>xsl:output</CODE></A> 
declarations, taking them in order of increasing <A title="import precedence" 
href="REC-xslt20-20070123.htm#dt-import-precedence">import 
precedence</A>, or where several have the same import precedence, in <A 
title="declaration order" 
href="REC-xslt20-20070123.htm#dt-declaration-order">declaration 
order</A>.</SPAN> For other attributes, the <A title="output definition" 
href="REC-xslt20-20070123.htm#dt-output-definition">output 
definition</A> uses the value of that attribute from the <A 
href="REC-xslt20-20070123.htm#element-output"><CODE>xsl:output</CODE></A> 
declaration with the highest <A title="import precedence" 
href="REC-xslt20-20070123.htm#dt-import-precedence">import 
precedence</A>.</P>
<P><A id=err-XTSE1560 name=err-XTSE1560><SPAN class=error>[ERR 
XTSE1560]</SPAN></A> It is a <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A> if two <A 
href="REC-xslt20-20070123.htm#element-output"><CODE>xsl:output</CODE></A> 
declarations within an <A title="output definition" 
href="REC-xslt20-20070123.htm#dt-output-definition">output 
definition</A> specify explicit values for the same attribute (other than 
<CODE>cdata-section-elements</CODE> and <CODE>use-character-maps</CODE>), with 
the values of the attributes being not equal, unless there is another <A 
href="REC-xslt20-20070123.htm#element-output"><CODE>xsl:output</CODE></A> 
declaration within the same <A title="output definition" 
href="REC-xslt20-20070123.htm#dt-output-definition">output 
definition</A> that has higher import precedence and that specifies an explicit 
value for the same attribute.</P>
<P>If none of the <A 
href="REC-xslt20-20070123.htm#element-output"><CODE>xsl:output</CODE></A> 
declarations within an <A title="output definition" 
href="REC-xslt20-20070123.htm#dt-output-definition">output 
definition</A> specifies a value for a particular attribute, then the 
corresponding serialization parameter takes a default value. The default value 
depends on the chosen output method.</P>
<P>There are some serialization parameters that apply to some output methods but 
not to others. For example, the <CODE>indent</CODE> attribute has no effect on 
the <CODE>text</CODE> output method. If a value is supplied for an attribute 
that is inapplicable to the output method, its value is <SPAN>not passed to the 
serializer</SPAN>. The processor <SPAN class=verb>may</SPAN> validate the value 
of such an attribute, but is not <SPAN class=verb>required</SPAN> to do so.</P>
<P>An implementation <SPAN class=verb>may</SPAN> allow the attributes of the <A 
href="REC-xslt20-20070123.htm#element-output"><CODE>xsl:output</CODE></A> 
declaration to be overridden, or the default values to be changed, using the API 
that controls the transformation.</P>
<P>The location to which <A title="final result tree" 
href="REC-xslt20-20070123.htm#dt-final-result-tree">final 
result trees</A> are serialized (whether in filestore or elsewhere) is <A 
title=implementation-defined 
href="REC-xslt20-20070123.htm#dt-implementation-defined">implementation-defined</A> 
(which in practice <SPAN class=verb>may</SPAN> mean that it is controlled using 
an implementation-defined API). However, these locations <SPAN 
class=verb>must</SPAN> satisfy the constraint that when two <A 
title="final result tree" 
href="REC-xslt20-20070123.htm#dt-final-result-tree">final 
result trees</A> are both created (implicitly or explicitly) using relative URIs 
in the <CODE>href</CODE> attribute of the <A 
href="REC-xslt20-20070123.htm#element-result-document"><CODE>xsl:result-document</CODE></A> 
instruction, then these relative URIs may be used to construct references from 
one tree to the other, and such references <SPAN class=verb>must</SPAN> remain 
valid when both result trees are serialized.</P>
<P>The <CODE>method</CODE> attribute on the <A 
href="REC-xslt20-20070123.htm#element-output"><CODE>xsl:output</CODE></A> 
element identifies the overall method that is to be used for outputting the <A 
title="final result tree" 
href="REC-xslt20-20070123.htm#dt-final-result-tree">final 
result tree</A>.</P>
<P><A id=err-XTSE1570 name=err-XTSE1570><SPAN class=error>[ERR 
XTSE1570]</SPAN></A> The value <SPAN class=verb>must</SPAN> <SPAN>(if 
present)</SPAN> be a valid <A title=QName 
href="REC-xslt20-20070123.htm#dt-qname">QName</A>. If the 
<A title=QName 
href="REC-xslt20-20070123.htm#dt-qname">QName</A> does 
not have a prefix, then it identifies a method specified in <A 
href="REC-xslt20-20070123.htm#xslt-xquery-serialization">[XSLT 
and XQuery Serialization]</A> and <SPAN class=verb>must</SPAN> be one of 
<CODE>xml</CODE>, <CODE>html</CODE>, <CODE>xhtml</CODE>, or <CODE>text</CODE>. 
If the <A title=QName 
href="REC-xslt20-20070123.htm#dt-qname">QName</A> has a 
prefix, then the <A title=QName 
href="REC-xslt20-20070123.htm#dt-qname">QName</A> is 
expanded into an <A title=expanded-QName 
href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded-QName</A> 
as described in <A 
href="REC-xslt20-20070123.htm#qname"><I>5.1 Qualified 
Names</I></A>; the <A title=expanded-QName 
href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded-QName</A> 
identifies the output method; the behavior in this case is not specified by this 
document.</P>
<P>The default for the <CODE>method</CODE> attribute <SPAN>depends on the 
contents of the tree being serialized, and</SPAN> is chosen as follows. If the 
document node of the <A title="final result tree" 
href="REC-xslt20-20070123.htm#dt-final-result-tree">final 
result tree</A> has an element child, and any text nodes preceding the first 
element child of the document node of the result tree contain only whitespace 
characters, then:</P>
<UL>
  <LI>
  <P>If the <A title=expanded-QName 
  href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded-QName</A> 
  of this first element child has local part <CODE>html</CODE> (in lower case), 
  and namespace URI <CODE>http://www.w3.org/1999/xhtml</CODE>, then the default 
  output method is <SPAN>normally</SPAN> <CODE>xhtml</CODE>. <SPAN>However, if 
  the <CODE>version</CODE> attribute of the <A 
  href="REC-xslt20-20070123.htm#element-stylesheet"><CODE>xsl:stylesheet</CODE></A> 
  element of the <A title="principal stylesheet module" 
  href="REC-xslt20-20070123.htm#dt-principal-stylesheet-module">principal 
  stylesheet module</A> has the value <CODE>1.0</CODE>, and if the result tree 
  is generated implicitly (rather than by an explicit <A 
  href="REC-xslt20-20070123.htm#element-result-document"><CODE>xsl:result-document</CODE></A> 
  instruction), then the default output method in this situation is 
  <CODE>xml</CODE>.</SPAN></P>
  <LI>
  <P>If the <A title=expanded-QName 
  href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded-QName</A> 
  of this first element child has local part <CODE>html</CODE> (in any 
  combination of upper and lower case) and a null namespace URI, then the 
  default output method is <CODE>html</CODE>.</P></LI></UL>
<P>In all other cases, the default output method is <CODE>xml</CODE>.</P>
<P>The default output method is used if the selected <A 
title="output definition" 
href="REC-xslt20-20070123.htm#dt-output-definition">output 
definition</A> does not include a <CODE>method</CODE> attribute.</P>
<P>The other attributes on <A 
href="REC-xslt20-20070123.htm#element-output"><CODE>xsl:output</CODE></A> 
provide parameters for the output method. The following attributes are 
allowed:</P>
<UL>
  <LI>
  <P>The value of the <CODE>encoding</CODE> attribute provides the value of the 
  <CODE>encoding</CODE> parameter to the serialization method. The default value 
  is <A title=implementation-defined 
  href="REC-xslt20-20070123.htm#dt-implementation-defined">implementation-defined</A>, 
  but in the case of the <CODE>xml</CODE> and <CODE>xhtml</CODE> methods it 
  <SPAN class=verb>must</SPAN> be either <CODE>UTF-8</CODE> or 
  <CODE>UTF-16</CODE>.</P>
  <LI>
  <P>The <CODE>byte-order-mark</CODE> attribute defines whether a byte order 
  mark is written at the start of the file. If the value <CODE>yes</CODE> is 
  specified, a byte order mark is written; if <CODE>no</CODE> is specified, no 
  byte order mark is written. The default value depends on the encoding used. If 
  the encoding is <CODE>UTF-16</CODE>, the default is <CODE>yes</CODE>; for 
  <CODE>UTF-8</CODE> it is <A title=implementation-defined 
  href="REC-xslt20-20070123.htm#dt-implementation-defined">implementation-defined</A>, 
  and for all other encodings it is <CODE>no</CODE>. The value of the byte order 
  mark indicates whether high order bytes are written before or after low order 
  bytes; the actual byte order used is <A title=implementation-dependent 
  href="REC-xslt20-20070123.htm#dt-implementation-dependent">implementation-dependent</A><SPAN> 
  , unless it is defined by the selected encoding</SPAN>.</P>
  <LI>
  <P>The <CODE>cdata-section-elements</CODE> attribute is a whitespace-separated 
  list of QNames. The default value is an empty list. After expansion of these 
  names using the in-scope namespace declarations for the <A 
  href="REC-xslt20-20070123.htm#element-output"><CODE>xsl:output</CODE></A> 
  declaration in which they appear, this list of names provides the value of the 
  <CODE>cdata-section-elements</CODE> parameter to the serialization method. 
  <SPAN>In the case of an unprefixed name, the default namespace (that is, the 
  namespace declared using <CODE>xmlns="uri"</CODE>) is used.</SPAN></P>
  <DIV class=note>
  <P class=prefix><B>Note:</B></P>
  <P>This differs from the rule for most other QNames used in a stylesheet. The 
  reason is that these names refer to elements in the result document, and 
  therefore follow the same convention as the name of a literal result element 
  or the <CODE>name</CODE> attribute of <A 
  href="REC-xslt20-20070123.htm#element-element"><CODE>xsl:element</CODE></A>.</P></DIV>
  <LI>
  <P>The value of the <CODE>doctype-system</CODE> attribute provides the value 
  of the <CODE>doctype-system</CODE> parameter to the serialization method. By 
  default, the parameter is not supplied.</P>
  <LI>
  <P>The value of the <CODE>doctype-public</CODE> attribute provides the value 
  of the <CODE>doctype-public</CODE> parameter to the serialization method. By 
  default, the parameter is not supplied.</P>
  <LI>
  <P>The value of the <CODE>escape-uri-attributes</CODE> attribute provides the 
  value of the <CODE>escape-uri-attributes</CODE> parameter to the serialization 
  method. The default value is <CODE>yes</CODE>.</P>
  <LI>
  <P>The value of the <CODE>include-content-type</CODE> attribute provides the 
  value of the <CODE>include-content-type</CODE> parameter to the serialization 
  method. The default value is <CODE>yes</CODE>.</P>
  <LI>
  <P>The value of the <CODE>indent</CODE> attribute provides the value of the 
  <CODE>indent</CODE> parameter to the serialization method. The default value 
  is <CODE>yes</CODE> in the case of the <CODE>html</CODE> and 
  <CODE>xhtml</CODE> output methods, <CODE>no</CODE> in the case of the 
  <CODE>xml</CODE> output method.</P>
  <LI>
  <P>The value of the <CODE>media-type</CODE> attribute provides the value of 
  the <CODE>media-type</CODE> parameter to the serialization method. The default 
  value is <CODE>text/xml</CODE> in the case of the <CODE>xml</CODE> output 
  method, <CODE>text/html</CODE> in the case of the <CODE>html</CODE> and 
  <CODE>xhtml</CODE> output methods, and <CODE>text/plain</CODE> in the case of 
  the <CODE>text</CODE> output method.</P>
  <LI>
  <P>The value of the <CODE>normalization-form</CODE> attribute provides the 
  value of the <CODE>normalization-form</CODE> parameter to the serialization 
  method. A value that is an <CODE>NMTOKEN</CODE> other than one of those 
  enumerated for the <CODE>normalization-form</CODE> attribute specifes an 
  implementation-defined normalization form; the behavior in this case is not 
  specified by this document. The default value is <CODE>none</CODE>.</P>
  <LI>
  <P>The value of the <CODE>omit-xml-declaration</CODE> attribute provides the 
  value of the <CODE>omit-xml-declaration</CODE> parameter to the serialization 
  method. The default value is <CODE>no</CODE>.</P>
  <LI>
  <P>The value of the <CODE>standalone</CODE> attribute provides the value of 
  the <CODE>standalone</CODE> parameter to the serialization method. <SPAN>The 
  default value is <CODE>omit</CODE>; this means that no <CODE>standalone</CODE> 
  attribute is to be included in the XML declaration.</SPAN></P>
  <LI>
  <P>The <CODE>undeclare-prefixes</CODE> attribute is relevant only when 
  producing output with <CODE>method="xml"</CODE> and <CODE>version="1.1"</CODE> 
  <SPAN>(or later)</SPAN>. It defines whether namespace undeclarations (of the 
  form <CODE>xmlns:foo=""</CODE>) <SPAN class=verb>should</SPAN> be output when 
  a child element has no namespace node with the same name (that is, namespace 
  prefix) as a namespace node of its parent element. The default value is 
  <CODE>no</CODE>: this means that namespace undeclarations are not output, 
  which has the effect that when the resulting XML is reparsed, the new tree may 
  contain namespace nodes on the child element that were not there in the 
  original tree before serialization.</P>
  <LI>
  <P>The <CODE>use-character-maps</CODE> attribute provides a list of named 
  character maps that are used in conjunction with this <A 
  title="output definition" 
  href="REC-xslt20-20070123.htm#dt-output-definition">output 
  definition</A>. The way this attribute is used is described in <A 
  href="REC-xslt20-20070123.htm#character-maps"><I>20.1 
  Character Maps</I></A>. <SPAN>The default value is an empty list.</SPAN></P>
  <LI>
  <P>The value of the <CODE>version</CODE> attribute provides the value of the 
  <CODE>version</CODE> parameter to the serialization method. <SPAN>The set of 
  permitted values, and the default value, are <A title=implementation-defined 
  href="REC-xslt20-20070123.htm#dt-implementation-defined">implementation-defined</A>. 
  A <A title="serialization error" 
  href="REC-xslt20-20070123.htm#dt-serialization-error">serialization 
  error</A> will be reported if the requested version is not supported by the 
  implementation.</SPAN></P></LI></UL>
<P>If the processor performs serialization, then it must signal any 
non-recoverable serialization errors that occur. These have the same effect as 
<A title="non-recoverable dynamic error" 
href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
dynamic errors</A>: that is, the processor must signal the error and must not 
finish as if the transformation had been successful.</P>
<DIV class=div2>
<H3><A id=character-maps name=character-maps></A>20.1 Character Maps</H3>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-character-map 
title="character map" name=dt-character-map></A>A <B>character map</B> allows a 
specific character appearing in a text or attribute node in the <A 
title="final result tree" 
href="REC-xslt20-20070123.htm#dt-final-result-tree">final 
result tree</A> to be substituted by a specified string of characters during 
serialization.<SPAN class=definition>]</SPAN> The effect of character maps is 
defined in <A 
href="REC-xslt20-20070123.htm#xslt-xquery-serialization">[XSLT 
and XQuery Serialization]</A>.</P>
<P>The character map that is supplied as a parameter to the serializer is 
determined from the <A 
href="REC-xslt20-20070123.htm#element-character-map"><CODE>xsl:character-map</CODE></A> 
elements referenced from the <A 
href="REC-xslt20-20070123.htm#element-output"><CODE>xsl:output</CODE></A> 
declaration for the selected <A title="output definition" 
href="REC-xslt20-20070123.htm#dt-output-definition">output 
definition</A>.</P>
<P>The <A 
href="REC-xslt20-20070123.htm#element-character-map"><CODE>xsl:character-map</CODE></A> 
element is a declaration that may appear as a child of the <A 
href="REC-xslt20-20070123.htm#element-stylesheet"><CODE>xsl:stylesheet</CODE></A> 
element.</P>
<P class=element-syntax><A id=element-character-map 
name=element-character-map></A><CODE>&lt;!-- Category: declaration 
--&gt;<BR>&lt;xsl:character-map<BR>&nbsp;&nbsp;<B>name</B> = 
<VAR>qname</VAR><BR>&nbsp;&nbsp;use-character-maps? = 
<VAR>qnames</VAR>&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: (<A 
href="REC-xslt20-20070123.htm#element-output-character">xsl:output-character</A>*) 
--&gt;<BR>&lt;/xsl:character-map&gt;</CODE></P>
<P>The <A 
href="REC-xslt20-20070123.htm#element-character-map"><CODE>xsl:character-map</CODE></A> 
declaration declares a character map with a name and a set of character 
mappings. The character mappings are specified by means of <A 
href="REC-xslt20-20070123.htm#element-output-character"><CODE>xsl:output-character</CODE></A> 
elements contained either directly within the <A 
href="REC-xslt20-20070123.htm#element-character-map"><CODE>xsl:character-map</CODE></A> 
element, or in further character maps referenced in the 
<CODE>use-character-maps</CODE> attribute.</P>
<P>The <SPAN class=verb>required</SPAN> <CODE>name</CODE> attribute provides a 
name for the character map. When a character map is used by an <A 
title="output definition" 
href="REC-xslt20-20070123.htm#dt-output-definition">output 
definition</A> or another character map, the character map with the highest <A 
title="import precedence" 
href="REC-xslt20-20070123.htm#dt-import-precedence">import 
precedence</A> is used.</P>
<P><A id=err-XTSE1580 name=err-XTSE1580><SPAN class=error>[ERR 
XTSE1580]</SPAN></A> It is a <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A> if the <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
contains two or more character maps with the same name and the same <A 
title="import precedence" 
href="REC-xslt20-20070123.htm#dt-import-precedence">import 
precedence</A><SPAN>, unless it also contains another character map with the 
same name and higher import precedence.</SPAN></P>
<P>The optional <CODE>use-character-maps</CODE> attribute lists the names of 
further character maps that are included into this character map.</P>
<P><A id=err-XTSE1590 name=err-XTSE1590><SPAN class=error>[ERR 
XTSE1590]</SPAN></A> It is a <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A> if a name in the <CODE>use-character-maps</CODE> attribute <SPAN>of 
the <A 
href="REC-xslt20-20070123.htm#element-output"><CODE>xsl:output</CODE></A> 
or <A 
href="REC-xslt20-20070123.htm#element-character-map"><CODE>xsl:character-map</CODE></A> 
elements</SPAN> does not match the <CODE>name</CODE> attribute of any <A 
href="REC-xslt20-20070123.htm#element-character-map"><CODE>xsl:character-map</CODE></A> 
in the <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A>.</P>
<P><A id=err-XTSE1600 name=err-XTSE1600><SPAN class=error>[ERR 
XTSE1600]</SPAN></A> It is a <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A> if a character map references itself, directly or indirectly, via a 
name in the <CODE>use-character-maps</CODE> attribute.</P>
<P>It is not an error if the same character map is referenced more than once, 
directly or indirectly.</P>
<P>An <A title="output definition" 
href="REC-xslt20-20070123.htm#dt-output-definition">output 
definition</A>, after recursive expansion of character maps referenced via its 
<CODE>use-character-maps</CODE> attribute, may contain several mappings for the 
same character. In this situation, the last character mapping takes precedence. 
To establish the ordering, the following rules are used:</P>
<UL>
  <LI>
  <P>Within a single <A 
  href="REC-xslt20-20070123.htm#element-character-map"><CODE>xsl:character-map</CODE></A> 
  element, the characters defined in character maps referenced in the 
  <CODE>use-character-maps</CODE> attribute are considered before the characters 
  defined in the child <A 
  href="REC-xslt20-20070123.htm#element-output-character"><CODE>xsl:output-character</CODE></A> 
  elements.</P>
  <LI>
  <P>The character maps referenced in a single <CODE>use-character-maps</CODE> 
  attribute are considered in the order in which they are listed in that 
  attribute. The expansion is depth-first: each referenced character map is 
  fully expanded before the next one is considered.</P>
  <LI>
  <P>Two <A 
  href="REC-xslt20-20070123.htm#element-output-character"><CODE>xsl:output-character</CODE></A> 
  elements appearing as children of the same <A 
  href="REC-xslt20-20070123.htm#element-character-map"><CODE>xsl:character-map</CODE></A> 
  element are considered in document order.</P></LI></UL>
<P>The <A 
href="REC-xslt20-20070123.htm#element-output-character"><CODE>xsl:output-character</CODE></A> 
element is defined as follows:</P>
<P class=element-syntax><A id=element-output-character 
name=element-output-character></A><CODE>&lt;xsl:output-character<BR>&nbsp;&nbsp;<B>character</B> 
= <VAR>char</VAR><BR>&nbsp;&nbsp;<B>string</B> = 
<VAR>string</VAR>&nbsp;/&gt;</CODE></P>
<P>The character map that is passed as a parameter to the serializer contains a 
mapping for the character specified in the <CODE>character</CODE> attribute to 
the string specified in the <CODE>string</CODE> attribute.</P>
<P>Character mapping is not applied to characters for which output escaping has 
been disabled as described in <A 
href="REC-xslt20-20070123.htm#disable-output-escaping"><I>20.2 
Disabling Output Escaping</I></A>.</P>
<P>If a character is mapped, then it is not subjected to XML or HTML 
escaping.</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e29242 name=d5e29242></A>Example: Using 
Character Maps to Generate Non-XML Output </DIV>
<P>Character maps can be useful when producing serialized output in a format 
that resembles, but is not strictly conformant to, HTML or XML. For example, 
when the output is a JSP page, there might be a need to generate the output:</P>
<DIV class=exampleInner><PRE>&lt;jsp:setProperty name="user" property="id" value='&lt;%= "id" + idValue %&gt;'/&gt;
</PRE></DIV>
<P>Although this output is not well-formed XML or HTML, it is valid in Java 
Server Pages. This can be achieved by allocating three Unicode characters (which 
are not needed for any other purpose) to represent the strings 
<CODE>&lt;%</CODE>, <CODE>%&gt;</CODE>, and <CODE>"</CODE>, for example:</P>
<DIV class=exampleInner><PRE>&lt;xsl:character-map name="jsp"&gt;
  &lt;xsl:output-character character="«" string="&amp;lt;%"/&gt;   
  &lt;xsl:output-character character="»" string="%&amp;gt;"/&gt;
  &lt;xsl:output-character character="§" string='"'/&gt;
&lt;/xsl:character-map&gt;
</PRE></DIV>
<P>When this character map is referenced in the <A 
href="REC-xslt20-20070123.htm#element-output"><CODE>xsl:output</CODE></A> 
declaration, the required output can be produced by writing the following in the 
stylesheet:</P>
<DIV class=exampleInner><PRE>&lt;jsp:setProperty name="user" property="id" value='«= §id§ + idValue »'/&gt;
</PRE></DIV>
<P>This works <SPAN>on the assumption that</SPAN> when an apostrophe or 
quotation mark is generated as part of an attribute value by the use of 
character maps, the serializer will (where possible) use the other choice of 
delimiter around the attribute value.</P></DIV>
<P>&nbsp;</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e29274 name=d5e29274></A>Example: Constructing 
a Composite Character Map </DIV>
<P>The following example illustrates a composite character map constructed in a 
modular fashion:</P>
<DIV class=exampleInner><PRE>&lt;xsl:output name="htmlDoc" use-character-maps="htmlDoc" /&gt;

&lt;xsl:character-map name="htmlDoc"
  use-character-maps="html-chars doc-entities windows-format" /&gt;
  
&lt;xsl:character-map name="html-chars"
  use-character-maps="latin1 ..." /&gt;

&lt;xsl:character-map name="latin1"&gt;
  &lt;xsl:output-character character="&amp;#160;" string="&amp;amp;nbsp;" /&gt;
  &lt;xsl:output-character character="&amp;#161;" string="&amp;amp;iexcl;" /&gt;
  ...
&lt;/xsl:character-map&gt;

&lt;xsl:character-map name="doc-entities"&gt;
  &lt;xsl:output-character character="&amp;#xE400;" string="&amp;amp;t-and-c;" /&gt;
  &lt;xsl:output-character character="&amp;#xE401;" string="&amp;amp;chap1;" /&gt;
  &lt;xsl:output-character character="&amp;#xE402;" string="&amp;amp;chap2;" /&gt;
  ...
&lt;/xsl:character-map&gt;

&lt;xsl:character-map name="windows-format"&gt;
  &lt;!-- newlines as CRLF --&gt;
  &lt;xsl:output-character character="&amp;#xA;" string="&amp;#xD;&amp;#xA;" /&gt;

  &lt;!-- tabs as three spaces --&gt;
  &lt;xsl:output-character character="&amp;#x9;" string="   " /&gt;

  &lt;!-- images for special characters --&gt;
  &lt;xsl:output-character character="&amp;#xF001;"
    string="&amp;lt;img src='special1.gif' /&amp;gt;" /&gt;
  &lt;xsl:output-character character="&amp;#xF002;"
    string="&amp;lt;img src='special2.gif' /&amp;gt;" /&gt;
  ...
&lt;/xsl:character-map&gt;
</PRE></DIV></DIV></DIV>
<DIV class=div2>
<H3><A id=disable-output-escaping name=disable-output-escaping></A>20.2 
Disabling Output Escaping</H3>
<P>Normally, when using the XML, HTML, or XHTML output method, the serializer 
will escape special characters such as <CODE>&amp;</CODE> and <CODE>&lt;</CODE> 
when outputting text nodes. This ensures that the output is well-formed. 
However, it is sometimes convenient to be able to produce output that is almost, 
but not quite well-formed XML; for example, the output may include ill-formed 
sections which are intended to be transformed into well-formed XML by a 
subsequent non-XML-aware process. For this reason, XSLT defines a mechanism for 
disabling output escaping.</P>
<P>This feature is <A title=deprecated 
href="REC-xslt20-20070123.htm#dt-deprecated">deprecated</A>.</P>
<P>This is an optional feature: it is not <SPAN class=verb>required</SPAN> that 
a XSLT processor that implements the serialization option <SPAN 
class=verb>should</SPAN> offer the ability to disable output escaping, and there 
is no conformance level that requires this feature.</P>
<P>This feature requires an extension to the serializer described in <A 
href="REC-xslt20-20070123.htm#xslt-xquery-serialization">[XSLT 
and XQuery Serialization]</A>. Conceptually, the <A title="final result tree" 
href="REC-xslt20-20070123.htm#dt-final-result-tree">final 
result tree</A> provides an additional boolean property 
<CODE>disable-escaping</CODE> associated with every character in a text node. 
When this property is set, the normal action of the serializer to escape special 
characters such as <CODE>&amp;</CODE> and <CODE>&lt;</CODE> is suppressed.</P>
<P>An <A 
href="REC-xslt20-20070123.htm#element-value-of"><CODE>xsl:value-of</CODE></A> 
or <A 
href="REC-xslt20-20070123.htm#element-text"><CODE>xsl:text</CODE></A> 
element may have a <CODE>disable-output-escaping</CODE> attribute; the allowed 
values are <CODE>yes</CODE> or <CODE>no</CODE>. The default is <CODE>no</CODE>; 
if the value is <CODE>yes</CODE>, then every character in the text node 
generated by evaluating the <A 
href="REC-xslt20-20070123.htm#element-value-of"><CODE>xsl:value-of</CODE></A> 
or <A 
href="REC-xslt20-20070123.htm#element-text"><CODE>xsl:text</CODE></A> 
element <SPAN class=verb>should</SPAN> have the <CODE>disable-output</CODE> 
property set.</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e29357 name=d5e29357></A>Example: Disable 
Output Escaping </DIV>
<P>For example,</P>
<DIV class=exampleInner><PRE>&lt;xsl:text disable-output-escaping="yes"&gt;&amp;lt;&lt;/xsl:text&gt;
</PRE></DIV>
<P>should generate the single character <CODE>&lt;</CODE>.</P></DIV>
<P>If output escaping is disabled for an <A 
href="REC-xslt20-20070123.htm#element-value-of"><CODE>xsl:value-of</CODE></A> 
or <A 
href="REC-xslt20-20070123.htm#element-text"><CODE>xsl:text</CODE></A> 
instruction evaluated when <A title="temporary output state" 
href="REC-xslt20-20070123.htm#dt-temporary-output-state">temporary 
output state</A> is in effect, the request to disable output escaping is 
ignored.</P>
<P>If output escaping is disabled for text within an element that would normally 
be output using a CDATA section, because the element is listed in the 
<CODE>cdata-section-elements</CODE>, then the relevant text will not be included 
in a CDATA section. In effect, CDATA is treated as an alternative escaping 
mechanism, which is disabled by the <CODE>disable-output-escaping</CODE> 
option.</P>
<DIV class=example>
<DIV class=exampleHeader><A id=d5e29388 name=d5e29388></A>Example: Interaction 
of Output Escaping and CDATA </DIV>
<P>For example, if <CODE>&lt;xsl:output 
cdata-section-elements="title"/&gt;</CODE> is specified, then the following 
instructions:</P>
<DIV class=exampleInner><PRE>&lt;title&gt;
  &lt;xsl:text disable-output-escaping="yes"&gt;This is not &amp;lt;hr/&amp;gt; good coding practice&lt;/xsl:text&gt;
&lt;/title&gt;
</PRE></DIV>
<P>should generate the output:</P>
<DIV class=exampleInner><PRE>&lt;title&gt;&lt;![CDATA[This is not ]]&gt;&lt;hr/&gt;&lt;![CDATA[ good coding practice]]&gt;&lt;/title&gt;
</PRE></DIV></DIV>
<P>The <CODE>disable-output-escaping</CODE> attribute may be used with the 
<CODE>html</CODE> output method as well as with the <CODE>xml</CODE> output 
method. The <CODE>text</CODE> output method ignores the 
<CODE>disable-output-escaping</CODE> attribute, since it does not perform any 
output escaping.</P>
<P>A <A title=processor 
href="REC-xslt20-20070123.htm#dt-processor">processor</A> 
will only be able to disable output escaping if it controls how the <A 
title="final result tree" 
href="REC-xslt20-20070123.htm#dt-final-result-tree">final 
result tree</A> is output. This might not always be the case. For example, the 
result tree might be used as a <A title="source tree" 
href="REC-xslt20-20070123.htm#dt-source-tree">source 
tree</A> for another XSLT transformation instead of being output. It is <A 
title=implementation-defined 
href="REC-xslt20-20070123.htm#dt-implementation-defined">implementation-defined</A> 
whether (and under what circumstances) disabling output escaping is 
supported.</P>
<P><A id=err-XTRE1620 name=err-XTRE1620><SPAN class=error>[ERR 
XTRE1620]</SPAN></A> It is a <A title="recoverable error" 
href="REC-xslt20-20070123.htm#dt-recoverable-error">recoverable 
dynamic error</A> if an <A 
href="REC-xslt20-20070123.htm#element-value-of"><CODE>xsl:value-of</CODE></A> 
or <A 
href="REC-xslt20-20070123.htm#element-text"><CODE>xsl:text</CODE></A> 
instruction specifies that output escaping is to be disabled and the 
implementation does not support this. The <A title="optional recovery action" 
href="REC-xslt20-20070123.htm#dt-optional-recovery-action">optional 
recovery action</A> is to ignore the <CODE>disable-output-escaping</CODE> 
attribute.</P>
<P><A id=err-XTRE1630 name=err-XTRE1630><SPAN class=error>[ERR 
XTRE1630]</SPAN></A> It is a <A title="recoverable error" 
href="REC-xslt20-20070123.htm#dt-recoverable-error">recoverable 
dynamic error</A> if an <A 
href="REC-xslt20-20070123.htm#element-value-of"><CODE>xsl:value-of</CODE></A> 
or <A 
href="REC-xslt20-20070123.htm#element-text"><CODE>xsl:text</CODE></A> 
instruction specifies that output escaping is to be disabled when writing to a 
<A title="final result tree" 
href="REC-xslt20-20070123.htm#dt-final-result-tree">final 
result tree</A> that is not being serialized. The <A 
title="optional recovery action" 
href="REC-xslt20-20070123.htm#dt-optional-recovery-action">optional 
recovery action</A> is to ignore the <CODE>disable-output-escaping</CODE> 
attribute.</P>
<P>If output escaping is disabled for a character that is not representable in 
the encoding that the <A title=processor 
href="REC-xslt20-20070123.htm#dt-processor">processor</A> 
is using for output, the request to disable output escaping is ignored in 
respect of that character.</P>
<P>Since disabling output escaping might not work with all implementations and 
can result in XML that is not well-formed, it <SPAN class=verb>should</SPAN> be 
used only when there is no alternative.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>The facility to define character maps for use during serialization, as 
described in <A 
href="REC-xslt20-20070123.htm#character-maps"><I>20.1 
Character Maps</I></A>, has been produced as an alternative mechanism that can 
be used in many situations where disabling of output escaping was previously 
necessary, without the same difficulties.</P></DIV></DIV></DIV>
<DIV class=div1>
<H2><A id=conformance name=conformance></A>21 Conformance</H2>
<P>A <A title=processor 
href="REC-xslt20-20070123.htm#dt-processor">processor</A> 
that claims conformance with this specification <SPAN class=verb>must</SPAN> 
claim conformance either as a <A title="basic XSLT processor" 
href="REC-xslt20-20070123.htm#dt-basic-xslt-processor">basic 
XSLT processor</A> or as a <A title="schema-aware XSLT processor" 
href="REC-xslt20-20070123.htm#dt-schema-aware-xslt-processor">schema-aware 
XSLT processor</A>. The rules for these two conformance levels are defined in 
the following sections.</P>
<P>A processor that claims conformance at either of these two levels <SPAN 
class=verb>may</SPAN> additionally claim conformance with either or both of the 
following optional features: the serialization feature, defined in <A 
href="REC-xslt20-20070123.htm#serialization-feature"><I>21.3 
Serialization Feature</I></A>, and the backwards compatibility feature, defined 
in <A 
href="REC-xslt20-20070123.htm#backwards-compatibility-feature"><I>21.4 
Backwards Compatibility Feature</I></A>.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>There is no conformance level or feature defined in this specification that 
requires implementation of the static typing features described in <A 
href="REC-xslt20-20070123.htm#xpath20">[XPath 2.0]</A>. 
An XSLT processor may provide a user option to invoke static typing, but to be 
conformant with this specification it must allow a stylesheet to be processed 
with static typing disabled. The interaction of XSLT stylesheets with the static 
typing feature of XPath 2.0 has not been specified, so the results of using 
static typing, if available, are implementation-defined.</P></DIV>
<P>An XSLT processor takes as its inputs a stylesheet and one or more <SPAN>XDM 
trees conforming to</SPAN> the data model defined in <A 
href="REC-xslt20-20070123.htm#xpath-datamodel">[Data 
Model]</A>. It is not <SPAN class=verb>required</SPAN> that the processor 
supports any particular method of constructing <SPAN>XDM trees</SPAN>, but 
conformance can only be tested if it provides a mechanism that enables <SPAN>XDM 
trees</SPAN> representing the stylesheet and primary source document to be 
constructed and supplied as input to the processor.</P>
<P>The output of the XSLT processor consists of <SPAN>zero</SPAN> or more <A 
title="final result tree" 
href="REC-xslt20-20070123.htm#dt-final-result-tree">final 
result trees</A>. It is not <SPAN class=verb>required</SPAN> that the processor 
supports any particular method of accessing a final result tree, but if it does 
not support the serialization module, conformance can only be tested if it 
provides some alternative mechanism that enables access to the results of the 
transformation.</P>
<P>Certain facilities in this specification are described as producing <A 
title=implementation-defined 
href="REC-xslt20-20070123.htm#dt-implementation-defined">implementation-defined</A> 
results. A claim that asserts conformance with this specification <SPAN 
class=verb>must</SPAN> be accompanied by documentation stating the effect of 
each implementation-defined feature. For convenience, a non-normative checklist 
of implementation-defined features is provided at <A 
href="REC-xslt20-20070123.htm#implementation-defined-features"><I>F 
Checklist of Implementation-Defined Features</I></A>.</P>
<P>A conforming <A title=processor 
href="REC-xslt20-20070123.htm#dt-processor">processor</A> 
<SPAN class=verb>must</SPAN> signal any <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A> occurring in the stylesheet, or in any XPath <A title=expression 
href="REC-xslt20-20070123.htm#dt-expression">expression</A>, 
except where specified otherwise either for individual error conditions or under 
the general provisions for <A title="forwards-compatible behavior" 
href="REC-xslt20-20070123.htm#dt-forwards-compatible-behavior">forwards 
compatible behavior</A> (see <A 
href="REC-xslt20-20070123.htm#forwards"><I>3.9 
Forwards-Compatible Processing</I></A>). After signaling such an error, the 
processor <SPAN class=verb>may</SPAN> continue for the purpose of signaling 
additional errors, but <SPAN class=verb>must</SPAN> terminate abnormally without 
performing any transformation.</P>
<P>When a <A title="dynamic error" 
href="REC-xslt20-20070123.htm#dt-dynamic-error">dynamic 
error</A> occurs during the course of a transformation, the action depends on 
whether the error is classified as a <A title="recoverable error" 
href="REC-xslt20-20070123.htm#dt-recoverable-error">recoverable 
error</A>. If a non-recoverable error occurs, the processor <SPAN 
class=verb>must</SPAN> signal it and <SPAN class=verb>must</SPAN> eventually 
terminate abnormally. If a recoverable error occurs, the processor <SPAN 
class=verb>must</SPAN> either signal it and terminate abnormally, or it <SPAN 
class=verb>must</SPAN> take the defined recovery action and continue 
processing.</P>
<P>Some errors, notably <A title="type errors" 
href="REC-xslt20-20070123.htm#dt-type-error">type 
errors</A>, <SPAN class=verb>may</SPAN> be treated as <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
errors</A> or <A title="dynamic error" 
href="REC-xslt20-20070123.htm#dt-dynamic-error">dynamic 
errors</A> at the discretion of the processor.</P>
<P>A conforming processor <SPAN class=verb>may</SPAN> impose limits on the 
processing resources consumed by the processing of a stylesheet.</P>
<DIV class=div2>
<H3><A id=basic-conformance name=basic-conformance></A>21.1 Basic XSLT 
Processor</H3>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A id=dt-basic-xslt-processor 
title="basic XSLT processor" name=dt-basic-xslt-processor></A>A <B>basic XSLT 
processor</B> is an XSLT processor that implements all the mandatory 
requirements of this specification with the exception of certain 
explicitly-identified constructs related to schema processing.<SPAN 
class=definition>]</SPAN> These constructs are listed below.</P>
<P>The mandatory requirements of this specification are taken to include the 
mandatory requirements of XPath 2.0, as described in <A 
href="REC-xslt20-20070123.htm#xpath20">[XPath 2.0]</A>. A 
requirement is mandatory unless the specification includes wording (such as the 
use of the words <SPAN class=verb>should</SPAN> or <SPAN class=verb>may</SPAN>) 
that clearly indicates that it is optional.</P>
<P>A <A title="basic XSLT processor" 
href="REC-xslt20-20070123.htm#dt-basic-xslt-processor">basic 
XSLT processor</A> <SPAN class=verb>must</SPAN> enforce the following 
restrictions. It <SPAN class=verb>must</SPAN> signal a static or dynamic error 
when the restriction is violated, as described below.</P>
<P><A id=err-XTSE1650 name=err-XTSE1650><SPAN class=error>[ERR 
XTSE1650]</SPAN></A> A <A title="basic XSLT processor" 
href="REC-xslt20-20070123.htm#dt-basic-xslt-processor">basic 
XSLT processor</A> <SPAN class=verb>must</SPAN> signal a <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A> if the <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
includes an <A 
href="REC-xslt20-20070123.htm#element-import-schema"><CODE>xsl:import-schema</CODE></A> 
declaration.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>A processor that rejects an <A 
href="REC-xslt20-20070123.htm#element-import-schema"><CODE>xsl:import-schema</CODE></A> 
declaration will also reject any reference to a user-defined type defined in a 
schema, or to a user-defined element or attribute declaration; it will not, 
however, reject references to the built-in types listed in <A 
href="REC-xslt20-20070123.htm#built-in-types"><I>3.13 
Built-in Types</I></A>.</P></DIV>
<P><A id=err-XTSE1660 name=err-XTSE1660><SPAN class=error>[ERR 
XTSE1660]</SPAN></A> A <A title="basic XSLT processor" 
href="REC-xslt20-20070123.htm#dt-basic-xslt-processor">basic 
XSLT processor</A> <SPAN class=verb>must</SPAN> signal a <A title="static error" 
href="REC-xslt20-20070123.htm#dt-static-error">static 
error</A> if the <A title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
includes an <CODE>[xsl:]type</CODE> attribute, or an 
<CODE>[xsl:]validation</CODE> or <CODE>default-validation</CODE> attribute with 
a value other than <CODE>strip</CODE>.</P>
<P>A <A title="basic XSLT processor" 
href="REC-xslt20-20070123.htm#dt-basic-xslt-processor">basic 
XSLT processor</A> constrains the data model as follows:</P>
<UL>
  <LI>
  <P>Atomic values <SPAN class=verb>must</SPAN> belong to one of the atomic 
  types listed in <A 
  href="REC-xslt20-20070123.htm#built-in-types"><I>3.13 
  Built-in Types</I></A> (except as noted below).</P>
  <P>An atomic value may also belong to an implementation-defined type that has 
  been added to the context for use with <A title="extension function" 
  href="REC-xslt20-20070123.htm#dt-extension-function">extension 
  functions</A> or <A title="extension instruction" 
  href="REC-xslt20-20070123.htm#dt-extension-instruction">extension 
  instructions</A>.</P>
  <P>The set of constructor functions available are limited to those that 
  construct values of the above atomic types.</P>
  <P>The static context, which defines the full set of type names recognized by 
  an XSLT processor and also by the XPath processor, includes these atomic 
  types, plus <CODE>xs:anyType</CODE>, <CODE>xs:anySimpleType</CODE>, 
  <SPAN><CODE>xs:untyped</CODE></SPAN>, and 
  <SPAN><CODE>xs:anyAtomicType</CODE></SPAN>.</P>
  <LI>
  <P>Element nodes <SPAN class=verb>must</SPAN> be annotated with the <A 
  title="type annotation" 
  href="REC-xslt20-20070123.htm#dt-annotation">type 
  annotation</A> <SPAN><CODE>xs:untyped</CODE></SPAN>, and attribute nodes with 
  the type annotation <CODE>xs:untypedAtomic</CODE>.</P></LI></UL>
<P><A id=err-XTDE1665 name=err-XTDE1665><SPAN class=error>[ERR 
XTDE1665]</SPAN></A> A <A title="basic XSLT processor" 
href="REC-xslt20-20070123.htm#dt-basic-xslt-processor">basic 
XSLT processor</A> <SPAN class=verb>must</SPAN> raise a <A 
title="non-recoverable dynamic error" 
href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
dynamic error</A> if the input to the processor includes a node with a <A 
title="type annotation" 
href="REC-xslt20-20070123.htm#dt-annotation">type 
annotation</A> other than <SPAN><CODE>xs:untyped</CODE></SPAN> or 
<SPAN><CODE>xs:untypedAtomic</CODE></SPAN>, or an atomic value of a type other 
than those which a basic XSLT processor supports. <SPAN>This error will not 
arise if the <CODE>input-type-annotations</CODE> attribute is set to 
<CODE>strip</CODE>.</SPAN></P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>Although this is expressed in terms of a requirement to detect invalid input, 
an alternative approach is for a basic XSLT processor to prevent this error 
condition occurring, by not providing any interfaces that would allow the 
situation to arise. A processor might, for example, implement a mapping from the 
PSVI to the data model that loses all non-trivial <A title="type annotation" 
href="REC-xslt20-20070123.htm#dt-annotation">type 
annotations</A>; or it might not accept input from a PSVI at all.</P>
<P>The phrase <EM>input to the processor</EM> is deliberately wide: it includes 
the tree containing the <A title="initial context node" 
href="REC-xslt20-20070123.htm#dt-initial-context-node">initial 
context node</A>, trees passed as <A title="stylesheet parameter" 
href="REC-xslt20-20070123.htm#dt-stylesheet-parameter">stylesheet 
parameters</A>, trees accessed using the <A 
href="REC-xslt20-20070123.htm#function-document"><CODE>document</CODE></A>, 
<A 
href="http://www.w3.org/TR/xpath-functions/#func-doc"><CODE>doc</CODE></A><SUP> 
<SMALL>FO</SMALL></SUP>, and <A 
href="http://www.w3.org/TR/xpath-functions/#func-collection"><CODE>collection</CODE></A><SUP><SMALL>FO</SMALL></SUP> 
functions, and trees returned by <A title="extension function" 
href="REC-xslt20-20070123.htm#dt-extension-function">extension 
functions</A> and <A title="extension instruction" 
href="REC-xslt20-20070123.htm#dt-extension-instruction">extension 
instructions</A>.</P></DIV></DIV>
<DIV class=div2>
<H3><A id=schema-aware-conformance name=schema-aware-conformance></A>21.2 
Schema-Aware XSLT Processor</H3>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A 
id=dt-schema-aware-xslt-processor title="schema-aware XSLT processor" 
name=dt-schema-aware-xslt-processor></A>A <B>schema-aware XSLT processor</B> is 
an XSLT processor that implements all the mandatory requirements of this 
specification, including those features that a <A title="basic XSLT processor" 
href="REC-xslt20-20070123.htm#dt-basic-xslt-processor">basic 
XSLT processor</A> signals as an error. The mandatory requirements of this 
specification are taken to include the mandatory requirements of XPath 2.0, as 
described in <A 
href="REC-xslt20-20070123.htm#xpath20">[XPath 2.0]</A>. A 
requirement is mandatory unless the specification includes wording (such as the 
use of the words <SPAN class=verb>should</SPAN> or <SPAN class=verb>may</SPAN>) 
that clearly indicates that it is optional.<SPAN 
class=definition>]</SPAN></P></DIV>
<DIV class=div2>
<H3><A id=serialization-feature name=serialization-feature></A>21.3 
Serialization Feature</H3>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A 
id=dt-serialization-feature title="serialization feature" 
name=dt-serialization-feature></A>A processor that claims conformance with the 
<B>serialization feature</B> <SPAN class=verb>must</SPAN> support the conversion 
of a <A title="final result tree" 
href="REC-xslt20-20070123.htm#dt-final-result-tree">final 
result tree</A> to a sequence of <SPAN>octets</SPAN> following the rules defined 
in <A href="REC-xslt20-20070123.htm#serialization"><I>20 
Serialization</I></A>.<SPAN class=definition>]</SPAN> It <SPAN 
class=verb>must</SPAN> respect all the attributes of the <A 
href="REC-xslt20-20070123.htm#element-output"><CODE>xsl:output</CODE></A> 
and <A 
href="REC-xslt20-20070123.htm#element-character-map"><CODE>xsl:character-map</CODE></A> 
declarations, and <SPAN class=verb>must</SPAN> provide all four output methods, 
<CODE>xml</CODE>, <CODE>xhtml</CODE>, <CODE>html</CODE>, and <CODE>text</CODE>. 
Where the specification uses words such as <SPAN class=verb>must</SPAN> and 
<SPAN class=verb>required</SPAN>, then it <SPAN class=verb>must</SPAN> serialize 
the result tree in precisely the way described; in other cases it <SPAN 
class=verb>may</SPAN> use an alternative, equivalent representation.</P>
<P>A processor may claim conformance with the serialization feature whether or 
not it supports the setting <CODE>disable-output-escaping="yes"</CODE> on <A 
href="REC-xslt20-20070123.htm#element-text"><CODE>xsl:text</CODE></A>, 
or <A 
href="REC-xslt20-20070123.htm#element-value-of"><CODE>xsl:value-of</CODE></A>.</P>
<P>A processor that does not claim conformance with the serialization feature 
<SPAN class=verb>must not</SPAN> signal an error merely because the <A 
title=stylesheet 
href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
contains <A 
href="REC-xslt20-20070123.htm#element-output"><CODE>xsl:output</CODE></A> 
or <A 
href="REC-xslt20-20070123.htm#element-character-map"><CODE>xsl:character-map</CODE></A> 
declarations, <SPAN>or serialization attributes on the <A 
href="REC-xslt20-20070123.htm#element-result-document"><CODE>xsl:result-document</CODE></A> 
instruction. Such a processor <SPAN class=verb>may</SPAN> check that these 
declarations and attributes have valid values, but is not <SPAN 
class=verb>required</SPAN> to do so. Apart from optional validation,</SPAN> 
these declarations <SPAN class=verb>should</SPAN> be ignored.</P></DIV>
<DIV class=div2>
<H3><A id=backwards-compatibility-feature 
name=backwards-compatibility-feature></A>21.4 Backwards Compatibility 
Feature</H3>
<P><SPAN class=definition>[Definition:&nbsp;</SPAN><A 
id=dt-backwards-compatibility-feature title="backwards compatibility feature" 
name=dt-backwards-compatibility-feature></A>A processor that claims conformance 
with the <B>backwards compatibility feature</B> <SPAN class=verb>must</SPAN> 
support the processing of stylesheet instructions and XPath expressions with <A 
title="backwards compatible behavior" 
href="REC-xslt20-20070123.htm#dt-backwards-compatible-behavior">backwards 
compatible behavior</A>, as defined in <A 
href="REC-xslt20-20070123.htm#backwards"><I>3.8 
Backwards-Compatible Processing</I></A>.<SPAN class=definition>]</SPAN></P>
<P>Note that a processor that does not claim conformance with the backwards 
compatibility feature <SPAN class=verb>must</SPAN> raise a <A 
title="non-recoverable dynamic error" 
href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
dynamic error</A> if an instruction is evaluated containing an 
<CODE>[xsl:]version</CODE> attribute that invokes backwards compatible behavior 
<SPAN class=error>[see <A 
href="REC-xslt20-20070123.htm#err-XTDE0160">ERR 
XTDE0160</A>]</SPAN>.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>The reason this is a dynamic error rather than a static error is to allow 
stylesheets to contain conditional logic, following different paths depending on 
whether the XSLT processor implements XSLT 1.0 or XSLT 2.0. The selection of 
which path to use can be controlled by using the <A 
href="REC-xslt20-20070123.htm#function-system-property"><CODE>system-property</CODE></A> 
function to test the <CODE>xsl:version</CODE> system property.</P></DIV>
<P>A processor that claims conformance with the backwards compatibility feature 
<SPAN class=verb>must</SPAN> permit the use of the namespace axis in XPath 
expressions when backwards compatible behavior is enabled. In all other 
circumstances, support for the namespace axis is optional.</P></DIV></DIV></DIV>
<DIV class=back>
<DIV class=div1>
<H2><A id=references name=references></A>A References</H2>
<DIV class=div2>
<H3><A id=normative-references name=normative-references></A>A.1 Normative 
References</H3>
<DL>
  <DT class=label><SPAN><A id=xpath-datamodel name=xpath-datamodel></A>Data 
  Model</SPAN> 
  <DD>
  <DIV><A href="http://www.w3.org/TR/xpath-datamodel/"><CITE>XQuery 1.0 and 
  XPath 2.0 Data Model (XDM)</CITE></A>, Norman Walsh, Mary Fernández, Ashok 
  Malhotra, <EM>et. al.</EM>, Editors. World Wide Web Consortium, 23 Jan 2007. 
  This version is REC-xpath-datamodel-20070123.htm. The 
  <A href="http://www.w3.org/TR/xpath-datamodel/">latest version</A> is 
  available at http://www.w3.org/TR/xpath-datamodel/. </DIV>
  <DT class=label><SPAN><A id=xpath-functions name=xpath-functions></A>Functions 
  and Operators</SPAN> 
  <DD>
  <DIV><A href="http://www.w3.org/TR/xpath-functions/"><CITE>XQuery 1.0 and 
  XPath 2.0 Functions and Operators</CITE></A>, Ashok Malhotra, Jim Melton, and 
  Norman Walsh, Editors. World Wide Web Consortium, 23 Jan 2007. This version is 
  REC-xpath-functions-20070123.htm. The <A 
  href="http://www.w3.org/TR/xpath-functions/">latest version</A> is available 
  at http://www.w3.org/TR/xpath-functions/. </DIV>
  <DT class=label><SPAN><A id=xml-infoset name=xml-infoset></A>XML Information 
  Set</SPAN> 
  <DD>
  <DIV><A href="http://www.w3.org/TR/xml-infoset"><CITE>XML Information Set 
  (Second Edition)</CITE></A>, John Cowan and Richard Tobin, Editors. World Wide 
  Web Consortium, 04&nbsp;Feb&nbsp;2004. This version is 
  http://www.w3.org/TR/2004/REC-xml-infoset-20040204. The <A 
  href="http://www.w3.org/TR/xml-infoset">latest version</A> is available at 
  http://www.w3.org/TR/xml-infoset. </DIV>
  <DT class=label><SPAN><A id=ISO3166 name=ISO3166></A>ISO 3166-1</SPAN> 
  <DD>
  <DIV>ISO (International Organization for Standardization) <EM>Codes for the 
  representation of names of countries and their subdivisions - Part 1: Country 
  codes</EM> ISO 3166-1:1997. </DIV>
  <DT class=label><SPAN><A id=ISO8601 name=ISO8601></A>ISO 8601</SPAN> 
  <DD>
  <DIV>ISO (International Organization for Standardization) <EM>Data elements 
  and interchange formats - Information interchange - Representation of dates 
  and times.</EM> ISO 8601:2000(E), Second edition, 2000-12-15. </DIV>
  <DT class=label><SPAN><A id=xslt-xquery-serialization 
  name=xslt-xquery-serialization></A>XSLT and XQuery Serialization</SPAN> 
  <DD>
  <DIV><A href="http://www.w3.org/TR/xslt-xquery-serialization/"><CITE>XSLT 2.0 
  and XQuery 1.0 Serialization</CITE></A>, Joanne Tong, Michael Kay, Norman 
  Walsh, <EM>et. al.</EM>, Editors. World Wide Web Consortium, 23 Jan 2007. This 
  version is REC-xslt-xquery-serialization-20070123.htm. 
  The <A href="http://www.w3.org/TR/xslt-xquery-serialization/">latest 
  version</A> is available at http://www.w3.org/TR/xslt-xquery-serialization/. 
  </DIV>
  <DT class=label><SPAN><A id=REC-xml name=REC-xml></A>XML 1.0</SPAN> 
  <DD>
  <DIV><A href="http://www.w3.org/TR/xml"><CITE>Extensible Markup Language (XML) 
  1.0 (Fourth Edition)</CITE></A>, Eve Maler, Jean Paoli, François Yergeau, 
  <EM>et. al.</EM>, Editors. World Wide Web Consortium, 16&nbsp;Aug&nbsp;2006. 
  This version is http://www.w3.org/TR/2006/REC-xml-20060816. The <A 
  href="http://www.w3.org/TR/xml">latest version</A> is available at 
  http://www.w3.org/TR/xml. </DIV>
  <DT class=label><SPAN><A id=xml11 name=xml11></A>XML 1.1</SPAN> 
  <DD>
  <DIV><A href="http://www.w3.org/TR/xml11/"><CITE>Extensible Markup Language 
  (XML) 1.1 (Second Edition)</CITE></A>, Tim Bray, John Cowan, Jean Paoli, 
  <EM>et. al.</EM>, Editors. World Wide Web Consortium, 16&nbsp;Aug&nbsp;2006. 
  This version is http://www.w3.org/TR/2006/REC-xml11-20060816. The <A 
  href="http://www.w3.org/TR/xml11/">latest version</A> is available at 
  http://www.w3.org/TR/xml11/. </DIV>
  <DT class=label><SPAN><A id=xmlbase name=xmlbase></A>XML Base</SPAN> 
  <DD>
  <DIV><A href="http://www.w3.org/TR/xmlbase/"><CITE>XML Base</CITE></A>, 
  Jonathan Marsh, Editor. World Wide Web Consortium, 27&nbsp;Jun&nbsp;2001. This 
  version is http://www.w3.org/TR/2001/REC-xmlbase-20010627/. The <A 
  href="http://www.w3.org/TR/xmlbase/">latest version</A> is available at 
  http://www.w3.org/TR/xmlbase/. </DIV>
  <DT class=label><SPAN><A id=xml-id name=xml-id></A>xml:id</SPAN> 
  <DD>
  <DIV><A href="http://www.w3.org/TR/xml-id/"><CITE>xml:id Version 
  1.0</CITE></A>, Norman Walsh, Daniel Veillard, and Jonathan Marsh, Editors. 
  World Wide Web Consortium, 09&nbsp;Sep&nbsp;2005. This version is 
  http://www.w3.org/TR/2005/REC-xml-id-20050909/. The <A 
  href="http://www.w3.org/TR/xml-id/">latest version</A> is available at 
  http://www.w3.org/TR/xml-id/. </DIV>
  <DT class=label><SPAN><A id=REC-xml-names name=REC-xml-names></A>Namespaces in 
  XML 1.0</SPAN> 
  <DD>
  <DIV><A href="http://www.w3.org/TR/REC-xml-names"><CITE>Namespaces in 
  XML</CITE></A>, Andrew Layman, Dave Hollander, and Tim Bray, Editors. World 
  Wide Web Consortium, 14&nbsp;Jan&nbsp;1999. This version is 
  http://www.w3.org/TR/1999/REC-xml-names-19990114. The <A 
  href="http://www.w3.org/TR/REC-xml-names">latest version</A> is available at 
  http://www.w3.org/TR/REC-xml-names. </DIV>
  <DT class=label><SPAN><A id=xml-names11 name=xml-names11></A>Namespaces in XML 
  1.1</SPAN> 
  <DD>
  <DIV><A href="http://www.w3.org/TR/xml-names11/"><CITE>Namespaces in XML 1.1 
  (Second Edition)</CITE></A>, Tim Bray, Dave Hollander, Andrew Layman, and 
  Richard Tobin, Editors. World Wide Web Consortium, 16&nbsp;Aug&nbsp;2006. This 
  version is http://www.w3.org/TR/2006/REC-xml-names11-20060816. The <A 
  href="http://www.w3.org/TR/xml-names11/">latest version</A> is available at 
  http://www.w3.org/TR/xml-names11/. </DIV>
  <DT class=label><SPAN><A id=xmlschema-1 name=xmlschema-1></A>XML Schema Part 
  1</SPAN> 
  <DD>
  <DIV><A href="http://www.w3.org/TR/xmlschema-1/"><CITE>XML Schema Part 1: 
  Structures Second Edition</CITE></A>, Henry S. Thompson, David Beech, Noah 
  Mendelsohn, and Murray Maloney, Editors. World Wide Web Consortium, 
  28&nbsp;Oct&nbsp;2004. This version is 
  http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/. The <A 
  href="http://www.w3.org/TR/xmlschema-1/">latest version</A> is available at 
  http://www.w3.org/TR/xmlschema-1/. </DIV>
  <DT class=label><SPAN><A id=xmlschema-2 name=xmlschema-2></A>XML Schema Part 
  2</SPAN> 
  <DD>
  <DIV><A href="http://www.w3.org/TR/xmlschema-2/"><CITE>XML Schema Part 2: 
  Datatypes Second Edition</CITE></A>, Paul V. Biron and Ashok Malhotra, 
  Editors. World Wide Web Consortium, 28&nbsp;Oct&nbsp;2004. This version is 
  http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/. The <A 
  href="http://www.w3.org/TR/xmlschema-2/">latest version</A> is available at 
  http://www.w3.org/TR/xmlschema-2/. </DIV>
  <DT class=label><SPAN><A id=xpath20 name=xpath20></A>XPath 2.0</SPAN> 
  <DD>
  <DIV><A href="http://www.w3.org/TR/xpath20/"><CITE>XML Path Language (XPath) 
  2.0</CITE></A>, Don Chamberlin , Anders Berglund, Scott Boag, <EM>et. 
  al.</EM>, Editors. World Wide Web Consortium, 23 Jan 2007. This version is 
  REC-xpath20-20070123.htm. The <A 
  href="http://www.w3.org/TR/xpath20/">latest version</A> is available at 
  http://www.w3.org/TR/xpath20/. </DIV></DD></DL></DIV>
<DIV class=div2>
<H3><A id=other-references name=other-references></A>A.2 Other References</H3>
<DL>
  <DT class=label><SPAN><A id=CALCALC name=CALCALC></A>Calendrical 
  Calculations</SPAN> 
  <DD>
  <DIV>Edward M. Reingold and Nachum Dershowitz. <EM>Calendrical Calculations 
  Millennium edition (2nd Edition)</EM>. Cambridge University Press, ISBN 0 521 
  77752 6 </DIV>
  <DT class=label><SPAN><A id=DOM-Level-2-Core name=DOM-Level-2-Core></A>DOM 
  Level 2</SPAN> 
  <DD>
  <DIV><A href="http://www.w3.org/TR/DOM-Level-2-Core/"><CITE>Document Object 
  Model (DOM) Level 2 Core Specification</CITE></A>, Philippe Le Hégaret, Steve 
  Byrne, Arnaud Le Hors, <EM>et. al.</EM>, Editors. World Wide Web Consortium, 
  13&nbsp;Nov&nbsp;2000. This version is 
  http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113. The <A 
  href="http://www.w3.org/TR/DOM-Level-2-Core/">latest version</A> is available 
  at http://www.w3.org/TR/DOM-Level-2-Core/. </DIV>
  <DT class=label><SPAN><A id=RFC2119 name=RFC2119></A>RFC2119</SPAN> 
  <DD>
  <DIV>S. Bradner. <EM>Key words for use in RFCs to Indicate Requirement 
  Levels</EM>. IETF RFC 2119. See <A 
  href="http://www.ietf.org/rfc/rfc2119.txt">http://www.ietf.org/rfc/rfc2119.txt</A>. 
  </DIV>
  <DT class=label><SPAN><A id=RFC2376 name=RFC2376></A>RFC2376</SPAN> 
  <DD>
  <DIV>E. Whitehead, M. Murata. <EM>XML Media Types</EM>. IETF RFC 2376. See <A 
  href="http://www.ietf.org/rfc/rfc2376.txt">http://www.ietf.org/rfc/rfc2376.txt</A>. 
  </DIV>
  <DT class=label><SPAN><A id=RFC3023 name=RFC3023></A>RFC3023</SPAN> 
  <DD>
  <DIV>M. Murata, S. St.Laurent, and D. Cohn. <EM>XML Media Types</EM>. IETF RFC 
  3023. See <A 
  href="http://www.ietf.org/rfc/rfc3023.txt">http://www.ietf.org/rfc/rfc3023.txt</A>. 
  <SPAN>References to RFC 3023 should be taken to refer to any document that 
  supersedes RFC 3023.</SPAN> </DIV>
  <DT class=label><SPAN><A id=RFC3986 name=RFC3986></A>RFC3986</SPAN> 
  <DD>
  <DIV>T. Berners-Lee, R. Fielding, and L. Masinter. <EM>Uniform Resource 
  Identifiers (URI): Generic Syntax</EM>. IETF RFC 3986. See <A 
  href="http://www.ietf.org/rfc/rfc3986.txt">http://www.ietf.org/rfc/rfc3986.txt</A>. 
  </DIV>
  <DT class=label><SPAN><A id=RFC3987 name=RFC3987></A>RFC3987</SPAN> 
  <DD>
  <DIV>M. Duerst, M. Suignard. <EM>Internationalized Resource Identifiers 
  (IRIs)</EM>. IETF RFC 3987. See <A 
  href="http://www.ietf.org/rfc/rfc3987.txt">http://www.ietf.org/rfc/rfc3987.txt</A>. 
  </DIV>
  <DT class=label><SPAN><A id=UNICODE-TR10 name=UNICODE-TR10></A>UNICODE 
  TR10</SPAN> 
  <DD>
  <DIV>Unicode Consortium. <EM>Unicode Technical Standard #10. Unicode Collation 
  Algorithm</EM>. Unicode Technical Report. See <A 
  href="http://www.unicode.org/unicode/reports/tr10/">http://www.unicode.org/unicode/reports/tr10/</A>. 
  </DIV>
  <DT class=label><SPAN><A id=xinclude name=xinclude></A>XInclude</SPAN> 
  <DD>
  <DIV><A href="http://www.w3.org/TR/xinclude/"><CITE>XML Inclusions (XInclude) 
  Version 1.0 (Second Edition)</CITE></A>, David Orchard, Jonathan Marsh, and 
  Daniel Veillard, Editors. World Wide Web Consortium, 15&nbsp;Nov&nbsp;2006. 
  This version is http://www.w3.org/TR/2006/REC-xinclude-20061115/. The <A 
  href="http://www.w3.org/TR/xinclude/">latest version</A> is available at 
  http://www.w3.org/TR/xinclude/. </DIV>
  <DT class=label><SPAN><A id=xlink name=xlink></A>XLink</SPAN> 
  <DD>
  <DIV><A href="http://www.w3.org/TR/xlink/"><CITE>XML Linking Language (XLink) 
  Version 1.0</CITE></A>, David Orchard, Eve Maler, and Steven DeRose, Editors. 
  World Wide Web Consortium, 27&nbsp;Jun&nbsp;2001. This version is 
  http://www.w3.org/TR/2001/REC-xlink-20010627/. The <A 
  href="http://www.w3.org/TR/xlink/">latest version</A> is available at 
  http://www.w3.org/TR/xlink/. </DIV>
  <DT class=label><SPAN><A id=SCHEMA-AND-XML-1.1 name=SCHEMA-AND-XML-1.1></A>XML 
  Schema 1.0 and XML 1.1</SPAN> 
  <DD>
  <DIV>World Wide Web Consortium. <EM>Processing XML 1.1 documents with XML 
  Schema 1.0 processors</EM>. W3C Working Group Note 11 May 2005. See <A 
  href="http://www.w3.org/TR/2005/NOTE-xml11schema10-20050511/">http://www.w3.org/TR/2005/NOTE-xml11schema10-20050511/</A> 
  </DIV>
  <DT class=label><SPAN><A id=xml-stylesheet name=xml-stylesheet></A>XML 
  Stylesheet</SPAN> 
  <DD>
  <DIV><A href="http://www.w3.org/TR/xml-stylesheet"><CITE>Associating Style 
  Sheets with XML documents</CITE></A>, James Clark, Editor. World Wide Web 
  Consortium, 29&nbsp;Jun&nbsp;1999. This version is 
  http://www.w3.org/1999/06/REC-xml-stylesheet-19990629. The <A 
  href="http://www.w3.org/TR/xml-stylesheet">latest version</A> is available at 
  http://www.w3.org/TR/xml-stylesheet. </DIV>
  <DT class=label><SPAN><A id=xptr-framework name=xptr-framework></A>XPointer 
  Framework</SPAN> 
  <DD>
  <DIV><A href="http://www.w3.org/TR/xptr-framework/"><CITE>XPointer 
  Framework</CITE></A>, Paul Grosso, Jonathan Marsh, Eve Maler, and Norman 
  Walsh, Editors. World Wide Web Consortium, 25&nbsp;Mar&nbsp;2003. This version 
  is http://www.w3.org/TR/2003/REC-xptr-framework-20030325/. The <A 
  href="http://www.w3.org/TR/xptr-framework/">latest version</A> is available at 
  http://www.w3.org/TR/xptr-framework/. </DIV>
  <DT class=label><SPAN><A id=xsl name=xsl></A>Extensible Stylesheet Language 
  (XSL)</SPAN> 
  <DD>
  <DIV><A href="http://www.w3.org/TR/xsl/"><CITE>Extensible Stylesheet Language 
  (XSL) Version 1.1</CITE></A>, Anders Berglund, Editor. World Wide Web 
  Consortium, 05&nbsp;Dec&nbsp;2006. This version is 
  http://www.w3.org/TR/2006/REC-xsl11-20061205/. The <A 
  href="http://www.w3.org/TR/xsl/">latest version</A> is available at 
  http://www.w3.org/TR/xsl/. </DIV>
  <DT class=label><SPAN><A id=xslt name=xslt></A>XSLT 1.0</SPAN> 
  <DD>
  <DIV><A href="http://www.w3.org/TR/xslt"><CITE>XSL Transformations (XSLT) 
  Version 1.0</CITE></A>, James Clark, Editor. World Wide Web Consortium, 
  16&nbsp;Nov&nbsp;1999. This version is 
  http://www.w3.org/TR/1999/REC-xslt-19991116. The <A 
  href="http://www.w3.org/TR/xslt">latest version</A> is available at 
  http://www.w3.org/TR/xslt. </DIV>
  <DT class=label><SPAN><A id=xslt20req name=xslt20req></A>XSLT 2.0 
  Requirements</SPAN> 
  <DD>
  <DIV><A href="http://www.w3.org/TR/xslt20req"><CITE>XSLT Requirements Version 
  2.0</CITE></A>, Steve Muench and Mark Scardina, Editors. World Wide Web 
  Consortium, 14&nbsp;Feb&nbsp;2001. This version is 
  http://www.w3.org/TR/2001/WD-xslt20req-20010214. The <A 
  href="http://www.w3.org/TR/xslt20req">latest version</A> is available at 
  http://www.w3.org/TR/xslt20req. </DIV></DD></DL></DIV></DIV>
<DIV class=div1>
<H2><A id=xslt-mime-definition name=xslt-mime-definition></A>B The XSLT Media 
Type</H2>
<P>This appendix registers a new MIME media type, 
"<CODE>application/xslt+xml</CODE>".</P>
<P>This information is being submitted to the IESG (Internet Engineering 
Steering Group) for review, approval, and registration with IANA (the Internet 
Assigned Numbers Authority).</P>
<DIV class=div2>
<H3><A id=media-type-registration name=media-type-registration></A>B.1 
Registration of MIME Media Type application/xslt+xml</H3>
<DL>
  <DT class=label>MIME media type name: 
  <DD>
  <P><CODE>application</CODE></P>
  <DT class=label>MIME subtype name: 
  <DD>
  <P><CODE>xslt+xml</CODE></P>
  <DT class=label>Required parameters: 
  <DD>
  <P>None.</P>
  <DT class=label>Optional parameters: 
  <DD>
  <DL>
    <DT class=label><CODE>charset</CODE> 
    <DD>
    <P>This parameter has identical semantics to the <CODE>charset</CODE> 
    parameter of the <CODE>application/xml</CODE> media type as specified in <A 
    href="REC-xslt20-20070123.htm#RFC3023">[RFC3023]</A>.</P></DD></DL>
  <DT class=label>Encoding considerations: 
  <DD>
  <P>By virtue of XSLT content being XML, it has the same considerations when 
  sent as "<CODE>application/xslt+xml</CODE>" as does XML. See RFC 3023, section 
  3.2.</P>
  <DT class=label>Security considerations: 
  <DD>
  <P>Several XSLT instructions may cause arbitrary URIs to be dereferenced. In 
  this case, the security issues of <SPAN><A 
  href="REC-xslt20-20070123.htm#RFC3986">[RFC3986]</A>, 
  section 7,</SPAN> should be considered.</P>
  <P>In addition, because of the extensibility features for XSLT, it is possible 
  that "<CODE>application/xslt+xml</CODE>" may describe content that has 
  security implications beyond those described here. However, if the processor 
  follows only the normative semantics of this specification, this content will 
  be ignored. Only in the case where the processor recognizes and processes the 
  additional content, or where further processing of that content is dispatched 
  to other processors, would security issues potentially arise. And in that 
  case, they would fall outside the domain of this registration document.</P>
  <DT class=label>Interoperability considerations: 
  <DD>
  <P>This specification describes processing semantics that dictate behavior 
  that must be followed when dealing with, among other things, unrecognized 
  elements.</P>
  <P>Because XSLT is extensible, conformant "<CODE>application/xslt+xml</CODE>" 
  processors can expect that content received is well-formed XML, but it cannot 
  be guaranteed that the content is valid XSLT or that the processor will 
  recognize all of the elements and attributes in the document.</P>
  <DT class=label>Published specification: 
  <DD>
  <P>This media type registration is for XSLT stylesheet modules as described by 
  the XSLT 2.0 specification, <SPAN>which is located at <A 
  href="http://www.w3.org/TR/xslt20/">http://www.w3.org/TR/xslt20/</A>.</SPAN> 
  It is also appropriate to use this media type with earlier and later versions 
  of the XSLT language.</P>
  <DT class=label>Applications which use this media type: 
  <DD>
  <P>Existing XSLT 1.0 stylesheets are most often described using the 
  unregistered media type "<CODE>text/xsl</CODE>".</P>
  <P>There is no experimental, vendor specific, or personal tree predecessor to 
  "<CODE>application/xslt+xml</CODE>", reflecting the fact that no applications 
  currently recognize it. This new type is being registered in order to allow 
  for the expected deployment of XSLT 2.0 on the World Wide Web, as a first 
  class XML application.</P>
  <DT class=label>Additional information: 
  <DD>
  <DL>
    <DT class=label>Magic number(s): 
    <DD>
    <P>There is no single initial octet sequence that is always present in XSLT 
    documents.</P>
    <DT class=label>File extension(s): 
    <DD>
    <P>XSLT documents are most often identified with the extensions 
    "<CODE>.xsl</CODE>" or "<CODE>.xslt</CODE>".</P>
    <DT class=label>Macintosh File Type Code(s): 
    <DD>
    <P>TEXT</P></DD></DL>
  <DT class=label>Person &amp; email address to contact for further information: 

  <DD>
  <P>Norman Walsh, <CODE>&lt;<A 
  href="mailto:Norman.Walsh@Sun.COM">Norman.Walsh@Sun.COM</A>&gt;</CODE>.</P>
  <DT class=label>Intended usage: 
  <DD>
  <P>COMMON</P>
  <DT class=label>Author/Change controller: 
  <DD>
  <P>The XSLT specification is a work product of the World Wide Web Consortium's 
  XSL Working Group. The W3C has change control over these 
  specifications.</P></DD></DL></DIV>
<DIV class=div2>
<H3><A id=media-type-fragid name=media-type-fragid></A>B.2 Fragment 
Identifiers</H3>
<P>For documents labeled as "<CODE>application/xslt+xml</CODE>", the fragment 
identifier notation is exactly that for "<CODE>application/xml</CODE>", as 
specified in RFC 3023.</P></DIV></DIV>
<DIV class=div1>
<H2><A id=glossary name=glossary></A>C Glossary (Non-Normative)</H2>
<DL>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-qname">QName</A> 
  <DD>
  <P>A <B>QName</B> is always written in the form <CODE>(NCName ":")? 
  NCName</CODE>, that is, a local name optionally preceded by a namespace 
  prefix. When two QNames are compared, however, they are considered equal if 
  the corresponding <A title=expanded-QName 
  href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded-QNames</A> 
  are the same, as described below.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-uri-reference">URI 
  Reference</A> 
  <DD>
  <P>Within this specification, the term <B>URI Reference</B>, unless otherwise 
  stated, refers to a string in the lexical space of the <CODE>xs:anyURI</CODE> 
  data type as defined in <A 
  href="REC-xslt20-20070123.htm#xmlschema-2">[XML Schema 
  Part 2]</A>.</P>
  <DT><A href="REC-xslt20-20070123.htm#xml-namespace">XML 
  namespace</A> 
  <DD>
  <P>The <B>XML namespace</B>, <SPAN>defined in <A 
  href="REC-xslt20-20070123.htm#REC-xml-names">[Namespaces 
  in XML 1.0]</A> as <CODE>http://www.w3.org/XML/1998/namespace</CODE></SPAN>, 
  is used for attributes such as <CODE>xml:lang</CODE>, <CODE>xml:space</CODE>, 
  and <CODE>xml:id</CODE>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-compatibility-mode">XPath 
  1.0 compatibility mode</A> 
  <DD>
  <P>The term <B>XPath 1.0 compatibility mode</B> is defined in <A 
  href="http://www.w3.org/TR/xpath20/#static_context">Section 2.1.1 Static 
  Context</A><SUP><SMALL>XP</SMALL></SUP>. This is a setting in the static 
  context of an XPath expression; it has two values, <CODE>true</CODE> and 
  <CODE>false</CODE>. When the value is set to true, the semantics of function 
  calls and certain other operations are adjusted to give a greater degree of 
  backwards compatibility between XPath 2.0 and XPath 1.0.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-xslt-element">XSLT 
  element</A> 
  <DD>
  <P>An <B>XSLT element</B> is an element in the <A title="XSLT namespace" 
  href="REC-xslt20-20070123.htm#dt-xslt-namespace">XSLT 
  namespace</A> whose syntax and semantics are defined in this 
specification.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-xslt-instruction">XSLT 
  instruction</A> 
  <DD>
  <P>An <B>XSLT instruction</B> is an <A title="XSLT element" 
  href="REC-xslt20-20070123.htm#dt-xslt-element">XSLT 
  element</A> whose syntax summary in this specification contains the annotation 
  <CODE>&lt;!-- category: instruction --&gt;</CODE>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-xslt-namespace">XSLT 
  namespace</A> 
  <DD>
  <P>The <B>XSLT namespace</B> has the URI 
  <CODE>http://www.w3.org/1999/XSL/Transform</CODE>. It is used to identify 
  elements, attributes, and other names that have a special meaning defined in 
  this specification.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-alias">alias</A> 
  <DD>
  <P>A stylesheet can use the <A 
  href="REC-xslt20-20070123.htm#element-namespace-alias"><CODE>xsl:namespace-alias</CODE></A> 
  element to declare that a <A title="literal namespace URI" 
  href="REC-xslt20-20070123.htm#dt-literal-namespace-uri">literal 
  namespace URI</A> is being used as an <B>alias</B> for a <A 
  title="target namespace URI" 
  href="REC-xslt20-20070123.htm#dt-target-namespace-uri">target 
  namespace URI</A>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-arity">arity</A> 
  <DD>
  <P>The <B>arity</B> of a stylesheet function is the number of <A 
  href="REC-xslt20-20070123.htm#element-param"><CODE>xsl:param</CODE></A> 
  elements in the function definition.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-atomization">atomize</A> 

  <DD>
  <P>The term <B>atomization</B> is defined in <A 
  href="http://www.w3.org/TR/xpath20/#id-atomization">Section 2.4.2 
  Atomization</A><SUP><SMALL>XP</SMALL></SUP>. It is a process that takes as 
  input a sequence of nodes and atomic values, and returns a sequence of atomic 
  values, in which the nodes are replaced by their typed values as defined in <A 
  href="REC-xslt20-20070123.htm#xpath-datamodel">[Data 
  Model]</A>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-attribute-set">attribute 
  set</A> 
  <DD>
  <P>The <A 
  href="REC-xslt20-20070123.htm#element-attribute-set"><CODE>xsl:attribute-set</CODE></A> 
  element defines a named <B>attribute set</B>: that is, a collection of 
  attribute <SPAN>definitions</SPAN> that can be used repeatedly on different 
  constructed elements.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-attribute-value-template">attribute 
  value template</A> 
  <DD>
  <P>In an attribute that is designated as an <B>attribute value template</B>, 
  such as an attribute of a <A title="literal result element" 
  href="REC-xslt20-20070123.htm#dt-literal-result-element">literal 
  result element</A>, an <A title=expression 
  href="REC-xslt20-20070123.htm#dt-expression">expression</A> 
  can be used by surrounding the expression with curly brackets 
  (<CODE>{}</CODE>)</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-backwards-compatibility-feature">backwards 
  compatibility feature</A> 
  <DD>
  <P>A processor that claims conformance with the <B>backwards compatibility 
  feature</B> <SPAN class=verb>must</SPAN> support the processing of stylesheet 
  instructions and XPath expressions with <A 
  title="backwards compatible behavior" 
  href="REC-xslt20-20070123.htm#dt-backwards-compatible-behavior">backwards 
  compatible behavior</A>, as defined in <A 
  href="REC-xslt20-20070123.htm#backwards"><I>3.8 
  Backwards-Compatible Processing</I></A>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-backwards-compatible-behavior">backwards 
  compatible behavior</A> 
  <DD>
  <P>An element enables backwards-compatible behavior for itself, its 
  attributes, its descendants and their attributes if it has an 
  <CODE>[xsl:]version</CODE> attribute (see <A 
  href="REC-xslt20-20070123.htm#standard-attributes"><I>3.5 
  Standard Attributes</I></A>) whose value is less than <CODE>2.0</CODE>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-base-output-uri">base 
  output URI</A> 
  <DD>
  <P>The <B>base output URI</B> is a URI to be used as the base URI when 
  resolving a relative URI allocated to a <A title="final result tree" 
  href="REC-xslt20-20070123.htm#dt-final-result-tree">final 
  result tree</A>. If the transformation generates more than one final result 
  tree, then typically each one will be allocated a URI relative to this base 
  URI.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-basic-xslt-processor">basic 
  XSLT processor</A> 
  <DD>
  <P>A <B>basic XSLT processor</B> is an XSLT processor that implements all the 
  mandatory requirements of this specification with the exception of certain 
  explicitly-identified constructs related to schema processing.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-character-map">character 
  map</A> 
  <DD>
  <P>A <B>character map</B> allows a specific character appearing in a text or 
  attribute node in the <A title="final result tree" 
  href="REC-xslt20-20070123.htm#dt-final-result-tree">final 
  result tree</A> to be substituted by a specified string of characters during 
  serialization.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-circularity">circularity</A> 

  <DD>
  <P>A <B>circularity</B> is said to exist if a construct such as a <A 
  title="global variable" 
  href="REC-xslt20-20070123.htm#dt-global-variable">global 
  variable</A>, an <A title="attribute set" 
  href="REC-xslt20-20070123.htm#dt-attribute-set">attribute 
  set</A>, or a <A title=key 
  href="REC-xslt20-20070123.htm#dt-key">key</A> is 
  defined in terms of itself. For example, if the <A title=expression 
  href="REC-xslt20-20070123.htm#dt-expression">expression</A> 
  or <A title="sequence constructor" 
  href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
  constructor</A> specifying the value of a <A title="global variable" 
  href="REC-xslt20-20070123.htm#dt-global-variable">global 
  variable</A> <VAR>X</VAR> references a global variable <VAR>Y</VAR>, then the 
  value for <VAR>Y</VAR> <SPAN class=verb>must</SPAN> be computed before the 
  value of <VAR>X</VAR>. A circularity exists if it is impossible to do this for 
  all global variable definitions.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-collation">collation</A> 

  <DD>
  <P>Facilities in XSLT 2.0 and XPath 2.0 that require strings to be ordered 
  rely on the concept of a named <B>collation</B>. A collation is a set of rules 
  that determine whether two strings are equal, and if not, which of them is to 
  be sorted before the other.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-context-item">context 
  item</A> 
  <DD>
  <P>The <B>context item</B> is the item currently being processed. An item (see 
  <A href="REC-xslt20-20070123.htm#xpath-datamodel">[Data 
  Model]</A>) is either an atomic value (such as an integer, date, or string), 
  or a node. The context item is initially set to the <A 
  title="initial context node" 
  href="REC-xslt20-20070123.htm#dt-initial-context-node">initial 
  context node</A> supplied when the transformation is invoked (see <A 
  href="REC-xslt20-20070123.htm#initiating"><I>2.3 
  Initiating a Transformation</I></A>). It changes whenever instructions such as 
  <A 
  href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A> 
  and <A 
  href="REC-xslt20-20070123.htm#element-for-each"><CODE>xsl:for-each</CODE></A> 
  are used to process a sequence of items; each item in such a sequence becomes 
  the context item while that item is being processed.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-context-node">context 
  node</A> 
  <DD>
  <P>If the <A title="context item" 
  href="REC-xslt20-20070123.htm#dt-context-item">context 
  item</A> is a node (as distinct from an atomic value such as an integer), then 
  it is also referred to as the <B>context node</B>. The context node is not an 
  independent variable, it changes whenever the context item changes. When the 
  context item is an atomic value, there is no context node.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-context-position">context 
  position</A> 
  <DD>
  <P>The <B>context position</B> is the position of the context item within the 
  sequence of items currently being processed. It changes whenever the context 
  item changes. When an instruction such as <A 
  href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A> 
  or <A 
  href="REC-xslt20-20070123.htm#element-for-each"><CODE>xsl:for-each</CODE></A> 
  is used to process a sequence of items, the first item in the sequence is 
  processed with a context position of 1, the second item with a context 
  position of 2, and so on.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-context-size">context 
  size</A> 
  <DD>
  <P>The <B>context size</B> is the number of items in the sequence of items 
  currently being processed. It changes whenever instructions such as <A 
  href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A> 
  and <A 
  href="REC-xslt20-20070123.htm#element-for-each"><CODE>xsl:for-each</CODE></A> 
  are used to process a sequence of items; during the processing of each one of 
  those items, the context size is set to the count of the number of items in 
  the sequence (or equivalently, the position of the last item in the 
  sequence).</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-core-function">core 
  function</A> 
  <DD>
  <P>The term <B>core function</B> means a function that is specified in <A 
  href="REC-xslt20-20070123.htm#xpath-functions">[Functions 
  and Operators]</A> and that is in the <A title="standard function namespace" 
  href="REC-xslt20-20070123.htm#dt-standard-function-namespace">standard 
  function namespace</A>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-current-captured-substrings">current 
  captured substrings</A> 
  <DD>
  <P>While the <A 
  href="REC-xslt20-20070123.htm#element-matching-substring"><CODE>xsl:matching-substring</CODE></A> 
  instruction is active, a set of <B>current captured substrings</B> is 
  available, corresponding to the parenthesized sub-expressions of the regular 
  expression.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-current-group">current 
  group</A> 
  <DD>
  <P>The evaluation context for XPath <A title=expression 
  href="REC-xslt20-20070123.htm#dt-expression">expressions</A> 
  includes a <SPAN>component</SPAN> called the <B>current group</B>, which is a 
  sequence. The current group is the collection of related items that are 
  processed collectively in one iteration of the <A 
  href="REC-xslt20-20070123.htm#element-for-each-group"><CODE>xsl:for-each-group</CODE></A> 
  element.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-current-grouping-key">current 
  grouping key</A> 
  <DD>
  <P>The evaluation context for XPath <A title=expression 
  href="REC-xslt20-20070123.htm#dt-expression">expressions</A> 
  includes a component called the <B>current grouping key</B>, which is an 
  atomic value. The current grouping key is <SPAN>the <A title="grouping key" 
  href="REC-xslt20-20070123.htm#dt-grouping-key">grouping 
  key</A></SPAN> shared in common by all the items within the <A 
  title="current group" 
  href="REC-xslt20-20070123.htm#dt-current-group">current 
  group</A>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-current-mode">current 
  mode</A> 
  <DD>
  <P>At any point in the processing of a stylesheet, there is a <B>current 
  mode</B>. When the transformation is initiated, the current mode is the <A 
  title="default mode" 
  href="REC-xslt20-20070123.htm#dt-default-mode">default 
  mode</A>, <SPAN>unless a different initial mode has been supplied, as 
  described in <A 
  href="REC-xslt20-20070123.htm#initiating"><I>2.3 
  Initiating a Transformation</I></A>.</SPAN> Whenever an <A 
  href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A> 
  instruction is evaluated, the current mode becomes the mode selected by this 
  instruction.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-current-template-rule">current 
  template rule</A> 
  <DD>
  <P>At any point in the processing of a <A title=stylesheet 
  href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A>, 
  there may be a <B>current template rule</B>. Whenever a <A 
  title="template rule" 
  href="REC-xslt20-20070123.htm#dt-template-rule">template 
  rule</A> is chosen <SPAN>as a result of evaluating <A 
  href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A>, 
  <A 
  href="REC-xslt20-20070123.htm#element-apply-imports"><CODE>xsl:apply-imports</CODE></A>, 
  or <A 
  href="REC-xslt20-20070123.htm#element-next-match"><CODE>xsl:next-match</CODE></A></SPAN>, 
  the template rule becomes the current template rule for the evaluation of the 
  rule's sequence constructor. When an <A 
  href="REC-xslt20-20070123.htm#element-for-each"><CODE>xsl:for-each</CODE></A>, 
  <A 
  href="REC-xslt20-20070123.htm#element-for-each-group"><CODE>xsl:for-each-group</CODE></A>, 
  <SPAN>or <A 
  href="REC-xslt20-20070123.htm#element-analyze-string"><CODE>xsl:analyze-string</CODE></A> 
  instruction is evaluated, or when evaluating a sequence constructor contained 
  in an <A 
  href="REC-xslt20-20070123.htm#element-sort"><CODE>xsl:sort</CODE></A> 
  or <A 
  href="REC-xslt20-20070123.htm#element-key"><CODE>xsl:key</CODE></A> 
  element, or when</SPAN> a <A title="stylesheet function" 
  href="REC-xslt20-20070123.htm#dt-stylesheet-function">stylesheet 
  function</A> is called (see <A 
  href="REC-xslt20-20070123.htm#stylesheet-functions"><I>10.3 
  Stylesheet Functions</I></A>), the current template rule becomes null for the 
  evaluation of that instruction or function.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-date-formatting-function">date 
  formatting function</A> 
  <DD>
  <P>The three functions <A 
  href="REC-xslt20-20070123.htm#function-format-date"><CODE>format-date</CODE></A>, 
  <A 
  href="REC-xslt20-20070123.htm#function-format-time"><CODE>format-time</CODE></A>, 
  and <A 
  href="REC-xslt20-20070123.htm#function-format-dateTime"><CODE>format-dateTime</CODE></A> 
  are referred to collectively as the <B>date formatting functions</B>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-decimal-format">decimal 
  format</A> 
  <DD>
  <P>All the <A 
  href="REC-xslt20-20070123.htm#element-decimal-format"><CODE>xsl:decimal-format</CODE></A> 
  declarations in a stylesheet that share the same name are grouped into a named 
  <B>decimal format</B>; those that have no name are grouped into a single 
  unnamed decimal format.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-declaration">declaration</A> 

  <DD>
  <P>Top-level elements fall into two categories: declarations, and user-defined 
  data elements. Top-level elements whose names are in the <A 
  title="XSLT namespace" 
  href="REC-xslt20-20070123.htm#dt-xslt-namespace">XSLT 
  namespace</A> are <B>declarations</B>. Top-level elements in any other 
  namespace are <A title="user-defined data element" 
  href="REC-xslt20-20070123.htm#dt-data-element">user-defined 
  data elements</A> (see <A 
  href="REC-xslt20-20070123.htm#user-defined-top-level"><I>3.6.2 
  User-defined Data Elements</I></A>)</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-declaration-order">declaration 
  order</A> 
  <DD>
  <P>The <A title=declaration 
  href="REC-xslt20-20070123.htm#dt-declaration">declarations</A> 
  within a <A title="stylesheet level" 
  href="REC-xslt20-20070123.htm#dt-stylesheet-level">stylesheet 
  level</A> have a total ordering known as <B>declaration order</B>. The order 
  of declarations within a stylesheet level is the same as the document order 
  that would result if each stylesheet module were inserted textually in place 
  of the <A 
  href="REC-xslt20-20070123.htm#element-include"><CODE>xsl:include</CODE></A> 
  element that references it.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-default-collation">default 
  collation</A> 
  <DD>
  <P>In this specification the term <B>default collation</B> means the collation 
  that is used by XPath operators such as <CODE>eq</CODE> and <CODE>lt</CODE> 
  appearing in XPath expressions within the stylesheet.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-default-mode">default 
  mode</A> 
  <DD>
  <P>There is always a <B>default mode</B> available. The default mode is an 
  unnamed <A title=mode 
  href="REC-xslt20-20070123.htm#dt-mode">mode</A>, and it 
  is used when no <CODE>mode</CODE> attribute is specified on an <A 
  href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A> 
  instruction.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-default-priority">default 
  priority</A> 
  <DD>
  <P>If no <CODE>priority</CODE> attribute is specified on the <A 
  href="REC-xslt20-20070123.htm#element-template"><CODE>xsl:template</CODE></A> 
  element, a <B>default priority</B> is computed, based on the syntax of the 
  pattern supplied in the <CODE>match</CODE> attribute.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-defining-element">defining 
  element</A> 
  <DD>
  <P><SPAN>A string in the form of a lexical QName</SPAN> may occur as the value 
  of an attribute node in a stylesheet module, or within an XPath <A 
  title=expression 
  href="REC-xslt20-20070123.htm#dt-expression">expression</A> 
  contained in such an attribute node, or as the result of evaluating an XPath 
  expression contained in such an attribute node. The element containing this 
  attribute node is referred to as the <B>defining element</B> of the QName.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-deprecated">deprecated</A> 

  <DD>
  <P>Some constructs defined in this specification are described as being 
  <B>deprecated</B>. The use of this term implies that stylesheet authors <SPAN 
  class=verb>should not</SPAN> use the construct, and that the construct may be 
  removed in a later version of this specification.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-dynamic-error">dynamic 
  error</A> 
  <DD>
  <P>An error that is not detected until a source document is being transformed 
  is referred to as a <B>dynamic error</B>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-effective-value">effective 
  value</A> 
  <DD>
  <P>The result of evaluating an attribute value template is referred to as the 
  <B>effective value</B> of the attribute.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-embedded-stylesheet-module">embedded 
  stylesheet module</A> 
  <DD>
  <P>An <B>embedded stylesheet module</B> is a stylesheet module that is 
  embedded within another XML document, typically the source document that is 
  being transformed.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded-QName</A> 

  <DD>
  <P>An <B>expanded-QName</B> <SPAN>contains a pair of values, namely a local 
  name and an optional namespace URI. It may also contain a namespace 
  prefix.</SPAN> Two expanded-QNames are equal if the namespace URIs are the 
  same (or both absent) and the local names are the same. <SPAN>The prefix plays 
  no part in the comparison, but is used only if the expanded-QName needs to be 
  converted back to a string.</SPAN></P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-expression">expression</A> 

  <DD>
  <P>Within this specification, the term <B>XPath expression</B>, or simply 
  <B>expression</B>, means a string that matches the production <SPAN><A 
  href="http://www.w3.org/TR/xpath20/#doc-xpath-Expr">Expr</A><SUP> 
  <SMALL>XP</SMALL></SUP></SPAN> defined in <A 
  href="REC-xslt20-20070123.htm#xpath20">[XPath 
  2.0]</A>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-extension-attribute">extension 
  attribute</A> 
  <DD>
  <P>An element from the XSLT namespace may have any attribute not from the XSLT 
  namespace, provided that the <A title=expanded-QName 
  href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded-QName</A> 
  (see <A href="REC-xslt20-20070123.htm#xpath20">[XPath 
  2.0]</A>) of the attribute has a non-null namespace URI. These attributes are 
  referred to as <B>extension attributes</B>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-extension-function">extension 
  function</A> 
  <DD>
  <P>An <B>extension function</B> is a function that is available for use within 
  an XPath <A title=expression 
  href="REC-xslt20-20070123.htm#dt-expression">expression</A>, 
  other than a <A title="core function" 
  href="REC-xslt20-20070123.htm#dt-core-function">core 
  function</A> defined in <A 
  href="REC-xslt20-20070123.htm#xpath-functions">[Functions 
  and Operators]</A>, an additional function defined in this XSLT specification, 
  <SPAN>a constructor function named after an atomic type,</SPAN> or a <A 
  title="stylesheet function" 
  href="REC-xslt20-20070123.htm#dt-stylesheet-function">stylesheet 
  function</A> defined using an <A 
  href="REC-xslt20-20070123.htm#element-function"><CODE>xsl:function</CODE></A> 
  declaration.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-extension-instruction">extension 
  instruction</A> 
  <DD>
  <P>An <B>extension instruction</B> is an element within a <A 
  title="sequence constructor" 
  href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
  constructor</A> that is in a namespace (not the <A title="XSLT namespace" 
  href="REC-xslt20-20070123.htm#dt-xslt-namespace">XSLT 
  namespace</A>) designated as an extension namespace.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-extension-namespace">extension 
  namespace</A> 
  <DD>
  <P>The <A title="extension instruction" 
  href="REC-xslt20-20070123.htm#dt-extension-instruction">extension 
  instruction</A> mechanism allows namespaces to be designated as <B>extension 
  namespaces</B>. When a namespace is designated as an extension namespace and 
  an element with a name from that namespace occurs in a <A 
  title="sequence constructor" 
  href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
  constructor</A>, then the element is treated as an <A title=instruction 
  href="REC-xslt20-20070123.htm#dt-instruction">instruction</A> 
  rather than as a <A title="literal result element" 
  href="REC-xslt20-20070123.htm#dt-literal-result-element">literal 
  result element</A>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-final-output-state">final 
  output state</A> 
  <DD>
  <P>The first of the two <A title="output state" 
  href="REC-xslt20-20070123.htm#dt-output-state">output 
  states</A> is called <B>final output</B> state. This state applies when 
  instructions are writing to a <A title="final result tree" 
  href="REC-xslt20-20070123.htm#dt-final-result-tree">final 
  result tree</A>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-final-result-tree">final 
  result tree</A> 
  <DD>
  <P>A <B>final result tree</B> is a <A title="result tree" 
  href="REC-xslt20-20070123.htm#dt-result-tree">result 
  tree</A> that forms part of the final output of a transformation. Once 
  created, the contents of a final result tree are not accessible within the 
  stylesheet itself.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-focus">focus</A> 
  <DD>
  <P>When a <A title="sequence constructor" 
  href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
  constructor</A> is evaluated, the <A title=processor 
  href="REC-xslt20-20070123.htm#dt-processor">processor</A> 
  keeps track of which items are being processed by means of a set of implicit 
  variables referred to collectively as the <B>focus</B>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-forwards-compatible-behavior">forwards-compatible 
  behavior</A> 
  <DD>
  <P>An element enables <B>forwards-compatible behavior</B> for itself, its 
  attributes, its descendants and their attributes if it has an 
  <CODE>[xsl:]version</CODE> attribute (see <A 
  href="REC-xslt20-20070123.htm#standard-attributes"><I>3.5 
  Standard Attributes</I></A>) whose value is greater than <CODE>2.0</CODE>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-function-conversion-rules">function 
  conversion rules</A> 
  <DD>
  <P>Except where otherwise indicated, the actual value of an <A 
  title=expression 
  href="REC-xslt20-20070123.htm#dt-expression">expression</A> 
  is converted to the <A title="required type" 
  href="REC-xslt20-20070123.htm#dt-required-type">required 
  type</A> using the <B>function conversion rules</B>. These are the rules 
  defined in <A 
  href="REC-xslt20-20070123.htm#xpath20">[XPath 2.0]</A> 
  for converting the supplied argument of a function call to the required type 
  of that argument, as defined in the function signature. The relevant rules are 
  those that apply when <A title="XPath 1.0 compatibility mode" 
  href="REC-xslt20-20070123.htm#dt-compatibility-mode">XPath 
  1.0 compatibility mode</A> is set to <CODE>false</CODE>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-function-parameter">function 
  parameter</A> 
  <DD>
  <P>An <A 
  href="REC-xslt20-20070123.htm#element-param"><CODE>xsl:param</CODE></A> 
  element may appear as a child of an <A 
  href="REC-xslt20-20070123.htm#element-function"><CODE>xsl:function</CODE></A> 
  element, before any non-<A 
  href="REC-xslt20-20070123.htm#element-param"><CODE>xsl:param</CODE></A> 
  children of that element. Such a parameter is known as a <B>function 
  parameter</B>. A function parameter is a <A title="local variable" 
  href="REC-xslt20-20070123.htm#dt-local-variable">local 
  variable</A> with the additional property that its value can be set when the 
  function is called, using a function call in an XPath <A title=expression 
  href="REC-xslt20-20070123.htm#dt-expression">expression</A>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-global-variable">global 
  variable</A> 
  <DD>
  <P>A top-level <A title="variable-binding element" 
  href="REC-xslt20-20070123.htm#dt-variable-binding-element">variable-binding 
  element</A> declares a <B>global variable</B> that is visible everywhere 
  (except where it is <A title=shadows 
  href="REC-xslt20-20070123.htm#dt-shadows">shadowed</A> 
  by another binding).</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-group">group</A> 
  <DD>
  <P>The <A 
  href="REC-xslt20-20070123.htm#element-for-each-group"><CODE>xsl:for-each-group</CODE></A> 
  instruction <SPAN>allocates the items in an input sequence</SPAN> into 
  <B>groups</B> of items (that is, it establishes a collection of sequences) 
  based either on common values of a grouping key, or on a <A title=pattern 
  href="REC-xslt20-20070123.htm#dt-pattern">pattern</A> 
  that the initial or final node in a group must match.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-grouping-key">grouping 
  key</A> 
  <DD>
  <P>If either of the <CODE>group-by</CODE> attribute or 
  <CODE>group-adjacent</CODE> attributes is present, then <B>grouping keys</B> 
  are calculated for each item in the <A title=population 
  href="REC-xslt20-20070123.htm#dt-population">population</A>. 
  <SPAN>The grouping keys are the items in the sequence obtained by evaluating 
  the expression contained in the <CODE>group-by</CODE> attribute or 
  <CODE>group-adjacent</CODE> attribute, atomizing the result, and then casting 
  an <CODE>xs:untypedAtomic</CODE> value to <CODE>xs:string</CODE>.</SPAN></P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-implementation">implementation</A> 

  <DD>
  <P>A specific product that performs the functions of an <A title=processor 
  href="REC-xslt20-20070123.htm#dt-processor">XSLT 
  processor</A> is referred to as an <B>implementation</B></P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-implementation-defined">implementation-defined</A> 

  <DD>
  <P>In this specification, the term <B>implementation-defined</B> refers to a 
  feature where the implementation is allowed some flexibility, and where the 
  choices made by the implementation <SPAN class=verb>must</SPAN> be described 
  in documentation that accompanies any conformance claim.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-implementation-dependent">implementation-dependent</A> 

  <DD>
  <P>The term <B>implementation-dependent</B> refers to a feature where the 
  behavior <SPAN class=verb>may</SPAN> vary from one implementation to another, 
  and where the vendor is not expected to provide a full specification of the 
  behavior.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-import-precedence">import 
  precedence</A> 
  <DD>
  <P>A <A title=declaration 
  href="REC-xslt20-20070123.htm#dt-declaration">declaration</A> 
  <VAR>D</VAR> in the stylesheet is defined to have lower <B>import 
  precedence</B> than another declaration <VAR>E</VAR> if the stylesheet level 
  containing <VAR>D</VAR> would be visited before the stylesheet level 
  containing <VAR>E</VAR> in a post-order traversal of the import tree (that is, 
  a traversal of the import tree in which a stylesheet level is visited after 
  its children). Two declarations within the same stylesheet level have the same 
  import precedence.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-import-tree">import 
  tree</A> 
  <DD>
  <P>The <A title="stylesheet level" 
  href="REC-xslt20-20070123.htm#dt-stylesheet-level">stylesheet 
  levels</A> making up a <A title=stylesheet 
  href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
  are treated as forming an <B>import tree</B>. In the import tree, each 
  stylesheet level has one child for each <A 
  href="REC-xslt20-20070123.htm#element-import"><CODE>xsl:import</CODE></A> 
  declaration that it contains.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-in-scope-schema-component">in-scope 
  schema component</A> 
  <DD>
  <P>The <A title="schema component" 
  href="REC-xslt20-20070123.htm#dt-schema-component">schema 
  components</A> that may be referenced by name in a <A title=stylesheet 
  href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
  are referred to as the <B>in-scope schema components</B>. This set is the same 
  throughout all the modules of a stylesheet.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-initial-context-node">initial 
  context node</A> 
  <DD>
  <P>A node that acts as the <B>initial context node</B> for the transformation. 
  This node is accessible within the <A title=stylesheet 
  href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
  as the initial value of the XPath <A title=expression 
  href="REC-xslt20-20070123.htm#dt-expression">expressions</A> 
  <CODE>.</CODE> (dot) and <CODE>self::node()</CODE>, as described in <A 
  href="REC-xslt20-20070123.htm#focus"><I>5.4.3.1 
  Maintaining Position: the Focus</I></A></P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-initial-item">initial 
  item</A> 
  <DD>
  <P>For each <A title=group 
  href="REC-xslt20-20070123.htm#dt-group">group</A>, the 
  item within the group that is first in <A title="population order" 
  href="REC-xslt20-20070123.htm#dt-population-order">population 
  order</A> is known as the <B>initial item</B> of the group.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-initial-sequence">initial 
  sequence</A> 
  <DD>
  <P>The sequence to be sorted is referred to as the <B>initial 
sequence</B>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-initial-template">initial 
  template</A> 
  <DD>
  <P>The transformation is performed by evaluating an <B>initial template</B>. 
  If a <A title="named template" 
  href="REC-xslt20-20070123.htm#dt-named-template">named 
  template</A> is supplied when the transformation is initiated, then this is 
  the initial template; <SPAN>otherwise, the initial template is the <A 
  title="template rule" 
  href="REC-xslt20-20070123.htm#dt-template-rule">template 
  rule</A> selected according to the rules of the <A 
  href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A> 
  instruction for processing the <A title="initial context node" 
  href="REC-xslt20-20070123.htm#dt-initial-context-node">initial 
  context node</A> in the initial <A title=mode 
  href="REC-xslt20-20070123.htm#dt-mode">mode</A>.</SPAN></P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-instruction">instruction</A> 

  <DD>
  <P>An <B>instruction</B> is either an <A title="XSLT instruction" 
  href="REC-xslt20-20070123.htm#dt-xslt-instruction">XSLT 
  instruction</A> or an <A title="extension instruction" 
  href="REC-xslt20-20070123.htm#dt-extension-instruction">extension 
  instruction</A>.</P>
  <DT><A href="REC-xslt20-20070123.htm#dt-key">key</A> 
  <DD>
  <P>A <B>key</B> is defined as a set of <A 
  href="REC-xslt20-20070123.htm#element-key"><CODE>xsl:key</CODE></A> 
  declarations in the <A title=stylesheet 
  href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
  that share the same name.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-key-specifier">key 
  specifier</A> 
  <DD>
  <P>The expression in the <CODE>use</CODE> attribute and the <A 
  title="sequence constructor" 
  href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
  constructor</A> within an <A 
  href="REC-xslt20-20070123.htm#element-key"><CODE>xsl:key</CODE></A> 
  declaration are referred to collectively as the <B>key specifier</B>. The key 
  specifier determines the values that may be used to find a node using this <A 
  title=key 
  href="REC-xslt20-20070123.htm#dt-key">key</A>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-lexical-qname">lexical 
  QName</A> 
  <DD>
  <P>A <B>lexical QName</B> is a string representing a <A title=QName 
  href="REC-xslt20-20070123.htm#dt-qname">QName</A> in 
  the form <CODE>(NCName ":")? NCName</CODE>, that is, a local name optionally 
  preceded by a namespace prefix.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-literal-namespace-uri">literal 
  namespace URI</A> 
  <DD>
  <P>A namespace URI in the stylesheet tree that is being used to specify a 
  namespace URI in the <A title="result tree" 
  href="REC-xslt20-20070123.htm#dt-result-tree">result 
  tree</A> is called a <B>literal namespace URI</B>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-literal-result-element">literal 
  result element</A> 
  <DD>
  <P>In a <A title="sequence constructor" 
  href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
  constructor</A>, an element in the <A title=stylesheet 
  href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
  that does not belong to the <A title="XSLT namespace" 
  href="REC-xslt20-20070123.htm#dt-xslt-namespace">XSLT 
  namespace</A> and that is not an <A title="extension instruction" 
  href="REC-xslt20-20070123.htm#dt-extension-instruction">extension 
  instruction</A> (see <A 
  href="REC-xslt20-20070123.htm#extension-instruction"><I>18.2 
  Extension Instructions</I></A>) is classified as a <B>literal result 
  element</B>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-local-variable">local 
  variable</A> 
  <DD>
  <P>As well as being allowed as <A title=declaration 
  href="REC-xslt20-20070123.htm#dt-declaration">declaration</A> 
  elements, the <A 
  href="REC-xslt20-20070123.htm#element-variable"><CODE>xsl:variable</CODE></A> 
  element is also allowed in <A title="sequence constructor" 
  href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
  constructors</A>. Such a variable is known as a <B>local variable</B>.</P>
  <DT><A href="REC-xslt20-20070123.htm#dt-mode">mode</A> 
  <DD>
  <P><B>Modes</B> allow a node in a <A title="source tree" 
  href="REC-xslt20-20070123.htm#dt-source-tree">source 
  tree</A> to be processed multiple times, each time producing a different 
  result. They also allow different sets of <A title="template rule" 
  href="REC-xslt20-20070123.htm#dt-template-rule">template 
  rules</A> to be active when processing different trees, for example when 
  processing documents loaded using the <A 
  href="REC-xslt20-20070123.htm#function-document"><CODE>document</CODE></A> 
  function (see <A 
  href="REC-xslt20-20070123.htm#document"><I>16.1 
  Multiple Source Documents</I></A>) or when processing <A 
  title="temporary tree" 
  href="REC-xslt20-20070123.htm#dt-temporary-tree">temporary 
  trees</A>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-named-template">named 
  template</A> 
  <DD>
  <P>Templates can be invoked by name. An <A 
  href="REC-xslt20-20070123.htm#element-template"><CODE>xsl:template</CODE></A> 
  element with a <CODE>name</CODE> attribute defines a <B>named 
template</B>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-namespace-fixup">namespace 
  fixup</A> 
  <DD>
  <P>The rules for the individual XSLT instructions that construct a <A 
  title="result tree" 
  href="REC-xslt20-20070123.htm#dt-result-tree">result 
  tree</A> (see <A 
  href="REC-xslt20-20070123.htm#creating-new-nodes"><I>11 
  Creating Nodes and Sequences</I></A>) prescribe some of the situations in 
  which namespace nodes are written to the tree. These rules, however, are not 
  sufficient to ensure that the prescribed constraints are always satisfied. The 
  XSLT processor <SPAN class=verb>must</SPAN> therefore add additional namespace 
  nodes to satisfy these constraints. This process is referred to as 
  <B>namespace fixup</B>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A> 
  <DD>
  <P>A <A title="dynamic error" 
  href="REC-xslt20-20070123.htm#dt-dynamic-error">dynamic 
  error</A> that is not recoverable is referred to as a <B>non-recoverable 
  dynamic error</B>. When a non-recoverable dynamic error occurs, the <A 
  title=processor 
  href="REC-xslt20-20070123.htm#dt-processor">processor</A> 
  <SPAN class=verb>must</SPAN> signal the error, and the transformation 
  fails.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-optional-recovery-action">optional 
  recovery action</A> 
  <DD>
  <P>If an implementation chooses to recover from a <A title="recoverable error" 
  href="REC-xslt20-20070123.htm#dt-recoverable-error">recoverable 
  dynamic error</A>, it <SPAN class=verb>must</SPAN> take the <B>optional 
  recovery action</B> defined for that error condition in this 
specification.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-first-appearance">order 
  of first appearance</A> 
  <DD>
  <P>There is an ordering among <A title=group 
  href="REC-xslt20-20070123.htm#dt-group">groups</A> 
  referred to as the <B>order of first appearance</B>. A group <VAR>G</VAR> is 
  defined to precede a group <VAR>H</VAR> in order of first appearance if the <A 
  title="initial item" 
  href="REC-xslt20-20070123.htm#dt-initial-item">initial 
  item</A> of <VAR>G</VAR> precedes the initial item of <VAR>H</VAR> in 
  population order. <SPAN>If two groups <VAR>G</VAR> and <VAR>H</VAR> have the 
  same initial item (because the item is in both groups) then <VAR>G</VAR> 
  precedes <VAR>H</VAR> if the <A title="grouping key" 
  href="REC-xslt20-20070123.htm#dt-grouping-key">grouping 
  key</A> of <VAR>G</VAR> precedes the grouping key of <VAR>H</VAR> in the 
  sequence that results from evaluating the <CODE>group-by</CODE> expression of 
  this initial item.</SPAN></P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-output-definition">output 
  definition</A> 
  <DD>
  <P>All the <A 
  href="REC-xslt20-20070123.htm#element-output"><CODE>xsl:output</CODE></A> 
  declarations in a stylesheet that share the same name are grouped into a named 
  <B>output definition</B>; those that have no name are grouped into a single 
  unnamed output definition.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-output-state">output 
  state</A> 
  <DD>
  <P>Each instruction in the <A title=stylesheet 
  href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
  is evaluated in one of two possible <B>output states</B>: <A 
  title="final output state" 
  href="REC-xslt20-20070123.htm#dt-final-output-state">final 
  output state</A> or <A title="temporary output state" 
  href="REC-xslt20-20070123.htm#dt-temporary-output-state">temporary 
  output state</A></P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-parameter">parameter</A> 

  <DD>
  <P>The <A 
  href="REC-xslt20-20070123.htm#element-param"><CODE>xsl:param</CODE></A> 
  element declares a <B>parameter</B>, which may be a <A 
  title="stylesheet parameter" 
  href="REC-xslt20-20070123.htm#dt-stylesheet-parameter">stylesheet 
  parameter</A>, a <A title="template parameter" 
  href="REC-xslt20-20070123.htm#dt-template-parameter">template 
  parameter</A>, or a <A title="function parameter" 
  href="REC-xslt20-20070123.htm#dt-function-parameter">function 
  parameter</A>. A parameter is a <A title=variable 
  href="REC-xslt20-20070123.htm#dt-variable">variable</A> 
  with the additional property that its value can be set by the caller when the 
  stylesheet, the template, or the function is invoked.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-pattern">pattern</A> 
  <DD>
  <P>A <B>pattern</B> specifies a set of conditions on a node. A node that 
  satisfies the conditions matches the pattern; a node that does not satisfy the 
  conditions does not match the pattern. The syntax for patterns is a subset of 
  the syntax for <A title=expression 
  href="REC-xslt20-20070123.htm#dt-expression">expressions</A>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-picture-string">picture 
  string</A> 
  <DD>
  <P>The formatting of a number is controlled by a <B>picture string</B>. The 
  picture string is a sequence of characters, in which the characters assigned 
  to the variables <VAR>decimal-separator-sign</VAR>, <VAR>grouping-sign</VAR>, 
  <VAR>zero-digit-sign</VAR>, <VAR>digit-sign</VAR> and 
  <VAR>pattern-separator-sign</VAR> are classified as active characters, and all 
  other characters (including the <VAR>percent-sign</VAR> and 
  <VAR>per-mille-sign</VAR>) are classified as passive characters.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-place-marker">place 
  marker</A> 
  <DD>
  <P>The <A 
  href="REC-xslt20-20070123.htm#element-number"><CODE>xsl:number</CODE></A> 
  instruction performs two tasks: firstly, determining a <B>place marker</B> 
  (this is a sequence of integers, to allow for hierarchic numbering schemes 
  such as <CODE>1.12.2</CODE> or <CODE>3(c)ii</CODE>), and secondly, formatting 
  the place marker for output as a text node in the result sequence.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-population">population</A> 

  <DD>
  <P>The sequence of items to be grouped, which is referred to as the 
  <B>population</B>, is determined by evaluating the XPath <A title=expression 
  href="REC-xslt20-20070123.htm#dt-expression">expression</A> 
  contained in the <CODE>select</CODE> attribute.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-population-order">population 
  order</A> 
  <DD>
  <P>The population is treated as a sequence; the order of items in this 
  sequence is referred to as <B>population order</B></P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-principal-stylesheet-module">principal 
  stylesheet module</A> 
  <DD>
  <P>A <A title=stylesheet 
  href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
  may consist of several <A title="stylesheet module" 
  href="REC-xslt20-20070123.htm#dt-stylesheet-module">stylesheet 
  modules</A>, contained in different XML documents. For a given transformation, 
  one of these functions as the <B>principal stylesheet module</B>. The complete 
  <A title=stylesheet 
  href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
  is assembled by finding the <A title="stylesheet module" 
  href="REC-xslt20-20070123.htm#dt-stylesheet-module">stylesheet 
  modules</A> referenced directly or indirectly from the principal stylesheet 
  module using <A 
  href="REC-xslt20-20070123.htm#element-include"><CODE>xsl:include</CODE></A> 
  and <A 
  href="REC-xslt20-20070123.htm#element-import"><CODE>xsl:import</CODE></A> 
  elements: see <A 
  href="REC-xslt20-20070123.htm#include"><I>3.10.2 
  Stylesheet Inclusion</I></A> and <A 
  href="REC-xslt20-20070123.htm#import"><I>3.10.3 
  Stylesheet Import</I></A>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-processing-order">processing 
  order</A> 
  <DD>
  <P>There is another ordering among groups referred to as <B>processing 
  order</B>. <SPAN>If group <VAR>R</VAR> precedes group <VAR>S</VAR> in 
  processing order, then in the result sequence returned by the <A 
  href="REC-xslt20-20070123.htm#element-for-each-group"><CODE>xsl:for-each-group</CODE></A> 
  instruction the items generated by processing group <VAR>R</VAR> will precede 
  the items generated by processing group <VAR>S</VAR>.</SPAN></P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-processor">processor</A> 

  <DD>
  <P>The software responsible for transforming source trees into result trees 
  using an XSLT stylesheet is referred to as the <B>processor</B>. This is 
  sometimes expanded to <EM>XSLT processor</EM> to avoid any confusion with 
  other processors, for example an XML processor.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-recoverable-error">recoverable 
  error</A> 
  <DD>
  <P>Some dynamic errors are classed as <B>recoverable errors</B>. When a 
  recoverable error occurs, this specification allows the processor either to 
  signal the error (by reporting the error condition and terminating execution) 
  or to take a defined recovery action and continue processing.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-required-type">required 
  type</A> 
  <DD>
  <P>The context within a <A title=stylesheet 
  href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
  where an XPath <A title=expression 
  href="REC-xslt20-20070123.htm#dt-expression">expression</A> 
  <SPAN>appears may specify</SPAN> the <B>required type</B> of the expression. 
  The required type indicates the type of the value that the expression is 
  expected to return.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-reserved-namespace">reserved 
  namespace</A> 
  <DD>
  <P>The XSLT namespace, together with certain other namespaces recognized by an 
  XSLT processor, are classified as <B>reserved namespaces</B> and <SPAN 
  class=verb>must</SPAN> be used only as specified in this and related 
  specifications.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-result-tree">result 
  tree</A> 
  <DD>
  <P>The term <B>result tree</B> is used to refer to any tree constructed by <A 
  title=instruction 
  href="REC-xslt20-20070123.htm#dt-instruction">instructions</A> 
  in the stylesheet. A result tree is either a <A title="final result tree" 
  href="REC-xslt20-20070123.htm#dt-final-result-tree">final 
  result tree</A> or a <A title="temporary tree" 
  href="REC-xslt20-20070123.htm#dt-temporary-tree">temporary 
  tree</A>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-schema-component">schema 
  component</A> 
  <DD>
  <P>Type definitions and element and attribute declarations are referred to 
  collectively as <B>schema components</B>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-schema-instance-namespace">schema 
  instance namespace</A> 
  <DD>
  <P>The <B>schema instance namespace</B> 
  <CODE>http://www.w3.org/2001/XMLSchema-instance</CODE> is used as defined in 
  <A href="REC-xslt20-20070123.htm#xmlschema-1">[XML 
  Schema Part 1]</A></P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-schema-namespace">schema 
  namespace</A> 
  <DD>
  <P>The <B>schema namespace</B> <CODE>http://www.w3.org/2001/XMLSchema</CODE> 
  is used as defined in <A 
  href="REC-xslt20-20070123.htm#xmlschema-1">[XML Schema 
  Part 1]</A></P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-schema-aware-xslt-processor">schema-aware 
  XSLT processor</A> 
  <DD>
  <P>A <B>schema-aware XSLT processor</B> is an XSLT processor that implements 
  all the mandatory requirements of this specification, including those features 
  that a <A title="basic XSLT processor" 
  href="REC-xslt20-20070123.htm#dt-basic-xslt-processor">basic 
  XSLT processor</A> signals as an error. The mandatory requirements of this 
  specification are taken to include the mandatory requirements of XPath 2.0, as 
  described in <A 
  href="REC-xslt20-20070123.htm#xpath20">[XPath 2.0]</A>. 
  A requirement is mandatory unless the specification includes wording (such as 
  the use of the words <SPAN class=verb>should</SPAN> or <SPAN 
  class=verb>may</SPAN>) that clearly indicates that it is optional.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
  constructor</A> 
  <DD>
  <P>A <B>sequence constructor</B> is a sequence of zero or more sibling nodes 
  in the <A title=stylesheet 
  href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
  that can be evaluated to return a sequence of nodes and atomic values. The way 
  that the resulting sequence is used depends on the containing instruction.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-serialization">serialization</A> 

  <DD>
  <P>A frequent requirement is to output a <A title="final result tree" 
  href="REC-xslt20-20070123.htm#dt-final-result-tree">final 
  result tree</A> as an XML document (or in other formats such as HTML). This 
  process is referred to as <B>serialization</B>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-serialization-error">serialization 
  error</A> 
  <DD>
  <P>If a transformation has successfully produced a <A 
  title="final result tree" 
  href="REC-xslt20-20070123.htm#dt-final-result-tree">final 
  result tree</A>, it is still possible that errors may occur in serializing the 
  result tree. For example, it may be impossible to serialize the result tree 
  using the encoding selected by the user. Such an error is referred to as a 
  <B>serialization error</B>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-serialization-feature">serialization 
  feature</A> 
  <DD>
  <P>A processor that claims conformance with the <B>serialization feature</B> 
  <SPAN class=verb>must</SPAN> support the conversion of a <A 
  title="final result tree" 
  href="REC-xslt20-20070123.htm#dt-final-result-tree">final 
  result tree</A> to a sequence of <SPAN>octets</SPAN> following the rules 
  defined in <A 
  href="REC-xslt20-20070123.htm#serialization"><I>20 
  Serialization</I></A>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-shadows">shadows</A> 
  <DD>
  <P>A binding <B>shadows</B> another binding if the binding occurs at a point 
  where the other binding is visible, and the bindings have the same name.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-simplified-stylesheet-module">simplified 
  stylesheet module</A> 
  <DD>
  <P>A <B>simplified stylesheet module</B> is a tree, or part of a tree, 
  consisting of a <A title="literal result element" 
  href="REC-xslt20-20070123.htm#dt-literal-result-element">literal 
  result element</A> together with its descendant nodes and associated 
  attributes and namespaces. This element is not itself in the XSLT namespace, 
  but it <SPAN class=verb>must</SPAN> have an <CODE>xsl:version</CODE> 
  attribute, which implies that it <SPAN class=verb>must</SPAN> have a namespace 
  node that declares a binding for the XSLT namespace. For further details see 
  <A 
  href="REC-xslt20-20070123.htm#simplified-stylesheet"><I>3.7 
  Simplified Stylesheet Modules</I></A>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-singleton-focus">singleton 
  focus</A> 
  <DD>
  <P>A <B>singleton focus</B> based on a node <VAR>N</VAR> has the <A 
  title="context item" 
  href="REC-xslt20-20070123.htm#dt-context-item">context 
  item</A> (and therefore the <A title="context node" 
  href="REC-xslt20-20070123.htm#dt-context-node">context 
  node</A>) set to <VAR>N</VAR>, and the <A title="context position" 
  href="REC-xslt20-20070123.htm#dt-context-position">context 
  position</A> and <A title="context size" 
  href="REC-xslt20-20070123.htm#dt-context-size">context 
  size</A> both set to 1 (one).</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-sort-key-component">sort 
  key component</A> 
  <DD>
  <P>Within a <A title="sort key specification" 
  href="REC-xslt20-20070123.htm#dt-sort-key-specification">sort 
  key specification</A>, each <A 
  href="REC-xslt20-20070123.htm#element-sort"><CODE>xsl:sort</CODE></A> 
  element defines one <B>sort key component</B>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-sort-key-specification">sort 
  key specification</A> 
  <DD>
  <P>A <B>sort key specification</B> is a sequence of one or more adjacent <A 
  href="REC-xslt20-20070123.htm#element-sort"><CODE>xsl:sort</CODE></A> 
  elements which together define rules for sorting the items in an input 
  sequence to form a sorted sequence.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-sort-key-value">sort 
  key value</A> 
  <DD>
  <P>For each item in the <A title="initial sequence" 
  href="REC-xslt20-20070123.htm#dt-initial-sequence">initial 
  sequence</A>, a value is computed for each <A title="sort key component" 
  href="REC-xslt20-20070123.htm#dt-sort-key-component">sort 
  key component</A> within the <A title="sort key specification" 
  href="REC-xslt20-20070123.htm#dt-sort-key-specification">sort 
  key specification</A>. The value computed for an item by using the 
  <VAR>N</VAR>th sort key component is referred to as the <VAR>N</VAR>th <B>sort 
  key value</B> of that item.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-sorted-sequence">sorted 
  sequence</A> 
  <DD>
  <P>The sequence after sorting as defined by the <A 
  href="REC-xslt20-20070123.htm#element-sort"><CODE>xsl:sort</CODE></A> 
  elements is referred to as the <B>sorted sequence</B>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-source-tree">source 
  tree</A> 
  <DD>
  <P>The term <B>source tree</B> means any tree provided as input to the 
  transformation. This includes the document containing the <A 
  title="initial context node" 
  href="REC-xslt20-20070123.htm#dt-initial-context-node">initial 
  context node</A> if any, documents containing nodes supplied as the values of 
  <A title="stylesheet parameter" 
  href="REC-xslt20-20070123.htm#dt-stylesheet-parameter">stylesheet 
  parameters</A>, documents obtained from the results of functions such as <A 
  href="REC-xslt20-20070123.htm#function-document"><CODE>document</CODE></A>, 
  <A 
  href="http://www.w3.org/TR/xpath-functions/#func-doc"><CODE>doc</CODE></A><SUP> 
  <SMALL>FO</SMALL></SUP>, and <A 
  href="http://www.w3.org/TR/xpath-functions/#func-collection"><CODE>collection</CODE></A><SUP><SMALL>FO</SMALL></SUP>, 
  and documents returned by extension functions or extension instructions. In 
  the context of a particular XSLT instruction, the term <B>source tree</B> 
  means any tree provided as input to that instruction; this may be a source 
  tree of the transformation as a whole, or it may be a <A 
  title="temporary tree" 
  href="REC-xslt20-20070123.htm#dt-temporary-tree">temporary 
  tree</A> produced during the course of the transformation.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-stable">stable</A> 
  <DD>
  <P>A <A title="sort key specification" 
  href="REC-xslt20-20070123.htm#dt-sort-key-specification">sort 
  key specification</A> is said to be <B>stable</B> if its first <A 
  href="REC-xslt20-20070123.htm#element-sort"><CODE>xsl:sort</CODE></A> 
  element has no <CODE>stable</CODE> attribute, or has a <CODE>stable</CODE> 
  attribute whose <A title="effective value" 
  href="REC-xslt20-20070123.htm#dt-effective-value">effective 
  value</A> is <CODE>yes</CODE>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-standalone-stylesheet-module">standalone 
  stylesheet module</A> 
  <DD>
  <P>A <B>standalone stylesheet module</B> is a stylesheet module that comprises 
  the whole of an XML document.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-standard-attributes">standard 
  attributes</A> 
  <DD>
  <P>There are a number of <B>standard attributes</B> that may appear on any <A 
  title="XSLT element" 
  href="REC-xslt20-20070123.htm#dt-xslt-element">XSLT 
  element</A>: specifically <CODE>version</CODE>, 
  <CODE>exclude-result-prefixes</CODE>, <CODE>extension-element-prefixes</CODE>, 
  <CODE>xpath-default-namespace</CODE><SPAN>, <CODE>default-collation</CODE>, 
  and <CODE>use-when</CODE>.</SPAN></P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-standard-function-namespace">standard 
  function namespace</A> 
  <DD>
  <P>The <B>standard function namespace</B> 
  <CODE>http://www.w3.org/2005/xpath-functions</CODE> is used for functions in 
  the function library defined in <A 
  href="REC-xslt20-20070123.htm#xpath-functions">[Functions 
  and Operators]</A> and standard functions defined in this specification.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-standard-stylesheet-module">standard 
  stylesheet module</A> 
  <DD>
  <P>A <B>standard stylesheet module</B> is a tree, or part of a tree, 
  consisting of an <A 
  href="REC-xslt20-20070123.htm#element-stylesheet"><CODE>xsl:stylesheet</CODE></A> 
  or <A 
  href="REC-xslt20-20070123.htm#element-transform"><CODE>xsl:transform</CODE></A> 
  element (see <A 
  href="REC-xslt20-20070123.htm#stylesheet-element"><I>3.6 
  Stylesheet Element</I></A>) together with its descendant nodes and associated 
  attributes and namespaces.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A> 
  <DD>
  <P>An error that is detected by examining a <A title=stylesheet 
  href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
  before execution starts (that is, before the source document and values of 
  stylesheet parameters are available) is referred to as a <B>static 
  error</B>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-string-value">string 
  value</A> 
  <DD>
  <P>The term <B>string value</B> is defined in <A 
  href="http://www.w3.org/TR/xpath-datamodel/#dm-string-value">Section 5.13 
  string-value Accessor</A><SUP><SMALL>DM</SMALL></SUP>. Every node has a <A 
  title="string value" 
  href="REC-xslt20-20070123.htm#dt-string-value">string 
  value</A>. For example, the <A title="string value" 
  href="REC-xslt20-20070123.htm#dt-string-value">string 
  value</A> of an element is the concatenation of the <A title="string value" 
  href="REC-xslt20-20070123.htm#dt-string-value">string 
  values</A> of all its descendant text nodes.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 

  <DD>
  <P>A transformation in the XSLT language is expressed in the form of a 
  <B>stylesheet</B>, whose syntax is well-formed XML <A 
  href="REC-xslt20-20070123.htm#REC-xml">[XML 1.0]</A> 
  conforming to the Namespaces in XML Recommendation <A 
  href="REC-xslt20-20070123.htm#REC-xml-names">[Namespaces 
  in XML 1.0]</A>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-stylesheet-function">stylesheet 
  function</A> 
  <DD>
  <P>An <A 
  href="REC-xslt20-20070123.htm#element-function"><CODE>xsl:function</CODE></A> 
  declaration declares the name, parameters, and implementation of a 
  <B>stylesheet function</B> that can be called from any XPath <A 
  title=expression 
  href="REC-xslt20-20070123.htm#dt-expression">expression</A> 
  within the <A title=stylesheet 
  href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-stylesheet-level">stylesheet 
  level</A> 
  <DD>
  <P>A <B>stylesheet level</B> is a collection of <A title="stylesheet module" 
  href="REC-xslt20-20070123.htm#dt-stylesheet-module">stylesheet 
  modules</A> connected using <A 
  href="REC-xslt20-20070123.htm#element-include"><CODE>xsl:include</CODE></A> 
  declarations: specifically, two stylesheet modules <VAR>A</VAR> and 
  <VAR>B</VAR> are part of the same stylesheet level if one of them includes the 
  other by means of an <A 
  href="REC-xslt20-20070123.htm#element-include"><CODE>xsl:include</CODE></A> 
  declaration, or if there is a third stylesheet module <VAR>C</VAR> that is in 
  the same stylesheet level as both <VAR>A</VAR> and <VAR>B</VAR>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-stylesheet-module">stylesheet 
  module</A> 
  <DD>
  <P>A <A title=stylesheet 
  href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
  consists of one or more <B>stylesheet modules</B>, each one forming all or 
  part of an XML document.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-stylesheet-parameter">stylesheet 
  parameter</A> 
  <DD>
  <P>A top-level <A 
  href="REC-xslt20-20070123.htm#element-param"><CODE>xsl:param</CODE></A> 
  element declares a <B>stylesheet parameter</B>. A stylesheet parameter is a 
  global variable with the additional property that its value can be supplied by 
  the caller when a transformation is initiated.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-supplied-value">supplied 
  value</A> 
  <DD>
  <P>The value of the variable is computed using the <A title=expression 
  href="REC-xslt20-20070123.htm#dt-expression">expression</A> 
  given in the <CODE>select</CODE> attribute or the contained <A 
  title="sequence constructor" 
  href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
  constructor</A>, as described in <A 
  href="REC-xslt20-20070123.htm#variable-values"><I>9.3 
  Values of Variables and Parameters</I></A>. This value is referred to as the 
  <B>supplied value</B> of the variable.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-target-namespace-uri">target 
  namespace URI</A> 
  <DD>
  <P>The namespace URI that is to be used in the <A title="result tree" 
  href="REC-xslt20-20070123.htm#dt-result-tree">result 
  tree</A> as a substitute for a <A title="literal namespace URI" 
  href="REC-xslt20-20070123.htm#dt-literal-namespace-uri">literal 
  namespace URI</A> is called the <B>target namespace URI</B>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-template">template</A> 

  <DD>
  <P>An <A 
  href="REC-xslt20-20070123.htm#element-template"><CODE>xsl:template</CODE></A> 
  declaration defines a <B>template</B>, which contains a <SPAN><A 
  title="sequence constructor" 
  href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
  constructor</A></SPAN> for creating nodes and/or atomic values. A template can 
  serve either as a <A title="template rule" 
  href="REC-xslt20-20070123.htm#dt-template-rule">template 
  rule</A>, invoked by matching nodes against a <A title=pattern 
  href="REC-xslt20-20070123.htm#dt-pattern">pattern</A>, 
  or as a <A title="named template" 
  href="REC-xslt20-20070123.htm#dt-named-template">named 
  template</A>, invoked explicitly by name. It is also possible for the same 
  template to serve in both capacities.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-template-parameter">template 
  parameter</A> 
  <DD>
  <P>An <A 
  href="REC-xslt20-20070123.htm#element-param"><CODE>xsl:param</CODE></A> 
  element may appear as a child of an <A 
  href="REC-xslt20-20070123.htm#element-template"><CODE>xsl:template</CODE></A> 
  element, before any non-<A 
  href="REC-xslt20-20070123.htm#element-param"><CODE>xsl:param</CODE></A> 
  children of that element. Such a parameter is known as a <B>template 
  parameter</B>. A template parameter is a <A title="local variable" 
  href="REC-xslt20-20070123.htm#dt-local-variable">local 
  variable</A> with the additional property that its value can be set when the 
  template is called, using any of the instructions <A 
  href="REC-xslt20-20070123.htm#element-call-template"><CODE>xsl:call-template</CODE></A>, 
  <A 
  href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A>, 
  <A 
  href="REC-xslt20-20070123.htm#element-apply-imports"><CODE>xsl:apply-imports</CODE></A>, 
  <SPAN>or <A 
  href="REC-xslt20-20070123.htm#element-next-match"><CODE>xsl:next-match</CODE></A></SPAN>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-template-rule">template 
  rule</A> 
  <DD>
  <P>A stylesheet contains a set of <B>template rules</B> (see <A 
  href="REC-xslt20-20070123.htm#rules"><I>6 Template 
  Rules</I></A>). A template rule has three parts: a <A title=pattern 
  href="REC-xslt20-20070123.htm#dt-pattern">pattern</A> 
  that is matched against nodes, a (possibly empty) set of <A 
  title="template parameter" 
  href="REC-xslt20-20070123.htm#dt-template-parameter">template 
  parameters</A>, and a <A title="sequence constructor" 
  href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
  constructor</A> that is evaluated to produce a sequence of items.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-temporary-output-state">temporary 
  output state</A> 
  <DD>
  <P>The second of the two <A title="output state" 
  href="REC-xslt20-20070123.htm#dt-output-state">output 
  states</A> is called <B>temporary output</B> state. This state applies when 
  instructions are writing to a <A title="temporary tree" 
  href="REC-xslt20-20070123.htm#dt-temporary-tree">temporary 
  tree</A> or any other non-final destination.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-temporary-tree">temporary 
  tree</A> 
  <DD>
  <P>The term <B>temporary tree</B> means any tree that is neither a <A 
  title="source tree" 
  href="REC-xslt20-20070123.htm#dt-source-tree">source 
  tree</A> nor a <A title="final result tree" 
  href="REC-xslt20-20070123.htm#dt-final-result-tree">final 
  result tree</A>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-top-level">top-level</A> 

  <DD>
  <P>An element occurring as a child of an <A 
  href="REC-xslt20-20070123.htm#element-stylesheet"><CODE>xsl:stylesheet</CODE></A> 
  element is called a <B>top-level</B> element.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-tunnel-parameter">tunnel 
  parameter</A> 
  <DD>
  <P>A parameter passed to a template may be defined as a <B>tunnel 
  parameter</B>. Tunnel parameters have the property that they are automatically 
  passed on by the called template to any further templates that it calls, and 
  so on recursively.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-annotation">type 
  annotation</A> 
  <DD>
  <P>The term <B>type annotation</B> is used in this specification to refer to 
  the value returned by the <CODE>dm:type-name</CODE> accessor of a node: see <A 
  href="http://www.w3.org/TR/xpath-datamodel/#dm-type-name">Section 5.14 
  type-name Accessor</A><SUP><SMALL>DM</SMALL></SUP>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-type-error">type 
  errors</A> 
  <DD>
  <P>Certain errors are classified as <B>type errors</B>. A type error occurs 
  when the value supplied as input to an operation is of the wrong type for that 
  operation, for example when an integer is supplied to an operation that 
  expects a node.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-typed-value">typed 
  value</A> 
  <DD>
  <P>The term <B>typed value</B> is defined in <A 
  href="http://www.w3.org/TR/xpath-datamodel/#dm-typed-value">Section 5.15 
  typed-value Accessor</A><SUP><SMALL>DM</SMALL></SUP>. Every node except an 
  element defined in the schema with element-only content has a <A 
  title="string value" 
  href="REC-xslt20-20070123.htm#dt-string-value">typed 
  value</A>. For example, the <A title="typed value" 
  href="REC-xslt20-20070123.htm#dt-typed-value">typed 
  value</A> of an attribute of type <CODE>xs:IDREFS</CODE> is a sequence of zero 
  or more <CODE>xs:IDREF</CODE> values.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-data-element">user-defined 
  data element</A> 
  <DD>
  <P>In addition to <A title=declaration 
  href="REC-xslt20-20070123.htm#dt-declaration">declarations</A>, 
  the <A 
  href="REC-xslt20-20070123.htm#element-stylesheet"><CODE>xsl:stylesheet</CODE></A> 
  element may contain any element not from the <A title="XSLT namespace" 
  href="REC-xslt20-20070123.htm#dt-xslt-namespace">XSLT 
  namespace</A>, provided that the <A title=expanded-QName 
  href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded-QName</A> 
  of the element has a non-null namespace URI. Such elements are referred to as 
  <B>user-defined data elements</B>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-value">value</A> 
  <DD>
  <P>A variable is a binding between a name and a value. The <B>value</B> of a 
  variable is any sequence (of nodes and/or atomic values), as defined in <A 
  href="REC-xslt20-20070123.htm#xpath-datamodel">[Data 
  Model]</A>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-variable">variable</A> 

  <DD>
  <P>The <A 
  href="REC-xslt20-20070123.htm#element-variable"><CODE>xsl:variable</CODE></A> 
  element declares a <B>variable</B>, which may be a <A title="global variable" 
  href="REC-xslt20-20070123.htm#dt-global-variable">global 
  variable</A> or a <A title="local variable" 
  href="REC-xslt20-20070123.htm#dt-local-variable">local 
  variable</A>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-variable-binding-element">variable-binding 
  element</A> 
  <DD>
  <P>The two elements <A 
  href="REC-xslt20-20070123.htm#element-variable"><CODE>xsl:variable</CODE></A> 
  and <A 
  href="REC-xslt20-20070123.htm#element-param"><CODE>xsl:param</CODE></A> 
  are referred to as <B>variable-binding elements</B></P>
  <DT><A 
  href="REC-xslt20-20070123.htm#dt-whitespace-text-node">whitespace 
  text node</A> 
  <DD>
  <P>A <B>whitespace text node</B> is a text node whose content consists 
  entirely of whitespace characters (that is, #x09, #x0A, #x0D, or 
  #x20).</P></DD></DL></DIV>
<DIV class=div1>
<H2><A id=element-syntax-summary name=element-syntax-summary></A>D Element 
Syntax Summary (Non-Normative)</H2>
<P>The syntax of each XSLT element is summarized below, together with the 
context in the stylesheet where the element may appear. Some elements 
(specifically, instructions) are allowed as a child of any element that is 
allowed to contain a sequence constructor. These elements are:</P>
<UL>
  <LI>Literal result elements 
  <LI>Extension instructions, if so defined </LI></UL>
<P><B><A 
href="REC-xslt20-20070123.htm#element-analyze-string">xsl:analyze-string</A></B></P>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD width="10%">&nbsp;</TD>
    <TD>
      <P><I>Category:</I> instruction</P>
      <P><I>Model:</I></P>
      <P 
      class=element-syntax-summary><CODE>&lt;xsl:analyze-string<BR>&nbsp;&nbsp;<B>select</B> 
      = <VAR>expression</VAR><BR>&nbsp;&nbsp;<B>regex</B> = { <VAR>string</VAR> 
      }<BR>&nbsp;&nbsp;flags? = { <VAR>string</VAR> }&gt;<BR>&nbsp;&nbsp;&lt;!-- 
      Content: (<A 
      href="REC-xslt20-20070123.htm#element-matching-substring">xsl:matching-substring</A>?, 
      <A 
      href="REC-xslt20-20070123.htm#element-non-matching-substring">xsl:non-matching-substring</A>?, 
      <A 
      href="REC-xslt20-20070123.htm#element-fallback">xsl:fallback</A>*) 
      --&gt;<BR>&lt;/xsl:analyze-string&gt;</CODE></P>
      <P><I>Permitted parent elements:</I></P>
      <UL>
        <LI>any XSLT element whose content model is <I>sequence constructor</I> 
        <LI>any literal result element </LI></UL></TD></TR></TBODY></TABLE>
<P><B><A 
href="REC-xslt20-20070123.htm#element-apply-imports">xsl:apply-imports</A></B></P>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD width="10%">&nbsp;</TD>
    <TD>
      <P><I>Category:</I> instruction</P>
      <P><I>Model:</I></P>
      <P 
      class=element-syntax-summary><CODE>&lt;xsl:apply-imports&gt;<BR>&nbsp;&nbsp;&lt;!-- 
      Content: <A 
      href="REC-xslt20-20070123.htm#element-with-param">xsl:with-param</A>* 
      --&gt;<BR>&lt;/xsl:apply-imports&gt;</CODE></P>
      <P><I>Permitted parent elements:</I></P>
      <UL>
        <LI>any XSLT element whose content model is <I>sequence constructor</I> 
        <LI>any literal result element </LI></UL></TD></TR></TBODY></TABLE>
<P><B><A 
href="REC-xslt20-20070123.htm#element-apply-templates">xsl:apply-templates</A></B></P>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD width="10%">&nbsp;</TD>
    <TD>
      <P><I>Category:</I> instruction</P>
      <P><I>Model:</I></P>
      <P 
      class=element-syntax-summary><CODE>&lt;xsl:apply-templates<BR>&nbsp;&nbsp;select? 
      = <VAR>expression</VAR><BR>&nbsp;&nbsp;mode? = 
      <VAR>token</VAR>&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: (<A 
      href="REC-xslt20-20070123.htm#element-sort">xsl:sort</A> 
      | <A 
      href="REC-xslt20-20070123.htm#element-with-param">xsl:with-param</A>)* 
      --&gt;<BR>&lt;/xsl:apply-templates&gt;</CODE></P>
      <P><I>Permitted parent elements:</I></P>
      <UL>
        <LI>any XSLT element whose content model is <I>sequence constructor</I> 
        <LI>any literal result element </LI></UL></TD></TR></TBODY></TABLE>
<P><B><A 
href="REC-xslt20-20070123.htm#element-attribute">xsl:attribute</A></B></P>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD width="10%">&nbsp;</TD>
    <TD>
      <P><I>Category:</I> instruction</P>
      <P><I>Model:</I></P>
      <P 
      class=element-syntax-summary><CODE>&lt;xsl:attribute<BR>&nbsp;&nbsp;<B>name</B> 
      = { <VAR>qname</VAR> }<BR>&nbsp;&nbsp;namespace? = { 
      <VAR>uri-reference</VAR> }<BR>&nbsp;&nbsp;select? = 
      <VAR>expression</VAR><BR>&nbsp;&nbsp;separator? = { <VAR>string</VAR> 
      }<BR>&nbsp;&nbsp;type? = <VAR>qname</VAR><BR>&nbsp;&nbsp;validation? = 
      "strict" | "lax" | "preserve" | "strip"&gt;<BR>&nbsp;&nbsp;&lt;!-- 
      Content: <VAR>sequence-constructor</VAR> 
      --&gt;<BR>&lt;/xsl:attribute&gt;</CODE></P>
      <P><I>Permitted parent elements:</I></P>
      <UL>
        <LI><CODE>xsl:attribute-set</CODE> 
        <LI>any XSLT element whose content model is <I>sequence constructor</I> 
        <LI>any literal result element </LI></UL></TD></TR></TBODY></TABLE>
<P><B><A 
href="REC-xslt20-20070123.htm#element-attribute-set">xsl:attribute-set</A></B></P>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD width="10%">&nbsp;</TD>
    <TD>
      <P><I>Category:</I> declaration</P>
      <P><I>Model:</I></P>
      <P 
      class=element-syntax-summary><CODE>&lt;xsl:attribute-set<BR>&nbsp;&nbsp;<B>name</B> 
      = <VAR>qname</VAR><BR>&nbsp;&nbsp;use-attribute-sets? = 
      <VAR>qnames</VAR>&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: <A 
      href="REC-xslt20-20070123.htm#element-attribute">xsl:attribute</A>* 
      --&gt;<BR>&lt;/xsl:attribute-set&gt;</CODE></P>
      <P><I>Permitted parent elements:</I></P>
      <UL>
        <LI><CODE>xsl:stylesheet</CODE> 
        <LI><CODE>xsl:transform</CODE> </LI></UL></TD></TR></TBODY></TABLE>
<P><B><A 
href="REC-xslt20-20070123.htm#element-call-template">xsl:call-template</A></B></P>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD width="10%">&nbsp;</TD>
    <TD>
      <P><I>Category:</I> instruction</P>
      <P><I>Model:</I></P>
      <P 
      class=element-syntax-summary><CODE>&lt;xsl:call-template<BR>&nbsp;&nbsp;<B>name</B> 
      = <VAR>qname</VAR>&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: <A 
      href="REC-xslt20-20070123.htm#element-with-param">xsl:with-param</A>* 
      --&gt;<BR>&lt;/xsl:call-template&gt;</CODE></P>
      <P><I>Permitted parent elements:</I></P>
      <UL>
        <LI>any XSLT element whose content model is <I>sequence constructor</I> 
        <LI>any literal result element </LI></UL></TD></TR></TBODY></TABLE>
<P><B><A 
href="REC-xslt20-20070123.htm#element-character-map">xsl:character-map</A></B></P>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD width="10%">&nbsp;</TD>
    <TD>
      <P><I>Category:</I> declaration</P>
      <P><I>Model:</I></P>
      <P 
      class=element-syntax-summary><CODE>&lt;xsl:character-map<BR>&nbsp;&nbsp;<B>name</B> 
      = <VAR>qname</VAR><BR>&nbsp;&nbsp;use-character-maps? = 
      <VAR>qnames</VAR>&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: (<A 
      href="REC-xslt20-20070123.htm#element-output-character">xsl:output-character</A>*) 
      --&gt;<BR>&lt;/xsl:character-map&gt;</CODE></P>
      <P><I>Permitted parent elements:</I></P>
      <UL>
        <LI><CODE>xsl:stylesheet</CODE> 
        <LI><CODE>xsl:transform</CODE> </LI></UL></TD></TR></TBODY></TABLE>
<P><B><A 
href="REC-xslt20-20070123.htm#element-choose">xsl:choose</A></B></P>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD width="10%">&nbsp;</TD>
    <TD>
      <P><I>Category:</I> instruction</P>
      <P><I>Model:</I></P>
      <P 
      class=element-syntax-summary><CODE>&lt;xsl:choose&gt;<BR>&nbsp;&nbsp;&lt;!-- 
      Content: (<A 
      href="REC-xslt20-20070123.htm#element-when">xsl:when</A>+, 
      <A 
      href="REC-xslt20-20070123.htm#element-otherwise">xsl:otherwise</A>?) 
      --&gt;<BR>&lt;/xsl:choose&gt;</CODE></P>
      <P><I>Permitted parent elements:</I></P>
      <UL>
        <LI>any XSLT element whose content model is <I>sequence constructor</I> 
        <LI>any literal result element </LI></UL></TD></TR></TBODY></TABLE>
<P><B><A 
href="REC-xslt20-20070123.htm#element-comment">xsl:comment</A></B></P>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD width="10%">&nbsp;</TD>
    <TD>
      <P><I>Category:</I> instruction</P>
      <P><I>Model:</I></P>
      <P 
      class=element-syntax-summary><CODE>&lt;xsl:comment<BR>&nbsp;&nbsp;select? 
      = <VAR>expression</VAR>&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: 
      <VAR>sequence-constructor</VAR> --&gt;<BR>&lt;/xsl:comment&gt;</CODE></P>
      <P><I>Permitted parent elements:</I></P>
      <UL>
        <LI>any XSLT element whose content model is <I>sequence constructor</I> 
        <LI>any literal result element </LI></UL></TD></TR></TBODY></TABLE>
<P><B><A 
href="REC-xslt20-20070123.htm#element-copy">xsl:copy</A></B></P>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD width="10%">&nbsp;</TD>
    <TD>
      <P><I>Category:</I> instruction</P>
      <P><I>Model:</I></P>
      <P 
      class=element-syntax-summary><CODE>&lt;xsl:copy<BR>&nbsp;&nbsp;copy-namespaces? 
      = "yes" | "no"<BR>&nbsp;&nbsp;inherit-namespaces? = "yes" | 
      "no"<BR>&nbsp;&nbsp;use-attribute-sets? = 
      <VAR>qnames</VAR><BR>&nbsp;&nbsp;type? = 
      <VAR>qname</VAR><BR>&nbsp;&nbsp;validation? = "strict" | "lax" | 
      "preserve" | "strip"&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: 
      <VAR>sequence-constructor</VAR> --&gt;<BR>&lt;/xsl:copy&gt;</CODE></P>
      <P><I>Permitted parent elements:</I></P>
      <UL>
        <LI>any XSLT element whose content model is <I>sequence constructor</I> 
        <LI>any literal result element </LI></UL></TD></TR></TBODY></TABLE>
<P><B><A 
href="REC-xslt20-20070123.htm#element-copy-of">xsl:copy-of</A></B></P>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD width="10%">&nbsp;</TD>
    <TD>
      <P><I>Category:</I> instruction</P>
      <P><I>Model:</I></P>
      <P 
      class=element-syntax-summary><CODE>&lt;xsl:copy-of<BR>&nbsp;&nbsp;<B>select</B> 
      = <VAR>expression</VAR><BR>&nbsp;&nbsp;copy-namespaces? = "yes" | 
      "no"<BR>&nbsp;&nbsp;type? = <VAR>qname</VAR><BR>&nbsp;&nbsp;validation? = 
      "strict" | "lax" | "preserve" | "strip"&nbsp;/&gt;</CODE></P>
      <P><I>Permitted parent elements:</I></P>
      <UL>
        <LI>any XSLT element whose content model is <I>sequence constructor</I> 
        <LI>any literal result element </LI></UL></TD></TR></TBODY></TABLE>
<P><B><A 
href="REC-xslt20-20070123.htm#element-decimal-format">xsl:decimal-format</A></B></P>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD width="10%">&nbsp;</TD>
    <TD>
      <P><I>Category:</I> declaration</P>
      <P><I>Model:</I></P>
      <P 
      class=element-syntax-summary><CODE>&lt;xsl:decimal-format<BR>&nbsp;&nbsp;name? 
      = <VAR>qname</VAR><BR>&nbsp;&nbsp;decimal-separator? = 
      <VAR>char</VAR><BR>&nbsp;&nbsp;grouping-separator? = 
      <VAR>char</VAR><BR>&nbsp;&nbsp;infinity? = 
      <VAR>string</VAR><BR>&nbsp;&nbsp;minus-sign? = 
      <VAR>char</VAR><BR>&nbsp;&nbsp;NaN? = 
      <VAR>string</VAR><BR>&nbsp;&nbsp;percent? = 
      <VAR>char</VAR><BR>&nbsp;&nbsp;per-mille? = 
      <VAR>char</VAR><BR>&nbsp;&nbsp;zero-digit? = 
      <VAR>char</VAR><BR>&nbsp;&nbsp;digit? = 
      <VAR>char</VAR><BR>&nbsp;&nbsp;pattern-separator? = 
      <VAR>char</VAR>&nbsp;/&gt;</CODE></P>
      <P><I>Permitted parent elements:</I></P>
      <UL>
        <LI><CODE>xsl:stylesheet</CODE> 
        <LI><CODE>xsl:transform</CODE> </LI></UL></TD></TR></TBODY></TABLE>
<P><B><A 
href="REC-xslt20-20070123.htm#element-document">xsl:document</A></B></P>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD width="10%">&nbsp;</TD>
    <TD>
      <P><I>Category:</I> instruction</P>
      <P><I>Model:</I></P>
      <P 
      class=element-syntax-summary><CODE>&lt;xsl:document<BR>&nbsp;&nbsp;validation? 
      = "strict" | "lax" | "preserve" | "strip"<BR>&nbsp;&nbsp;type? = 
      <VAR>qname</VAR>&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: 
      <VAR>sequence-constructor</VAR> --&gt;<BR>&lt;/xsl:document&gt;</CODE></P>
      <P><I>Permitted parent elements:</I></P>
      <UL>
        <LI>any XSLT element whose content model is <I>sequence constructor</I> 
        <LI>any literal result element </LI></UL></TD></TR></TBODY></TABLE>
<P><B><A 
href="REC-xslt20-20070123.htm#element-element">xsl:element</A></B></P>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD width="10%">&nbsp;</TD>
    <TD>
      <P><I>Category:</I> instruction</P>
      <P><I>Model:</I></P>
      <P 
      class=element-syntax-summary><CODE>&lt;xsl:element<BR>&nbsp;&nbsp;<B>name</B> 
      = { <VAR>qname</VAR> }<BR>&nbsp;&nbsp;namespace? = { 
      <VAR>uri-reference</VAR> }<BR>&nbsp;&nbsp;inherit-namespaces? = "yes" | 
      "no"<BR>&nbsp;&nbsp;use-attribute-sets? = 
      <VAR>qnames</VAR><BR>&nbsp;&nbsp;type? = 
      <VAR>qname</VAR><BR>&nbsp;&nbsp;validation? = "strict" | "lax" | 
      "preserve" | "strip"&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: 
      <VAR>sequence-constructor</VAR> --&gt;<BR>&lt;/xsl:element&gt;</CODE></P>
      <P><I>Permitted parent elements:</I></P>
      <UL>
        <LI>any XSLT element whose content model is <I>sequence constructor</I> 
        <LI>any literal result element </LI></UL></TD></TR></TBODY></TABLE>
<P><B><A 
href="REC-xslt20-20070123.htm#element-fallback">xsl:fallback</A></B></P>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD width="10%">&nbsp;</TD>
    <TD>
      <P><I>Category:</I> instruction</P>
      <P><I>Model:</I></P>
      <P 
      class=element-syntax-summary><CODE>&lt;xsl:fallback&gt;<BR>&nbsp;&nbsp;&lt;!-- 
      Content: <VAR>sequence-constructor</VAR> 
      --&gt;<BR>&lt;/xsl:fallback&gt;</CODE></P>
      <P><I>Permitted parent elements:</I></P>
      <UL>
        <LI>any XSLT element whose content model is <I>sequence constructor</I> 
        <LI>any literal result element </LI></UL></TD></TR></TBODY></TABLE>
<P><B><A 
href="REC-xslt20-20070123.htm#element-for-each">xsl:for-each</A></B></P>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD width="10%">&nbsp;</TD>
    <TD>
      <P><I>Category:</I> instruction</P>
      <P><I>Model:</I></P>
      <P 
      class=element-syntax-summary><CODE>&lt;xsl:for-each<BR>&nbsp;&nbsp;<B>select</B> 
      = <VAR>expression</VAR>&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: (<A 
      href="REC-xslt20-20070123.htm#element-sort">xsl:sort</A>*, 
      <VAR>sequence-constructor</VAR>) 
--&gt;<BR>&lt;/xsl:for-each&gt;</CODE></P>
      <P><I>Permitted parent elements:</I></P>
      <UL>
        <LI>any XSLT element whose content model is <I>sequence constructor</I> 
        <LI>any literal result element </LI></UL></TD></TR></TBODY></TABLE>
<P><B><A 
href="REC-xslt20-20070123.htm#element-for-each-group">xsl:for-each-group</A></B></P>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD width="10%">&nbsp;</TD>
    <TD>
      <P><I>Category:</I> instruction</P>
      <P><I>Model:</I></P>
      <P 
      class=element-syntax-summary><CODE>&lt;xsl:for-each-group<BR>&nbsp;&nbsp;<B>select</B> 
      = <VAR>expression</VAR><BR>&nbsp;&nbsp;group-by? = 
      <VAR>expression</VAR><BR>&nbsp;&nbsp;group-adjacent? = 
      <VAR>expression</VAR><BR>&nbsp;&nbsp;group-starting-with? = 
      <VAR>pattern</VAR><BR>&nbsp;&nbsp;group-ending-with? = 
      <VAR>pattern</VAR><BR>&nbsp;&nbsp;collation? = { <VAR>uri</VAR> 
      }&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: (<A 
      href="REC-xslt20-20070123.htm#element-sort">xsl:sort</A>*, 
      <VAR>sequence-constructor</VAR>) 
      --&gt;<BR>&lt;/xsl:for-each-group&gt;</CODE></P>
      <P><I>Permitted parent elements:</I></P>
      <UL>
        <LI>any XSLT element whose content model is <I>sequence constructor</I> 
        <LI>any literal result element </LI></UL></TD></TR></TBODY></TABLE>
<P><B><A 
href="REC-xslt20-20070123.htm#element-function">xsl:function</A></B></P>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD width="10%">&nbsp;</TD>
    <TD>
      <P><I>Category:</I> declaration</P>
      <P><I>Model:</I></P>
      <P 
      class=element-syntax-summary><CODE>&lt;xsl:function<BR>&nbsp;&nbsp;<B>name</B> 
      = <VAR>qname</VAR><BR>&nbsp;&nbsp;as? = 
      <VAR>sequence-type</VAR><BR>&nbsp;&nbsp;override? = "yes" | 
      "no"&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: (<A 
      href="REC-xslt20-20070123.htm#element-param">xsl:param</A>*, 
      <VAR>sequence-constructor</VAR>) 
--&gt;<BR>&lt;/xsl:function&gt;</CODE></P>
      <P><I>Permitted parent elements:</I></P>
      <UL>
        <LI><CODE>xsl:stylesheet</CODE> 
        <LI><CODE>xsl:transform</CODE> </LI></UL></TD></TR></TBODY></TABLE>
<P><B><A 
href="REC-xslt20-20070123.htm#element-if">xsl:if</A></B></P>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD width="10%">&nbsp;</TD>
    <TD>
      <P><I>Category:</I> instruction</P>
      <P><I>Model:</I></P>
      <P 
      class=element-syntax-summary><CODE>&lt;xsl:if<BR>&nbsp;&nbsp;<B>test</B> = 
      <VAR>expression</VAR>&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: 
      <VAR>sequence-constructor</VAR> --&gt;<BR>&lt;/xsl:if&gt;</CODE></P>
      <P><I>Permitted parent elements:</I></P>
      <UL>
        <LI>any XSLT element whose content model is <I>sequence constructor</I> 
        <LI>any literal result element </LI></UL></TD></TR></TBODY></TABLE>
<P><B><A 
href="REC-xslt20-20070123.htm#element-import">xsl:import</A></B></P>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD width="10%">&nbsp;</TD>
    <TD>
      <P><I>Category:</I> declaration</P>
      <P><I>Model:</I></P>
      <P 
      class=element-syntax-summary><CODE>&lt;xsl:import<BR>&nbsp;&nbsp;<B>href</B> 
      = <VAR>uri-reference</VAR>&nbsp;/&gt;</CODE></P>
      <P><I>Permitted parent elements:</I></P>
      <UL>
        <LI><CODE>xsl:stylesheet</CODE> 
        <LI><CODE>xsl:transform</CODE> </LI></UL></TD></TR></TBODY></TABLE>
<P><B><A 
href="REC-xslt20-20070123.htm#element-import-schema">xsl:import-schema</A></B></P>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD width="10%">&nbsp;</TD>
    <TD>
      <P><I>Category:</I> declaration</P>
      <P><I>Model:</I></P>
      <P 
      class=element-syntax-summary><CODE>&lt;xsl:import-schema<BR>&nbsp;&nbsp;namespace? 
      = <VAR>uri-reference</VAR><BR>&nbsp;&nbsp;schema-location? = 
      <VAR>uri-reference</VAR>&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: xs:schema? 
      --&gt;<BR>&lt;/xsl:import-schema&gt;</CODE></P>
      <P><I>Permitted parent elements:</I></P>
      <UL>
        <LI><CODE>xsl:stylesheet</CODE> 
        <LI><CODE>xsl:transform</CODE> </LI></UL></TD></TR></TBODY></TABLE>
<P><B><A 
href="REC-xslt20-20070123.htm#element-include">xsl:include</A></B></P>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD width="10%">&nbsp;</TD>
    <TD>
      <P><I>Category:</I> declaration</P>
      <P><I>Model:</I></P>
      <P 
      class=element-syntax-summary><CODE>&lt;xsl:include<BR>&nbsp;&nbsp;<B>href</B> 
      = <VAR>uri-reference</VAR>&nbsp;/&gt;</CODE></P>
      <P><I>Permitted parent elements:</I></P>
      <UL>
        <LI><CODE>xsl:stylesheet</CODE> 
        <LI><CODE>xsl:transform</CODE> </LI></UL></TD></TR></TBODY></TABLE>
<P><B><A 
href="REC-xslt20-20070123.htm#element-key">xsl:key</A></B></P>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD width="10%">&nbsp;</TD>
    <TD>
      <P><I>Category:</I> declaration</P>
      <P><I>Model:</I></P>
      <P 
      class=element-syntax-summary><CODE>&lt;xsl:key<BR>&nbsp;&nbsp;<B>name</B> 
      = <VAR>qname</VAR><BR>&nbsp;&nbsp;<B>match</B> = 
      <VAR>pattern</VAR><BR>&nbsp;&nbsp;use? = 
      <VAR>expression</VAR><BR>&nbsp;&nbsp;collation? = 
      <VAR>uri</VAR>&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: 
      <VAR>sequence-constructor</VAR> --&gt;<BR>&lt;/xsl:key&gt;</CODE></P>
      <P><I>Permitted parent elements:</I></P>
      <UL>
        <LI><CODE>xsl:stylesheet</CODE> 
        <LI><CODE>xsl:transform</CODE> </LI></UL></TD></TR></TBODY></TABLE>
<P><B><A 
href="REC-xslt20-20070123.htm#element-matching-substring">xsl:matching-substring</A></B></P>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD width="10%">&nbsp;</TD>
    <TD>
      <P><I>Model:</I></P>
      <P 
      class=element-syntax-summary><CODE>&lt;xsl:matching-substring&gt;<BR>&nbsp;&nbsp;&lt;!-- 
      Content: <VAR>sequence-constructor</VAR> 
      --&gt;<BR>&lt;/xsl:matching-substring&gt;</CODE></P>
      <P><I>Permitted parent elements:</I></P>
      <UL>
        <LI><CODE>xsl:analyze-string</CODE> </LI></UL></TD></TR></TBODY></TABLE>
<P><B><A 
href="REC-xslt20-20070123.htm#element-message">xsl:message</A></B></P>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD width="10%">&nbsp;</TD>
    <TD>
      <P><I>Category:</I> instruction</P>
      <P><I>Model:</I></P>
      <P 
      class=element-syntax-summary><CODE>&lt;xsl:message<BR>&nbsp;&nbsp;select? 
      = <VAR>expression</VAR><BR>&nbsp;&nbsp;terminate? = { "yes" | "no" 
      }&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: <VAR>sequence-constructor</VAR> 
      --&gt;<BR>&lt;/xsl:message&gt;</CODE></P>
      <P><I>Permitted parent elements:</I></P>
      <UL>
        <LI>any XSLT element whose content model is <I>sequence constructor</I> 
        <LI>any literal result element 
        <LI><CODE>xsl:function</CODE> </LI></UL></TD></TR></TBODY></TABLE>
<P><B><A 
href="REC-xslt20-20070123.htm#element-namespace">xsl:namespace</A></B></P>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD width="10%">&nbsp;</TD>
    <TD>
      <P><I>Category:</I> instruction</P>
      <P><I>Model:</I></P>
      <P 
      class=element-syntax-summary><CODE>&lt;xsl:namespace<BR>&nbsp;&nbsp;<B>name</B> 
      = { <VAR>ncname</VAR> }<BR>&nbsp;&nbsp;select? = 
      <VAR>expression</VAR>&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: 
      <VAR>sequence-constructor</VAR> 
--&gt;<BR>&lt;/xsl:namespace&gt;</CODE></P>
      <P><I>Permitted parent elements:</I></P>
      <UL>
        <LI>any XSLT element whose content model is <I>sequence constructor</I> 
        <LI>any literal result element </LI></UL></TD></TR></TBODY></TABLE>
<P><B><A 
href="REC-xslt20-20070123.htm#element-namespace-alias">xsl:namespace-alias</A></B></P>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD width="10%">&nbsp;</TD>
    <TD>
      <P><I>Category:</I> declaration</P>
      <P><I>Model:</I></P>
      <P 
      class=element-syntax-summary><CODE>&lt;xsl:namespace-alias<BR>&nbsp;&nbsp;<B>stylesheet-prefix</B> 
      = <VAR>prefix</VAR> | "#default"<BR>&nbsp;&nbsp;<B>result-prefix</B> = 
      <VAR>prefix</VAR> | "#default"&nbsp;/&gt;</CODE></P>
      <P><I>Permitted parent elements:</I></P>
      <UL>
        <LI><CODE>xsl:stylesheet</CODE> 
        <LI><CODE>xsl:transform</CODE> </LI></UL></TD></TR></TBODY></TABLE>
<P><B><A 
href="REC-xslt20-20070123.htm#element-next-match">xsl:next-match</A></B></P>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD width="10%">&nbsp;</TD>
    <TD>
      <P><I>Category:</I> instruction</P>
      <P><I>Model:</I></P>
      <P 
      class=element-syntax-summary><CODE>&lt;xsl:next-match&gt;<BR>&nbsp;&nbsp;&lt;!-- 
      Content: (<A 
      href="REC-xslt20-20070123.htm#element-with-param">xsl:with-param</A> 
      | <A 
      href="REC-xslt20-20070123.htm#element-fallback">xsl:fallback</A>)* 
      --&gt;<BR>&lt;/xsl:next-match&gt;</CODE></P>
      <P><I>Permitted parent elements:</I></P>
      <UL>
        <LI>any XSLT element whose content model is <I>sequence constructor</I> 
        <LI>any literal result element </LI></UL></TD></TR></TBODY></TABLE>
<P><B><A 
href="REC-xslt20-20070123.htm#element-non-matching-substring">xsl:non-matching-substring</A></B></P>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD width="10%">&nbsp;</TD>
    <TD>
      <P><I>Model:</I></P>
      <P 
      class=element-syntax-summary><CODE>&lt;xsl:non-matching-substring&gt;<BR>&nbsp;&nbsp;&lt;!-- 
      Content: <VAR>sequence-constructor</VAR> 
      --&gt;<BR>&lt;/xsl:non-matching-substring&gt;</CODE></P>
      <P><I>Permitted parent elements:</I></P>
      <UL>
        <LI><CODE>xsl:analyze-string</CODE> </LI></UL></TD></TR></TBODY></TABLE>
<P><B><A 
href="REC-xslt20-20070123.htm#element-number">xsl:number</A></B></P>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD width="10%">&nbsp;</TD>
    <TD>
      <P><I>Category:</I> instruction</P>
      <P><I>Model:</I></P>
      <P class=element-syntax-summary><CODE>&lt;xsl:number<BR>&nbsp;&nbsp;value? 
      = <VAR>expression</VAR><BR>&nbsp;&nbsp;select? = 
      <VAR>expression</VAR><BR>&nbsp;&nbsp;level? = "single" | "multiple" | 
      "any"<BR>&nbsp;&nbsp;count? = <VAR>pattern</VAR><BR>&nbsp;&nbsp;from? = 
      <VAR>pattern</VAR><BR>&nbsp;&nbsp;format? = { <VAR>string</VAR> 
      }<BR>&nbsp;&nbsp;lang? = { <VAR>nmtoken</VAR> 
      }<BR>&nbsp;&nbsp;letter-value? = { "alphabetic" | "traditional" 
      }<BR>&nbsp;&nbsp;ordinal? = { <VAR>string</VAR> 
      }<BR>&nbsp;&nbsp;grouping-separator? = { <VAR>char</VAR> 
      }<BR>&nbsp;&nbsp;grouping-size? = { <VAR>number</VAR> 
      }&nbsp;/&gt;</CODE></P>
      <P><I>Permitted parent elements:</I></P>
      <UL>
        <LI>any XSLT element whose content model is <I>sequence constructor</I> 
        <LI>any literal result element </LI></UL></TD></TR></TBODY></TABLE>
<P><B><A 
href="REC-xslt20-20070123.htm#element-otherwise">xsl:otherwise</A></B></P>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD width="10%">&nbsp;</TD>
    <TD>
      <P><I>Model:</I></P>
      <P 
      class=element-syntax-summary><CODE>&lt;xsl:otherwise&gt;<BR>&nbsp;&nbsp;&lt;!-- 
      Content: <VAR>sequence-constructor</VAR> 
      --&gt;<BR>&lt;/xsl:otherwise&gt;</CODE></P>
      <P><I>Permitted parent elements:</I></P>
      <UL>
        <LI><CODE>xsl:choose</CODE> </LI></UL></TD></TR></TBODY></TABLE>
<P><B><A 
href="REC-xslt20-20070123.htm#element-output">xsl:output</A></B></P>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD width="10%">&nbsp;</TD>
    <TD>
      <P><I>Category:</I> declaration</P>
      <P><I>Model:</I></P>
      <P class=element-syntax-summary><CODE>&lt;xsl:output<BR>&nbsp;&nbsp;name? 
      = <VAR>qname</VAR><BR>&nbsp;&nbsp;method? = "xml" | "html" | "xhtml" | 
      "text" | <VAR>qname-but-not-ncname</VAR><BR>&nbsp;&nbsp;byte-order-mark? = 
      "yes" | "no"<BR>&nbsp;&nbsp;cdata-section-elements? = 
      <VAR>qnames</VAR><BR>&nbsp;&nbsp;doctype-public? = 
      <VAR>string</VAR><BR>&nbsp;&nbsp;doctype-system? = 
      <VAR>string</VAR><BR>&nbsp;&nbsp;encoding? = 
      <VAR>string</VAR><BR>&nbsp;&nbsp;escape-uri-attributes? = "yes" | 
      "no"<BR>&nbsp;&nbsp;include-content-type? = "yes" | 
      "no"<BR>&nbsp;&nbsp;indent? = "yes" | "no"<BR>&nbsp;&nbsp;media-type? = 
      <VAR>string</VAR><BR>&nbsp;&nbsp;normalization-form? = "NFC" | "NFD" | 
      "NFKC" | "NFKD" | "fully-normalized" | "none" | 
      <VAR>nmtoken</VAR><BR>&nbsp;&nbsp;omit-xml-declaration? = "yes" | 
      "no"<BR>&nbsp;&nbsp;standalone? = "yes" | "no" | 
      "omit"<BR>&nbsp;&nbsp;undeclare-prefixes? = "yes" | 
      "no"<BR>&nbsp;&nbsp;use-character-maps? = 
      <VAR>qnames</VAR><BR>&nbsp;&nbsp;version? = 
      <VAR>nmtoken</VAR>&nbsp;/&gt;</CODE></P>
      <P><I>Permitted parent elements:</I></P>
      <UL>
        <LI><CODE>xsl:stylesheet</CODE> 
        <LI><CODE>xsl:transform</CODE> </LI></UL></TD></TR></TBODY></TABLE>
<P><B><A 
href="REC-xslt20-20070123.htm#element-output-character">xsl:output-character</A></B></P>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD width="10%">&nbsp;</TD>
    <TD>
      <P><I>Model:</I></P>
      <P 
      class=element-syntax-summary><CODE>&lt;xsl:output-character<BR>&nbsp;&nbsp;<B>character</B> 
      = <VAR>char</VAR><BR>&nbsp;&nbsp;<B>string</B> = 
      <VAR>string</VAR>&nbsp;/&gt;</CODE></P>
      <P><I>Permitted parent elements:</I></P>
      <UL>
        <LI><CODE>xsl:character-map</CODE> </LI></UL></TD></TR></TBODY></TABLE>
<P><B><A 
href="REC-xslt20-20070123.htm#element-param">xsl:param</A></B></P>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD width="10%">&nbsp;</TD>
    <TD>
      <P><I>Category:</I> declaration</P>
      <P><I>Model:</I></P>
      <P 
      class=element-syntax-summary><CODE>&lt;xsl:param<BR>&nbsp;&nbsp;<B>name</B> 
      = <VAR>qname</VAR><BR>&nbsp;&nbsp;select? = 
      <VAR>expression</VAR><BR>&nbsp;&nbsp;as? = 
      <VAR>sequence-type</VAR><BR>&nbsp;&nbsp;required? = "yes" | 
      "no"<BR>&nbsp;&nbsp;tunnel? = "yes" | "no"&gt;<BR>&nbsp;&nbsp;&lt;!-- 
      Content: <VAR>sequence-constructor</VAR> 
      --&gt;<BR>&lt;/xsl:param&gt;</CODE></P>
      <P><I>Permitted parent elements:</I></P>
      <UL>
        <LI><CODE>xsl:stylesheet</CODE> 
        <LI><CODE>xsl:transform</CODE> 
        <LI><CODE>xsl:function</CODE> 
        <LI><CODE>xsl:template</CODE> </LI></UL></TD></TR></TBODY></TABLE>
<P><B><A 
href="REC-xslt20-20070123.htm#element-perform-sort">xsl:perform-sort</A></B></P>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD width="10%">&nbsp;</TD>
    <TD>
      <P><I>Category:</I> instruction</P>
      <P><I>Model:</I></P>
      <P 
      class=element-syntax-summary><CODE>&lt;xsl:perform-sort<BR>&nbsp;&nbsp;select? 
      = <VAR>expression</VAR>&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: (<A 
      href="REC-xslt20-20070123.htm#element-sort">xsl:sort</A>+, 
      <VAR>sequence-constructor</VAR>) 
      --&gt;<BR>&lt;/xsl:perform-sort&gt;</CODE></P>
      <P><I>Permitted parent elements:</I></P>
      <UL>
        <LI>any XSLT element whose content model is <I>sequence constructor</I> 
        <LI>any literal result element </LI></UL></TD></TR></TBODY></TABLE>
<P><B><A 
href="REC-xslt20-20070123.htm#element-preserve-space">xsl:preserve-space</A></B></P>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD width="10%">&nbsp;</TD>
    <TD>
      <P><I>Category:</I> declaration</P>
      <P><I>Model:</I></P>
      <P 
      class=element-syntax-summary><CODE>&lt;xsl:preserve-space<BR>&nbsp;&nbsp;<B>elements</B> 
      = <VAR>tokens</VAR>&nbsp;/&gt;</CODE></P>
      <P><I>Permitted parent elements:</I></P>
      <UL>
        <LI><CODE>xsl:stylesheet</CODE> 
        <LI><CODE>xsl:transform</CODE> </LI></UL></TD></TR></TBODY></TABLE>
<P><B><A 
href="REC-xslt20-20070123.htm#element-processing-instruction">xsl:processing-instruction</A></B></P>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD width="10%">&nbsp;</TD>
    <TD>
      <P><I>Category:</I> instruction</P>
      <P><I>Model:</I></P>
      <P 
      class=element-syntax-summary><CODE>&lt;xsl:processing-instruction<BR>&nbsp;&nbsp;<B>name</B> 
      = { <VAR>ncname</VAR> }<BR>&nbsp;&nbsp;select? = 
      <VAR>expression</VAR>&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: 
      <VAR>sequence-constructor</VAR> 
      --&gt;<BR>&lt;/xsl:processing-instruction&gt;</CODE></P>
      <P><I>Permitted parent elements:</I></P>
      <UL>
        <LI>any XSLT element whose content model is <I>sequence constructor</I> 
        <LI>any literal result element </LI></UL></TD></TR></TBODY></TABLE>
<P><B><A 
href="REC-xslt20-20070123.htm#element-result-document">xsl:result-document</A></B></P>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD width="10%">&nbsp;</TD>
    <TD>
      <P><I>Category:</I> instruction</P>
      <P><I>Model:</I></P>
      <P 
      class=element-syntax-summary><CODE>&lt;xsl:result-document<BR>&nbsp;&nbsp;format? 
      = { <VAR>qname</VAR> }<BR>&nbsp;&nbsp;href? = { <VAR>uri-reference</VAR> 
      }<BR>&nbsp;&nbsp;validation? = "strict" | "lax" | "preserve" | 
      "strip"<BR>&nbsp;&nbsp;type? = <VAR>qname</VAR><BR>&nbsp;&nbsp;method? = { 
      "xml" | "html" | "xhtml" | "text" | <VAR>qname-but-not-ncname</VAR> 
      }<BR>&nbsp;&nbsp;byte-order-mark? = { "yes" | "no" 
      }<BR>&nbsp;&nbsp;cdata-section-elements? = { <VAR>qnames</VAR> 
      }<BR>&nbsp;&nbsp;doctype-public? = { <VAR>string</VAR> 
      }<BR>&nbsp;&nbsp;doctype-system? = { <VAR>string</VAR> 
      }<BR>&nbsp;&nbsp;encoding? = { <VAR>string</VAR> 
      }<BR>&nbsp;&nbsp;escape-uri-attributes? = { "yes" | "no" 
      }<BR>&nbsp;&nbsp;include-content-type? = { "yes" | "no" 
      }<BR>&nbsp;&nbsp;indent? = { "yes" | "no" }<BR>&nbsp;&nbsp;media-type? = { 
      <VAR>string</VAR> }<BR>&nbsp;&nbsp;normalization-form? = { "NFC" | "NFD" | 
      "NFKC" | "NFKD" | "fully-normalized" | "none" | <VAR>nmtoken</VAR> 
      }<BR>&nbsp;&nbsp;omit-xml-declaration? = { "yes" | "no" 
      }<BR>&nbsp;&nbsp;standalone? = { "yes" | "no" | "omit" 
      }<BR>&nbsp;&nbsp;undeclare-prefixes? = { "yes" | "no" 
      }<BR>&nbsp;&nbsp;use-character-maps? = 
      <VAR>qnames</VAR><BR>&nbsp;&nbsp;output-version? = { <VAR>nmtoken</VAR> 
      }&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: <VAR>sequence-constructor</VAR> 
      --&gt;<BR>&lt;/xsl:result-document&gt;</CODE></P>
      <P><I>Permitted parent elements:</I></P>
      <UL>
        <LI>any XSLT element whose content model is <I>sequence constructor</I> 
        <LI>any literal result element </LI></UL></TD></TR></TBODY></TABLE>
<P><B><A 
href="REC-xslt20-20070123.htm#element-sequence">xsl:sequence</A></B></P>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD width="10%">&nbsp;</TD>
    <TD>
      <P><I>Category:</I> instruction</P>
      <P><I>Model:</I></P>
      <P 
      class=element-syntax-summary><CODE>&lt;xsl:sequence<BR>&nbsp;&nbsp;<B>select</B> 
      = <VAR>expression</VAR>&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: <A 
      href="REC-xslt20-20070123.htm#element-fallback">xsl:fallback</A>* 
      --&gt;<BR>&lt;/xsl:sequence&gt;</CODE></P>
      <P><I>Permitted parent elements:</I></P>
      <UL>
        <LI>any XSLT element whose content model is <I>sequence constructor</I> 
        <LI>any literal result element </LI></UL></TD></TR></TBODY></TABLE>
<P><B><A 
href="REC-xslt20-20070123.htm#element-sort">xsl:sort</A></B></P>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD width="10%">&nbsp;</TD>
    <TD>
      <P><I>Model:</I></P>
      <P class=element-syntax-summary><CODE>&lt;xsl:sort<BR>&nbsp;&nbsp;select? 
      = <VAR>expression</VAR><BR>&nbsp;&nbsp;lang? = { <VAR>nmtoken</VAR> 
      }<BR>&nbsp;&nbsp;order? = { "ascending" | "descending" 
      }<BR>&nbsp;&nbsp;collation? = { <VAR>uri</VAR> }<BR>&nbsp;&nbsp;stable? = 
      { "yes" | "no" }<BR>&nbsp;&nbsp;case-order? = { "upper-first" | 
      "lower-first" }<BR>&nbsp;&nbsp;data-type? = { "text" | "number" | 
      <VAR>qname-but-not-ncname</VAR> }&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: 
      <VAR>sequence-constructor</VAR> --&gt;<BR>&lt;/xsl:sort&gt;</CODE></P>
      <P><I>Permitted parent elements:</I></P>
      <UL>
        <LI><CODE>xsl:apply-templates</CODE> 
        <LI><CODE>xsl:for-each</CODE> 
        <LI><CODE>xsl:for-each-group</CODE> 
        <LI><CODE>xsl:perform-sort</CODE> </LI></UL></TD></TR></TBODY></TABLE>
<P><B><A 
href="REC-xslt20-20070123.htm#element-strip-space">xsl:strip-space</A></B></P>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD width="10%">&nbsp;</TD>
    <TD>
      <P><I>Category:</I> declaration</P>
      <P><I>Model:</I></P>
      <P 
      class=element-syntax-summary><CODE>&lt;xsl:strip-space<BR>&nbsp;&nbsp;<B>elements</B> 
      = <VAR>tokens</VAR>&nbsp;/&gt;</CODE></P>
      <P><I>Permitted parent elements:</I></P>
      <UL>
        <LI><CODE>xsl:stylesheet</CODE> 
        <LI><CODE>xsl:transform</CODE> </LI></UL></TD></TR></TBODY></TABLE>
<P><B><A 
href="REC-xslt20-20070123.htm#element-stylesheet">xsl:stylesheet</A></B></P>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD width="10%">&nbsp;</TD>
    <TD>
      <P><I>Model:</I></P>
      <P 
      class=element-syntax-summary><CODE>&lt;xsl:stylesheet<BR>&nbsp;&nbsp;id? = 
      <VAR>id</VAR><BR>&nbsp;&nbsp;extension-element-prefixes? = 
      <VAR>tokens</VAR><BR>&nbsp;&nbsp;exclude-result-prefixes? = 
      <VAR>tokens</VAR><BR>&nbsp;&nbsp;<B>version</B> = 
      <VAR>number</VAR><BR>&nbsp;&nbsp;xpath-default-namespace? = 
      <VAR>uri</VAR><BR>&nbsp;&nbsp;default-validation? = "preserve" | 
      "strip"<BR>&nbsp;&nbsp;default-collation? = 
      <VAR>uri-list</VAR><BR>&nbsp;&nbsp;input-type-annotations? = "preserve" | 
      "strip" | "unspecified"&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: (<A 
      href="REC-xslt20-20070123.htm#element-import">xsl:import</A>*, 
      <VAR>other-declarations</VAR>) 
--&gt;<BR>&lt;/xsl:stylesheet&gt;</CODE></P>
      <P><I>Permitted parent elements:</I></P>
      <UL>
        <LI>None </LI></UL></TD></TR></TBODY></TABLE>
<P><B><A 
href="REC-xslt20-20070123.htm#element-template">xsl:template</A></B></P>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD width="10%">&nbsp;</TD>
    <TD>
      <P><I>Category:</I> declaration</P>
      <P><I>Model:</I></P>
      <P 
      class=element-syntax-summary><CODE>&lt;xsl:template<BR>&nbsp;&nbsp;match? 
      = <VAR>pattern</VAR><BR>&nbsp;&nbsp;name? = 
      <VAR>qname</VAR><BR>&nbsp;&nbsp;priority? = 
      <VAR>number</VAR><BR>&nbsp;&nbsp;mode? = 
      <VAR>tokens</VAR><BR>&nbsp;&nbsp;as? = 
      <VAR>sequence-type</VAR>&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: (<A 
      href="REC-xslt20-20070123.htm#element-param">xsl:param</A>*, 
      <VAR>sequence-constructor</VAR>) 
--&gt;<BR>&lt;/xsl:template&gt;</CODE></P>
      <P><I>Permitted parent elements:</I></P>
      <UL>
        <LI><CODE>xsl:stylesheet</CODE> 
        <LI><CODE>xsl:transform</CODE> </LI></UL></TD></TR></TBODY></TABLE>
<P><B><A 
href="REC-xslt20-20070123.htm#element-text">xsl:text</A></B></P>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD width="10%">&nbsp;</TD>
    <TD>
      <P><I>Category:</I> instruction</P>
      <P><I>Model:</I></P>
      <P class=element-syntax-summary><CODE>&lt;xsl:text<BR>&nbsp;&nbsp;<SPAN 
      class=grayed>[disable-output-escaping]?</SPAN> = "yes" | 
      "no"&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: #PCDATA 
      --&gt;<BR>&lt;/xsl:text&gt;</CODE></P>
      <P><I>Permitted parent elements:</I></P>
      <UL>
        <LI>any XSLT element whose content model is <I>sequence constructor</I> 
        <LI>any literal result element </LI></UL></TD></TR></TBODY></TABLE>
<P><B><A 
href="REC-xslt20-20070123.htm#element-transform">xsl:transform</A></B></P>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD width="10%">&nbsp;</TD>
    <TD>
      <P><I>Model:</I></P>
      <P class=element-syntax-summary><CODE>&lt;xsl:transform<BR>&nbsp;&nbsp;id? 
      = <VAR>id</VAR><BR>&nbsp;&nbsp;extension-element-prefixes? = 
      <VAR>tokens</VAR><BR>&nbsp;&nbsp;exclude-result-prefixes? = 
      <VAR>tokens</VAR><BR>&nbsp;&nbsp;<B>version</B> = 
      <VAR>number</VAR><BR>&nbsp;&nbsp;xpath-default-namespace? = 
      <VAR>uri</VAR><BR>&nbsp;&nbsp;default-validation? = "preserve" | 
      "strip"<BR>&nbsp;&nbsp;default-collation? = 
      <VAR>uri-list</VAR><BR>&nbsp;&nbsp;input-type-annotations? = "preserve" | 
      "strip" | "unspecified"&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: (<A 
      href="REC-xslt20-20070123.htm#element-import">xsl:import</A>*, 
      <VAR>other-declarations</VAR>) --&gt;<BR>&lt;/xsl:transform&gt;</CODE></P>
      <P><I>Permitted parent elements:</I></P>
      <UL>
        <LI>None </LI></UL></TD></TR></TBODY></TABLE>
<P><B><A 
href="REC-xslt20-20070123.htm#element-value-of">xsl:value-of</A></B></P>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD width="10%">&nbsp;</TD>
    <TD>
      <P><I>Category:</I> instruction</P>
      <P><I>Model:</I></P>
      <P 
      class=element-syntax-summary><CODE>&lt;xsl:value-of<BR>&nbsp;&nbsp;select? 
      = <VAR>expression</VAR><BR>&nbsp;&nbsp;separator? = { <VAR>string</VAR> 
      }<BR>&nbsp;&nbsp;<SPAN class=grayed>[disable-output-escaping]?</SPAN> = 
      "yes" | "no"&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: 
      <VAR>sequence-constructor</VAR> --&gt;<BR>&lt;/xsl:value-of&gt;</CODE></P>
      <P><I>Permitted parent elements:</I></P>
      <UL>
        <LI>any XSLT element whose content model is <I>sequence constructor</I> 
        <LI>any literal result element </LI></UL></TD></TR></TBODY></TABLE>
<P><B><A 
href="REC-xslt20-20070123.htm#element-variable">xsl:variable</A></B></P>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD width="10%">&nbsp;</TD>
    <TD>
      <P><I>Category:</I> declaration instruction</P>
      <P><I>Model:</I></P>
      <P 
      class=element-syntax-summary><CODE>&lt;xsl:variable<BR>&nbsp;&nbsp;<B>name</B> 
      = <VAR>qname</VAR><BR>&nbsp;&nbsp;select? = 
      <VAR>expression</VAR><BR>&nbsp;&nbsp;as? = 
      <VAR>sequence-type</VAR>&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: 
      <VAR>sequence-constructor</VAR> --&gt;<BR>&lt;/xsl:variable&gt;</CODE></P>
      <P><I>Permitted parent elements:</I></P>
      <UL>
        <LI><CODE>xsl:stylesheet</CODE> 
        <LI><CODE>xsl:transform</CODE> 
        <LI><CODE>xsl:function</CODE> 
        <LI>any XSLT element whose content model is <I>sequence constructor</I> 
        <LI>any literal result element </LI></UL></TD></TR></TBODY></TABLE>
<P><B><A 
href="REC-xslt20-20070123.htm#element-when">xsl:when</A></B></P>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD width="10%">&nbsp;</TD>
    <TD>
      <P><I>Model:</I></P>
      <P 
      class=element-syntax-summary><CODE>&lt;xsl:when<BR>&nbsp;&nbsp;<B>test</B> 
      = <VAR>expression</VAR>&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: 
      <VAR>sequence-constructor</VAR> --&gt;<BR>&lt;/xsl:when&gt;</CODE></P>
      <P><I>Permitted parent elements:</I></P>
      <UL>
        <LI><CODE>xsl:choose</CODE> </LI></UL></TD></TR></TBODY></TABLE>
<P><B><A 
href="REC-xslt20-20070123.htm#element-with-param">xsl:with-param</A></B></P>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD width="10%">&nbsp;</TD>
    <TD>
      <P><I>Model:</I></P>
      <P 
      class=element-syntax-summary><CODE>&lt;xsl:with-param<BR>&nbsp;&nbsp;<B>name</B> 
      = <VAR>qname</VAR><BR>&nbsp;&nbsp;select? = 
      <VAR>expression</VAR><BR>&nbsp;&nbsp;as? = 
      <VAR>sequence-type</VAR><BR>&nbsp;&nbsp;tunnel? = "yes" | 
      "no"&gt;<BR>&nbsp;&nbsp;&lt;!-- Content: <VAR>sequence-constructor</VAR> 
      --&gt;<BR>&lt;/xsl:with-param&gt;</CODE></P>
      <P><I>Permitted parent elements:</I></P>
      <UL>
        <LI><CODE>xsl:apply-templates</CODE> 
        <LI><CODE>xsl:apply-imports</CODE> 
        <LI><CODE>xsl:call-template</CODE> 
        <LI><CODE>xsl:next-match</CODE> </LI></UL></TD></TR></TBODY></TABLE></DIV>
<DIV class=div1>
<H2><A id=error-summary name=error-summary></A>E Summary of Error Conditions 
(Non-Normative)</H2>
<P>This appendix provides a summary of error conditions that a processor may 
signal. This list is not exhaustive or definitive. The errors are numbered for 
ease of reference, but there is no implication that an implementation <SPAN 
class=verb>must</SPAN> signal errors using these error codes, or that 
applications can test for these codes. Moreover, implementations are not <SPAN 
class=verb>required</SPAN> to signal errors using the descriptive text used 
here.</P>
<P><B>Static errors</B></P>
<DL>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE0010"><SPAN 
  class=error>ERR XTSE0010</SPAN></A> 
  <DD>
  <P>A <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A> is signaled if an XSLT-defined element is used in a context where it 
  is not permitted, if a <SPAN class=verb>required</SPAN> attribute is omitted, 
  or if the content of the element does not correspond to the content that is 
  allowed for the element.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE0020"><SPAN 
  class=error>ERR XTSE0020</SPAN></A> 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A> if an attribute (other than an attribute written using curly 
  brackets in a position where an <A title="attribute value template" 
  href="REC-xslt20-20070123.htm#dt-attribute-value-template">attribute 
  value template</A> is permitted) contains a value that is not one of the 
  permitted values for that attribute.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE0080"><SPAN 
  class=error>ERR XTSE0080</SPAN></A> 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A> to use a <A title="reserved namespace" 
  href="REC-xslt20-20070123.htm#dt-reserved-namespace">reserved 
  namespace</A> in the name of a <A title="named template" 
  href="REC-xslt20-20070123.htm#dt-named-template">named 
  template</A>, a <A title=mode 
  href="REC-xslt20-20070123.htm#dt-mode">mode</A>, an <A 
  title="attribute set" 
  href="REC-xslt20-20070123.htm#dt-attribute-set">attribute 
  set</A>, a <A title=key 
  href="REC-xslt20-20070123.htm#dt-key">key</A>, a <A 
  title="decimal format" 
  href="REC-xslt20-20070123.htm#dt-decimal-format">decimal-format</A>, 
  a <A title=variable 
  href="REC-xslt20-20070123.htm#dt-variable">variable</A> 
  or <A title=parameter 
  href="REC-xslt20-20070123.htm#dt-parameter">parameter</A>, 
  a <A title="stylesheet function" 
  href="REC-xslt20-20070123.htm#dt-stylesheet-function">stylesheet 
  function</A>, a named <A title="output definition" 
  href="REC-xslt20-20070123.htm#dt-output-definition">output 
  definition</A>, or a <A title="character map" 
  href="REC-xslt20-20070123.htm#dt-character-map">character 
  map</A>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE0090"><SPAN 
  class=error>ERR XTSE0090</SPAN></A> 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A> for an element from the XSLT namespace to have an attribute whose 
  namespace is either null (that is, an attribute with an unprefixed name) or 
  the XSLT namespace, other than attributes defined for the element in this 
  document.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE0110"><SPAN 
  class=error>ERR XTSE0110</SPAN></A> 
  <DD>
  <P>The value of the <CODE>version</CODE> attribute <SPAN 
  class=verb>must</SPAN> be a number: specifically, it <SPAN 
  class=verb>must</SPAN> be a <SPAN>a valid instance of the type 
  <CODE>xs:decimal</CODE> as defined in <A 
  href="REC-xslt20-20070123.htm#xmlschema-2">[XML Schema 
  Part 2]</A></SPAN>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE0120"><SPAN 
  class=error>ERR XTSE0120</SPAN></A> 
  <DD>
  <P>An <A 
  href="REC-xslt20-20070123.htm#element-stylesheet"><CODE>xsl:stylesheet</CODE></A> 
  element <SPAN class=verb>must not</SPAN> have any text node children.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE0125"><SPAN 
  class=error>ERR XTSE0125</SPAN></A> 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A> if the value of an <CODE>[xsl:]default-collation</CODE> 
  attribute<SPAN>, after resolving against the base URI,</SPAN> contains no URI 
  that the implementation recognizes as a collation URI.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE0130"><SPAN 
  class=error>ERR XTSE0130</SPAN></A> 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A> if the <A 
  href="REC-xslt20-20070123.htm#element-stylesheet"><CODE>xsl:stylesheet</CODE></A> 
  element has a child element whose name has a null namespace URI.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE0150"><SPAN 
  class=error>ERR XTSE0150</SPAN></A> 
  <DD>
  <P>A <A title="literal result element" 
  href="REC-xslt20-20070123.htm#dt-literal-result-element">literal 
  result element</A> that is used as the outermost element of a simplified 
  stylesheet module <SPAN class=verb>must</SPAN> have an 
  <CODE>xsl:version</CODE> attribute.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE0165"><SPAN 
  class=error>ERR XTSE0165</SPAN></A> 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A> if the processor is not able to retrieve the resource identified by 
  the URI reference [ in the <CODE>href</CODE> attribute of <A 
  href="REC-xslt20-20070123.htm#element-include"><CODE>xsl:include</CODE></A> 
  or <A 
  href="REC-xslt20-20070123.htm#element-import"><CODE>xsl:import</CODE></A>] 
  , or if the resource that is retrieved does not contain a stylesheet module 
  conforming to this specification.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE0170"><SPAN 
  class=error>ERR XTSE0170</SPAN></A> 
  <DD>
  <P>An <A 
  href="REC-xslt20-20070123.htm#element-include"><CODE>xsl:include</CODE></A> 
  element <SPAN class=verb>must</SPAN> be a <A title=top-level 
  href="REC-xslt20-20070123.htm#dt-top-level">top-level</A> 
  element.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE0180"><SPAN 
  class=error>ERR XTSE0180</SPAN></A> 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A> if a stylesheet module directly or indirectly includes itself.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE0190"><SPAN 
  class=error>ERR XTSE0190</SPAN></A> 
  <DD>
  <P>An <A 
  href="REC-xslt20-20070123.htm#element-import"><CODE>xsl:import</CODE></A> 
  element <SPAN class=verb>must</SPAN> be a <A title=top-level 
  href="REC-xslt20-20070123.htm#dt-top-level">top-level</A> 
  element.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE0200"><SPAN 
  class=error>ERR XTSE0200</SPAN></A> 
  <DD>
  <P>The <A 
  href="REC-xslt20-20070123.htm#element-import"><CODE>xsl:import</CODE></A> 
  element children <SPAN class=verb>must</SPAN> precede all other element 
  children of an <A 
  href="REC-xslt20-20070123.htm#element-stylesheet"><CODE>xsl:stylesheet</CODE></A> 
  element, including any <A 
  href="REC-xslt20-20070123.htm#element-include"><CODE>xsl:include</CODE></A> 
  element children and any <A title="user-defined data element" 
  href="REC-xslt20-20070123.htm#dt-data-element">user-defined 
  data elements</A>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE0210"><SPAN 
  class=error>ERR XTSE0210</SPAN></A> 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A> if a stylesheet module directly or indirectly imports itself.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE0215"><SPAN 
  class=error>ERR XTSE0215</SPAN></A> 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A> if an <A 
  href="REC-xslt20-20070123.htm#element-import-schema"><CODE>xsl:import-schema</CODE></A> 
  element that contains an <CODE>xs:schema</CODE> element has a 
  <CODE>schema-location</CODE> attribute, or if it has a <CODE>namespace</CODE> 
  attribute that conflicts with the target namespace of the contained 
schema.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE0220"><SPAN 
  class=error>ERR XTSE0220</SPAN></A> 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A> if the synthetic schema document does not satisfy the constraints 
  described in <A 
  href="REC-xslt20-20070123.htm#xmlschema-1">[XML Schema 
  Part 1]</A> (section 5.1, <EM>Errors in Schema Construction and 
  Structure</EM>). This includes, without loss of generality, conflicts such as 
  multiple definitions of the same name.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE0260"><SPAN 
  class=error>ERR XTSE0260</SPAN></A> 
  <DD>
  <P>Within an <A title="XSLT element" 
  href="REC-xslt20-20070123.htm#dt-xslt-element">XSLT 
  element</A> that is <SPAN class=verb>required</SPAN> to be empty, any content 
  other than comments or processing instructions, including any <A 
  title="whitespace text node" 
  href="REC-xslt20-20070123.htm#dt-whitespace-text-node">whitespace 
  text node</A> preserved using the <CODE>xml:space="preserve"</CODE> attribute, 
  is a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE0265"><SPAN 
  class=error>ERR XTSE0265</SPAN></A> 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A> if there is a <A title="stylesheet module" 
  href="REC-xslt20-20070123.htm#dt-stylesheet-module">stylesheet 
  module</A> in the <A title=stylesheet 
  href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
  that specifies <CODE>input-type-annotations="strip"</CODE> and another <A 
  title="stylesheet module" 
  href="REC-xslt20-20070123.htm#dt-stylesheet-module">stylesheet 
  module</A> that specifies <CODE>input-type-annotations="preserve"</CODE>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE0280"><SPAN 
  class=error>ERR XTSE0280</SPAN></A> 
  <DD>
  <P>In the case of a <SPAN>prefixed</SPAN> <A title=QName 
  href="REC-xslt20-20070123.htm#dt-qname">QName</A> used 
  as the value of an attribute in the <A title=stylesheet 
  href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A>, 
  or appearing within an XPath <A title=expression 
  href="REC-xslt20-20070123.htm#dt-expression">expression</A> 
  in the stylesheet, it is a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A> if the <A title="defining element" 
  href="REC-xslt20-20070123.htm#dt-defining-element">defining 
  element</A> has no namespace node whose name matches the prefix of the <A 
  title=QName 
  href="REC-xslt20-20070123.htm#dt-qname">QName</A>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE0340"><SPAN 
  class=error>ERR XTSE0340</SPAN></A> 
  <DD>
  <P>Where an attribute is defined to contain a <A title=pattern 
  href="REC-xslt20-20070123.htm#dt-pattern">pattern</A>, 
  it is a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A> if the pattern does not match the production <A 
  href="REC-xslt20-20070123.htm#NT-Pattern">Pattern</A>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE0350"><SPAN 
  class=error>ERR XTSE0350</SPAN></A> 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A> if an unescaped left curly bracket appears in a fixed part of an 
  attribute value template without a matching right curly bracket.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE0370"><SPAN 
  class=error>ERR XTSE0370</SPAN></A> 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A> if an unescaped right curly bracket occurs in a fixed part of an 
  attribute value template.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE0500"><SPAN 
  class=error>ERR XTSE0500</SPAN></A> 
  <DD>
  <P>An <A 
  href="REC-xslt20-20070123.htm#element-template"><CODE>xsl:template</CODE></A> 
  element <SPAN class=verb>must</SPAN> have either a <CODE>match</CODE> 
  attribute or a <CODE>name</CODE> attribute, or both. An <A 
  href="REC-xslt20-20070123.htm#element-template"><CODE>xsl:template</CODE></A> 
  element that has no <CODE>match</CODE> attribute <SPAN class=verb>must</SPAN> 
  have no <CODE>mode</CODE> attribute and no <CODE>priority</CODE> 
attribute.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE0530"><SPAN 
  class=error>ERR XTSE0530</SPAN></A> 
  <DD>
  <P>The value of this attribute [the <CODE>priority</CODE> attribute of the <A 
  href="REC-xslt20-20070123.htm#element-template"><CODE>xsl:template</CODE></A> 
  element] <SPAN class=verb>must</SPAN> <SPAN>conform to the rules for the 
  <CODE>xs:decimal</CODE> type defined in <A 
  href="REC-xslt20-20070123.htm#xmlschema-2">[XML Schema 
  Part 2]</A>. Negative values are permitted.</SPAN>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE0550"><SPAN 
  class=error>ERR XTSE0550</SPAN></A> 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A> if the list [of modes in the <CODE>mode</CODE> attribute of <A 
  href="REC-xslt20-20070123.htm#element-template"><CODE>xsl:template</CODE></A>] 
  is empty, if the same token is included more than once in the list, if the 
  list contains an invalid token, or if the token <CODE>#all</CODE> appears 
  together with any other value.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE0580"><SPAN 
  class=error>ERR XTSE0580</SPAN></A> 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A> if two parameters of a template or of a stylesheet function have the 
  same name.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE0620"><SPAN 
  class=error>ERR XTSE0620</SPAN></A> 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A> if a <A title="variable-binding element" 
  href="REC-xslt20-20070123.htm#dt-variable-binding-element">variable-binding 
  element</A> has a <CODE>select</CODE> attribute and has non-empty content.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE0630"><SPAN 
  class=error>ERR XTSE0630</SPAN></A> 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A> if a <A title=stylesheet 
  href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
  contains more than one binding of a global variable with the same name and 
  same <A title="import precedence" 
  href="REC-xslt20-20070123.htm#dt-import-precedence">import 
  precedence</A><SPAN>, unless it also contains another binding with the same 
  name and higher import precedence</SPAN>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE0650"><SPAN 
  class=error>ERR XTSE0650</SPAN></A> 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A> if a <A title=stylesheet 
  href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
  contains an <A 
  href="REC-xslt20-20070123.htm#element-call-template"><CODE>xsl:call-template</CODE></A> 
  instruction whose <CODE>name</CODE> attribute does not match the 
  <CODE>name</CODE> attribute of any <A 
  href="REC-xslt20-20070123.htm#element-template"><CODE>xsl:template</CODE></A> 
  in the <A title=stylesheet 
  href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE0660"><SPAN 
  class=error>ERR XTSE0660</SPAN></A> 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A> if a <A title=stylesheet 
  href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
  contains more than one <A title=template 
  href="REC-xslt20-20070123.htm#dt-template">template</A> 
  with the same name and the same <A title="import precedence" 
  href="REC-xslt20-20070123.htm#dt-import-precedence">import 
  precedence</A><SPAN>, unless it also contains a <A title=template 
  href="REC-xslt20-20070123.htm#dt-template">template</A> 
  with the same name and higher <A title="import precedence" 
  href="REC-xslt20-20070123.htm#dt-import-precedence">import 
  precedence</A></SPAN>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE0670"><SPAN 
  class=error>ERR XTSE0670</SPAN></A> 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A> if a single <A 
  href="REC-xslt20-20070123.htm#element-call-template"><CODE>xsl:call-template</CODE></A>, 
  <A 
  href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A>, 
  <A 
  href="REC-xslt20-20070123.htm#element-apply-imports"><CODE>xsl:apply-imports</CODE></A>, 
  <SPAN>or <A 
  href="REC-xslt20-20070123.htm#element-next-match"><CODE>xsl:next-match</CODE></A></SPAN> 
  element contains two or more <A 
  href="REC-xslt20-20070123.htm#element-with-param"><CODE>xsl:with-param</CODE></A> 
  elements with <SPAN>matching <CODE>name</CODE> attributes</SPAN>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE0680"><SPAN 
  class=error>ERR XTSE0680</SPAN></A> 
  <DD>
  <P>In the case of <A 
  href="REC-xslt20-20070123.htm#element-call-template"><CODE>xsl:call-template</CODE></A>, 
  it is a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A> to pass a <SPAN>non-tunnel</SPAN> parameter named <VAR>x</VAR> to a 
  template that does not have a <A title="template parameter" 
  href="REC-xslt20-20070123.htm#dt-template-parameter">template 
  parameter</A> named <VAR>x</VAR><SPAN>, unless <A 
  title="backwards compatible behavior" 
  href="REC-xslt20-20070123.htm#dt-backwards-compatible-behavior">backwards 
  compatible behavior</A> is enabled for the <A 
  href="REC-xslt20-20070123.htm#element-call-template"><CODE>xsl:call-template</CODE></A> 
  instruction</SPAN>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE0690"><SPAN 
  class=error>ERR XTSE0690</SPAN></A> 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A> if a template that is invoked using <A 
  href="REC-xslt20-20070123.htm#element-call-template"><CODE>xsl:call-template</CODE></A> 
  declares a <A title="template parameter" 
  href="REC-xslt20-20070123.htm#dt-template-parameter">template 
  parameter</A> specifying <CODE>required="yes"</CODE> <SPAN>and not specifying 
  <CODE>tunnel="yes"</CODE></SPAN>, if no value for this parameter is supplied 
  by the calling instruction.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE0710"><SPAN 
  class=error>ERR XTSE0710</SPAN></A> 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A> if the value of the <CODE>use-attribute-sets</CODE> attribute of an 
  <A 
  href="REC-xslt20-20070123.htm#element-copy"><CODE>xsl:copy</CODE></A>, 
  <A 
  href="REC-xslt20-20070123.htm#element-element"><CODE>xsl:element</CODE></A>, 
  or <A 
  href="REC-xslt20-20070123.htm#element-attribute-set"><CODE>xsl:attribute-set</CODE></A> 
  element, or the <CODE>xsl:use-attribute-sets</CODE> attribute of a <A 
  title="literal result element" 
  href="REC-xslt20-20070123.htm#dt-literal-result-element">literal 
  result element</A>, is not a <SPAN>whitespace-separated</SPAN> sequence of <A 
  title=QName 
  href="REC-xslt20-20070123.htm#dt-qname">QNames</A>, or 
  if it contains a QName that does not match the <CODE>name</CODE> attribute of 
  any <A 
  href="REC-xslt20-20070123.htm#element-attribute-set"><CODE>xsl:attribute-set</CODE></A> 
  declaration in the stylesheet.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE0720"><SPAN 
  class=error>ERR XTSE0720</SPAN></A> 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A> if an <A 
  href="REC-xslt20-20070123.htm#element-attribute-set"><CODE>xsl:attribute-set</CODE></A> 
  element directly or indirectly references itself via the names contained in 
  the <CODE>use-attribute-sets</CODE> attribute.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE0740"><SPAN 
  class=error>ERR XTSE0740</SPAN></A> 
  <DD>
  <P>A <A title="stylesheet function" 
  href="REC-xslt20-20070123.htm#dt-stylesheet-function">stylesheet 
  function</A> <SPAN class=verb>must</SPAN> have a prefixed name, to remove any 
  risk of a clash with a function in the default function namespace. It is a <A 
  title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A> if the name has no prefix.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE0760"><SPAN 
  class=error>ERR XTSE0760</SPAN></A> 
  <DD>
  <P>Because arguments to a stylesheet function call <SPAN 
  class=verb>must</SPAN> all be specified, the <A 
  href="REC-xslt20-20070123.htm#element-param"><CODE>xsl:param</CODE></A> 
  elements within an <A 
  href="REC-xslt20-20070123.htm#element-function"><CODE>xsl:function</CODE></A> 
  element <SPAN class=verb>must not</SPAN> specify a default value: this means 
  they <SPAN class=verb>must</SPAN> be empty, and <SPAN class=verb>must 
  not</SPAN> have a <CODE>select</CODE> attribute.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE0770"><SPAN 
  class=error>ERR XTSE0770</SPAN></A> 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A> for a <A title=stylesheet 
  href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
  to contain two or more functions with the same <A title=expanded-QName 
  href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded-QName</A>, 
  the same <A title=arity 
  href="REC-xslt20-20070123.htm#dt-arity">arity</A>, and 
  the same <A title="import precedence" 
  href="REC-xslt20-20070123.htm#dt-import-precedence">import 
  precedence</A>, unless there is another function with the same <A 
  title=expanded-QName 
  href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded-QName</A> 
  and arity, and a higher import precedence.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE0805"><SPAN 
  class=error>ERR XTSE0805</SPAN></A> 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A> if an attribute on a literal result element is in the <A 
  title="XSLT namespace" 
  href="REC-xslt20-20070123.htm#dt-xslt-namespace">XSLT 
  namespace</A>, unless it is one of the attributes explicitly defined in this 
  specification.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE0808"><SPAN 
  class=error>ERR XTSE0808</SPAN></A> 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A> if a namespace prefix is used within the 
  <CODE>[xsl:]exclude-result-prefixes</CODE> attribute and there is no namespace 
  binding in scope for that prefix.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE0809"><SPAN 
  class=error>ERR XTSE0809</SPAN></A> 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A> if the value <CODE>#default</CODE> is used within the 
  <CODE>[xsl:]exclude-result-prefixes</CODE> attribute and the parent element of 
  the <CODE>[xsl:]exclude-result-prefixes</CODE> attribute has no default 
  namespace.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE0810"><SPAN 
  class=error>ERR XTSE0810</SPAN></A> 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A> if there is more than one such declaration [more than one <A 
  href="REC-xslt20-20070123.htm#element-namespace-alias"><CODE>xsl:namespace-alias</CODE></A> 
  declaration] with the same <A title="literal namespace URI" 
  href="REC-xslt20-20070123.htm#dt-literal-namespace-uri">literal 
  namespace URI</A> and the same <A title="import precedence" 
  href="REC-xslt20-20070123.htm#dt-import-precedence">import 
  precedence</A> and different values for the <A title="target namespace URI" 
  href="REC-xslt20-20070123.htm#dt-target-namespace-uri">target 
  namespace URI</A>, unless there is also an <A 
  href="REC-xslt20-20070123.htm#element-namespace-alias"><CODE>xsl:namespace-alias</CODE></A> 
  declaration with the same <A title="literal namespace URI" 
  href="REC-xslt20-20070123.htm#dt-literal-namespace-uri">literal 
  namespace URI</A> and a higher import precedence.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE0812"><SPAN 
  class=error>ERR XTSE0812</SPAN></A> 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A> if a value other than <CODE>#default</CODE> is specified for either 
  the <CODE>stylesheet-prefix</CODE> or the <CODE>result-prefix</CODE> 
  attributes of the <A 
  href="REC-xslt20-20070123.htm#element-namespace-alias"><CODE>xsl:namespace-alias</CODE></A> 
  element when there is no in-scope binding for that namespace prefix.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE0840"><SPAN 
  class=error>ERR XTSE0840</SPAN></A> 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A> if the <CODE>select</CODE> attribute of the <A 
  href="REC-xslt20-20070123.htm#element-attribute"><CODE>xsl:attribute</CODE></A> 
  element is present unless the element has empty content.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE0870"><SPAN 
  class=error>ERR XTSE0870</SPAN></A> 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A> if the <CODE>select</CODE> attribute of the <A 
  href="REC-xslt20-20070123.htm#element-value-of"><CODE>xsl:value-of</CODE></A> 
  element is present when the content of the element is non-empty, or if the 
  <CODE>select</CODE> attribute is absent when the content is empty.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE0880"><SPAN 
  class=error>ERR XTSE0880</SPAN></A> 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A> if the <CODE>select</CODE> attribute of the <A 
  href="REC-xslt20-20070123.htm#element-processing-instruction"><CODE>xsl:processing-instruction</CODE></A> 
  element is present unless the element has empty content.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE0910"><SPAN 
  class=error>ERR XTSE0910</SPAN></A> 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A> if the <CODE>select</CODE> attribute of the <A 
  href="REC-xslt20-20070123.htm#element-namespace"><CODE>xsl:namespace</CODE></A> 
  element is present when the element has content other than one or more <A 
  href="REC-xslt20-20070123.htm#element-fallback"><CODE>xsl:fallback</CODE></A> 
  instructions, or if the <CODE>select</CODE> attribute is absent when the 
  element has empty content.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE0940"><SPAN 
  class=error>ERR XTSE0940</SPAN></A> 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A> if the <CODE>select</CODE> attribute of the <A 
  href="REC-xslt20-20070123.htm#element-comment"><CODE>xsl:comment</CODE></A> 
  element is present unless the element has empty content.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTTE0950"><SPAN 
  class=error>ERR XTTE0950</SPAN></A> 
  <DD>
  <P>It is a <A title="type errors" 
  href="REC-xslt20-20070123.htm#dt-type-error">type 
  error</A> to use the <A 
  href="REC-xslt20-20070123.htm#element-copy"><CODE>xsl:copy</CODE></A> 
  or <A 
  href="REC-xslt20-20070123.htm#element-copy-of"><CODE>xsl:copy-of</CODE></A> 
  instruction to copy a node that has namespace-sensitive content if the 
  <CODE>copy-namespaces</CODE> attribute has the value <CODE>no</CODE> and its 
  explicit or implicit <CODE>validation</CODE> attribute has the value 
  <CODE>preserve</CODE>. It is also a type error if either of these instructions 
  (with <CODE>validation="preserve"</CODE>) is used to copy an attribute having 
  namespace-sensitive content, unless the parent element is also copied. A node 
  has namespace-sensitive content if its typed value contains an item of type 
  <CODE>xs:QName</CODE> or <CODE>xs:NOTATION</CODE> or a type derived therefrom. 
  The reason this is an error is because the validity of the content depends on 
  the namespace context being preserved.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE0975"><SPAN 
  class=error>ERR XTSE0975</SPAN></A> 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A> if the <CODE>value</CODE> attribute of <A 
  href="REC-xslt20-20070123.htm#element-number"><CODE>xsl:number</CODE></A> 
  is present unless the <CODE>select</CODE>, <CODE>level</CODE>, 
  <CODE>count</CODE>, and <CODE>from</CODE> attributes are all absent.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE1015"><SPAN 
  class=error>ERR XTSE1015</SPAN></A> 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A> if an <A 
  href="REC-xslt20-20070123.htm#element-sort"><CODE>xsl:sort</CODE></A> 
  element with a <CODE>select</CODE> attribute has non-empty content.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE1017"><SPAN 
  class=error>ERR XTSE1017</SPAN></A> 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A> if an <A 
  href="REC-xslt20-20070123.htm#element-sort"><CODE>xsl:sort</CODE></A> 
  element other than the first in a sequence of sibling <A 
  href="REC-xslt20-20070123.htm#element-sort"><CODE>xsl:sort</CODE></A> 
  elements has a <CODE>stable</CODE> attribute.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE1040"><SPAN 
  class=error>ERR XTSE1040</SPAN></A> 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A> if an <A 
  href="REC-xslt20-20070123.htm#element-perform-sort"><CODE>xsl:perform-sort</CODE></A> 
  instruction with a <CODE>select</CODE> attribute has any content other than <A 
  href="REC-xslt20-20070123.htm#element-sort"><CODE>xsl:sort</CODE></A> 
  and <A 
  href="REC-xslt20-20070123.htm#element-fallback"><CODE>xsl:fallback</CODE></A> 
  instructions.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE1060"><SPAN 
  class=error>ERR XTSE1060</SPAN></A> 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A> if the <A 
  href="REC-xslt20-20070123.htm#function-current-group"><CODE>current-group</CODE></A> 
  function is used within a <A title=pattern 
  href="REC-xslt20-20070123.htm#dt-pattern">pattern</A>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE1070"><SPAN 
  class=error>ERR XTSE1070</SPAN></A> 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A> if the <A 
  href="REC-xslt20-20070123.htm#function-current-grouping-key"><CODE>current-grouping-key</CODE></A> 
  function is used within a <A title=pattern 
  href="REC-xslt20-20070123.htm#dt-pattern">pattern</A>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE1080"><SPAN 
  class=error>ERR XTSE1080</SPAN></A> 
  <DD>
  <P>These four attributes [the <CODE>group-by</CODE>, 
  <CODE>group-adjacent</CODE>, <CODE>group-starting-with</CODE>, and 
  <CODE>group-ending-with</CODE> attributes of <A 
  href="REC-xslt20-20070123.htm#element-for-each-group"><CODE>xsl:for-each-group</CODE></A> 
  ] are mutually exclusive: it is a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A> if none of these four attributes is present, or if more than one of 
  them is present.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE1090"><SPAN 
  class=error>ERR XTSE1090</SPAN></A> 
  <DD>
  <P>It is an error to specify the <CODE>collation</CODE> attribute if neither 
  the <CODE>group-by</CODE> attribute nor <CODE>group-adjacent</CODE> attribute 
  is specified.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE1130"><SPAN 
  class=error>ERR XTSE1130</SPAN></A> 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A> if the <A 
  href="REC-xslt20-20070123.htm#element-analyze-string"><CODE>xsl:analyze-string</CODE></A> 
  instruction contains neither an <A 
  href="REC-xslt20-20070123.htm#element-matching-substring"><CODE>xsl:matching-substring</CODE></A> 
  nor an <A 
  href="REC-xslt20-20070123.htm#element-non-matching-substring"><CODE>xsl:non-matching-substring</CODE></A> 
  element.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE1205"><SPAN 
  class=error>ERR XTSE1205</SPAN></A> 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A> if an <A 
  href="REC-xslt20-20070123.htm#element-key"><CODE>xsl:key</CODE></A> 
  declaration has a <CODE>use</CODE> attribute and has non-empty content, or if 
  it has empty content and no <CODE>use</CODE> attribute.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE1210"><SPAN 
  class=error>ERR XTSE1210</SPAN></A> 
  <DD>
  <P>It is a static error if the <A 
  href="REC-xslt20-20070123.htm#element-key"><CODE>xsl:key</CODE></A> 
  declaration has a <CODE>collation</CODE> attribute whose value <SPAN>(after 
  resolving against the base URI)</SPAN> is not a URI recognized by the 
  implementation as referring to a collation.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE1220"><SPAN 
  class=error>ERR XTSE1220</SPAN></A> 
  <DD>
  <P>It is a static error if there are several <A 
  href="REC-xslt20-20070123.htm#element-key"><CODE>xsl:key</CODE></A> 
  declarations in the <A title=stylesheet 
  href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
  with the same key name and different effective collations. Two collations are 
  the same if their URIs are equal under the rules for comparing 
  <CODE>xs:anyURI</CODE> values, or if the implementation can determine that 
  they are different URIs referring to the same collation.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE1290"><SPAN 
  class=error>ERR XTSE1290</SPAN></A> 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A> if a named or unnamed <A title="decimal format" 
  href="REC-xslt20-20070123.htm#dt-decimal-format">decimal 
  format</A> contains two conflicting values for the same attribute in different 
  <A 
  href="REC-xslt20-20070123.htm#element-decimal-format"><CODE>xsl:decimal-format</CODE></A> 
  declarations having the same <A title="import precedence" 
  href="REC-xslt20-20070123.htm#dt-import-precedence">import 
  precedence</A>, unless there is another definition of the same attribute with 
  higher import precedence.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE1295"><SPAN 
  class=error>ERR XTSE1295</SPAN></A> 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A> if the character specified in the <CODE>zero-digit</CODE> attribute 
  is not a digit or is a digit that does not have the numeric value zero.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE1300"><SPAN 
  class=error>ERR XTSE1300</SPAN></A> 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A> if, for any named or unnamed decimal format, the variables 
  representing characters used in a <A title="picture string" 
  href="REC-xslt20-20070123.htm#dt-picture-string">picture 
  string</A> do not each have distinct values. These variables are 
  <VAR>decimal-separator-sign</VAR>, <VAR>grouping-sign</VAR>, 
  <VAR>percent-sign</VAR>, <VAR>per-mille-sign</VAR>, 
  <VAR>digit-zero-sign</VAR>, <VAR>digit-sign</VAR>, and 
  <VAR>pattern-separator-sign</VAR>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE1430"><SPAN 
  class=error>ERR XTSE1430</SPAN></A> 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A> if there is no namespace bound to the prefix on the element bearing 
  the <CODE>[xsl:]extension-element-prefixes</CODE> attribute <SPAN>or, when 
  <CODE>#default</CODE> is specified, if there is no default 
  namespace</SPAN>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE1505"><SPAN 
  class=error>ERR XTSE1505</SPAN></A> 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A> if both the <CODE>[xsl:]type</CODE> and 
  <CODE>[xsl:]validation</CODE> attributes are present on the <A 
  href="REC-xslt20-20070123.htm#element-element"><CODE>xsl:element</CODE></A>, 
  <A 
  href="REC-xslt20-20070123.htm#element-attribute"><CODE>xsl:attribute</CODE></A>, 
  <A 
  href="REC-xslt20-20070123.htm#element-copy"><CODE>xsl:copy</CODE></A>, 
  <A 
  href="REC-xslt20-20070123.htm#element-copy-of"><CODE>xsl:copy-of</CODE></A>, 
  <SPAN><A 
  href="REC-xslt20-20070123.htm#element-document"><CODE>xsl:document</CODE></A></SPAN>, 
  or <A 
  href="REC-xslt20-20070123.htm#element-result-document"><CODE>xsl:result-document</CODE></A> 
  instructions, or on a <A title="literal result element" 
  href="REC-xslt20-20070123.htm#dt-literal-result-element">literal 
  result element</A>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE1520"><SPAN 
  class=error>ERR XTSE1520</SPAN></A> 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A> if the value of the <CODE>type</CODE> attribute of an <A 
  href="REC-xslt20-20070123.htm#element-element"><CODE>xsl:element</CODE></A>, 
  <A 
  href="REC-xslt20-20070123.htm#element-attribute"><CODE>xsl:attribute</CODE></A>, 
  <A 
  href="REC-xslt20-20070123.htm#element-copy"><CODE>xsl:copy</CODE></A>, 
  <A 
  href="REC-xslt20-20070123.htm#element-copy-of"><CODE>xsl:copy-of</CODE></A>, 
  <SPAN><A 
  href="REC-xslt20-20070123.htm#element-document"><CODE>xsl:document</CODE></A>,</SPAN> 
  or <A 
  href="REC-xslt20-20070123.htm#element-result-document"><CODE>xsl:result-document</CODE></A> 
  instruction, or the <CODE>xsl:type</CODE> attribute of a literal result 
  element, is not a valid <CODE>QName</CODE>, or if it uses a prefix that is not 
  defined in an in-scope namespace declaration, or if the QName is not the name 
  of a type definition included in the <A title="in-scope schema component" 
  href="REC-xslt20-20070123.htm#dt-in-scope-schema-component">in-scope 
  schema components</A> for the stylesheet.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE1530"><SPAN 
  class=error>ERR XTSE1530</SPAN></A> 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A> if the value of the <CODE>type</CODE> attribute of an <A 
  href="REC-xslt20-20070123.htm#element-attribute"><CODE>xsl:attribute</CODE></A> 
  instruction refers to a complex type definition</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE1560"><SPAN 
  class=error>ERR XTSE1560</SPAN></A> 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A> if two <A 
  href="REC-xslt20-20070123.htm#element-output"><CODE>xsl:output</CODE></A> 
  declarations within an <A title="output definition" 
  href="REC-xslt20-20070123.htm#dt-output-definition">output 
  definition</A> specify explicit values for the same attribute (other than 
  <CODE>cdata-section-elements</CODE> and <CODE>use-character-maps</CODE>), with 
  the values of the attributes being not equal, unless there is another <A 
  href="REC-xslt20-20070123.htm#element-output"><CODE>xsl:output</CODE></A> 
  declaration within the same <A title="output definition" 
  href="REC-xslt20-20070123.htm#dt-output-definition">output 
  definition</A> that has higher import precedence and that specifies an 
  explicit value for the same attribute.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE1570"><SPAN 
  class=error>ERR XTSE1570</SPAN></A> 
  <DD>
  <P>The value [of the <CODE>method</CODE> attribute on <A 
  href="REC-xslt20-20070123.htm#element-output"><CODE>xsl:output</CODE></A> 
  ] <SPAN class=verb>must</SPAN> <SPAN>(if present)</SPAN> be a valid <A 
  title=QName 
  href="REC-xslt20-20070123.htm#dt-qname">QName</A>. If 
  the <A title=QName 
  href="REC-xslt20-20070123.htm#dt-qname">QName</A> does 
  not have a prefix, then it identifies a method specified in <A 
  href="REC-xslt20-20070123.htm#xslt-xquery-serialization">[XSLT 
  and XQuery Serialization]</A> and <SPAN class=verb>must</SPAN> be one of 
  <CODE>xml</CODE>, <CODE>html</CODE>, <CODE>xhtml</CODE>, or 
  <CODE>text</CODE>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE1580"><SPAN 
  class=error>ERR XTSE1580</SPAN></A> 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A> if the <A title=stylesheet 
  href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
  contains two or more character maps with the same name and the same <A 
  title="import precedence" 
  href="REC-xslt20-20070123.htm#dt-import-precedence">import 
  precedence</A><SPAN>, unless it also contains another character map with the 
  same name and higher import precedence.</SPAN></P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE1590"><SPAN 
  class=error>ERR XTSE1590</SPAN></A> 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A> if a name in the <CODE>use-character-maps</CODE> attribute <SPAN>of 
  the <A 
  href="REC-xslt20-20070123.htm#element-output"><CODE>xsl:output</CODE></A> 
  or <A 
  href="REC-xslt20-20070123.htm#element-character-map"><CODE>xsl:character-map</CODE></A> 
  elements</SPAN> does not match the <CODE>name</CODE> attribute of any <A 
  href="REC-xslt20-20070123.htm#element-character-map"><CODE>xsl:character-map</CODE></A> 
  in the <A title=stylesheet 
  href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE1600"><SPAN 
  class=error>ERR XTSE1600</SPAN></A> 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A> if a character map references itself, directly or indirectly, via a 
  name in the <CODE>use-character-maps</CODE> attribute.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE1650"><SPAN 
  class=error>ERR XTSE1650</SPAN></A> 
  <DD>
  <P>A <A title="basic XSLT processor" 
  href="REC-xslt20-20070123.htm#dt-basic-xslt-processor">basic 
  XSLT processor</A> <SPAN class=verb>must</SPAN> signal a <A 
  title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A> if the <A title=stylesheet 
  href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
  includes an <A 
  href="REC-xslt20-20070123.htm#element-import-schema"><CODE>xsl:import-schema</CODE></A> 
  declaration.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTSE1660"><SPAN 
  class=error>ERR XTSE1660</SPAN></A> 
  <DD>
  <P>A <A title="basic XSLT processor" 
  href="REC-xslt20-20070123.htm#dt-basic-xslt-processor">basic 
  XSLT processor</A> <SPAN class=verb>must</SPAN> signal a <A 
  title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A> if the <A title=stylesheet 
  href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
  includes an <CODE>[xsl:]type</CODE> attribute, or an 
  <CODE>[xsl:]validation</CODE> or <CODE>default-validation</CODE> attribute 
  with a value other than <CODE>strip</CODE>.</P></DD></DL>
<P><B>Type errors</B></P>
<DL>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTTE0505"><SPAN 
  class=error>ERR XTTE0505</SPAN></A> 
  <DD>
  <P>It is a <A title="type errors" 
  href="REC-xslt20-20070123.htm#dt-type-error">type 
  error</A> if the result of evaluating the <A title="sequence constructor" 
  href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
  constructor</A> cannot be converted to the required type.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTTE0510"><SPAN 
  class=error>ERR XTTE0510</SPAN></A> 
  <DD>
  <P>It is a <A title="type errors" 
  href="REC-xslt20-20070123.htm#dt-type-error">type 
  error</A> if an <A 
  href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A> 
  instruction with no <CODE>select</CODE> attribute is evaluated when the <A 
  title="context item" 
  href="REC-xslt20-20070123.htm#dt-context-item">context 
  item</A> is not a node.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTTE0520"><SPAN 
  class=error>ERR XTTE0520</SPAN></A> 
  <DD>
  <P>It is a <A title="type errors" 
  href="REC-xslt20-20070123.htm#dt-type-error">type 
  error</A> if the sequence returned by the <CODE>select</CODE> expression [of 
  <A 
  href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A>] 
  contains an item that is not a node.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTTE0570"><SPAN 
  class=error>ERR XTTE0570</SPAN></A> 
  <DD>
  <P>It is a <A title="type errors" 
  href="REC-xslt20-20070123.htm#dt-type-error">type 
  error</A> if the <A title="supplied value" 
  href="REC-xslt20-20070123.htm#dt-supplied-value">supplied 
  value</A> of a variable cannot be converted to the required type.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTTE0590"><SPAN 
  class=error>ERR XTTE0590</SPAN></A> 
  <DD>
  <P>It is a <A title="type errors" 
  href="REC-xslt20-20070123.htm#dt-type-error">type 
  error</A> if the conversion of the <A title="supplied value" 
  href="REC-xslt20-20070123.htm#dt-supplied-value">supplied 
  value</A> of a parameter to its required type fails.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTTE0600"><SPAN 
  class=error>ERR XTTE0600</SPAN></A> 
  <DD>
  <P>If a default value is given explicitly, that is, if there is either a 
  <CODE>select</CODE> attribute or a non-empty <A title="sequence constructor" 
  href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
  constructor</A>, then it is a <A title="type errors" 
  href="REC-xslt20-20070123.htm#dt-type-error">type 
  error</A> if the default value cannot be converted to the required type, using 
  the <A title="function conversion rules" 
  href="REC-xslt20-20070123.htm#dt-function-conversion-rules">function 
  conversion rules</A>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTTE0780"><SPAN 
  class=error>ERR XTTE0780</SPAN></A> 
  <DD>
  <P>If the <CODE>as</CODE> attribute [of <A 
  href="REC-xslt20-20070123.htm#element-function"><CODE>xsl:function</CODE></A> 
  ] is specified, then the result evaluated by the <A 
  title="sequence constructor" 
  href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
  constructor</A> (see <A 
  href="REC-xslt20-20070123.htm#sequence-constructors"><I>5.7 
  Sequence Constructors</I></A>) is converted to the required type, using the <A 
  title="function conversion rules" 
  href="REC-xslt20-20070123.htm#dt-function-conversion-rules">function 
  conversion rules</A>. It is a <A title="type errors" 
  href="REC-xslt20-20070123.htm#dt-type-error">type 
  error</A> if this conversion fails.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTTE0790"><SPAN 
  class=error>ERR XTTE0790</SPAN></A> 
  <DD>
  <P>If the value of a parameter to a <A title="stylesheet function" 
  href="REC-xslt20-20070123.htm#dt-stylesheet-function">stylesheet 
  function</A> cannot be converted to the required type, a <A 
  title="type errors" 
  href="REC-xslt20-20070123.htm#dt-type-error">type 
  error</A> is signaled.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTTE0990"><SPAN 
  class=error>ERR XTTE0990</SPAN></A> 
  <DD>
  <P>It is a <A title="type errors" 
  href="REC-xslt20-20070123.htm#dt-type-error">type 
  error</A> if the <A 
  href="REC-xslt20-20070123.htm#element-number"><CODE>xsl:number</CODE></A> 
  instruction is evaluated, with no <CODE>value</CODE> or <CODE>select</CODE> 
  attribute, when the <A title="context item" 
  href="REC-xslt20-20070123.htm#dt-context-item">context 
  item</A> is not a node.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTTE1000"><SPAN 
  class=error>ERR XTTE1000</SPAN></A> 
  <DD>
  <P>It is a <A title="type errors" 
  href="REC-xslt20-20070123.htm#dt-type-error">type 
  error</A> if the result of evaluating the <CODE>select</CODE> attribute of the 
  <A 
  href="REC-xslt20-20070123.htm#element-number"><CODE>xsl:number</CODE></A> 
  instruction is anything other than a single node.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTTE1020"><SPAN 
  class=error>ERR XTTE1020</SPAN></A> 
  <DD>
  <P>If any <A title="sort key value" 
  href="REC-xslt20-20070123.htm#dt-sort-key-value">sort 
  key value</A>, after <A title=atomize 
  href="REC-xslt20-20070123.htm#dt-atomization">atomization</A> 
  and any type conversion <SPAN class=verb>required</SPAN> by the 
  <CODE>data-type</CODE> attribute, is a sequence containing more than one item, 
  then the effect depends on whether the <A 
  href="REC-xslt20-20070123.htm#element-sort"><CODE>xsl:sort</CODE></A> 
  element is evaluated with <A title="backwards compatible behavior" 
  href="REC-xslt20-20070123.htm#dt-backwards-compatible-behavior">backwards 
  compatible behavior</A>. With backwards compatible behavior, the effective 
  sort key value is the first item in the sequence. In other cases, this is a <A 
  title="type errors" 
  href="REC-xslt20-20070123.htm#dt-type-error">type 
  error</A>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTTE1100"><SPAN 
  class=error>ERR XTTE1100</SPAN></A> 
  <DD>
  <P>It is a <A title="type errors" 
  href="REC-xslt20-20070123.htm#dt-type-error">type 
  error</A> if the <SPAN>grouping key evaluated using</SPAN> the 
  <CODE>group-adjacent</CODE> attribute is an empty sequence, or a sequence 
  containing more than one item.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTTE1120"><SPAN 
  class=error>ERR XTTE1120</SPAN></A> 
  <DD>
  <P>When the <CODE>group-starting-with</CODE> or <CODE>group-ending-with</CODE> 
  attribute [of the <A 
  href="REC-xslt20-20070123.htm#element-for-each-group"><CODE>xsl:for-each-group</CODE></A> 
  instruction] is used, it is a <A title="type errors" 
  href="REC-xslt20-20070123.htm#dt-type-error">type 
  error</A> if the result of evaluating the <CODE>select</CODE> expression 
  contains an item that is not a node.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTTE1510"><SPAN 
  class=error>ERR XTTE1510</SPAN></A> 
  <DD>
  <P>If the <CODE>validation</CODE> attribute of an <A 
  href="REC-xslt20-20070123.htm#element-element"><CODE>xsl:element</CODE></A>, 
  <A 
  href="REC-xslt20-20070123.htm#element-attribute"><CODE>xsl:attribute</CODE></A>, 
  <A 
  href="REC-xslt20-20070123.htm#element-copy"><CODE>xsl:copy</CODE></A>, 
  <A 
  href="REC-xslt20-20070123.htm#element-copy-of"><CODE>xsl:copy-of</CODE></A>, 
  or <A 
  href="REC-xslt20-20070123.htm#element-result-document"><CODE>xsl:result-document</CODE></A> 
  instruction, or the <CODE>xsl:validation</CODE> attribute of a literal result 
  element, has the effective value <CODE>strict</CODE>, and schema validity 
  assessment concludes that the validity of the element or attribute is invalid 
  or unknown, a type error occurs. As with other type errors, the error <SPAN 
  class=verb>may</SPAN> be signaled statically if it can be detected 
  statically.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTTE1512"><SPAN 
  class=error>ERR XTTE1512</SPAN></A> 
  <DD>
  <P>If the <CODE>validation</CODE> attribute of an <A 
  href="REC-xslt20-20070123.htm#element-element"><CODE>xsl:element</CODE></A>, 
  <A 
  href="REC-xslt20-20070123.htm#element-attribute"><CODE>xsl:attribute</CODE></A>, 
  <A 
  href="REC-xslt20-20070123.htm#element-copy"><CODE>xsl:copy</CODE></A>, 
  <A 
  href="REC-xslt20-20070123.htm#element-copy-of"><CODE>xsl:copy-of</CODE></A>, 
  or <A 
  href="REC-xslt20-20070123.htm#element-result-document"><CODE>xsl:result-document</CODE></A> 
  instruction, or the <CODE>xsl:validation</CODE> attribute of a literal result 
  element, has the effective value <CODE>strict</CODE>, and there is no matching 
  top-level declaration in the schema, then a type error occurs. As with other 
  type errors, the error <SPAN class=verb>may</SPAN> be signaled statically if 
  it can be detected statically.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTTE1515"><SPAN 
  class=error>ERR XTTE1515</SPAN></A> 
  <DD>
  <P>If the <CODE>validation</CODE> attribute of an <A 
  href="REC-xslt20-20070123.htm#element-element"><CODE>xsl:element</CODE></A>, 
  <A 
  href="REC-xslt20-20070123.htm#element-attribute"><CODE>xsl:attribute</CODE></A>, 
  <A 
  href="REC-xslt20-20070123.htm#element-copy"><CODE>xsl:copy</CODE></A>, 
  <A 
  href="REC-xslt20-20070123.htm#element-copy-of"><CODE>xsl:copy-of</CODE></A>, 
  or <A 
  href="REC-xslt20-20070123.htm#element-result-document"><CODE>xsl:result-document</CODE></A> 
  instruction, or the <CODE>xsl:validation</CODE> attribute of a literal result 
  element, has the effective value <CODE>lax</CODE>, and schema validity 
  assessment concludes that the element or attribute is invalid, a type error 
  occurs. As with other type errors, the error <SPAN class=verb>may</SPAN> be 
  signaled statically if it can be detected statically.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTTE1540"><SPAN 
  class=error>ERR XTTE1540</SPAN></A> 
  <DD>
  <P>It is a <A title="type errors" 
  href="REC-xslt20-20070123.htm#dt-type-error">type 
  error</A> if an <CODE>[xsl:]type</CODE> attribute is defined for a constructed 
  element or attribute, and the outcome of schema validity assessment against 
  that type is that the <CODE>validity</CODE> property of that element or 
  attribute information item is other than <CODE>valid</CODE>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTTE1545"><SPAN 
  class=error>ERR XTTE1545</SPAN></A> 
  <DD>
  <P>A <A title="type errors" 
  href="REC-xslt20-20070123.htm#dt-type-error">type 
  error</A> occurs if a <CODE>type</CODE> or <CODE>validation</CODE> attribute 
  is defined (explicitly or implicitly) for an instruction that constructs a new 
  attribute node, if the effect of this is to cause the attribute value to be 
  validated against a type that is derived from, or constructed by list or union 
  from, the primitive types <CODE>xs:QName</CODE> or 
  <CODE>xs:NOTATION</CODE>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTTE1550"><SPAN 
  class=error>ERR XTTE1550</SPAN></A> 
  <DD>
  <P>A <A title="type errors" 
  href="REC-xslt20-20070123.htm#dt-type-error">type 
  error</A> occurs [when a document node is validated] unless the children of 
  the document node comprise exactly one element node, no text nodes, and zero 
  or more comment and processing instruction nodes, in any order.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTTE1555"><SPAN 
  class=error>ERR XTTE1555</SPAN></A> 
  <DD>
  <P>It is a <A title="type errors" 
  href="REC-xslt20-20070123.htm#dt-type-error">type 
  error</A> if, when validating a document node, document-level constraints are 
  not satisfied. These constraints include identity constraints 
  (<CODE>xs:unique</CODE>, <CODE>xs:key</CODE>, and <CODE>xs:keyref</CODE>) and 
  ID/IDREF constraints.</P></DD></DL>
<P><B>Dynamic errors</B></P>
<DL>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTDE0030"><SPAN 
  class=error>ERR XTDE0030</SPAN></A> 
  <DD>
  <P>It is a <A title="non-recoverable dynamic error" 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A> if the <A title="effective value" 
  href="REC-xslt20-20070123.htm#dt-effective-value">effective 
  value</A> of an attribute written using curly brackets, in a position where an 
  <A title="attribute value template" 
  href="REC-xslt20-20070123.htm#dt-attribute-value-template">attribute 
  value template</A> is permitted, is a value that is not one of the permitted 
  values for that attribute. If the processor is able to detect the error 
  statically (for example, when any XPath expressions within the curly brackets 
  can be evaluated statically), then the processor may optionally signal this as 
  a static error.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTDE0040"><SPAN 
  class=error>ERR XTDE0040</SPAN></A> 
  <DD>
  <P>It is a <A title="non-recoverable dynamic error" 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A> if the invocation of the <A title=stylesheet 
  href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
  specifies a template name that does not match the <A title=expanded-QName 
  href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded-QName</A> 
  of a named template defined in the <A title=stylesheet 
  href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTDE0045"><SPAN 
  class=error>ERR XTDE0045</SPAN></A> 
  <DD>
  <P>It is a <A title="non-recoverable dynamic error" 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A> if the invocation of the <A title=stylesheet 
  href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
  specifies an initial <A title=mode 
  href="REC-xslt20-20070123.htm#dt-mode">mode</A> (other 
  than the default mode) that does not match the <A title=expanded-QName 
  href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded-QName</A> 
  in the <CODE>mode</CODE> attribute of any template defined in the <A 
  title=stylesheet 
  href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTDE0047"><SPAN 
  class=error>ERR XTDE0047</SPAN></A> 
  <DD>
  <P>It is a <A title="non-recoverable dynamic error" 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A> if the invocation of the <A title=stylesheet 
  href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
  specifies both an initial <A title=mode 
  href="REC-xslt20-20070123.htm#dt-mode">mode</A> and an 
  initial template.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTDE0050"><SPAN 
  class=error>ERR XTDE0050</SPAN></A> 
  <DD>
  <P>It is a <A title="non-recoverable dynamic error" 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A> if the stylesheet that is invoked declares a visible <A 
  title="stylesheet parameter" 
  href="REC-xslt20-20070123.htm#dt-stylesheet-parameter">stylesheet 
  parameter</A> with <CODE>required="yes"</CODE> and no value for this parameter 
  is supplied during the invocation of the stylesheet. A stylesheet parameter is 
  visible if it is not masked by another global variable or parameter with the 
  same name and higher <A title="import precedence" 
  href="REC-xslt20-20070123.htm#dt-import-precedence">import 
  precedence</A>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTDE0060"><SPAN 
  class=error>ERR XTDE0060</SPAN></A> 
  <DD>
  <P>It is a <A title="non-recoverable dynamic error" 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A> if the <A title="initial template" 
  href="REC-xslt20-20070123.htm#dt-initial-template">initial 
  template</A> defines a <A title="template parameter" 
  href="REC-xslt20-20070123.htm#dt-template-parameter">template 
  parameter</A> that specifies <CODE>required="yes"</CODE>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTDE0160"><SPAN 
  class=error>ERR XTDE0160</SPAN></A> 
  <DD>
  <P>If an implementation does not support backwards-compatible behavior, then 
  it is a <A title="non-recoverable dynamic error" 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A> if any element is evaluated that enables 
  backwards-compatible behavior.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTRE0270"><SPAN 
  class=error>ERR XTRE0270</SPAN></A> 
  <DD>
  <P>It is a <A title="recoverable error" 
  href="REC-xslt20-20070123.htm#dt-recoverable-error">recoverable 
  dynamic error</A> if this [the process of finding an <A 
  href="REC-xslt20-20070123.htm#element-strip-space"><CODE>xsl:strip-space</CODE></A> 
  or <A 
  href="REC-xslt20-20070123.htm#element-preserve-space"><CODE>xsl:preserve-space</CODE></A> 
  declaration to match an element in the source document] leaves more than one 
  match<SPAN>, unless all the matched declarations are equivalent (that is, they 
  are all <A 
  href="REC-xslt20-20070123.htm#element-strip-space"><CODE>xsl:strip-space</CODE></A> 
  or they are all <A 
  href="REC-xslt20-20070123.htm#element-preserve-space"><CODE>xsl:preserve-space</CODE></A>)</SPAN>.<BR><I>&nbsp;&nbsp;&nbsp;&nbsp;Action:</I> 
  <SPAN>The <A title="optional recovery action" 
  href="REC-xslt20-20070123.htm#dt-optional-recovery-action">optional 
  recovery action</A> is to select, from the matches that are left, the one that 
  occurs last in <A title="declaration order" 
  href="REC-xslt20-20070123.htm#dt-declaration-order">declaration 
  order</A>.</SPAN></P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTDE0290"><SPAN 
  class=error>ERR XTDE0290</SPAN></A> 
  <DD>
  <P>Where the result of evaluating an XPath expression (or an attribute value 
  template) is required to be a <A title="lexical QName" 
  href="REC-xslt20-20070123.htm#dt-lexical-qname">lexical 
  QName</A>, <SPAN>then unless otherwise specified</SPAN> it is a <A 
  title="non-recoverable dynamic error" 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A> if the <A title="defining element" 
  href="REC-xslt20-20070123.htm#dt-defining-element">defining 
  element</A> has no namespace node whose name matches the prefix of the <A 
  title="lexical QName" 
  href="REC-xslt20-20070123.htm#dt-lexical-qname">lexical 
  QName</A>. <SPAN>This error <SPAN class=verb>may</SPAN> be signaled as a <A 
  title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A> if the value of the expression can be determined 
  statically.</SPAN></P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTDE0410"><SPAN 
  class=error>ERR XTDE0410</SPAN></A> 
  <DD>
  <P>It is a <A title="non-recoverable dynamic error" 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A> if the result sequence used to construct the content of an 
  element node contains a namespace node or attribute node that is preceded in 
  the sequence by a node that is neither a namespace node nor an attribute 
  node.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTDE0420"><SPAN 
  class=error>ERR XTDE0420</SPAN></A> 
  <DD>
  <P>It is a <A title="non-recoverable dynamic error" 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A> if the result sequence used to construct the content of a 
  document node contains a namespace node or attribute node.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTDE0430"><SPAN 
  class=error>ERR XTDE0430</SPAN></A> 
  <DD>
  <P>It is a <A title="non-recoverable dynamic error" 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A> if the result sequence contains two or more namespace nodes 
  having the same name but different <A title="string value" 
  href="REC-xslt20-20070123.htm#dt-string-value">string 
  values</A> (that is, namespace nodes that map the same prefix to different 
  namespace URIs).</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTDE0440"><SPAN 
  class=error>ERR XTDE0440</SPAN></A> 
  <DD>
  <P>It is a <A title="non-recoverable dynamic error" 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A> if the result sequence contains a namespace node with no 
  name and the element node being constructed has a null namespace URI (that is, 
  it is an error to define a default namespace when the element is in no 
  namespace).</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTDE0485"><SPAN 
  class=error>ERR XTDE0485</SPAN></A> 
  <DD>
  <P>It is a <A title="non-recoverable dynamic error" 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A> if namespace fixup is performed on an element that contains 
  among the typed values of the element and its attributes two values of type 
  <CODE>xs:QName</CODE> or <CODE>xs:NOTATION</CODE> containing conflicting 
  namespace prefixes, that is, two values that use the same prefix to refer to 
  different namespace URIs.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTRE0540"><SPAN 
  class=error>ERR XTRE0540</SPAN></A> 
  <DD>
  <P>It is a <A title="recoverable error" 
  href="REC-xslt20-20070123.htm#dt-recoverable-error">recoverable 
  dynamic error</A> if the conflict resolution algorithm for template rules 
  leaves more than one matching template 
  rule.<BR><I>&nbsp;&nbsp;&nbsp;&nbsp;Action:</I> The <A 
  title="optional recovery action" 
  href="REC-xslt20-20070123.htm#dt-optional-recovery-action">optional 
  recovery action</A> is to select, from the matching template rules that are 
  left, the one that occurs last in <A title="declaration order" 
  href="REC-xslt20-20070123.htm#dt-declaration-order">declaration 
  order</A>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTDE0560"><SPAN 
  class=error>ERR XTDE0560</SPAN></A> 
  <DD>
  <P>It is a <A title="non-recoverable dynamic error" 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A> if <A 
  href="REC-xslt20-20070123.htm#element-apply-imports"><CODE>xsl:apply-imports</CODE></A> 
  <SPAN>or <A 
  href="REC-xslt20-20070123.htm#element-next-match"><CODE>xsl:next-match</CODE></A></SPAN> 
  is evaluated when the <A title="current template rule" 
  href="REC-xslt20-20070123.htm#dt-current-template-rule">current 
  template rule</A> is null.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTDE0610"><SPAN 
  class=error>ERR XTDE0610</SPAN></A> 
  <DD>
  <P>If an optional parameter has no <CODE>select</CODE> attribute and has an 
  empty <A title="sequence constructor" 
  href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
  constructor</A>, and if there is an <CODE>as</CODE> attribute, then the 
  default value of the parameter is an empty sequence. If the empty sequence is 
  not a valid instance of the required type defined in the <CODE>as</CODE> 
  attribute, then the parameter is treated as a required parameter, which means 
  that it is a <A title="non-recoverable dynamic error" 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A> if the caller supplies no value for the parameter.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTDE0640"><SPAN 
  class=error>ERR XTDE0640</SPAN></A> 
  <DD>
  <P>In general, a <A title=circularity 
  href="REC-xslt20-20070123.htm#dt-circularity">circularity</A> 
  in a <A title=stylesheet 
  href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
  is a <A title="non-recoverable dynamic error" 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTDE0700"><SPAN 
  class=error>ERR XTDE0700</SPAN></A> 
  <DD>
  <P>In other cases, [with <A 
  href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A>, 
  <A 
  href="REC-xslt20-20070123.htm#element-apply-imports"><CODE>xsl:apply-imports</CODE></A>, 
  and <A 
  href="REC-xslt20-20070123.htm#element-next-match"><CODE>xsl:next-match</CODE></A>, 
  or <A 
  href="REC-xslt20-20070123.htm#element-call-template"><CODE>xsl:call-template</CODE></A> 
  with <A title="tunnel parameter" 
  href="REC-xslt20-20070123.htm#dt-tunnel-parameter">tunnel 
  parameters</A>] it is a <A title="non-recoverable dynamic error" 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A> if the template that is invoked declares a <A 
  title="template parameter" 
  href="REC-xslt20-20070123.htm#dt-template-parameter">template 
  parameter</A> with <CODE>required="yes"</CODE> and no value for this parameter 
  is supplied by the calling instruction.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTRE0795"><SPAN 
  class=error>ERR XTRE0795</SPAN></A> 
  <DD>
  <P>It is a <A title="recoverable error" 
  href="REC-xslt20-20070123.htm#dt-recoverable-error">recoverable 
  dynamic error</A> if the name of a constructed attribute is 
  <CODE>xml:space</CODE> and the value is not either <CODE>default</CODE> or 
  <CODE>preserve</CODE>.<BR><I>&nbsp;&nbsp;&nbsp;&nbsp;Action:</I> The <A 
  title="optional recovery action" 
  href="REC-xslt20-20070123.htm#dt-optional-recovery-action">optional 
  recovery action</A> is to construct the attribute with the value as 
  requested.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTDE0820"><SPAN 
  class=error>ERR XTDE0820</SPAN></A> 
  <DD>
  <P>It is a <A title="non-recoverable dynamic error" 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A> if the <A title="effective value" 
  href="REC-xslt20-20070123.htm#dt-effective-value">effective 
  value</A> of the <CODE>name</CODE> attribute [of the <A 
  href="REC-xslt20-20070123.htm#element-element"><CODE>xsl:element</CODE></A> 
  instruction] is not a <A title="lexical QName" 
  href="REC-xslt20-20070123.htm#dt-lexical-qname">lexical 
  QName</A>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTDE0830"><SPAN 
  class=error>ERR XTDE0830</SPAN></A> 
  <DD>
  <P>In the case of an <A 
  href="REC-xslt20-20070123.htm#element-element"><CODE>xsl:element</CODE></A> 
  instruction with no <CODE>namespace</CODE> attribute, it is a <A 
  title="non-recoverable dynamic error" 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A> if the <A title="effective value" 
  href="REC-xslt20-20070123.htm#dt-effective-value">effective 
  value</A> of the <CODE>name</CODE> attribute is a <A title=QName 
  href="REC-xslt20-20070123.htm#dt-qname">QName</A> whose 
  prefix is not declared in an in-scope namespace declaration for the <A 
  href="REC-xslt20-20070123.htm#element-element"><CODE>xsl:element</CODE></A> 
  instruction.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTDE0835"><SPAN 
  class=error>ERR XTDE0835</SPAN></A> 
  <DD>
  <P>It is a <A title="non-recoverable dynamic error" 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A> if the <A title="effective value" 
  href="REC-xslt20-20070123.htm#dt-effective-value">effective 
  value</A> of the <CODE>namespace</CODE> attribute [of the <A 
  href="REC-xslt20-20070123.htm#element-element"><CODE>xsl:element</CODE></A> 
  instruction] is not in the lexical space of the <CODE>xs:anyURI</CODE> data 
  type.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTDE0850"><SPAN 
  class=error>ERR XTDE0850</SPAN></A> 
  <DD>
  <P>It is a <A title="non-recoverable dynamic error" 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A> if the <A title="effective value" 
  href="REC-xslt20-20070123.htm#dt-effective-value">effective 
  value</A> of the <CODE>name</CODE> attribute [of an <A 
  href="REC-xslt20-20070123.htm#element-attribute"><CODE>xsl:attribute</CODE></A> 
  instruction] is not a <A title="lexical QName" 
  href="REC-xslt20-20070123.htm#dt-lexical-qname">lexical 
  QName</A>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTDE0855"><SPAN 
  class=error>ERR XTDE0855</SPAN></A> 
  <DD>
  <P>In the case of an <A 
  href="REC-xslt20-20070123.htm#element-attribute"><CODE>xsl:attribute</CODE></A> 
  instruction with no <CODE>namespace</CODE> attribute, it is a <A 
  title="non-recoverable dynamic error" 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A> if the <A title="effective value" 
  href="REC-xslt20-20070123.htm#dt-effective-value">effective 
  value</A> of the <CODE>name</CODE> attribute is the string 
  <CODE>xmlns</CODE>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTDE0860"><SPAN 
  class=error>ERR XTDE0860</SPAN></A> 
  <DD>
  <P>In the case of an <A 
  href="REC-xslt20-20070123.htm#element-attribute"><CODE>xsl:attribute</CODE></A> 
  instruction with no <CODE>namespace</CODE> attribute, it is a <A 
  title="non-recoverable dynamic error" 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A> if the <A title="effective value" 
  href="REC-xslt20-20070123.htm#dt-effective-value">effective 
  value</A> of the <CODE>name</CODE> attribute is a <A title="lexical QName" 
  href="REC-xslt20-20070123.htm#dt-lexical-qname">lexical 
  QName</A> whose prefix is not declared in an in-scope namespace declaration 
  for the <A 
  href="REC-xslt20-20070123.htm#element-attribute"><CODE>xsl:attribute</CODE></A> 
  instruction.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTDE0865"><SPAN 
  class=error>ERR XTDE0865</SPAN></A> 
  <DD>
  <P>It is a <A title="non-recoverable dynamic error" 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A> if the <A title="effective value" 
  href="REC-xslt20-20070123.htm#dt-effective-value">effective 
  value</A> of the <CODE>namespace</CODE> attribute [of the <A 
  href="REC-xslt20-20070123.htm#element-attribute"><CODE>xsl:attribute</CODE></A> 
  instruction] is not in the lexical space of the <CODE>xs:anyURI</CODE> data 
  type.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTDE0890"><SPAN 
  class=error>ERR XTDE0890</SPAN></A> 
  <DD>
  <P>It is a <A title="non-recoverable dynamic error" 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A> if the <A title="effective value" 
  href="REC-xslt20-20070123.htm#dt-effective-value">effective 
  value</A> of the <CODE>name</CODE> attribute [of the <A 
  href="REC-xslt20-20070123.htm#element-processing-instruction"><CODE>xsl:processing-instruction</CODE></A> 
  instruction] is not both an <A 
  href="http://www.w3.org/TR/REC-xml-names/#NT-NCName">NCName</A><SUP> 
  <SMALL>Names</SMALL></SUP> and a <A 
  href="http://www.w3.org/TR/2000/REC-xml-20001006#NT-PITarget">PITarget</A><SUP> 
  <SMALL>XML</SMALL></SUP>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTDE0905"><SPAN 
  class=error>ERR XTDE0905</SPAN></A> 
  <DD>
  <P>It is a <A title="non-recoverable dynamic error" 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A> if the string value of the new namespace node [created using 
  <A 
  href="REC-xslt20-20070123.htm#element-namespace"><CODE>xsl:namespace</CODE></A>] 
  is not valid in the lexical space of the data type <CODE>xs:anyURI</CODE>. 
  <SPAN class=error>[see <A 
  href="REC-xslt20-20070123.htm#err-XTDE0835">ERR 
  XTDE0835</A>]</SPAN></P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTDE0920"><SPAN 
  class=error>ERR XTDE0920</SPAN></A> 
  <DD>
  <P>It is a <A title="non-recoverable dynamic error" 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A> if the <A title="effective value" 
  href="REC-xslt20-20070123.htm#dt-effective-value">effective 
  value</A> of the <CODE>name</CODE> attribute [of the <A 
  href="REC-xslt20-20070123.htm#element-namespace"><CODE>xsl:namespace</CODE></A> 
  instruction] is neither a zero-length string nor an <A 
  href="http://www.w3.org/TR/REC-xml-names/#NT-NCName">NCName</A><SUP> 
  <SMALL>Names</SMALL></SUP>, or if it is <CODE>xmlns</CODE>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTDE0925"><SPAN 
  class=error>ERR XTDE0925</SPAN></A> 
  <DD>
  <P>It is a <A title="non-recoverable dynamic error" 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A> if the <A 
  href="REC-xslt20-20070123.htm#element-namespace"><CODE>xsl:namespace</CODE></A> 
  instruction generates a namespace node whose name is <CODE>xml</CODE> and 
  whose string value is not <CODE>http://www.w3.org/XML/1998/namespace</CODE>, 
  or a namespace node whose string value is 
  <CODE>http://www.w3.org/XML/1998/namespace</CODE> and whose name is not 
  <CODE>xml</CODE>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTDE0930"><SPAN 
  class=error>ERR XTDE0930</SPAN></A> 
  <DD>
  <P>It is a <A title="non-recoverable dynamic error" 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A> if evaluating the <SPAN><CODE>select</CODE> attribute or the 
  contained <A title="sequence constructor" 
  href="REC-xslt20-20070123.htm#dt-sequence-constructor">sequence 
  constructor</A> of an <A 
  href="REC-xslt20-20070123.htm#element-namespace"><CODE>xsl:namespace</CODE></A> 
  instruction</SPAN> results in a zero-length string.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTDE0980"><SPAN 
  class=error>ERR XTDE0980</SPAN></A> 
  <DD>
  <P>It is a <A title="non-recoverable dynamic error" 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A> if any undiscarded item in the atomized sequence supplied as 
  the value of the <CODE>value</CODE> attribute of <A 
  href="REC-xslt20-20070123.htm#element-number"><CODE>xsl:number</CODE></A> 
  cannot be converted to an integer, or if the resulting integer is less than 0 
  (zero).</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTDE1030"><SPAN 
  class=error>ERR XTDE1030</SPAN></A> 
  <DD>
  <P>It is a <A title="non-recoverable dynamic error" 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A> if, for any <A title="sort key component" 
  href="REC-xslt20-20070123.htm#dt-sort-key-component">sort 
  key component</A>, the set of <A title="sort key value" 
  href="REC-xslt20-20070123.htm#dt-sort-key-value">sort 
  key values</A> evaluated for all the items in the <A title="initial sequence" 
  href="REC-xslt20-20070123.htm#dt-initial-sequence">initial 
  sequence</A>, after any type conversion requested, contains a pair of ordinary 
  values for which the result of the XPath <CODE>lt</CODE> operator is an 
  error.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTDE1035"><SPAN 
  class=error>ERR XTDE1035</SPAN></A> 
  <DD>
  <P>It is a <A title="non-recoverable dynamic error" 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A> if the <CODE>collation</CODE> attribute of <A 
  href="REC-xslt20-20070123.htm#element-sort"><CODE>xsl:sort</CODE></A> 
  (after resolving against the base URI) is not a URI that is recognized by the 
  implementation as referring to a collation.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTDE1110"><SPAN 
  class=error>ERR XTDE1110</SPAN></A> 
  <DD>
  <P>It is a <A title="non-recoverable dynamic error" 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A> if the collation URI specified to <A 
  href="REC-xslt20-20070123.htm#element-for-each-group"><CODE>xsl:for-each-group</CODE></A> 
  <SPAN>(after resolving against the base URI)</SPAN> is a collation that is not 
  recognized by the implementation. (For notes, <SPAN class=error>[see <A 
  href="REC-xslt20-20070123.htm#err-XTDE1035">ERR 
  XTDE1035</A>]</SPAN>.)</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTDE1140"><SPAN 
  class=error>ERR XTDE1140</SPAN></A> 
  <DD>
  <P>It is a <A title="non-recoverable dynamic error" 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A> if the <A title="effective value" 
  href="REC-xslt20-20070123.htm#dt-effective-value">effective 
  value</A> of the <CODE>regex</CODE> attribute [of the <A 
  href="REC-xslt20-20070123.htm#element-analyze-string"><CODE>xsl:analyze-string</CODE></A> 
  instruction] does not conform to the <SPAN class=verb>required</SPAN> syntax 
  for regular expressions, as specified in <A 
  href="REC-xslt20-20070123.htm#xpath-functions">[Functions 
  and Operators]</A>. If the regular expression is known statically (for 
  example, if the attribute does not contain any <A title=expression 
  href="REC-xslt20-20070123.htm#dt-expression">expressions</A> 
  enclosed in curly brackets) then the processor <SPAN class=verb>may</SPAN> 
  signal the error as a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTDE1145"><SPAN 
  class=error>ERR XTDE1145</SPAN></A> 
  <DD>
  <P>It is a <A title="non-recoverable dynamic error" 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A> if the <A title="effective value" 
  href="REC-xslt20-20070123.htm#dt-effective-value">effective 
  value</A> of the <CODE>flags</CODE> attribute [of the <A 
  href="REC-xslt20-20070123.htm#element-analyze-string"><CODE>xsl:analyze-string</CODE></A> 
  instruction] has a value other than the values defined in <A 
  href="REC-xslt20-20070123.htm#xpath-functions">[Functions 
  and Operators]</A>. If the value of the attribute is known statically (for 
  example, if the attribute does not contain any <A title=expression 
  href="REC-xslt20-20070123.htm#dt-expression">expressions</A> 
  enclosed in curly brackets) then the processor <SPAN class=verb>may</SPAN> 
  signal the error as a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTDE1150"><SPAN 
  class=error>ERR XTDE1150</SPAN></A> 
  <DD>
  <P>It is a <A title="non-recoverable dynamic error" 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A> if the <A title="effective value" 
  href="REC-xslt20-20070123.htm#dt-effective-value">effective 
  value</A> of the <CODE>regex</CODE> attribute [of the <A 
  href="REC-xslt20-20070123.htm#element-analyze-string"><CODE>xsl:analyze-string</CODE></A> 
  instruction] is a regular expression that matches a zero-length string: or 
  more specifically, if the regular expression <CODE>$r</CODE> and flags 
  <CODE>$f</CODE> are such that <CODE>matches("", $r, $f)</CODE> returns true. 
  If the regular expression is known statically (for example, if the attribute 
  does not contain any <A title=expression 
  href="REC-xslt20-20070123.htm#dt-expression">expressions</A> 
  enclosed in curly brackets) then the processor <SPAN class=verb>may</SPAN> 
  signal the error as a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTRE1160"><SPAN 
  class=error>ERR XTRE1160</SPAN></A> 
  <DD>
  <P>When a URI reference [supplied to the <A 
  href="REC-xslt20-20070123.htm#function-document"><CODE>document</CODE></A> 
  function] contains a fragment identifier, it is a <A title="recoverable error" 
  href="REC-xslt20-20070123.htm#dt-recoverable-error">recoverable 
  dynamic error</A> if the media type is not one that is recognized by the 
  processor, or if the fragment identifier does not conform to the rules for 
  fragment identifiers for that media type, or if the fragment identifier 
  selects something other than a sequence of nodes (for example, if it selects a 
  range of characters within a text 
  node).<BR><I>&nbsp;&nbsp;&nbsp;&nbsp;Action:</I> The <A 
  title="optional recovery action" 
  href="REC-xslt20-20070123.htm#dt-optional-recovery-action">optional 
  recovery action</A> is to ignore the fragment identifier and return the 
  document node.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTDE1170"><SPAN 
  class=error>ERR XTDE1170</SPAN></A> 
  <DD>
  <P>It is a <A title="non-recoverable dynamic error" 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A> if a URI [supplied in the first argument to the <A 
  href="REC-xslt20-20070123.htm#function-unparsed-text"><CODE>unparsed-text</CODE></A> 
  function] <SPAN>contains a fragment identifier,</SPAN> or if it cannot be used 
  to retrieve a resource containing text.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTDE1190"><SPAN 
  class=error>ERR XTDE1190</SPAN></A> 
  <DD>
  <P>It is a <A title="non-recoverable dynamic error" 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A> if a resource [retrieved using the <A 
  href="REC-xslt20-20070123.htm#function-unparsed-text"><CODE>unparsed-text</CODE></A> 
  function] contains octets that cannot be decoded into Unicode characters using 
  the specified encoding, or if the resulting characters are not permitted XML 
  characters. This includes the case where the <A title=processor 
  href="REC-xslt20-20070123.htm#dt-processor">processor</A> 
  does not support the requested encoding.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTDE1200"><SPAN 
  class=error>ERR XTDE1200</SPAN></A> 
  <DD>
  <P>It is a <A title="non-recoverable dynamic error" 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A> if the second argument of the <A 
  href="REC-xslt20-20070123.htm#function-unparsed-text"><CODE>unparsed-text</CODE></A> 
  function is omitted and the <A title=processor 
  href="REC-xslt20-20070123.htm#dt-processor">processor</A> 
  cannot infer the encoding using external information and the encoding is not 
  UTF-8.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTDE1260"><SPAN 
  class=error>ERR XTDE1260</SPAN></A> 
  <DD>
  <P>It is a <A title="non-recoverable dynamic error" 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A> if the value [of the first argument to the <A 
  href="REC-xslt20-20070123.htm#function-key"><CODE>key</CODE></A> 
  function] is not a valid QName, or if there is no namespace declaration in 
  scope for the prefix of the QName, or if the name obtained by expanding the 
  QName is not the same as the expanded name of any <A 
  href="REC-xslt20-20070123.htm#element-key"><CODE>xsl:key</CODE></A> 
  declaration in the <A title=stylesheet 
  href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A>. 
  If the processor is able to detect the error statically (for example, when the 
  argument is supplied as a string literal), then the processor <SPAN 
  class=verb>may</SPAN> optionally signal this as a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTDE1270"><SPAN 
  class=error>ERR XTDE1270</SPAN></A> 
  <DD>
  <P>It is a <A title="non-recoverable dynamic error" 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A> to call the <A 
  href="REC-xslt20-20070123.htm#function-key"><CODE>key</CODE></A> 
  function with two arguments if there is no <A title="context node" 
  href="REC-xslt20-20070123.htm#dt-context-node">context 
  node</A>, <SPAN>or if the root of the tree containing the context node is not 
  a document node</SPAN>; or to call the function with three arguments if the 
  root of the tree containing the node supplied in the third argument is not a 
  document node.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTDE1280"><SPAN 
  class=error>ERR XTDE1280</SPAN></A> 
  <DD>
  <P>It is a <A title="non-recoverable dynamic error" 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A> if the name specified as the 
  <CODE>$decimal-format-name</CODE> argument [ to the <A 
  href="REC-xslt20-20070123.htm#function-format-number"><CODE>format-number</CODE></A> 
  function] <SPAN>is not a valid <A title=QName 
  href="REC-xslt20-20070123.htm#dt-qname">QName</A>, or 
  if its prefix has not been declared in an in-scope namespace 
  declaration</SPAN>, or if the <A title=stylesheet 
  href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
  does not contain a declaration of a decimal-format with a matching <A 
  title=expanded-QName 
  href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded-QName</A>. 
  If the processor is able to detect the error statically (for example, when the 
  argument is supplied as a string literal), then the processor <SPAN 
  class=verb>may</SPAN> optionally signal this as a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTDE1310"><SPAN 
  class=error>ERR XTDE1310</SPAN></A> 
  <DD>
  <P>The <A title="picture string" 
  href="REC-xslt20-20070123.htm#dt-picture-string">picture 
  string</A> [supplied to the <A 
  href="REC-xslt20-20070123.htm#function-format-number"><CODE>format-number</CODE></A> 
  function] <SPAN class=verb>must</SPAN> conform to the following rules. [ See 
  full specification.] It is a <A title="non-recoverable dynamic error" 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A> if the picture string does not satisfy these rules.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTDE1340"><SPAN 
  class=error>ERR XTDE1340</SPAN></A> 
  <DD>
  <P>It is a <A title="non-recoverable dynamic error" 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A> if the syntax of the picture [used for date/time formatting] 
  is incorrect.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTDE1350"><SPAN 
  class=error>ERR XTDE1350</SPAN></A> 
  <DD>
  <P>It is a <A title="non-recoverable dynamic error" 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A> if a component specifier within the picture [used for 
  date/time formatting] refers to components that are not available in the given 
  type of <CODE>$value</CODE>, for example if the picture supplied to the <A 
  href="REC-xslt20-20070123.htm#function-format-time"><CODE>format-time</CODE></A> 
  refers to the year, month, or day component.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTDE1360"><SPAN 
  class=error>ERR XTDE1360</SPAN></A> 
  <DD>
  <P>If the <A 
  href="REC-xslt20-20070123.htm#function-current"><CODE>current</CODE></A> 
  function is evaluated within an expression that is evaluated when the context 
  item is undefined, a <A title="non-recoverable dynamic error" 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A> occurs.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTDE1370"><SPAN 
  class=error>ERR XTDE1370</SPAN></A> 
  <DD>
  <P>It is a <A title="non-recoverable dynamic error" 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A> if the <A 
  href="REC-xslt20-20070123.htm#function-unparsed-entity-uri"><CODE>unparsed-entity-uri</CODE></A> 
  function is called when there is no <A title="context node" 
  href="REC-xslt20-20070123.htm#dt-context-node">context 
  node</A>, or when the root of the tree containing the context node is not a 
  document node.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTDE1380"><SPAN 
  class=error>ERR XTDE1380</SPAN></A> 
  <DD>
  <P>It is a <A title="non-recoverable dynamic error" 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A> if the <A 
  href="REC-xslt20-20070123.htm#function-unparsed-entity-public-id"><CODE>unparsed-entity-public-id</CODE></A> 
  function is called when there is no <A title="context node" 
  href="REC-xslt20-20070123.htm#dt-context-node">context 
  node</A>, or when the root of the tree containing the context node is not a 
  document node.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTDE1390"><SPAN 
  class=error>ERR XTDE1390</SPAN></A> 
  <DD>
  <P>It is a <A title="non-recoverable dynamic error" 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A> if the value [supplied as the <CODE>$property-name</CODE> 
  argument to the <A 
  href="REC-xslt20-20070123.htm#function-system-property"><CODE>system-property</CODE></A> 
  function] is not a valid QName, or if there is no namespace declaration in 
  scope for the prefix of the QName. If the processor is able to detect the 
  error statically (for example, when the argument is supplied as a string 
  literal), then the processor <SPAN class=verb>may</SPAN> optionally signal 
  this as a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTMM9000"><SPAN 
  class=error>ERR XTMM9000</SPAN></A> 
  <DD>
  <P>When a transformation is terminated by use of <CODE>xsl:message 
  terminate="yes"</CODE>, the effect is the same as when a <A 
  title="non-recoverable dynamic error" 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A> occurs during the transformation.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTDE1400"><SPAN 
  class=error>ERR XTDE1400</SPAN></A> 
  <DD>
  <P>It is a <A title="non-recoverable dynamic error" 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A> if the argument [passed to the <A 
  href="REC-xslt20-20070123.htm#function-function-available"><CODE>function-available</CODE></A> 
  function] does not evaluate to a string that is a valid <A title=QName 
  href="REC-xslt20-20070123.htm#dt-qname">QName</A>, or 
  if there is no namespace declaration in scope for the prefix of the <A 
  title=QName 
  href="REC-xslt20-20070123.htm#dt-qname">QName</A>. If 
  the processor is able to detect the error statically (for example, when the 
  argument is supplied as a string literal), then the processor <SPAN 
  class=verb>may</SPAN> optionally signal this as a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTDE1420"><SPAN 
  class=error>ERR XTDE1420</SPAN></A> 
  <DD>
  <P>It is a <A title="non-recoverable dynamic error" 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A> if the arguments supplied to a call on an extension function 
  do not satisfy the rules defined for that particular extension function, or if 
  the extension function reports an error, or if the result of the extension 
  function cannot be converted to an XPath value.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTDE1425"><SPAN 
  class=error>ERR XTDE1425</SPAN></A> 
  <DD>
  <P>When <A title="backwards compatible behavior" 
  href="REC-xslt20-20070123.htm#dt-backwards-compatible-behavior">backwards 
  compatible behavior</A> is enabled, it is a <A 
  title="non-recoverable dynamic error" 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A> to evaluate an extension function call if no implementation 
  of the extension function is available.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTDE1428"><SPAN 
  class=error>ERR XTDE1428</SPAN></A> 
  <DD>
  <P>It is a <A title="non-recoverable dynamic error" 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A> if the argument [passed to the <A 
  href="REC-xslt20-20070123.htm#function-type-available"><CODE>type-available</CODE></A> 
  function] does not evaluate to a string that is a valid <A title=QName 
  href="REC-xslt20-20070123.htm#dt-qname">QName</A>, or 
  if there is no namespace declaration in scope for the prefix of the <A 
  title=QName 
  href="REC-xslt20-20070123.htm#dt-qname">QName</A>. If 
  the processor is able to detect the error statically (for example, when the 
  argument is supplied as a string literal), then the processor <SPAN 
  class=verb>may</SPAN> optionally signal this as a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTDE1440"><SPAN 
  class=error>ERR XTDE1440</SPAN></A> 
  <DD>
  <P>It is a <A title="non-recoverable dynamic error" 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A> if the argument [passed to the <A 
  href="REC-xslt20-20070123.htm#function-element-available"><CODE>element-available</CODE></A> 
  function] does not evaluate to a string that is a valid <A title=QName 
  href="REC-xslt20-20070123.htm#dt-qname">QName</A>, or 
  if there is no namespace declaration in scope for the prefix of the <A 
  title=QName 
  href="REC-xslt20-20070123.htm#dt-qname">QName</A>. If 
  the processor is able to detect the error statically (for example, when the 
  argument is supplied as a string literal), then the processor <SPAN 
  class=verb>may</SPAN> optionally signal this as a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTDE1450"><SPAN 
  class=error>ERR XTDE1450</SPAN></A> 
  <DD>
  <P>When a <A title=processor 
  href="REC-xslt20-20070123.htm#dt-processor">processor</A> 
  performs fallback for an <A title="extension instruction" 
  href="REC-xslt20-20070123.htm#dt-extension-instruction">extension 
  instruction</A> that is not recognized, if the instruction element has one or 
  more <A 
  href="REC-xslt20-20070123.htm#element-fallback"><CODE>xsl:fallback</CODE></A> 
  children, then the content of each of the <A 
  href="REC-xslt20-20070123.htm#element-fallback"><CODE>xsl:fallback</CODE></A> 
  children <SPAN class=verb>must</SPAN> be evaluated; it is a <A 
  title="non-recoverable dynamic error" 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A> if it has no <A 
  href="REC-xslt20-20070123.htm#element-fallback"><CODE>xsl:fallback</CODE></A> 
  children.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTDE1460"><SPAN 
  class=error>ERR XTDE1460</SPAN></A> 
  <DD>
  <P>It is a <A title="non-recoverable dynamic error" 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A> if the <A title="effective value" 
  href="REC-xslt20-20070123.htm#dt-effective-value">effective 
  value</A> of the <CODE>format</CODE> attribute [of an <A 
  href="REC-xslt20-20070123.htm#element-result-document"><CODE>xsl:result-document</CODE></A> 
  element] is not a valid <A title="lexical QName" 
  href="REC-xslt20-20070123.htm#dt-lexical-qname">lexical 
  QName</A>, or if it does not match the <A title=expanded-QName 
  href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded-QName</A> 
  of an <A title="output definition" 
  href="REC-xslt20-20070123.htm#dt-output-definition">output 
  definition</A> in the <A title=stylesheet 
  href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A>. 
  If the processor is able to detect the error statically (for example, when the 
  <CODE>format</CODE> attribute contains no curly brackets), then the processor 
  <SPAN class=verb>may</SPAN> optionally signal this as a <A 
  title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTDE1480"><SPAN 
  class=error>ERR XTDE1480</SPAN></A> 
  <DD>
  <P>It is a <A title="non-recoverable dynamic error" 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A> to evaluate the <A 
  href="REC-xslt20-20070123.htm#element-result-document"><CODE>xsl:result-document</CODE></A> 
  instruction in <A title="temporary output state" 
  href="REC-xslt20-20070123.htm#dt-temporary-output-state">temporary 
  output state</A>.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTDE1490"><SPAN 
  class=error>ERR XTDE1490</SPAN></A> 
  <DD>
  <P>It is a <A title="non-recoverable dynamic error" 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A> for a transformation to generate two or more <A 
  title="final result tree" 
  href="REC-xslt20-20070123.htm#dt-final-result-tree">final 
  result trees</A> with the same URI.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTRE1495"><SPAN 
  class=error>ERR XTRE1495</SPAN></A> 
  <DD>
  <P>It is a <A title="recoverable error" 
  href="REC-xslt20-20070123.htm#dt-recoverable-error">recoverable 
  dynamic error</A> for a transformation to generate two or more <A 
  title="final result tree" 
  href="REC-xslt20-20070123.htm#dt-final-result-tree">final 
  result trees</A> with URIs that identify the same physical resource. The <A 
  title="optional recovery action" 
  href="REC-xslt20-20070123.htm#dt-optional-recovery-action">optional 
  recovery action</A> is <A title=implementation-dependent 
  href="REC-xslt20-20070123.htm#dt-implementation-dependent">implementation-dependent</A>, 
  since it may be impossible for the processor to detect the error.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTRE1500"><SPAN 
  class=error>ERR XTRE1500</SPAN></A> 
  <DD>
  <P>It is a <A title="recoverable error" 
  href="REC-xslt20-20070123.htm#dt-recoverable-error">recoverable 
  dynamic error</A> for a <A title=stylesheet 
  href="REC-xslt20-20070123.htm#dt-stylesheet">stylesheet</A> 
  to write to an external resource and read from the same resource during a 
  single transformation, whether or not the same URI is used to access the 
  resource in both cases.<BR><I>&nbsp;&nbsp;&nbsp;&nbsp;Action:</I> The <A 
  title="optional recovery action" 
  href="REC-xslt20-20070123.htm#dt-optional-recovery-action">optional 
  recovery action</A> is <A title=implementation-dependent 
  href="REC-xslt20-20070123.htm#dt-implementation-dependent">implementation-dependent</A>: 
  implementations are not <SPAN class=verb>required</SPAN> to detect the error 
  condition. <SPAN>Note that if the error is not detected, it is undefined 
  whether the document that is read from the resource reflects its state before 
  or after the result tree is written.</SPAN></P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTRE1620"><SPAN 
  class=error>ERR XTRE1620</SPAN></A> 
  <DD>
  <P>It is a <A title="recoverable error" 
  href="REC-xslt20-20070123.htm#dt-recoverable-error">recoverable 
  dynamic error</A> if an <A 
  href="REC-xslt20-20070123.htm#element-value-of"><CODE>xsl:value-of</CODE></A> 
  or <A 
  href="REC-xslt20-20070123.htm#element-text"><CODE>xsl:text</CODE></A> 
  instruction specifies that output escaping is to be disabled and the 
  implementation does not support 
  this.<BR><I>&nbsp;&nbsp;&nbsp;&nbsp;Action:</I> The <A 
  title="optional recovery action" 
  href="REC-xslt20-20070123.htm#dt-optional-recovery-action">optional 
  recovery action</A> is to ignore the <CODE>disable-output-escaping</CODE> 
  attribute.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTRE1630"><SPAN 
  class=error>ERR XTRE1630</SPAN></A> 
  <DD>
  <P>It is a <A title="recoverable error" 
  href="REC-xslt20-20070123.htm#dt-recoverable-error">recoverable 
  dynamic error</A> if an <A 
  href="REC-xslt20-20070123.htm#element-value-of"><CODE>xsl:value-of</CODE></A> 
  or <A 
  href="REC-xslt20-20070123.htm#element-text"><CODE>xsl:text</CODE></A> 
  instruction specifies that output escaping is to be disabled when writing to a 
  <A title="final result tree" 
  href="REC-xslt20-20070123.htm#dt-final-result-tree">final 
  result tree</A> that is not being 
  serialized.<BR><I>&nbsp;&nbsp;&nbsp;&nbsp;Action:</I> The <A 
  title="optional recovery action" 
  href="REC-xslt20-20070123.htm#dt-optional-recovery-action">optional 
  recovery action</A> is to ignore the <CODE>disable-output-escaping</CODE> 
  attribute.</P>
  <DT><A 
  href="REC-xslt20-20070123.htm#err-XTDE1665"><SPAN 
  class=error>ERR XTDE1665</SPAN></A> 
  <DD>
  <P>A <A title="basic XSLT processor" 
  href="REC-xslt20-20070123.htm#dt-basic-xslt-processor">basic 
  XSLT processor</A> <SPAN class=verb>must</SPAN> raise a <A 
  title="non-recoverable dynamic error" 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A> if the input to the processor includes a node with a <A 
  title="type annotation" 
  href="REC-xslt20-20070123.htm#dt-annotation">type 
  annotation</A> other than <SPAN><CODE>xs:untyped</CODE></SPAN> or 
  <SPAN><CODE>xs:untypedAtomic</CODE></SPAN>, or an atomic value of a type other 
  than those which a basic XSLT processor supports.</P></DD></DL></DIV>
<DIV class=div1>
<H2><A id=implementation-defined-features 
name=implementation-defined-features></A>F Checklist of Implementation-Defined 
Features (Non-Normative)</H2>
<P>This appendix provides a summary of XSLT language features whose effect is 
explicitly <A title=implementation-defined 
href="REC-xslt20-20070123.htm#dt-implementation-defined">implementation-defined</A>. 
The conformance rules (see <A 
href="REC-xslt20-20070123.htm#conformance"><I>21 
Conformance</I></A>) require vendors to provide documentation that explains how 
these choices have been exercised.</P>
<OL>
  <LI>
  <P>The way in which an XSLT processor is invoked, and the way in which values 
  are supplied for the source document, starting node, <A 
  title="stylesheet parameter" 
  href="REC-xslt20-20070123.htm#dt-stylesheet-parameter">stylesheet 
  parameters</A>, and <A title="base output URI" 
  href="REC-xslt20-20070123.htm#dt-base-output-uri">base 
  output URI</A>, are implementation-defined. (See <A 
  href="REC-xslt20-20070123.htm#initiating"><I>2.3 
  Initiating a Transformation</I></A>)</P>
  <LI>
  <P>The mechanisms for creating new extension instructions and extension 
  functions are implementation-defined. (See <A 
  href="REC-xslt20-20070123.htm#extensibility"><I>2.7 
  Extensibility</I></A>)</P>
  <LI>
  <P>Where the specification provides a choice between signaling a dynamic error 
  or recovering, the decision that is made (but not the recovery action itself) 
  is implementation-defined. (See <A 
  href="REC-xslt20-20070123.htm#errors"><I>2.9 Error 
  Handling</I></A>)</P>
  <LI>
  <P>It is implementation-defined whether type errors are signaled statically. 
  (See <A href="REC-xslt20-20070123.htm#errors"><I>2.9 
  Error Handling</I></A>)</P>
  <LI>
  <P>The set of namespaces that are specially recognized by the implementation 
  (for example, for user-defined data elements, and <A 
  title="extension attribute" 
  href="REC-xslt20-20070123.htm#dt-extension-attribute">extension 
  attributes</A>) is implementation-defined. (See <A 
  href="REC-xslt20-20070123.htm#user-defined-top-level"><I>3.6.2 
  User-defined Data Elements</I></A>)</P>
  <LI>
  <P>The effect of user-defined data elements whose name is in a namespace 
  recognized by the implementation is implementation-defined. (See <A 
  href="REC-xslt20-20070123.htm#user-defined-top-level"><I>3.6.2 
  User-defined Data Elements</I></A>)</P>
  <LI>
  <P>It is implementation-defined whether an XSLT 2.0 processor supports 
  backwards-compatible behavior. (See <A 
  href="REC-xslt20-20070123.htm#backwards"><I>3.8 
  Backwards-Compatible Processing</I></A>)</P>
  <LI>
  <P>It is implementation-defined what forms of URI reference are acceptable in 
  the <CODE>href</CODE> attribute of the <A 
  href="REC-xslt20-20070123.htm#element-include"><CODE>xsl:include</CODE></A> 
  and <A 
  href="REC-xslt20-20070123.htm#element-import"><CODE>xsl:import</CODE></A> 
  elements, for example, the URI schemes that may be used, the forms of fragment 
  identifier that may be used, and the media types that are supported. (See <A 
  href="REC-xslt20-20070123.htm#locating-modules"><I>3.10.1 
  Locating Stylesheet Modules</I></A>)</P>
  <LI>
  <P>An implementation may define mechanisms, above and beyond <A 
  href="REC-xslt20-20070123.htm#element-import-schema"><CODE>xsl:import-schema</CODE></A> 
  that allow <A title="schema component" 
  href="REC-xslt20-20070123.htm#dt-schema-component">schema 
  components</A> such as type definitions to be made available within a 
  stylesheet. (See <A 
  href="REC-xslt20-20070123.htm#built-in-types"><I>3.13 
  Built-in Types</I></A>)</P>
  <LI>
  <P>It is implementation-defined which versions of XML and XML Namespaces (1.0 
  and/or 1.1) are supported. (See <A 
  href="REC-xslt20-20070123.htm#xml-versions"><I>4.1 XML 
  Versions</I></A>)</P>
  <LI>
  <P>Limits on the value space of primitive data types, where not fixed by <A 
  href="REC-xslt20-20070123.htm#xmlschema-2">[XML Schema 
  Part 2]</A>, are implementation-defined. (See <A 
  href="REC-xslt20-20070123.htm#limits"><I>4.6 
  Limits</I></A>)</P>
  <LI>
  <P>The implicit timezone for a transformation is implementation-defined. (See 
  <A 
  href="REC-xslt20-20070123.htm#evaluation-context"><I>5.4.3.2 
  Other components of the XPath Dynamic Context</I></A>)</P>
  <LI>
  <P>If an <CODE>xml:id</CODE> attribute that has not been subjected to 
  attribute value normalization is copied from a source tree to a result tree, 
  it is implementation-defined whether attribute value normalization will be 
  applied during the copy process. (See <A 
  href="REC-xslt20-20070123.htm#shallow-copy"><I>11.9.1 
  Shallow Copy</I></A>)</P>
  <LI>
  <P>The numbering sequences supported by the <A 
  href="REC-xslt20-20070123.htm#element-number"><CODE>xsl:number</CODE></A> 
  instructions, beyond those defined in this specification, are 
  implementation-defined. (See <A 
  href="REC-xslt20-20070123.htm#convert"><I>12.3 Number 
  to String Conversion Attributes</I></A>)</P>
  <LI>
  <P>There <SPAN class=verb>may</SPAN> be implementation-defined upper bounds on 
  the numbers that can be formatted by <A 
  href="REC-xslt20-20070123.htm#element-number"><CODE>xsl:number</CODE></A> 
  using any particular numbering sequence. (See <A 
  href="REC-xslt20-20070123.htm#convert"><I>12.3 Number 
  to String Conversion Attributes</I></A>)</P>
  <LI>
  <P>The set of languages for which numbering is supported by <A 
  href="REC-xslt20-20070123.htm#element-number"><CODE>xsl:number</CODE></A>, 
  and the method of choosing a default language, are implementation-defined. 
  (See <A href="REC-xslt20-20070123.htm#convert"><I>12.3 
  Number to String Conversion Attributes</I></A>)</P>
  <LI>
  <P>If the <CODE>data-type</CODE> attribute of the <A 
  href="REC-xslt20-20070123.htm#element-sort"><CODE>xsl:sort</CODE></A> 
  element has a value other than <CODE>text</CODE> or <CODE>number</CODE>, the 
  effect is implementation-defined. (See <A 
  href="REC-xslt20-20070123.htm#comparing-sort-keys"><I>13.1.2 
  Comparing Sort Key Values</I></A>)</P>
  <LI>
  <P>The facilities for defining collations and allocating URIs to identify them 
  are implementation-defined. (See <A 
  href="REC-xslt20-20070123.htm#collating-sequences"><I>13.1.3 
  Sorting Using Collations</I></A>)</P>
  <LI>
  <P>The algorithm used by <A 
  href="REC-xslt20-20070123.htm#element-sort"><CODE>xsl:sort</CODE></A> 
  to locate a collation, given the values of the <CODE>lang</CODE> and 
  <CODE>case-order</CODE> attributes, is implementation-defined. (See <A 
  href="REC-xslt20-20070123.htm#collating-sequences"><I>13.1.3 
  Sorting Using Collations</I></A>)</P>
  <LI>
  <P>The set of media types recognized by the processor, for the purpose of 
  interpreting fragment identifiers in URI references passed to the <A 
  href="REC-xslt20-20070123.htm#function-document"><CODE>document</CODE></A> 
  function, is implementation-defined. (See <A 
  href="REC-xslt20-20070123.htm#document"><I>16.1 
  Multiple Source Documents</I></A>)</P>
  <LI>
  <P>The set of encodings recognized by the <A 
  href="REC-xslt20-20070123.htm#function-unparsed-text"><CODE>unparsed-text</CODE></A> 
  function, other than <CODE>utf-8</CODE> and <CODE>utf-16</CODE>, is <A 
  title=implementation-defined 
  href="REC-xslt20-20070123.htm#dt-implementation-defined">implementation-defined</A>. 
  (See <A 
  href="REC-xslt20-20070123.htm#unparsed-text"><I>16.2 
  Reading Text Files</I></A>)</P>
  <LI>
  <P>If no encoding is specified on a call to the <A 
  href="REC-xslt20-20070123.htm#function-unparsed-text"><CODE>unparsed-text</CODE></A> 
  function, the processor <SPAN class=verb>may</SPAN> use <A 
  title=implementation-defined 
  href="REC-xslt20-20070123.htm#dt-implementation-defined">implementation-defined</A> 
  heuristics to determine the likely encoding. (See <A 
  href="REC-xslt20-20070123.htm#unparsed-text"><I>16.2 
  Reading Text Files</I></A>)</P>
  <LI>
  <P>The set of languages, calendars, and countries that are supported in the <A 
  title="date formatting function" 
  href="REC-xslt20-20070123.htm#dt-date-formatting-function">date 
  formatting functions</A> is implementation-defined. If any of these arguments 
  is omitted or set to an empty sequence, the default is implementation-defined. 
  (See <A 
  href="REC-xslt20-20070123.htm#lang-cal-country"><I>16.5.2 
  The Language, Calendar, and Country Arguments</I></A>)</P>
  <LI>
  <P>The choice of the names and abbreviations used in any given language for 
  calendar units such as days of the week and months of the year is <A 
  title=implementation-defined 
  href="REC-xslt20-20070123.htm#dt-implementation-defined">implementation-defined</A>. 
  (See <A 
  href="REC-xslt20-20070123.htm#lang-cal-country"><I>16.5.2 
  The Language, Calendar, and Country Arguments</I></A>)</P>
  <LI>
  <P>The values returned by the <A 
  href="REC-xslt20-20070123.htm#function-system-property"><CODE>system-property</CODE></A> 
  function, and the names of the additional properties that are recognized, are 
  implementation-defined. (See <A 
  href="REC-xslt20-20070123.htm#system-property"><I>16.6.5 
  system-property</I></A>)</P>
  <LI>
  <P>The destination and formatting of messages written using the <A 
  href="REC-xslt20-20070123.htm#element-message"><CODE>xsl:message</CODE></A> 
  instruction are implementation-defined. (See <A 
  href="REC-xslt20-20070123.htm#message"><I>17 
  Messages</I></A>)</P>
  <LI>
  <P>The effect of an extension function returning a string containing 
  characters that are not legal in XML is implementation-defined. (See <A 
  href="REC-xslt20-20070123.htm#calling-extension-functions"><I>18.1.2 
  Calling Extension Functions</I></A>)</P>
  <LI>
  <P>The way in which external objects are represented in the type system is 
  implementation-defined. (See <A 
  href="REC-xslt20-20070123.htm#external-objects"><I>18.1.3 
  External Objects</I></A>)</P>
  <LI>
  <P>The way in which a final result tree is delivered to an application is 
  implementation-defined. (See <A 
  href="REC-xslt20-20070123.htm#result-trees"><I>19 Final 
  Result Trees</I></A>)</P>
  <LI>
  <P>Implementations <SPAN class=verb>may</SPAN> provide additional mechanisms 
  allowing users to define the way in which <A title="final result tree" 
  href="REC-xslt20-20070123.htm#dt-final-result-tree">final 
  result trees</A> are processed. (See <A 
  href="REC-xslt20-20070123.htm#creating-result-trees"><I>19.1 
  Creating Final Result Trees</I></A>)</P>
  <LI>
  <P>If serialization is supported, then the location to which a <A 
  title="final result tree" 
  href="REC-xslt20-20070123.htm#dt-final-result-tree">final 
  result tree</A> is serialized is implementation-defined, subject to the 
  constraint that relative URIs used to reference one tree from another remain 
  valid. (See <A 
  href="REC-xslt20-20070123.htm#serialization"><I>20 
  Serialization</I></A>)</P>
  <LI>
  <P>The default value of the <CODE>encoding</CODE> attribute of the <A 
  href="REC-xslt20-20070123.htm#element-output"><CODE>xsl:output</CODE></A> 
  element is implementation-defined. (See <A 
  href="REC-xslt20-20070123.htm#serialization"><I>20 
  Serialization</I></A>)</P>
  <LI>
  <P>It is implementation-defined which versions of XML, HTML, and XHTML are 
  supported in the <CODE>version</CODE> attribute of the <A 
  href="REC-xslt20-20070123.htm#element-output"><CODE>xsl:output</CODE></A> 
  declaration. (See <A 
  href="REC-xslt20-20070123.htm#serialization"><I>20 
  Serialization</I></A>)</P>
  <LI>
  <P>The default value of the <CODE>byte-order-mark</CODE> serialization 
  parameter is implementation-defined in the case of UTF-8 encoding. (See <A 
  href="REC-xslt20-20070123.htm#serialization"><I>20 
  Serialization</I></A>)</P>
  <LI>
  <P>It is implementation-defined whether, and under what circumstances, 
  disabling output escaping is supported. (See <A 
  href="REC-xslt20-20070123.htm#disable-output-escaping"><I>20.2 
  Disabling Output Escaping</I></A>)</P></LI></OL></DIV>
<DIV class=div1>
<H2><A id=schema-for-xslt name=schema-for-xslt></A>G Schema for XSLT Stylesheets 
(Non-Normative)</H2>
<P>The following schema describes the structure of an XSLT stylesheet module. It 
does not define all the constraints that apply to a stylesheet (for example, it 
does not attempt to define a data type that precisely represents attributes 
containing XPath <A title=expression 
href="REC-xslt20-20070123.htm#dt-expression">expressions</A>). 
<SPAN>However, every valid stylesheet module conforms to this schema, unless it 
contains elements that invoke <A title="forwards-compatible behavior" 
href="REC-xslt20-20070123.htm#dt-forwards-compatible-behavior">forwards-compatible-behavior</A>.</SPAN></P>
<P>A copy of this schema is available at <A 
href="http://www.w3.org/2007/schema-for-xslt20.xsd">http://www.w3.org/2007/schema-for-xslt20.xsd</A></P><PRE>&lt;?xml version="1.0"?&gt;
&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" targetNamespace="http://www.w3.org/1999/XSL/Transform" elementFormDefault="qualified" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;
&lt;xs:annotation&gt;
  &lt;xs:documentation&gt;
  
    This is a schema for XSLT 2.0 stylesheets.
    
    It defines all the elements that appear in the XSLT namespace; it also
    provides hooks that allow the inclusion of user-defined literal result elements,
    extension instructions, and top-level data elements.
    
    The schema is derived (with kind permission) from a schema for XSLT 1.0 stylesheets
    produced by Asir S Vedamuthu of WebMethods Inc.
    
    This schema is available for use under the conditions of the W3C Software License
    published at http://www.w3.org/Consortium/Legal/copyright-software-19980720
    
    The schema is organized as follows:
    
    PART A: definitions of complex types and model groups used as the basis 
            for element definitions
    PART B: definitions of individual XSLT elements
    PART C: definitions for literal result elements
    PART D: definitions of simple types used in attribute definitions
    
    This schema does not attempt to define all the constraints that apply to a valid
    XSLT 2.0 stylesheet module. It is the intention that all valid stylesheet modules 
    should conform to this schema; however, the schema is non-normative and in the event 
    of any conflict, the text of the Recommendation takes precedence.

    This schema does not implement the special rules that apply when a stylesheet
    has sections that use forwards-compatible-mode. In this mode, setting version="3.0"
    allows elements from the XSLT namespace to be used that are not defined in XSLT 2.0.

    Simplified stylesheets (those with a literal result element as the outermost element)
    will validate against this schema only if validation starts in lax mode.
    
    This version is dated 2005-02-11
    Authors: Michael H Kay, Saxonica Limited
             Jeni Tennison, Jeni Tennison Consulting Ltd.
    
  &lt;/xs:documentation&gt;
&lt;/xs:annotation&gt;   
&lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;
 
&lt;!--
The declaration of xml:space and xml:lang may need to be commented out because
of problems processing the schema using various tools
--&gt;
      
&lt;xs:import namespace="http://www.w3.org/XML/1998/namespace" 
  schemaLocation="http://www.w3.org/2001/xml.xsd"/&gt;

&lt;!-- 
    An XSLT stylesheet may contain an in-line schema within an xsl:import-schema element,
    so the Schema for schemas needs to be imported
--&gt;
  
&lt;xs:import namespace="http://www.w3.org/2001/XMLSchema"
                  schemaLocation="http://www.w3.org/2001/XMLSchema.xsd"/&gt;

&lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;
&lt;xs:annotation&gt;
  &lt;xs:documentation&gt;
    PART A: definitions of complex types and model groups used as the basis 
            for element definitions
  &lt;/xs:documentation&gt;
&lt;/xs:annotation&gt;   
&lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;

&lt;xs:complexType name="generic-element-type" mixed="true"&gt;
  &lt;xs:attribute name="default-collation" type="xsl:uri-list"/&gt;
  &lt;xs:attribute name="exclude-result-prefixes" type="xsl:prefix-list-or-all"/&gt;
  &lt;xs:attribute name="extension-element-prefixes" type="xsl:prefix-list"/&gt;
  &lt;xs:attribute name="use-when" type="xsl:expression"/&gt;
  &lt;xs:attribute name="xpath-default-namespace" type="xs:anyURI"/&gt;
  &lt;xs:anyAttribute namespace="##other" processContents="lax"/&gt;
&lt;/xs:complexType&gt;

&lt;xs:complexType name="versioned-element-type" mixed="true"&gt;
  &lt;xs:complexContent&gt;
    &lt;xs:extension base="xsl:generic-element-type"&gt;    
      &lt;xs:attribute name="version" type="xs:decimal" use="optional"/&gt;
    &lt;/xs:extension&gt;
  &lt;/xs:complexContent&gt;
&lt;/xs:complexType&gt;

&lt;xs:complexType name="element-only-versioned-element-type" mixed="false"&gt;
  &lt;xs:complexContent&gt;
    &lt;xs:restriction base="xsl:versioned-element-type"&gt;
      &lt;xs:anyAttribute namespace="##other" processContents="lax"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:complexContent&gt;
&lt;/xs:complexType&gt;

&lt;xs:complexType name="sequence-constructor"&gt;
  &lt;xs:complexContent mixed="true"&gt;
    &lt;xs:extension base="xsl:versioned-element-type"&gt;    
      &lt;xs:group ref="xsl:sequence-constructor-group" minOccurs="0" maxOccurs="unbounded"/&gt;
    &lt;/xs:extension&gt;
  &lt;/xs:complexContent&gt;
&lt;/xs:complexType&gt;

&lt;xs:group name="sequence-constructor-group"&gt;
  &lt;xs:choice&gt;
    &lt;xs:element ref="xsl:variable"/&gt;
    &lt;xs:element ref="xsl:instruction"/&gt;
    &lt;xs:group ref="xsl:result-elements"/&gt;
  &lt;/xs:choice&gt;
&lt;/xs:group&gt;

&lt;xs:element name="declaration" type="xsl:generic-element-type" abstract="true"/&gt;

&lt;xs:element name="instruction" type="xsl:versioned-element-type" abstract="true"/&gt;

&lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;
&lt;xs:annotation&gt;
  &lt;xs:documentation&gt;
    PART B: definitions of individual XSLT elements    
    Elements are listed in alphabetical order.    
  &lt;/xs:documentation&gt;
&lt;/xs:annotation&gt;   
&lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;

&lt;xs:element name="analyze-string" substitutionGroup="xsl:instruction"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent&gt;
      &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
        &lt;xs:sequence&gt;
          &lt;xs:element ref="xsl:matching-substring" minOccurs="0"/&gt;
          &lt;xs:element ref="xsl:non-matching-substring" minOccurs="0"/&gt;
          &lt;xs:element ref="xsl:fallback" minOccurs="0" maxOccurs="unbounded"/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute name="select" type="xsl:expression" use="required"/&gt;
        &lt;xs:attribute name="regex" type="xsl:avt" use="required"/&gt;
        &lt;xs:attribute name="flags" type="xsl:avt" default=""/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="apply-imports" substitutionGroup="xsl:instruction"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent&gt;
      &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
        &lt;xs:sequence&gt;
          &lt;xs:element ref="xsl:with-param" minOccurs="0" maxOccurs="unbounded"/&gt;
        &lt;/xs:sequence&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="apply-templates" substitutionGroup="xsl:instruction"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent&gt;
      &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
        &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
          &lt;xs:element ref="xsl:sort"/&gt;
          &lt;xs:element ref="xsl:with-param"/&gt;
        &lt;/xs:choice&gt;
        &lt;xs:attribute name="select" type="xsl:expression" default="child::node()"/&gt;
        &lt;xs:attribute name="mode" type="xsl:mode"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="attribute" substitutionGroup="xsl:instruction"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent mixed="true"&gt;
      &lt;xs:extension base="xsl:sequence-constructor"&gt;
        &lt;xs:attribute name="name" type="xsl:avt" use="required"/&gt;
        &lt;xs:attribute name="namespace" type="xsl:avt"/&gt;
        &lt;xs:attribute name="select" type="xsl:expression"/&gt;
        &lt;xs:attribute name="separator" type="xsl:avt"/&gt;   
        &lt;xs:attribute name="type" type="xsl:QName"/&gt;
        &lt;xs:attribute name="validation" type="xsl:validation-type"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;        

&lt;xs:element name="attribute-set" substitutionGroup="xsl:declaration"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent&gt;
      &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
        &lt;xs:sequence minOccurs="0" maxOccurs="unbounded"&gt;
          &lt;xs:element ref="xsl:attribute"/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute name="name" type="xsl:QName" use="required"/&gt;
        &lt;xs:attribute name="use-attribute-sets" type="xsl:QNames" default=""/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="call-template" substitutionGroup="xsl:instruction"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent&gt;
      &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
        &lt;xs:sequence&gt;
          &lt;xs:element ref="xsl:with-param" minOccurs="0" maxOccurs="unbounded"/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute name="name" type="xsl:QName" use="required"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="character-map" substitutionGroup="xsl:declaration"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent&gt;
      &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
        &lt;xs:sequence&gt;
          &lt;xs:element ref="xsl:output-character" minOccurs="0" maxOccurs="unbounded"/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute name="name" type="xsl:QName" use="required"/&gt;
        &lt;xs:attribute name="use-character-maps" type="xsl:QNames" default=""/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="choose" substitutionGroup="xsl:instruction"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent&gt;
      &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
        &lt;xs:sequence&gt;
          &lt;xs:element ref="xsl:when" maxOccurs="unbounded"/&gt;
          &lt;xs:element ref="xsl:otherwise" minOccurs="0"/&gt;
        &lt;/xs:sequence&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="comment" substitutionGroup="xsl:instruction"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent mixed="true"&gt;
      &lt;xs:extension base="xsl:sequence-constructor"&gt;
        &lt;xs:attribute name="select" type="xsl:expression"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="copy" substitutionGroup="xsl:instruction"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent mixed="true"&gt;
      &lt;xs:extension base="xsl:sequence-constructor"&gt;
        &lt;xs:attribute name="copy-namespaces" type="xsl:yes-or-no" default="yes"/&gt;
        &lt;xs:attribute name="inherit-namespaces" type="xsl:yes-or-no" default="yes"/&gt;
        &lt;xs:attribute name="use-attribute-sets" type="xsl:QNames" default=""/&gt;
        &lt;xs:attribute name="type" type="xsl:QName"/&gt;
        &lt;xs:attribute name="validation" type="xsl:validation-type"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="copy-of" substitutionGroup="xsl:instruction"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent mixed="true"&gt;
      &lt;xs:extension base="xsl:versioned-element-type"&gt;
        &lt;xs:attribute name="select" type="xsl:expression" use="required"/&gt;
        &lt;xs:attribute name="copy-namespaces" type="xsl:yes-or-no" default="yes"/&gt;
        &lt;xs:attribute name="type" type="xsl:QName"/&gt;
        &lt;xs:attribute name="validation" type="xsl:validation-type"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="decimal-format" substitutionGroup="xsl:declaration"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent&gt;
      &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
        &lt;xs:attribute name="name" type="xsl:QName"/&gt;
        &lt;xs:attribute name="decimal-separator" type="xsl:char" default="."/&gt;
        &lt;xs:attribute name="grouping-separator" type="xsl:char" default=","/&gt;
        &lt;xs:attribute name="infinity" type="xs:string" default="Infinity"/&gt;
        &lt;xs:attribute name="minus-sign" type="xsl:char" default="-"/&gt;
        &lt;xs:attribute name="NaN" type="xs:string" default="NaN"/&gt;
        &lt;xs:attribute name="percent" type="xsl:char" default="%"/&gt;
        &lt;xs:attribute name="per-mille" type="xsl:char" default="&amp;#x2030;"/&gt;
        &lt;xs:attribute name="zero-digit" type="xsl:char" default="0"/&gt;
        &lt;xs:attribute name="digit" type="xsl:char" default="#"/&gt;
        &lt;xs:attribute name="pattern-separator" type="xsl:char" default=";"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="element" substitutionGroup="xsl:instruction"&gt;
  &lt;xs:complexType mixed="true"&gt;
    &lt;xs:complexContent&gt;
      &lt;xs:extension base="xsl:sequence-constructor"&gt;
        &lt;xs:attribute name="name" type="xsl:avt" use="required"/&gt;
        &lt;xs:attribute name="namespace" type="xsl:avt"/&gt;
        &lt;xs:attribute name="inherit-namespaces" type="xsl:yes-or-no" default="yes"/&gt;
        &lt;xs:attribute name="use-attribute-sets" type="xsl:QNames" default=""/&gt;
        &lt;xs:attribute name="type" type="xsl:QName"/&gt;
        &lt;xs:attribute name="validation" type="xsl:validation-type"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="fallback" substitutionGroup="xsl:instruction" type="xsl:sequence-constructor"/&gt;

&lt;xs:element name="for-each" substitutionGroup="xsl:instruction"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent mixed="true"&gt;
      &lt;xs:extension base="xsl:versioned-element-type"&gt;
        &lt;xs:sequence&gt;
          &lt;xs:element ref="xsl:sort" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;xs:group ref="xsl:sequence-constructor-group" minOccurs="0" maxOccurs="unbounded"/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute name="select" type="xsl:expression" use="required"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="for-each-group" substitutionGroup="xsl:instruction"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent mixed="true"&gt;
      &lt;xs:extension base="xsl:versioned-element-type"&gt;
        &lt;xs:sequence&gt;
          &lt;xs:element ref="xsl:sort" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;xs:group ref="xsl:sequence-constructor-group" minOccurs="0" maxOccurs="unbounded"/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute name="select" type="xsl:expression" use="required"/&gt;
        &lt;xs:attribute name="group-by" type="xsl:expression"/&gt;
        &lt;xs:attribute name="group-adjacent" type="xsl:expression"/&gt;            
        &lt;xs:attribute name="group-starting-with" type="xsl:pattern"/&gt;            
        &lt;xs:attribute name="group-ending-with" type="xsl:pattern"/&gt;            
        &lt;xs:attribute name="collation" type="xs:anyURI"/&gt;            
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="function" substitutionGroup="xsl:declaration"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent mixed="true"&gt;
      &lt;xs:extension base="xsl:versioned-element-type"&gt;
        &lt;xs:sequence&gt;
          &lt;xs:element ref="xsl:param" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;xs:group ref="xsl:sequence-constructor-group" minOccurs="0" maxOccurs="unbounded"/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute name="name" type="xsl:QName" use="required"/&gt;
        &lt;xs:attribute name="override" type="xsl:yes-or-no" default="yes"/&gt;
        &lt;xs:attribute name="as" type="xsl:sequence-type" default="item()*"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="if" substitutionGroup="xsl:instruction"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent mixed="true"&gt;
      &lt;xs:extension base="xsl:sequence-constructor"&gt;
        &lt;xs:attribute name="test" type="xsl:expression" use="required"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="import"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent&gt;
      &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
        &lt;xs:attribute name="href" type="xs:anyURI" use="required"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="import-schema" substitutionGroup="xsl:declaration"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent&gt;
      &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
        &lt;xs:sequence&gt;
          &lt;xs:element ref="xs:schema" minOccurs="0" maxOccurs="1"/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute name="namespace" type="xs:anyURI"/&gt;
        &lt;xs:attribute name="schema-location" type="xs:anyURI"/&gt;                  
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="include" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:attribute name="href" type="xs:anyURI" use="required"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="key" substitutionGroup="xsl:declaration"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent mixed="true"&gt;
      &lt;xs:extension base="xsl:sequence-constructor"&gt;
        &lt;xs:attribute name="name" type="xsl:QName" use="required"/&gt;
        &lt;xs:attribute name="match" type="xsl:pattern" use="required"/&gt;
        &lt;xs:attribute name="use" type="xsl:expression"/&gt;
        &lt;xs:attribute name="collation" type="xs:anyURI"/&gt;               
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="matching-substring" type="xsl:sequence-constructor"/&gt;

&lt;xs:element name="message" substitutionGroup="xsl:instruction"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent mixed="true"&gt;
      &lt;xs:extension base="xsl:sequence-constructor"&gt;
        &lt;xs:attribute name="select" type="xsl:expression"/&gt;
        &lt;xs:attribute name="terminate" type="xsl:avt" default="no"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="namespace" substitutionGroup="xsl:instruction"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent mixed="true"&gt;
      &lt;xs:extension base="xsl:sequence-constructor"&gt;
        &lt;xs:attribute name="name" type="xsl:avt" use="required"/&gt;
        &lt;xs:attribute name="select" type="xsl:expression"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="namespace-alias" substitutionGroup="xsl:declaration"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent&gt;
      &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
        &lt;xs:attribute name="stylesheet-prefix" type="xsl:prefix-or-default" use="required"/&gt;
        &lt;xs:attribute name="result-prefix" type="xsl:prefix-or-default" use="required"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="next-match" substitutionGroup="xsl:instruction"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent&gt;
      &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
        &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
          &lt;xs:element ref="xsl:with-param"/&gt;
          &lt;xs:element ref="xsl:fallback"/&gt;
        &lt;/xs:choice&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="non-matching-substring" type="xsl:sequence-constructor"/&gt;

&lt;xs:element name="number" substitutionGroup="xsl:instruction"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent mixed="true"&gt;
      &lt;xs:extension base="xsl:versioned-element-type"&gt;
        &lt;xs:attribute name="value" type="xsl:expression"/&gt;
        &lt;xs:attribute name="select" type="xsl:expression"/&gt;
        &lt;xs:attribute name="level" type="xsl:level" default="single"/&gt;
        &lt;xs:attribute name="count" type="xsl:pattern"/&gt;
        &lt;xs:attribute name="from" type="xsl:pattern"/&gt;
        &lt;xs:attribute name="format" type="xsl:avt" default="1"/&gt;
        &lt;xs:attribute name="lang" type="xsl:avt"/&gt;
        &lt;xs:attribute name="letter-value" type="xsl:avt"/&gt;
        &lt;xs:attribute name="ordinal" type="xsl:avt"/&gt;        
        &lt;xs:attribute name="grouping-separator" type="xsl:avt"/&gt;
        &lt;xs:attribute name="grouping-size" type="xsl:avt"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="otherwise" type="xsl:sequence-constructor"/&gt;

&lt;xs:element name="output" substitutionGroup="xsl:declaration"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent mixed="true"&gt;
      &lt;xs:extension base="xsl:generic-element-type"&gt;
        &lt;xs:attribute name="name" type="xsl:QName"/&gt;
        &lt;xs:attribute name="method" type="xsl:method"/&gt;
        &lt;xs:attribute name="byte-order-mark" type="xsl:yes-or-no"/&gt;
        &lt;xs:attribute name="cdata-section-elements" type="xsl:QNames"/&gt;
        &lt;xs:attribute name="doctype-public" type="xs:string"/&gt;
        &lt;xs:attribute name="doctype-system" type="xs:string"/&gt;
        &lt;xs:attribute name="encoding" type="xs:string"/&gt;
        &lt;xs:attribute name="escape-uri-attributes" type="xsl:yes-or-no"/&gt;
        &lt;xs:attribute name="include-content-type" type="xsl:yes-or-no"/&gt;
        &lt;xs:attribute name="indent" type="xsl:yes-or-no"/&gt;
        &lt;xs:attribute name="media-type" type="xs:string"/&gt;
        &lt;xs:attribute name="normalization-form" type="xs:NMTOKEN"/&gt;
        &lt;xs:attribute name="omit-xml-declaration" type="xsl:yes-or-no"/&gt;
        &lt;xs:attribute name="standalone" type="xsl:yes-or-no-or-omit"/&gt;
        &lt;xs:attribute name="undeclare-prefixes" type="xsl:yes-or-no"/&gt;
        &lt;xs:attribute name="use-character-maps" type="xsl:QNames"/&gt;
        &lt;xs:attribute name="version" type="xs:NMTOKEN"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="output-character"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent&gt;
      &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
        &lt;xs:attribute name="character" type="xsl:char" use="required"/&gt;
        &lt;xs:attribute name="string" type="xs:string" use="required"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="param"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent mixed="true"&gt;
      &lt;xs:extension base="xsl:sequence-constructor"&gt;
        &lt;xs:attribute name="name" type="xsl:QName" use="required"/&gt;
        &lt;xs:attribute name="select" type="xsl:expression"/&gt;
        &lt;xs:attribute name="as" type="xsl:sequence-type"/&gt;
        &lt;xs:attribute name="required" type="xsl:yes-or-no"/&gt;
        &lt;xs:attribute name="tunnel" type="xsl:yes-or-no"/&gt;        
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="perform-sort" substitutionGroup="xsl:instruction"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent mixed="true"&gt;
      &lt;xs:extension base="xsl:versioned-element-type"&gt;
        &lt;xs:sequence&gt;
          &lt;xs:element ref="xsl:sort" minOccurs="1" maxOccurs="unbounded"/&gt;
          &lt;xs:group ref="xsl:sequence-constructor-group" minOccurs="0" maxOccurs="unbounded"/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute name="select" type="xsl:expression"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="preserve-space" substitutionGroup="xsl:declaration"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent&gt;
      &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
        &lt;xs:attribute name="elements" type="xsl:nametests" use="required"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="processing-instruction" substitutionGroup="xsl:instruction"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent mixed="true"&gt;
      &lt;xs:extension base="xsl:sequence-constructor"&gt;
        &lt;xs:attribute name="name" type="xsl:avt" use="required"/&gt;
        &lt;xs:attribute name="select" type="xsl:expression"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="result-document" substitutionGroup="xsl:instruction"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent mixed="true"&gt;
      &lt;xs:extension base="xsl:sequence-constructor"&gt;
        &lt;xs:attribute name="format" type="xsl:avt"/&gt;
        &lt;xs:attribute name="href" type="xsl:avt"/&gt;
        &lt;xs:attribute name="type" type="xsl:QName"/&gt;
        &lt;xs:attribute name="validation" type="xsl:validation-type"/&gt;
        &lt;xs:attribute name="method" type="xsl:avt"/&gt;
        &lt;xs:attribute name="byte-order-mark" type="xsl:avt"/&gt;
        &lt;xs:attribute name="cdata-section-elements" type="xsl:avt"/&gt;
        &lt;xs:attribute name="doctype-public" type="xsl:avt"/&gt;
        &lt;xs:attribute name="doctype-system" type="xsl:avt"/&gt;
        &lt;xs:attribute name="encoding" type="xsl:avt"/&gt;
        &lt;xs:attribute name="escape-uri-attributes" type="xsl:avt"/&gt;
        &lt;xs:attribute name="include-content-type" type="xsl:avt"/&gt;
        &lt;xs:attribute name="indent" type="xsl:avt"/&gt;
        &lt;xs:attribute name="media-type" type="xsl:avt"/&gt;
        &lt;xs:attribute name="normalization-form" type="xsl:avt"/&gt;
        &lt;xs:attribute name="omit-xml-declaration" type="xsl:avt"/&gt;
        &lt;xs:attribute name="standalone" type="xsl:avt"/&gt;
        &lt;xs:attribute name="undeclare-prefixes" type="xsl:avt"/&gt;
        &lt;xs:attribute name="use-character-maps" type="xsl:QNames"/&gt;
        &lt;xs:attribute name="output-version" type="xsl:avt"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="sequence" substitutionGroup="xsl:instruction"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent mixed="true"&gt;
      &lt;xs:extension base="xsl:sequence-constructor"&gt;
        &lt;xs:attribute name="select" type="xsl:expression"/&gt;
        &lt;xs:attribute name="as" type="xsl:sequence-type"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="sort"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent mixed="true"&gt;
      &lt;xs:extension base="xsl:sequence-constructor"&gt;
        &lt;xs:attribute name="select" type="xsl:expression"/&gt;  
        &lt;xs:attribute name="lang" type="xsl:avt"/&gt;        
        &lt;xs:attribute name="data-type" type="xsl:avt" default="text"/&gt;        
        &lt;xs:attribute name="order" type="xsl:avt" default="ascending"/&gt;        
        &lt;xs:attribute name="case-order" type="xsl:avt"/&gt;
        &lt;xs:attribute name="collation" type="xsl:avt"/&gt;
        &lt;xs:attribute name="stable" type="xsl:yes-or-no"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="strip-space" substitutionGroup="xsl:declaration"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent&gt;
      &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
        &lt;xs:attribute name="elements" type="xsl:nametests" use="required"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="stylesheet" substitutionGroup="xsl:transform"/&gt;

&lt;xs:element name="template" substitutionGroup="xsl:declaration"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent mixed="true"&gt;
      &lt;xs:extension base="xsl:versioned-element-type"&gt;
        &lt;xs:sequence&gt;
          &lt;xs:element ref="xsl:param" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;xs:group ref="xsl:sequence-constructor-group" minOccurs="0" maxOccurs="unbounded"/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute name="match" type="xsl:pattern"/&gt;
        &lt;xs:attribute name="priority" type="xs:decimal"/&gt;
        &lt;xs:attribute name="mode" type="xsl:modes"/&gt;
        &lt;xs:attribute name="name" type="xsl:QName"/&gt;
        &lt;xs:attribute name="as" type="xsl:sequence-type" default="item()*"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:complexType name="text-element-base-type"&gt;
  &lt;xs:simpleContent&gt;
    &lt;xs:restriction base="xsl:versioned-element-type"&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:restriction base="xs:string"/&gt;
      &lt;/xs:simpleType&gt;
      &lt;xs:anyAttribute namespace="##other" processContents="lax"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleContent&gt;
&lt;/xs:complexType&gt;

&lt;xs:element name="text" substitutionGroup="xsl:instruction"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:simpleContent&gt;
      &lt;xs:extension base="xsl:text-element-base-type"&gt;
        &lt;xs:attribute name="disable-output-escaping" type="xsl:yes-or-no" default="no"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:simpleContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:complexType name="transform-element-base-type"&gt;
  &lt;xs:complexContent&gt;
    &lt;xs:restriction base="xsl:element-only-versioned-element-type"&gt;
      &lt;xs:attribute name="version" type="xs:decimal" use="required"/&gt;
      &lt;xs:anyAttribute namespace="##other" processContents="lax"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:complexContent&gt;
&lt;/xs:complexType&gt;

&lt;xs:element name="transform"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent&gt;
      &lt;xs:extension base="xsl:transform-element-base-type"&gt;
        &lt;xs:sequence&gt;
          &lt;xs:element ref="xsl:import" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
            &lt;xs:element ref="xsl:declaration"/&gt;
            &lt;xs:element ref="xsl:variable"/&gt;
            &lt;xs:element ref="xsl:param"/&gt;              
            &lt;xs:any namespace="##other" processContents="lax"/&gt; &lt;!-- weaker than XSLT 1.0 --&gt;
          &lt;/xs:choice&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute name="id" type="xs:ID"/&gt;
        &lt;xs:attribute name="default-validation" type="xsl:validation-strip-or-preserve" default="strip"/&gt;
        &lt;xs:attribute name="input-type-annotations" type="xsl:input-type-annotations-type" default="unspecified"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="value-of" substitutionGroup="xsl:instruction"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent mixed="true"&gt;
      &lt;xs:extension base="xsl:sequence-constructor"&gt;
        &lt;xs:attribute name="select" type="xsl:expression"/&gt;
        &lt;xs:attribute name="separator" type="xsl:avt"/&gt;            
        &lt;xs:attribute name="disable-output-escaping" type="xsl:yes-or-no" default="no"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="variable"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent mixed="true"&gt;
      &lt;xs:extension base="xsl:sequence-constructor"&gt;
        &lt;xs:attribute name="name" type="xsl:QName" use="required"/&gt;
        &lt;xs:attribute name="select" type="xsl:expression" use="optional"/&gt;
        &lt;xs:attribute name="as" type="xsl:sequence-type" use="optional"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="when"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent mixed="true"&gt;
      &lt;xs:extension base="xsl:sequence-constructor"&gt;
        &lt;xs:attribute name="test" type="xsl:expression" use="required"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="with-param"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent mixed="true"&gt;
      &lt;xs:extension base="xsl:sequence-constructor"&gt;
        &lt;xs:attribute name="name" type="xsl:QName" use="required"/&gt;
        &lt;xs:attribute name="select" type="xsl:expression"/&gt;
        &lt;xs:attribute name="as" type="xsl:sequence-type"/&gt;
        &lt;xs:attribute name="tunnel" type="xsl:yes-or-no"/&gt;   
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;
&lt;xs:annotation&gt;
  &lt;xs:documentation&gt;
    PART C: definition of literal result elements
    
    There are three ways to define the literal result elements
    permissible in a stylesheet.
    
    (a) do nothing. This allows any element to be used as a literal
        result element, provided it is not in the XSLT namespace
    
    (b) declare all permitted literal result elements as members
        of the xsl:literal-result-element substitution group
        
    (c) redefine the model group xsl:result-elements to accommodate
        all permitted literal result elements.
        
    Literal result elements are allowed to take certain attributes
    in the XSLT namespace. These are defined in the attribute group
    literal-result-element-attributes, which can be included in the
    definition of any literal result element.
    
  &lt;/xs:documentation&gt;
&lt;/xs:annotation&gt;   
&lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;

&lt;xs:element name="literal-result-element" abstract="true" type="xs:anyType"/&gt;

&lt;xs:attributeGroup name="literal-result-element-attributes"&gt;
  &lt;xs:attribute name="default-collation" form="qualified" type="xsl:uri-list"/&gt;
  &lt;xs:attribute name="extension-element-prefixes" form="qualified" type="xsl:prefixes"/&gt;
  &lt;xs:attribute name="exclude-result-prefixes" form="qualified" type="xsl:prefixes"/&gt;
  &lt;xs:attribute name="xpath-default-namespace" form="qualified" type="xs:anyURI"/&gt;    
  &lt;xs:attribute name="inherit-namespaces" form="qualified" type="xsl:yes-or-no" default="yes"/&gt;
  &lt;xs:attribute name="use-attribute-sets" form="qualified" type="xsl:QNames" default=""/&gt;
  &lt;xs:attribute name="use-when" form="qualified" type="xsl:expression"/&gt;
  &lt;xs:attribute name="version" form="qualified" type="xs:decimal"/&gt;
  &lt;xs:attribute name="type" form="qualified" type="xsl:QName"/&gt;
  &lt;xs:attribute name="validation" form="qualified" type="xsl:validation-type"/&gt;
&lt;/xs:attributeGroup&gt;

&lt;xs:group name="result-elements"&gt;
  &lt;xs:choice&gt;
    &lt;xs:element ref="xsl:literal-result-element"/&gt;
    &lt;xs:any namespace="##other" processContents="lax"/&gt;
    &lt;xs:any namespace="##local" processContents="lax"/&gt;
  &lt;/xs:choice&gt;
&lt;/xs:group&gt;


&lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;
&lt;xs:annotation&gt;
  &lt;xs:documentation&gt;
    PART D: definitions of simple types used in stylesheet attributes 
  &lt;/xs:documentation&gt;
&lt;/xs:annotation&gt;   
&lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;

&lt;xs:simpleType name="avt"&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;
      This type is used for all attributes that allow an attribute value template.
      The general rules for the syntax of attribute value templates, and the specific
      rules for each such attribute, are described in the XSLT 2.0 Recommendation.
    &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  &lt;xs:restriction base="xs:string"/&gt;
&lt;/xs:simpleType&gt;

&lt;xs:simpleType name="char"&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;
      A string containing exactly one character.
    &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  &lt;xs:restriction base="xs:string"&gt;
    &lt;xs:length value="1"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;

&lt;xs:simpleType name="expression"&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;
      An XPath 2.0 expression.
    &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  &lt;xs:restriction base="xs:token"&gt;
    &lt;xs:pattern value=".+"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;

&lt;xs:simpleType name="input-type-annotations-type"&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;
      Describes how type annotations in source documents are handled.
    &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  &lt;xs:restriction base="xs:token"&gt;
    &lt;xs:enumeration value="preserve"/&gt;
    &lt;xs:enumeration value="strip"/&gt;   
    &lt;xs:enumeration value="unspecified"/&gt;        
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;

&lt;xs:simpleType name="level"&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;
      The level attribute of xsl:number: 
      one of single, multiple, or any.
    &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  &lt;xs:restriction base="xs:NCName"&gt;
    &lt;xs:enumeration value="single"/&gt;
    &lt;xs:enumeration value="multiple"/&gt;
    &lt;xs:enumeration value="any"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;

&lt;xs:simpleType name="mode"&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;
      The mode attribute of xsl:apply-templates: 
      either a QName, or #current, or #default.
    &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  &lt;xs:union memberTypes="xsl:QName"&gt;
    &lt;xs:simpleType&gt;
      &lt;xs:restriction base="xs:token"&gt;
        &lt;xs:enumeration value="#default"/&gt;
        &lt;xs:enumeration value="#current"/&gt;
      &lt;/xs:restriction&gt;
    &lt;/xs:simpleType&gt;
  &lt;/xs:union&gt;
&lt;/xs:simpleType&gt;

&lt;xs:simpleType name="modes"&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;
      The mode attribute of xsl:template: 
      either a list, each member being either a QName or #default;
      or the value #all
    &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  &lt;xs:union&gt;
    &lt;xs:simpleType&gt;
      &lt;xs:list&gt;
        &lt;xs:simpleType&gt;
          &lt;xs:union memberTypes="xsl:QName"&gt;
            &lt;xs:simpleType&gt;
              &lt;xs:restriction base="xs:token"&gt;
                &lt;xs:enumeration value="#default"/&gt;
              &lt;/xs:restriction&gt;
            &lt;/xs:simpleType&gt;
          &lt;/xs:union&gt;
        &lt;/xs:simpleType&gt;
      &lt;/xs:list&gt;
    &lt;/xs:simpleType&gt;
    &lt;xs:simpleType&gt;
      &lt;xs:restriction base="xs:token"&gt;
        &lt;xs:enumeration value="#all"/&gt;
      &lt;/xs:restriction&gt;
    &lt;/xs:simpleType&gt;
  &lt;/xs:union&gt;
&lt;/xs:simpleType&gt;

&lt;xs:simpleType name="nametests"&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;
      A list of NameTests, as defined in the XPath 2.0 Recommendation.
      Each NameTest is either a QName, or "*", or "prefix:*", or "*:localname"
    &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  &lt;xs:list&gt;
    &lt;xs:simpleType&gt;
      &lt;xs:union memberTypes="xsl:QName"&gt;
        &lt;xs:simpleType&gt;
          &lt;xs:restriction base="xs:token"&gt;
            &lt;xs:enumeration value="*"/&gt;
          &lt;/xs:restriction&gt;
        &lt;/xs:simpleType&gt;
        &lt;xs:simpleType&gt;
          &lt;xs:restriction base="xs:token"&gt;
            &lt;xs:pattern value="\i\c*:\*"/&gt;
            &lt;xs:pattern value="\*:\i\c*"/&gt;            
          &lt;/xs:restriction&gt;
        &lt;/xs:simpleType&gt;
      &lt;/xs:union&gt;
    &lt;/xs:simpleType&gt;
  &lt;/xs:list&gt;
&lt;/xs:simpleType&gt;

&lt;xs:simpleType name="prefixes"&gt;
  &lt;xs:list itemType="xs:NCName"/&gt;
&lt;/xs:simpleType&gt;

&lt;xs:simpleType name="prefix-list-or-all"&gt;
  &lt;xs:union memberTypes="xsl:prefix-list"&gt;
    &lt;xs:simpleType&gt;
      &lt;xs:restriction base="xs:token"&gt;
        &lt;xs:enumeration value="#all"/&gt;
      &lt;/xs:restriction&gt;
    &lt;/xs:simpleType&gt;
  &lt;/xs:union&gt;
&lt;/xs:simpleType&gt;
      
&lt;xs:simpleType name="prefix-list"&gt;
  &lt;xs:list itemType="xsl:prefix-or-default"/&gt;
&lt;/xs:simpleType&gt;

&lt;xs:simpleType name="method"&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;
      The method attribute of xsl:output:
      Either one of the recognized names "xml", "xhtml", "html", "text",
      or a QName that must include a prefix.
    &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  &lt;xs:union&gt;
    &lt;xs:simpleType&gt;
      &lt;xs:restriction base="xs:NCName"&gt;
        &lt;xs:enumeration value="xml"/&gt;
        &lt;xs:enumeration value="xhtml"/&gt;
        &lt;xs:enumeration value="html"/&gt;
        &lt;xs:enumeration value="text"/&gt;
      &lt;/xs:restriction&gt;
    &lt;/xs:simpleType&gt;
    &lt;xs:simpleType&gt;
      &lt;xs:restriction base="xsl:QName"&gt;
        &lt;xs:pattern value="\c*:\c*"/&gt;
      &lt;/xs:restriction&gt;
    &lt;/xs:simpleType&gt;
  &lt;/xs:union&gt;
&lt;/xs:simpleType&gt;

&lt;xs:simpleType name="pattern"&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;
      A match pattern as defined in the XSLT 2.0 Recommendation.
      The syntax for patterns is a restricted form of the syntax for
      XPath 2.0 expressions.
    &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  &lt;xs:restriction base="xsl:expression"/&gt;
&lt;/xs:simpleType&gt;

&lt;xs:simpleType name="prefix-or-default"&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;
      Either a namespace prefix, or #default.
      Used in the xsl:namespace-alias element.
    &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  &lt;xs:union memberTypes="xs:NCName"&gt;
    &lt;xs:simpleType&gt;
      &lt;xs:restriction base="xs:token"&gt;
        &lt;xs:enumeration value="#default"/&gt;
      &lt;/xs:restriction&gt;
    &lt;/xs:simpleType&gt;
  &lt;/xs:union&gt;
&lt;/xs:simpleType&gt;

&lt;xs:simpleType name="QNames"&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;
      A list of QNames.
      Used in the [xsl:]use-attribute-sets attribute of various elements,
      and in the cdata-section-elements attribute of xsl:output
    &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  &lt;xs:list itemType="xsl:QName"/&gt;          
&lt;/xs:simpleType&gt;

&lt;xs:simpleType name="QName"&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;
      A QName.
      This schema does not use the built-in type xs:QName, but rather defines its own
      QName type. Although xs:QName would define the correct validation on these attributes,
      a schema processor would expand unprefixed QNames incorrectly when constructing the PSVI,
      because (as defined in XML Schema errata) an unprefixed xs:QName is assumed to be in
      the default namespace, which is not the correct assumption for XSLT.
      The data type is defined as a restriction of the built-in type Name, restricted
      so that it can only contain one colon which must not be the first or last character.
    &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  &lt;xs:restriction base="xs:Name"&gt;
    &lt;xs:pattern value="([^:]+:)?[^:]+"/&gt;      
  &lt;/xs:restriction&gt;        
&lt;/xs:simpleType&gt;

&lt;xs:simpleType name="sequence-type"&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;
      The description of a data type, conforming to the
      SequenceType production defined in the XPath 2.0 Recommendation
    &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  &lt;xs:restriction base="xs:token"&gt;
    &lt;xs:pattern value=".+"/&gt;      
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;

&lt;xs:simpleType name="uri-list"&gt;
  &lt;xs:list itemType="xs:anyURI"/&gt;
&lt;/xs:simpleType&gt;

&lt;xs:simpleType name="validation-strip-or-preserve"&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;
      Describes different ways of type-annotating an element or attribute.
    &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  &lt;xs:restriction base="xsl:validation-type"&gt;
    &lt;xs:enumeration value="preserve"/&gt;
    &lt;xs:enumeration value="strip"/&gt;    
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;

&lt;xs:simpleType name="validation-type"&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;
      Describes different ways of type-annotating an element or attribute.
    &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  &lt;xs:restriction base="xs:token"&gt;
    &lt;xs:enumeration value="strict"/&gt;
    &lt;xs:enumeration value="lax"/&gt;
    &lt;xs:enumeration value="preserve"/&gt;
    &lt;xs:enumeration value="strip"/&gt;    
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;

&lt;xs:simpleType name="yes-or-no"&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;
      One of the values "yes" or "no".
    &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  &lt;xs:restriction base="xs:token"&gt;
    &lt;xs:enumeration value="yes"/&gt;
    &lt;xs:enumeration value="no"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;

&lt;xs:simpleType name="yes-or-no-or-omit"&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;
      One of the values "yes" or "no" or "omit".
    &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  &lt;xs:restriction base="xs:token"&gt;
    &lt;xs:enumeration value="yes"/&gt;
    &lt;xs:enumeration value="no"/&gt;
    &lt;xs:enumeration value="omit"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;

&lt;/xs:schema&gt;
</PRE></DIV>
<DIV class=div1>
<H2><A id=acknowledgements name=acknowledgements></A>H Acknowledgements 
(Non-Normative)</H2>
<P>This specification was developed and approved for publication by the W3C XSL 
Working Group (WG). WG approval of this specification does not necessarily imply 
that all WG members voted for its approval.</P>
<P>The chair of the XSL WG is Sharon Adler, IBM. The XSL Working Group includes 
two overlapping teams working on XSLT and XSL Formatting Objects. The members of 
the XSL WG currently engaged in XSLT activities are:</P>
<TABLE cellPadding=5 border=1>
  <THEAD>
  <TR>
    <TH>Participant</TH>
    <TH>Affiliation</TH></TR></THEAD>
  <TBODY>
  <TR>
    <TD>Colin Paul Adams</TD>
    <TD>Invited Expert</TD></TR>
  <TR>
    <TD>Anders Berglund</TD>
    <TD>IBM</TD></TR>
  <TR>
    <TD>Scott Boag</TD>
    <TD>IBM</TD></TR>
  <TR>
    <TD>Michael Kay</TD>
    <TD>Invited Expert</TD></TR>
  <TR>
    <TD>Alex Milowski</TD>
    <TD>Invited Expert</TD></TR>
  <TR>
    <TD>William Peterson</TD>
    <TD>Novell, Inc</TD></TR>
  <TR>
    <TD>Michael Sperberg-McQueen</TD>
    <TD>W3C</TD></TR>
  <TR>
    <TD>Zarella Rendon</TD>
    <TD>Invited Expert</TD></TR>
  <TR>
    <TD>Jeni Tennison</TD>
    <TD>Invited Expert</TD></TR>
  <TR>
    <TD>Joanne Tong</TD>
    <TD>IBM</TD></TR>
  <TR>
    <TD>Norm Walsh</TD>
    <TD>Sun Microsystems Inc.</TD></TR>
  <TR>
    <TD>Mohamed Zergaoui</TD>
    <TD>Innovimax SARL</TD></TR>
  <TR>
    <TD>(vacancy)</TD>
    <TD>Oracle</TD></TR></TBODY></TABLE>
<P>Alternates are listed only where they have taken an active part in working 
group discussions. However, the group acknowledges the support that many members 
receive from colleagues in their organizations, whether or not they are 
officially appointed as alternates.</P>
<P>The W3C representative on the XSL Working Group is Michael 
Sperberg-McQueen.</P>
<P>The following individuals made significant contributions to XSLT 2.0 while 
they were members of the Working Group, and in some cases afterwards:</P>
<BLOCKQUOTE>
  <P>James Clark, Invited Expert<BR>Jonathan Marsh, Microsoft<BR>Steve Muench, 
  Oracle<BR>Steve Zilles, Adobe<BR>Evan Lenz, XYZFind<BR>Mark Scardina, 
  Oracle<BR>Kristoffer Rose, IBM<BR>Henry Zongaro, IBM<BR>Henry Thompson, 
  University of Edinburgh<BR>K Karun, Oracle</P></BLOCKQUOTE>
<P>The working group wishes to acknowledge the contribution made by David 
Marston of IBM especially to the new specification of the <A 
href="REC-xslt20-20070123.htm#function-format-number"><CODE>format-number</CODE></A> 
function.</P>
<P>This specification builds on the success of the XSLT 1.0 Recommendation. For 
a list of contributors to XSLT 1.0, see <A 
href="REC-xslt20-20070123.htm#xslt">[XSLT 
1.0]</A>.</P></DIV>
<DIV class=div1>
<H2><A id=requirements-checklist name=requirements-checklist></A>I Checklist of 
Requirements (Non-Normative)</H2>
<P>This section provides a checklist of progress against the published XSLT 2.0 
Requirements document (see <A 
href="REC-xslt20-20070123.htm#xslt20req">[XSLT 2.0 
Requirements]</A>).</P>
<P><B><I>Requirement 1</I></B></P>
<P><SPAN class=verb>must</SPAN>&nbsp;Maintain Backwards Compatibility with XSLT 
1.1 [Read this as "with XSLT 1.0"]</P>
<P>Any stylesheet whose behavior is fully defined in XSLT 1.0 and which 
generates no errors will produce the same result tree under XSLT 2.0</P>
<P><I>Response</I></P>
<P>See <A 
href="REC-xslt20-20070123.htm#incompatibilities"><I>J.1 
Incompatible Changes</I></A></P>
<P><B><I>Requirement 2</I></B></P>
<P><SPAN class=verb>must</SPAN> Match Elements with Null Values</P>
<P>A stylesheet should be able to match elements and attributes whose value is 
explicitly null.</P>
<P><I>Response</I></P>
<P>This has been handled as an XPath 2.0 requirement. <SPAN>A new function <A 
href="http://www.w3.org/TR/xpath-functions/#func-nilled"><CODE>nilled</CODE></A><SUP> 
<SMALL>FO</SMALL></SUP> is available to test whether an element has been marked 
as nil after schema validation.</SPAN></P>
<P><B><I>Requirement 3</I></B></P>
<P><SPAN class=verb>should</SPAN>&nbsp;Allow Included Documents to "Encapsulate" 
Local Stylesheets</P>
<P>XSLT 2.0 <SPAN class=verb>should</SPAN> define a mechanism to allow the 
templates in a stylesheet associated with a secondary source document, to be 
imported and used to format the included fragment, taking precedence over any 
applicable templates in the current stylesheet.</P>
<P><I>Response</I></P>
<P>The facility to define modes has been generalized, making it easier to define 
a distinct set of template rules for processing a particular document.</P>
<P><B><I>Requirement 4</I></B></P>
<P>Could&nbsp;Support Accessing Infoset Items for XML Declaration</P>
<P>A stylesheet COULD be able to access information like the version and 
encoding from the XML declaration of a document.</P>
<P><I>Response</I></P>
<P>No new facilities have been provided in this area, because this information 
is not available in the data model.</P>
<P><B><I>Requirement 5</I></B></P>
<P>Could&nbsp;Provide QName Aware String Functions</P>
<P>Users manipulating documents (for example stylesheets, schemas) that have 
QName-valued element or attribute content need functions that take a string 
containing a QName as their argument, convert it to an <A title=expanded-QName 
href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded-QName</A> 
using either the namespace declarations in scope at that point in the 
stylesheet, or the namespace declarations in scope for a specific source node, 
and return properties of the <A title=expanded-QName 
href="REC-xslt20-20070123.htm#dt-expanded-qname">expanded-QName</A> 
such as its namespace URI and local name.</P>
<P><I>Response</I></P>
<P>Functions operating on QNames are included in the XPath 2.0 Functions and 
Operators document: see <A 
href="REC-xslt20-20070123.htm#xpath-functions">[Functions 
and Operators]</A>.</P>
<P><B><I>Requirement 6</I></B></P>
<P>Could&nbsp;Enable Constructing a Namespace with Computed Name</P>
<P>Provide an <A 
href="REC-xslt20-20070123.htm#element-namespace"><CODE>xsl:namespace</CODE></A> 
analog to <A 
href="REC-xslt20-20070123.htm#element-element"><CODE>xsl:element</CODE></A> 
for constructing a namespace node with a computed prefix and URI.</P>
<P><I>Response</I></P>
<P>An <A 
href="REC-xslt20-20070123.htm#element-namespace"><CODE>xsl:namespace</CODE></A> 
instruction has been added: see <A 
href="REC-xslt20-20070123.htm#creating-namespace-nodes"><I>11.7 
Creating Namespace Nodes</I></A>.</P>
<P><B><I>Requirement 7</I></B></P>
<P>Could&nbsp;Simplify Resolving Prefix Conflicts in QName-Valued Attributes</P>
<P>XSLT 2.0 could simplify the renaming of conflicting namespace prefixes in 
result tree fragments, particularly for attributes declared in a schema as being 
QNames. Once the processor knows an attribute value is a QName, an XSLT 
processor <SPAN class=verb>should</SPAN> be able to rename prefixes and generate 
namespace declarations to preserve the semantics of that attribute value, just 
as it does for attribute names.</P>
<P><I>Response</I></P>
<P>If an attribute is typed as a QName in the schema, the new XPath 2.0 
functions can be used to manipulate it as required at application level. This 
<SPAN>is considered</SPAN> sufficient to meet the requirement.</P>
<P><B><I>Requirement 8</I></B></P>
<P>Could&nbsp;Support XHTML Output Method</P>
<P>Complementing the existing output methods for html, xml, and text, an xhtml 
output method could be provided to simplify transformations which target XHTML 
output.</P>
<P><I>Response</I></P>
<P>An XHTML output method is now provided: see <A 
href="REC-xslt20-20070123.htm#xslt-xquery-serialization">[XSLT 
and XQuery Serialization]</A></P>
<P><B><I>Requirement 9</I></B></P>
<P><SPAN class=verb>must</SPAN>&nbsp;Allow Matching on Default Namespace Without 
Explicit Prefix</P>
<P>Many users stumble trying to match an element with a default namespace.</P>
<P><I>Response</I></P>
<P>A new <CODE>[xsl:]xpath-default-namespace</CODE> attribute is provided for 
this purpose: see <A 
href="REC-xslt20-20070123.htm#unprefixed-qnames"><I>5.2 
Unprefixed QNames in Expressions and Patterns</I></A></P>
<P><B><I>Requirement 10</I></B></P>
<P><SPAN class=verb>must</SPAN>&nbsp;Add Date Formatting Functions</P>
<P>One of the more frequent requests from XSLT 1.0 users is the ability to 
format date information with similar control to XSLT's format-number. XML Schema 
introduces several kinds of date and time datatypes which will further increase 
the demand for date formatting during transformations. Functionality similar to 
that provided by java.text.SimpleDateFormat. A date analog of XSLT's named 
xsl:decimal-format may be required to handle locale-specific date formatting 
issues.</P>
<P><I>Response</I></P>
<P>A set of date formatting functions has been specified: see <A 
href="REC-xslt20-20070123.htm#format-date"><I>16.5 
Formatting Dates and Times</I></A></P>
<P><B><I>Requirement 11</I></B></P>
<P><SPAN class=verb>must</SPAN>&nbsp;Simplify Accessing Id's and Key's in Other 
Documents</P>
<P>Currently it is cumbersome to lookup nodes by id() or key() in documents 
other than the source document. Users <SPAN class=verb>must</SPAN> first use an 
xsl:for-each instruction, selecting the desired document() to make it the 
current node, then relative XPath expressions within the scope of the 
xsl:for-each can refer to id() or key() as desired.</P>
<P><I>Response</I></P>
<P>The requirement is met by the generalization of path syntax in XPath 2.0. It 
is now possible to use a path expression such as 
<CODE>document('a.xml')/id('A001')</CODE>.</P>
<P><B><I>Requirement 12</I></B></P>
<P><SPAN class=verb>should</SPAN>&nbsp;Provide Function to Absolutize Relative 
URIs</P>
<P>There <SPAN class=verb>should</SPAN> be a way in XSLT 2.0 to create an 
absolute URI. The functionality <SPAN class=verb>should</SPAN> allow passing a 
node-set and return a <A title="string value" 
href="REC-xslt20-20070123.htm#dt-string-value">string 
value</A> representing the absolute URI resolved with respect to the base URI of 
the current node.</P>
<P><I>Response</I></P>
<P>A function <A 
href="http://www.w3.org/TR/xpath-functions/#func-resolve-uri"><CODE>resolve-uri</CODE></A><SUP><SMALL>FO</SMALL></SUP> 
is now defined in <A 
href="REC-xslt20-20070123.htm#xpath-functions">[Functions 
and Operators]</A>.</P>
<P><B><I>Requirement 13</I></B></P>
<P><SPAN class=verb>should</SPAN>&nbsp;Include Unparsed Text from an External 
Resource</P>
<P>Frequently stylesheets <SPAN class=verb>must</SPAN> import text from external 
resources. Today users have to resort to <A title="extension function" 
href="REC-xslt20-20070123.htm#dt-extension-function">extension 
functions</A> to accomplish this because XSLT 1.0 only provides the document() 
function which, while useful, can only read external resources that are 
well-formed XML documents.</P>
<P><I>Response</I></P>
<P>A function <A 
href="REC-xslt20-20070123.htm#function-unparsed-text"><CODE>unparsed-text</CODE></A> 
has been added: see <A 
href="REC-xslt20-20070123.htm#unparsed-text"><I>16.2 
Reading Text Files</I></A></P>
<P><B><I>Requirement 14</I></B></P>
<P><SPAN class=verb>should</SPAN>&nbsp;Allow Authoring Extension Functions in 
XSLT</P>
<P>As part of the XSLT 1.1 work done on <A title="extension function" 
href="REC-xslt20-20070123.htm#dt-extension-function">extension 
functions</A>, a proposal to author XSLT extension functions in XSLT itself was 
deferred for reconsideration in XSLT 2.0. This would allow the functions in an 
extension namespace to be implemented in "pure" XSLT, without resulting to 
external programming languages.</P>
<P><I>Response</I></P>
<P>A solution to this requirement, the <A 
href="REC-xslt20-20070123.htm#element-function"><CODE>xsl:function</CODE></A> 
element, is included in this specification. See <A 
href="REC-xslt20-20070123.htm#stylesheet-functions"><I>10.3 
Stylesheet Functions</I></A>.</P>
<P><B><I>Requirement 15</I></B></P>
<P><SPAN class=verb>should</SPAN>&nbsp;Output Character Entity References 
Instead of Numeric Character Entities</P>
<P>Users have frequently requested the ability to have the output of their 
transformation use (named) character references instead of the numeric character 
entity. The ability to control this preference as the level of the whole 
document is sufficient. For example, rather than seeing &amp;#160; in the 
output, the user could request to see the equivalent &amp;nbsp; instead.</P>
<P><I>Response</I></P>
<P>The serialization specification gives the implementation discretion on how 
special characters are output. A user who wishes to force the use of named 
character references can achieve this using the new <A 
href="REC-xslt20-20070123.htm#element-character-map"><CODE>xsl:character-map</CODE></A> 
declaration.</P>
<P><B><I>Requirement 16</I></B></P>
<P><SPAN class=verb>should</SPAN>&nbsp;Construct Entity Reference by Name</P>
<P>Analogous to the ability to create elements and attributes, users have 
expressed a desire to construct named entity references.</P>
<P><I>Response</I></P>
<P>No solution has been provided to this requirement; it is difficult, because 
entity references are not defined in the data model.</P>
<P><B><I>Requirement 17</I></B></P>
<P><SPAN class=verb>should</SPAN>&nbsp;Support for Unicode String 
Normalization</P>
<P>For reliable string comparison of Unicode strings, users need the ability to 
apply Unicode normalization before comparing the strings.</P>
<P><I>Response</I></P>
<P>This requirement has been addressed by the provision of the <A 
href="http://www.w3.org/TR/xpath-functions/#func-normalize-unicode"><CODE>normalize-unicode</CODE></A><SUP><SMALL>FO</SMALL></SUP> 
function described in <A 
href="REC-xslt20-20070123.htm#xpath-functions">[Functions 
and Operators]</A>. In addition, a serialization parameter 
<CODE>normalization-form</CODE> has been added.</P>
<P><B><I>Requirement 18</I></B></P>
<P><SPAN class=verb>should</SPAN>&nbsp;Standardize Extension Element Language 
Bindings</P>
<P>XSLT 1.1 undertook the standardization of language bindings for XSLT <A 
title="extension function" 
href="REC-xslt20-20070123.htm#dt-extension-function">extension 
functions</A>. For XSLT 2.0, analogous bindings <SPAN class=verb>should</SPAN> 
be provided for extension elements [now renamed <A title="extension instruction" 
href="REC-xslt20-20070123.htm#dt-extension-instruction">extension 
instructions</A>].</P>
<P><I>Response</I></P>
<P>The XSL Working Group has decided not to pursue this requirement, and the 
attempt to standardize language bindings for extension functions that appeared 
in the XSLT 1.1 Working Draft has now been withdrawn. The Working Group decided 
that language bindings would be better published separately from the core XSLT 
specification.</P>
<P><B><I>Requirement 19</I></B></P>
<P>Could&nbsp;Improve Efficiency of Transformations on Large Documents</P>
<P>Many useful transformations take place on large documents consisting of 
thousands of repeating "sub-documents". Today transformations over these 
documents are impractical due to the need to have the entire source tree in 
memory. Enabling "progressive" transformations, where the processor is able to 
produce progressively more output as more input is received, is tantamount to 
avoiding the need for XSLT processors to have random access to the entire source 
document. This might be accomplished by:</P>
<P>Identifying a core subset of XPath that does not require random access to the 
source tree, or</P>
<P>Consider a "transform all subtrees" mode where the stylesheet says, "Apply 
the transformation implied by this stylesheet to each node that matches XXX, 
considered as the root of a separate tree, and copy all the results of these 
mini-transformations as separate subtrees on to the final result tree."</P>
<P><I>Response</I></P>
<P>The Working Group observes that implementation techniques for XSLT processing 
have advanced considerably since this requirement was written, and that further 
research developing new approaches continues both in industry and academia. In 
the light of these developments, the Working Group has decided that it would be 
inappropriate at this stage to identify language features or subsets designed 
specifically to enable progressive transformations.</P>
<P><B><I>Requirement 20</I></B></P>
<P>Could&nbsp;Support Reverse IDREF attributes</P>
<P>Given a particular value of an ID, produce a list of all elements that have 
an IDREF or IDREFS attribute which refers to this ID.</P>
<P>This functionality can be accomplished using the current &lt;xsl:key&gt; and 
key() mechanism.</P>
<P><I>Response</I></P>
<P>The <A 
href="http://www.w3.org/TR/xpath-functions/#func-idref"><CODE>idref</CODE></A><SUP> 
<SMALL>FO</SMALL></SUP> function defined in <A 
href="REC-xslt20-20070123.htm#xpath-functions">[Functions 
and Operators]</A> has been introduced in response to this requirement.</P>
<P><B><I>Requirement 21</I></B></P>
<P>Could&nbsp;Support Case-Insensitive Comparisons</P>
<P>XSLT 2.0 could expand its comparison functionality to include support for 
case-insensitive string comparison.</P>
<P><I>Response</I></P>
<P>This is an XPath 2.0 requirement. XPath 2.0 includes functions to convert 
strings to uppercase or lowercase, it also includes functions to compare strings 
using a named collating sequence, which provides the option of using a collating 
sequence that treats uppercase and lowercase as equal.</P>
<P><B><I>Requirement 22</I></B></P>
<P>Could&nbsp;Support Lexigraphic String Comparisons</P>
<P>We don't let users compare strings like $x &gt; 'a'.</P>
<P><I>Response</I></P>
<P>This requirement has been addressed in XPath 2.0.</P>
<P><B><I>Requirement 23</I></B></P>
<P>Could&nbsp;Allow Comparing Nodes Based on Document Order</P>
<P>Support the ability to test whether one node comes before another in document 
order.</P>
<P><I>Response</I></P>
<P>This requirement has been addressed in XPath 2.0, using the operators 
<CODE>&lt;&lt;</CODE> and <CODE>&gt;&gt;</CODE>.</P>
<P><B><I>Requirement 24</I></B></P>
<P>Could&nbsp;Improve Support for Unparsed Entities</P>
<P>In XSLT 1.0 there is an asymmetry in support for unparsed entities. They can 
be handled on input but not on output. In particular, there is no way to do an 
identity transformation that preserves them. At a minimum we need the ability to 
retrieve the Public ID of an unparsed entity.</P>
<P><I>Response</I></P>
<P>A function to retrieve the public identifier of an unparsed entity has been 
added. However, no facilities have been provided to include unparsed entities in 
a result document.</P>
<P><B><I>Requirement 25</I></B></P>
<P>Could&nbsp;Allow Processing a Node with the "Next Best Matching" Template</P>
<P>In the construction of large stylesheets for complex documents, it is often 
necessary to construct templates that implement special behavior for a 
particular instance of an element, and then apply the normal styling for that 
element. Currently this is not possible because <A 
href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A> 
specifies that for any given node only a single template will be selected and 
instantiated.</P>
<P>Currently the processor determines a list of matching templates and then 
discards all but the one with the highest priority. In order to support this 
requirement, the processor would retain the list of matching templates sorted in 
priority order. A new instruction, for example <A 
href="REC-xslt20-20070123.htm#element-next-match"><CODE>xsl:next-match</CODE></A>, 
in a template would simply trigger the next template in the list of matching 
templates. This "next best match" recursion naturally bottoms out at the builtin 
template which can be seen as the lowest priority matching template for every 
match pattern.</P>
<P><I>Response</I></P>
<P>An <A 
href="REC-xslt20-20070123.htm#element-next-match"><CODE>xsl:next-match</CODE></A> 
instruction has been added.</P>
<P><B><I>Requirement 26</I></B></P>
<P>Could&nbsp;Make Coercions Symmetric By Allowing Scalar to Nodeset 
Conversion</P>
<P>Presently, no datatype can be coerced or cast to a node-set. By allowing a <A 
title="string value" 
href="REC-xslt20-20070123.htm#dt-string-value">string 
value</A> to convert to a node-set, some user "gotchas" could be avoided.</P>
<P><I>Response</I></P>
<P>The availability of sequences of strings or numbers probably meets most of 
the use-cases envisaged by this requirement.</P>
<P><B><I>Requirement 27</I></B></P>
<P><SPAN class=verb>must</SPAN>&nbsp;Simplify Constructing and Copying Typed 
Content</P>
<P>It <SPAN class=verb>must</SPAN> be possible to construct XML Schema-typed 
elements and attributes. In addition, when copying an element or an attribute to 
the result, it <SPAN class=verb>should</SPAN> be possible to preserve the type 
during the process.</P>
<P><I>Response</I></P>
<P>Facilities to validate constructed and copied element and attribute nodes are 
defined in this specification; these elements and attributes will carry a type 
annotation indicating their XML Schema type. In addition, it is possible to 
specify when copying nodes whether type annotations should be preserved or 
removed.</P>
<P><B><I>Requirement 28</I></B></P>
<P><SPAN class=verb>must</SPAN>&nbsp;Support Sorting Nodes Based on XML Schema 
Type</P>
<P>XSLT 1.0 supports sorting based on string-valued and number-valued 
expressions. XML Schema: Datatypes introduces new scalar types (for example, 
date) with well-known sort orders. It <SPAN class=verb>must</SPAN> be possible 
to sort based on these extended set of scalar data types. Since XML Schema: 
Datatypes does not define an ordering for complex types, this sorting support 
<SPAN class=verb>should</SPAN> only be considered for simple types.</P>
<P><SPAN class=verb>should</SPAN> be consistent with whatever we define for the 
matrix of conversion and comparisons.</P>
<P><I>Response</I></P>
<P>Sorting based on any schema-defined primitive data type with a total ordering 
is included in this specification.</P>
<P><B><I>Requirement 29</I></B></P>
<P>Could&nbsp;Support Scientific Notation in Number Formatting</P>
<P>Several users have requested the ability to have the existing format-number() 
function extended to format numbers using Scientific Notation.</P>
<P><I>Response</I></P>
<P>Simple scientific formatting is now available through support for the 
schema-defined <CODE>xs:float</CODE> and <CODE>xs:double</CODE> data types; 
casting a large or small value of these types to a string produces a 
representation of the value in scientific notation. The Working Group believes 
that this will meet the requirement in most cases, and has therefore decided not 
to enhance the <A 
href="REC-xslt20-20070123.htm#function-format-number"><CODE>format-number</CODE></A> 
further to introduce scientific notation. Users with more specialized 
requirements can write their own functions.</P>
<P><B><I>Requirement 30</I></B></P>
<P>Could&nbsp;Provide Ability to Detect Whether "Rich" Schema Information is 
Available</P>
<P>A stylesheet that requires XML Schema type-related functionality could be 
able to test whether a "rich" Post-Schema-Validated Infoset is available from 
the XML Schema processor, so that the stylesheet can provide fallback behavior 
or choose to exit with <CODE>xsl:message abort="yes"</CODE>.</P>
<P><I>Response</I></P>
<P>This requirement is satisified through the <CODE>instance of</CODE> operator 
in XPath 2.0, which allows expressions to determine the type of element and 
attribute nodes, using information from the schema. The details of how these 
expressions behave when there is no schema are defined in the XPath 
specifications.</P>
<P><B><I>Requirement 31</I></B></P>
<P><SPAN class=verb>must</SPAN>&nbsp;Simplify Grouping</P>
<P>Grouping is complicated in XSLT 1.0. It <SPAN class=verb>must</SPAN> be 
possible for users to group nodes in a document based on common string-values, 
common names, or common values for any other expression</P>
<P>In addition XSLT <SPAN class=verb>must</SPAN> allow grouping based on 
sequential position, for example selecting groups of adjacent &lt;P&gt; 
elements. Ideally it <SPAN class=verb>should</SPAN> also make it easier to do 
fixed-size grouping as well, for example groups of three adjacent nodes, for 
laying out data in multiple columns. For each group of nodes identified, it 
<SPAN class=verb>must</SPAN> be possible to instantiate a template for the 
group. Grouping <SPAN class=verb>must</SPAN> be "nestable" to multiple levels so 
that groups of distinct nodes can be identified, then from among the distinct 
groups selected, further sub-grouping of distinct node in the current group can 
be done.</P>
<P><I>Response</I></P>
<P>A new <A 
href="REC-xslt20-20070123.htm#element-for-each-group"><CODE>xsl:for-each-group</CODE></A> 
instruction is provided: see <A 
href="REC-xslt20-20070123.htm#grouping"><I>14 
Grouping</I></A>. In addition, many of the new functions and operators provided 
in XPath 2.0 make these algorithms easier to write.</P></DIV>
<DIV class=div1>
<H2><A id=changes name=changes></A>J Changes from XSLT 1.0 (Non-Normative)</H2>
<DIV class=div2>
<H3><A id=incompatibilities name=incompatibilities></A>J.1 Incompatible 
Changes</H3>
<P>This section lists all known cases where a stylesheet that was valid 
(produced no errors) under XSLT 1.0, and whose behavior was fully specified by 
XSLT 1.0, will produce different results under XSLT 2.0.</P>
<P>Most of the discussion is concerned with compatibility in the absence of a 
schema: that is, it is assumed that the source document being transformed has no 
schema when processed using XSLT 1.0, and that no schema is added when moving to 
XSLT 2.0. Some additional factors that come into play when a schema is added are 
noted at the end of the section.</P>
<DIV class=div3>
<H4><A id=incompatibility-stripping name=incompatibility-stripping></A>J.1.1 
Tree construction: whitespace stripping</H4>
<P>Both in XSLT 1.0 and in XSLT 2.0, the XSLT specification places no 
constraints on the way in which source trees are constructed. For XSLT 2.0, 
however, the <A 
href="REC-xslt20-20070123.htm#xpath-datamodel">[Data 
Model]</A> specification describes explicit processes for constructing a tree 
from an Infoset or a PSVI, while also permitting other processes to be used. The 
process described in <A 
href="REC-xslt20-20070123.htm#xpath-datamodel">[Data 
Model]</A> has the effect of stripping <A title="whitespace text node" 
href="REC-xslt20-20070123.htm#dt-whitespace-text-node">whitespace 
text nodes</A> from elements declared to have element-only content. Although the 
XSLT 1.0 specification did not preclude such behavior, it differs from the way 
that most existing XSLT 1.0 implementations work. It is <SPAN 
class=verb>recommended</SPAN> that an XSLT 2.0 implementation wishing to provide 
maximum interoperability and backwards compatibility should offer the user the 
option either to construct source trees using the processes described in <A 
href="REC-xslt20-20070123.htm#xpath-datamodel">[Data 
Model]</A>, or alternatively to retain or remove whitespace according to the 
common practice of previous XSLT 1.0 implementations.</P>
<P>To write transformations that give the same result regardless of the 
whitespace stripping applied during tree construction, stylesheet authors 
can:</P>
<UL>
  <LI>
  <P>use the <A 
  href="REC-xslt20-20070123.htm#element-strip-space"><CODE>xsl:strip-space</CODE></A> 
  declaration to remove <A title="whitespace text node" 
  href="REC-xslt20-20070123.htm#dt-whitespace-text-node">whitespace 
  text nodes</A> from elements having element-only content (this has no effect 
  if the whitespace has already been stripped)</P>
  <LI>
  <P>use instructions such as <CODE>&lt;xsl:apply-templates 
  select="*"/&gt;</CODE> that cause only the element children of the context 
  node to be processed, and not its text nodes.</P></LI></UL></DIV>
<DIV class=div3>
<H4><A id=incompatibility-serialization 
name=incompatibility-serialization></A>J.1.2 Changes in Serialization 
Behavior</H4>
<P>The specification of the output of <A title=serialization 
href="REC-xslt20-20070123.htm#dt-serialization">serialization</A> 
is more prescriptive than in XSLT 1.0. For example, the <CODE>html</CODE> output 
method is <SPAN class=verb>required</SPAN> to detect invalid HTML characters. 
Also, certain combinations of serialization parameters are now defined to be 
errors. Furthermore, XSLT 1.0 implementations were allowed to add additional <A 
href="REC-xslt20-20070123.htm#element-output"><CODE>xsl:output</CODE></A> 
attributes that modified the behavior of the serializer. Some such extensions 
might be non-conformant under the stricter rules of XSLT 2.0. For example, some 
XSLT 1.0 processors provided an extension attribute to switch off the creation 
of <CODE>meta</CODE> elements by the <CODE>html</CODE> output method (a facility 
that is now provided as standard). A conformant XSLT 2.0 processor is not 
allowed to provide such extensions.</P>
<P>Where necessary, implementations <SPAN class=verb>may</SPAN> provide 
additional serialization methods designed to mimic more closely the behavior of 
specific XSLT 1.0 serializers.</P></DIV>
<DIV class=div3>
<H4><A id=backwards-compatibility-behavior 
name=backwards-compatibility-behavior></A>J.1.3 Backwards Compatibility 
Behavior</H4>
<P>Some XSLT constructs behave differently under XSLT 2.0 depending on whether 
<A title="backwards compatible behavior" 
href="REC-xslt20-20070123.htm#dt-backwards-compatible-behavior">backwards 
compatible behavior</A> is enabled. In these cases, the behavior may be made 
compatible with XSLT 1.0 by ensuring that <A 
title="backwards compatible behavior" 
href="REC-xslt20-20070123.htm#dt-backwards-compatible-behavior">backwards 
compatible behavior</A> is enabled (which is done using the 
<CODE>[xsl:]version</CODE> attribute).</P>
<P>These constructs are as follows:</P>
<OL class=enumar>
  <LI>
  <P>If the <A 
  href="REC-xslt20-20070123.htm#element-value-of"><CODE>xsl:value-of</CODE></A> 
  instruction has no <CODE>separator</CODE> attribute, and the value of the 
  <CODE>select</CODE> expression is a sequence of more than one item, then under 
  XSLT 2.0 all items in the sequence will be output, space separated, while in 
  XSLT 1.0, all items after the first will be discarded.</P>
  <LI>
  <P>If the <A title="effective value" 
  href="REC-xslt20-20070123.htm#dt-effective-value">effective 
  value</A> of an <A title="attribute value template" 
  href="REC-xslt20-20070123.htm#dt-attribute-value-template">attribute 
  value template</A> is a sequence of more than one item, then under XSLT 2.0 
  all items in the sequence will be output, space separated, while in XSLT 1.0, 
  all items after the first will be discarded.</P>
  <LI>
  <P>If the expression in the <CODE>value</CODE> attribute of the <A 
  href="REC-xslt20-20070123.htm#element-number"><CODE>xsl:number</CODE></A> 
  instruction returns a sequence of more than one item, then under XSLT 2.0 all 
  items in the sequence will be output, as defined by the <CODE>format</CODE> 
  attribute, but under XSLT 1.0, all items after the first will be discarded. If 
  the sequence is empty, then under XSLT 2.0 nothing will be output (other than 
  a prefix and suffix if requested), but under XSLT 1.0, the output is "NaN". If 
  the first item in the sequence cannot be converted to a number, then XSLT 2.0 
  signals a non-recoverable error, while XSLT 1.0 outputs "NaN".</P>
  <P>If the expression in the <CODE>value</CODE> attribute of <A 
  href="REC-xslt20-20070123.htm#element-number"><CODE>xsl:number</CODE></A> 
  returns an empty sequence or a sequence including non-numeric values, an XSLT 
  2.0 processor may signal a recoverable error; but with backwards compatibility 
  enabled, it outputs <CODE>NaN</CODE>.</P>
  <LI>
  <P>If the <A title=atomize 
  href="REC-xslt20-20070123.htm#dt-atomization">atomized</A> 
  value of the <CODE>select</CODE> attribute of the <A 
  href="REC-xslt20-20070123.htm#element-sort"><CODE>xsl:sort</CODE></A> 
  element is a sequence of more than one item, then under XSLT 2.0 an error will 
  be signaled, while in XSLT 1.0, all items after the first will be 
  discarded.</P>
  <LI>
  <P>If an <A 
  href="REC-xslt20-20070123.htm#element-call-template"><CODE>xsl:call-template</CODE></A> 
  instruction supplies a parameter that does not correspond to any <A 
  title="template parameter" 
  href="REC-xslt20-20070123.htm#dt-template-parameter">template 
  parameter</A> in the template being called, then under XSLT 2.0 a <A 
  title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A> is signaled, but under XSLT 1.0 the extra parameter is ignored.</P>
  <LI>
  <P>It is normally a <A title="static error" 
  href="REC-xslt20-20070123.htm#dt-static-error">static 
  error</A> if an XPath expression contains a call to an unknown function. But 
  when backwards compatible behavior is enabled, this is a <A 
  title="non-recoverable dynamic error" 
  href="REC-xslt20-20070123.htm#dt-nonrec-dynamic-error">non-recoverable 
  dynamic error</A>, which occurs only if the function call is actually 
  evaluated.</P>
  <LI>
  <P>An XSLT 1.0 processor compared the value of the expression in the 
  <CODE>use</CODE> attribute of <A 
  href="REC-xslt20-20070123.htm#element-key"><CODE>xsl:key</CODE></A> 
  to the value supplied in the second argument of the <A 
  href="REC-xslt20-20070123.htm#function-key"><CODE>key</CODE></A> 
  function by converting both to strings. An XSLT 2.0 processor normally 
  compares the values as supplied. The XSLT 1.0 behavior is retained if any of 
  the <A 
  href="REC-xslt20-20070123.htm#element-key"><CODE>xsl:key</CODE></A> 
  elements making up the <A title=key 
  href="REC-xslt20-20070123.htm#dt-key">key</A> 
  definition enables backwards-compatible behavior.</P>
  <LI>
  <P>If no output method is explicitly requested, and the first element node 
  output appears to be an XHTML document element, then under XSLT 2.0 the output 
  method defaults to XHTML; with backwards compatibility enabled, the XML output 
  method will be used.</P></LI></OL>
<P>Backwards compatible behavior also affects the results of certain XPath 
expressions, as defined in <A 
href="REC-xslt20-20070123.htm#xpath20">[XPath 
2.0]</A>.</P></DIV>
<DIV class=div3>
<H4><A id=incompatibility-without-schema 
name=incompatibility-without-schema></A>J.1.4 Incompatibility in the Absence of 
a Schema</H4>
<P>If the source documents supplied as input to a transformation contain no type 
information generated from a schema then the known areas of incompatibility are 
as follows. These apply whether or not <A title="backwards compatible behavior" 
href="REC-xslt20-20070123.htm#dt-backwards-compatible-behavior">backwards 
compatible behavior</A> is enabled.</P>
<OL class=enumar>
  <LI>
  <P>A stylesheet that specifies a version number other than 1.0 was defined in 
  XSLT 1.0 to execute in forwards-compatible mode; if such a stylesheet uses 
  features that are not defined in XSLT 2.0 then errors may be signaled by an 
  XSLT 2.0 processor that would not be signaled by an XSLT 1.0 processor.</P>
  <LI>
  <P>At XSLT 1.0 the <A 
  href="REC-xslt20-20070123.htm#function-system-property"><CODE>system-property</CODE></A> 
  function, when called with a first argument of <CODE>"xsl:version"</CODE>, 
  returned 1.0 as a number. At XSLT 2.0 it returns "2.0" as a string. The <SPAN 
  class=verb>recommended</SPAN> way of testing this property is, for example, 
  <CODE>&lt;xsl:if test="number(system-property('xsl:version')) &amp;lt; 
  2.0"&gt;</CODE>, which will work with either an XSLT 1.0 or an XSLT 2.0 
  processor.</P>
  <LI>
  <P>At XSLT 2.0 it is an error to specify the <CODE>mode</CODE> or 
  <CODE>priority</CODE> attribute on an <A 
  href="REC-xslt20-20070123.htm#element-template"><CODE>xsl:template</CODE></A> 
  element having no <CODE>match</CODE> attribute. At XSLT 1.0 the attributes 
  were silently ignored in this situation.</P>
  <LI>
  <P>When an <A 
  href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A> 
  or <A 
  href="REC-xslt20-20070123.htm#element-apply-imports"><CODE>xsl:apply-imports</CODE></A> 
  instruction causes a built-in template rule to be invoked, then any parameters 
  that are supplied are automatically passed on to any further template rules. 
  This did not happen in XSLT 1.0.</P>
  <LI>
  <P>In XSLT 1.0 it was a recoverable error to create any node other than a text 
  node while constructing the value of an attribute, comment, or 
  processing-instruction; the recovery action was to ignore the offending node 
  and its content. In XSLT 2.0 this is no longer an error, and the specified 
  action is to atomize the node. An XSLT 2.0 processor will therefore not 
  produce the same results as an XSLT 1.0 processor that took the error recovery 
  action.</P>
  <LI>
  <P>XSLT 1.0 defined a number of recoverable error conditions which in XSLT 2.0 
  have become non-recoverable errors. Under XSLT 1.0, a stylesheet that 
  triggered such errors would fail under some XSLT processors and succeed (or at 
  any rate, continue to completion) under others. Under XSLT 2.0 such a 
  stylesheet will fail under all processors. Notable examples of such errors are 
  constructing an element or attribute with an invalid name, generating 
  attributes as children of a document node, and generating an attribute of an 
  element after generating one or more children for the element. This change has 
  been made in the interests of interoperability. In classifying such errors as 
  non-recoverable, the Working Group used the criterion that no stylesheet 
  author would be likely to write code that deliberately triggered the error and 
  relied on the recovery action.</P>
  <LI>
  <P>In XSLT 1.0, the semantics of tree construction were described as being 
  top-down, in XSLT 2.0 they are described bottom up. In nearly all cases the 
  end result is the same. One difference arises in the case of a tree that is 
  constructed to contain an attribute node within a document node within an 
  element node, using an instruction such as the following:</P>
  <DIV class=example>
  <DIV class=exampleHeader><A id=d5e31247 name=d5e31247></A>Example: Attribute 
  within Document within Element </DIV>
  <DIV class=exampleInner><PRE>&lt;xsl:template match="/"&gt;
  &lt;e&gt;
    &lt;xsl:copy&gt;
      &lt;xsl:attribute name="a"&gt;5&lt;/xsl:attribute&gt;
    &lt;/xsl:copy&gt;
  &lt;/e&gt;
&lt;/xsl:template&gt;
</PRE></DIV></DIV>
  <P>In XSLT 1.0, the <A 
  href="REC-xslt20-20070123.htm#element-copy"><CODE>xsl:copy</CODE></A> 
  did nothing, and the attribute <CODE>a</CODE> was then attached to the element 
  <CODE>e</CODE>. In XSLT 2.0, an error occurs when attaching the attribute 
  <CODE>a</CODE> to the document node constructed by <A 
  href="REC-xslt20-20070123.htm#element-copy"><CODE>xsl:copy</CODE></A>, 
  because this happens before the resulting document node is copied to the 
  content of the constructed element.</P>
  <LI>
  <P>In XSLT 1.0 it was not an error for the <CODE>namespace</CODE> attribute of 
  <A 
  href="REC-xslt20-20070123.htm#element-element"><CODE>xsl:element</CODE></A> 
  or <A 
  href="REC-xslt20-20070123.htm#element-attribute"><CODE>xsl:attribute</CODE></A> 
  to evaluate to an invalid URI. Since many XML parsers accept any string as a 
  namespace name, this rarely caused problems. The <A 
  href="REC-xslt20-20070123.htm#xpath-datamodel">[Data 
  Model]</A>, however, requires the name of a node to be an 
  <CODE>xs:QName</CODE>, and the namespace part of an <CODE>xs:QName</CODE> is 
  always an <CODE>xs:anyURI</CODE>. It is therefore now defined to be an error 
  to create an element or attribute node in a namespace whose name is not a 
  valid instance of <CODE>xs:anyURI</CODE>. <SPAN>In practice, however, 
  implementations have some flexibility in how rigorously they validate 
  namespace URIs.</SPAN></P>
  <LI>
  <P>It is now a static error for the stylesheet to contain two conflicting <A 
  href="REC-xslt20-20070123.htm#element-namespace-alias"><CODE>xsl:namespace-alias</CODE></A> 
  declarations with the same import precedence.</P>
  <LI>
  <P>It is now a static error for an <A 
  href="REC-xslt20-20070123.htm#element-number"><CODE>xsl:number</CODE></A> 
  instruction to contain both a <CODE>value</CODE> attribute and a 
  <CODE>level</CODE>, <CODE>from</CODE>, or <CODE>count</CODE> attribute. In 
  XSLT 1.0 the <CODE>value</CODE> attribute took precedence and the other 
  attributes were silently ignored.</P>
  <LI>
  <P>When the <CODE>data-type</CODE> attribute of <A 
  href="REC-xslt20-20070123.htm#element-sort"><CODE>xsl:sort</CODE></A> 
  has the value <CODE>number</CODE>, an XSLT 1.0 processor would evaluate the 
  sort key as a string, and convert the result to a number. An XSLT 2.0 
  processor evaluates the sort key as a number directly. This only affects the 
  outcome in cases where <SPAN>in XSLT 1.0,</SPAN> conversion of a number to a 
  string and then back to a number does not produce the original number, as is 
  the case for example with the number <SPAN>positive infinity</SPAN>.</P>
  <LI>
  <P>When the <CODE>data-type</CODE> attribute of <A 
  href="REC-xslt20-20070123.htm#element-sort"><CODE>xsl:sort</CODE></A> 
  is omitted, an XSLT 1.0 processor would convert the sort key values to 
  strings, and sort them as strings. An XSLT 2.0 processor will sort them 
  according to their actual dynamic type. This means, for example, that if the 
  sort key component specifies <CODE>&lt;xsl:sort 
  select="string-length(.)"/&gt;</CODE>, an XSLT 2.0 processor will do a numeric 
  sort where an XSLT 1.0 processor would have done an alphabetic sort.</P>
  <LI>
  <P>When the <CODE>data-type</CODE> attribute of <A 
  href="REC-xslt20-20070123.htm#element-sort"><CODE>xsl:sort</CODE></A> 
  is omitted or has the value "text", an XSLT 1.0 processor treats a sort key 
  whose value is an empty node-set as being equal to a sort key whose value is a 
  zero-length string. XSLT 2.0 sorts the empty sequence before the zero-length 
  string. This means that if there are two sort keys, say <CODE>&lt;xsl:sort 
  select="@a"/&gt;</CODE> and <CODE>&lt;xsl:sort select="@b"/&gt;</CODE>, then 
  an XSLT 1.0 processor will sort the element <CODE>&lt;x b="2"/&gt;</CODE> 
  after <CODE>&lt;x a="" b="1"/&gt;</CODE>, while an XSLT 2.0 processor will 
  produce the opposite ordering.</P>
  <LI>
  <P>The specification of the <A 
  href="REC-xslt20-20070123.htm#function-format-number"><CODE>format-number</CODE></A> 
  function has been rewritten to remove the normative dependency on the Java JDK 
  1.1 specification. The JDK 1.1 specification left aspects of the behavior 
  undefined; it is therefore likely that some cases will give different 
  results.</P>
  <P>The ability to include literal text in the format picture enclosed in 
  single quotes has been removed; any stylesheet that uses this feature will 
  need to be modified, for example to display the literal text using the <A 
  href="http://www.w3.org/TR/xpath-functions/#func-concat"><CODE>concat</CODE></A><SUP><SMALL>FO</SMALL></SUP> 
  function instead.</P>
  <P>One specific difference between the XSLT 2.0 specification and a JDK-based 
  implementation is in the handling of the negative sub-picture. JDK releases 
  subsequent to JDK 1.1 have added the provision: <EM>If there is an explicit 
  negative subpattern [sub-picture], it serves only to specify the negative 
  prefix and suffix; the number of digits, minimal digits, and other 
  characteristics are all the same as the positive pattern [sub-picture].</EM> 
  This statement was not present in the JDK 1.1 specification, and therefore it 
  is not necessarily how every XSLT 1.0 implementation will behave, but it does 
  describe the behavior of some XSLT 1.0 implementations that use the JDK 
  directly. This behavior is not correct in XSLT 2.0: the negative sub-picture 
  <SPAN class=verb>must</SPAN> be used as written when the number is 
  negative.</P>
  <LI>
  <P>The recovery action has changed for the error condition where the processor 
  cannot handle the fragment identifier in a URI passed as an argument to the <A 
  href="REC-xslt20-20070123.htm#function-document"><CODE>document</CODE></A> 
  function. XSLT 1.0 specified that the entire URI reference should be ignored. 
  XSLT 2.0 specifies that the fragment identifier should be ignored.</P>
  <LI>
  <P>XSLT 1.0 allowed the URI returned by the <A 
  href="REC-xslt20-20070123.htm#function-unparsed-entity-uri"><CODE>unparsed-entity-uri</CODE></A> 
  function to be derived from some combination of the system identifier and the 
  public identifier in the source XML. XSLT 2.0 returns the system identifier as 
  defined in the Infoset, resolved using the base URI of the source document. A 
  new function is provided to return the public identifier.</P>
  <LI>
  <P>The default priority of the pattern <CODE>match="/"</CODE> has changed from 
  +0.5 to -0.5. The effect of this is that if there are any template rules that 
  specify <CODE>match="/"</CODE> with an explicit user-specified priority 
  between -0.5 and +0.5, these will now be chosen in preference to a template 
  rule that specifies <CODE>match="/"</CODE> with no explicit priority; 
  previously such rules would never have been invoked.</P>
  <LI>
  <P>In XSLT 1.0 it was possible to create a processing instruction in the 
  result tree whose string value contained a leading space. However, such 
  leading spaces would be lost after serialization and parsing. In XSLT 2.0, any 
  leading spaces in the string value of the processing instruction are removed 
  at the time the node is created.</P>
  <LI>
  <P>At XSLT 1.0 there were no restrictions on the namespaces that could be used 
  for the names of user-defined stylesheet objects such as keys, variables, and 
  named templates. In XSLT 2.0, certain namespaces (for example the XSLT 
  namespace and the XML Schema namespace) are reserved.</P>
  <LI>
  <P>An erratum to XSLT 1.0 specified what has become known as "sticky 
  disable-output-escaping": specifically, that it should be possible to use 
  <CODE>disable-output-escaping</CODE> when writing a node to a temporary tree, 
  and that this information would be retained for use when the same node was 
  later copied to a final result tree and serialized. XSLT 2.0 no longer 
  specifies this behavior (though it permits it, at the discretion of the 
  implementation). The use cases for this facility have been satisfied by a 
  completely different mechanism, the concept of character maps (see <A 
  href="REC-xslt20-20070123.htm#character-maps"><I>20.1 
  Character Maps</I></A>).</P></LI></OL></DIV>
<DIV class=div3>
<H4><A id=compatibility-with-schema name=compatibility-with-schema></A>J.1.5 
Compatibility in the Presence of a Schema</H4>
<P>An XSLT 1.0 processor ignored all information about data types that might be 
obtained from a schema associated with a source document. An XSLT 2.0 processor 
will take account of such information, <SPAN>unless the 
<CODE>input-type-annotations</CODE> attribute is set to 
<CODE>strip</CODE></SPAN>. This may lead to a number of differences in behavior. 
This section attempts only to give some examples of the kind of differences that 
might be expected when schema information is made available:</P>
<UL>
  <LI>
  <P>Operations such as sorting will be sensitive to the data type of the items 
  being sorted. For example, if the data type of a sort key component is defined 
  in the schema as a date, then in the absence of a <CODE>data-type</CODE> 
  attribute on the <A 
  href="REC-xslt20-20070123.htm#element-sort"><CODE>xsl:sort</CODE></A> 
  element, the sequence will be sorted in date order. With XSLT 1.0, the dates 
  would be compared and sorted as strings.</P>
  <LI>
  <P>Certain operations that are permitted on untyped data are not permitted on 
  typed data, if the type of the data is inappropriate for the operation. 
  <SPAN>For example, the <A 
  href="http://www.w3.org/TR/xpath-functions/#func-substring"><CODE>substring</CODE></A><SUP><SMALL>FO</SMALL></SUP> 
  function expects its first argument to be a string</SPAN>. It is acceptable to 
  supply an untyped value, which will be automatically converted to a string, 
  but it is not acceptable to supply a value which has been annotated (as a 
  result of schema processing) as an integer or a date.</P>
  <LI>
  <P>When an attribute value such as <CODE>colors="red green blue"</CODE> is 
  processed without a schema, the value is considered to be a single string. 
  When schema validation is applied, assuming the type is a list type like 
  <CODE>xs:NMTOKENS</CODE>, the value will be treated as a sequence of three 
  strings. This affects the results of many operations, for example comparison 
  of the value with another string. <SPAN>With this attribute value, the 
  expression <CODE>contains(@colors, "green")</CODE> returns true in XPath 1.0 
  and also in XPath 2.0 if <CODE>input-type-annotations</CODE> is set to 
  <CODE>strip</CODE>. In XPath 2.0, with a schema-aware processor and with 
  <CODE>input-type-annotations</CODE> set to <CODE>preserve</CODE>, the same 
  expression returns false with backwards-compatibility enabled, and raises an 
  error with backwards compatibility disabled.</SPAN></P></LI></UL></DIV>
<DIV class=div3>
<H4><A id=xpath-compatibility name=xpath-compatibility></A>J.1.6 XPath 2.0 
Backwards Compatibility</H4>
<P>Information about incompatibilities between XPath 2.0 and XPath 1.0 is 
included in <A 
href="REC-xslt20-20070123.htm#xpath20">[XPath 
2.0]</A></P>
<P>Incompatibilities in the specification of individual functions in the <A 
title="core function" 
href="REC-xslt20-20070123.htm#dt-core-function">core 
function</A> library are listed in <A 
href="REC-xslt20-20070123.htm#xpath-functions">[Functions 
and Operators]</A></P></DIV></DIV>
<DIV class=div2>
<H3><A id=changes-since-1.0 name=changes-since-1.0></A>J.2 New 
Functionality</H3>
<P>This section summarizes the new functionality offered in XSLT 2.0, compared 
with XSLT 1.0. These are arranged in three groups. Firstly, the changes that 
pervade the entire text. Secondly, the major new features introduced. And 
thirdly, a catalog of minor technical changes.</P>
<P>Changes since the <SPAN>November 2006 Proposed Recommendation</SPAN> are 
listed separately: see <A 
href="REC-xslt20-20070123.htm#changes-2007-01"><I>J.2.4 
Changes since Proposed Recommendation</I></A>.</P>
<P>In addition to these changes, reported <A 
href="http://www.w3.org/1999/11/REC-xslt-19991116-errata/">errors</A> in XSLT 
1.0 have been fixed.</P>
<DIV class=div3>
<H4><A id=pervasive-changes name=pervasive-changes></A>J.2.1 Pervasive 
changes</H4>
<UL>
  <LI>
  <P>There has been significant re-arrangement of the text. More terminology 
  definitions have been hyperlinked, and a glossary (see <A 
  href="REC-xslt20-20070123.htm#glossary"><I>C 
  Glossary</I></A>) has been added. Additional appendices summarize the error 
  conditions and implementation-defined features of the specification.</P>
  <LI>
  <P>The specifications of many features (for example keys, <A 
  href="REC-xslt20-20070123.htm#element-number"><CODE>xsl:number</CODE></A>, 
  the <A 
  href="REC-xslt20-20070123.htm#function-format-number"><CODE>format-number</CODE></A> 
  function, the <A 
  href="REC-xslt20-20070123.htm#element-import"><CODE>xsl:import</CODE></A> 
  mechanism, and the description of attribute sets) have been rewritten to make 
  them clearer and more precise.</P>
  <LI>
  <P>Many changes have been made to support the <SPAN>XDM</SPAN> data model, 
  notably the support for sequences as a replacement for the node-sets of XPath 
  1.0. This has affected the specification of elements such as <A 
  href="REC-xslt20-20070123.htm#element-for-each"><CODE>xsl:for-each</CODE></A>, 
  <A 
  href="REC-xslt20-20070123.htm#element-value-of"><CODE>xsl:value-of</CODE></A>, 
  and <A 
  href="REC-xslt20-20070123.htm#element-sort"><CODE>xsl:sort</CODE></A>, 
  and has led to the introduction of new instructions such as <A 
  href="REC-xslt20-20070123.htm#element-sequence"><CODE>xsl:sequence</CODE></A>.</P>
  <LI>
  <P>The processing model is described differently: instead of instructions 
  "writing to the result tree", they now return sequences of values. This change 
  is largely one of terminology, but it also means that it is now possible for 
  XSLT stylesheets to manipulate arbitrary sequences, including sequences 
  containing parentless element or attribute nodes.</P>
  <LI>
  <P>The description of the evaluation context has been changed. The concepts of 
  current node and current node list have been replaced by the XPath concepts of 
  context item, context position, and context size.</P>
  <LI>
  <P>With the introduction of support for XML Schema within XPath 2.0, XSLT now 
  supports stronger data typing, while retaining backwards compatibility. In 
  particular, the types of variables and parameters can now be specified 
  explicitly, and schema validation can be invoked for result trees and for 
  elements and attributes in temporary trees.</P>
  <LI>
  <P>The description of error handling has been improved (see <A 
  href="REC-xslt20-20070123.htm#errors"><I>2.9 Error 
  Handling</I></A>). This formalizes the difference between static and dynamic 
  errors, and tightens the rules that define which errors must be signaled under 
  which conditions.</P>
  <LI>
  <P>The terms <A title=implementation-defined 
  href="REC-xslt20-20070123.htm#dt-implementation-defined">implementation-defined</A> 
  and <A title=implementation-dependent 
  href="REC-xslt20-20070123.htm#dt-implementation-dependent">implementation-dependent</A> 
  are now defined and used consistently, and a checklist of 
  implementation-defined features is provided (see <A 
  href="REC-xslt20-20070123.htm#implementation-defined-features"><I>F 
  Checklist of Implementation-Defined Features</I></A>).</P></LI></UL></DIV>
<DIV class=div3>
<H4><A id=major-features name=major-features></A>J.2.2 Major Features</H4>
<UL>
  <LI>
  <P>XSLT 2.0 is designed to work with XPath 2.0 rather than XPath 1.0. This 
  brings an enhanced data model with a type system based on sequences of nodes 
  or atomic values, support for all the built-in types defined in XML Schema, 
  and a wide range of new functions and operators.</P>
  <LI>
  <P>The result tree fragment data-type is eliminated. <A 
  title="variable-binding element" 
  href="REC-xslt20-20070123.htm#dt-variable-binding-element">A 
  variable-binding element</A> with content (and no <CODE>as</CODE> attribute) 
  now constructs a <A title="temporary tree" 
  href="REC-xslt20-20070123.htm#dt-temporary-tree">temporary 
  tree</A>, and the value of the variable is the root node of this tree (see <A 
  href="REC-xslt20-20070123.htm#variable-values"><I>9.3 
  Values of Variables and Parameters</I></A>). With an <CODE>as</CODE> 
  attribute, a variable-binding element may be used to construct an arbitrary 
  sequence. These features eliminate the need for the <CODE>xx:node-set</CODE> 
  extension function provided by many XSLT 1.0 implementations.</P>
  <LI>
  <P>Facilities are introduced for grouping of nodes (the <A 
  href="REC-xslt20-20070123.htm#element-for-each-group"><CODE>xsl:for-each-group</CODE></A> 
  instruction, and the <CODE>current-group()</CODE> and 
  <CODE>current-grouping-key()</CODE> functions). See <A 
  href="REC-xslt20-20070123.htm#grouping"><I>14 
  Grouping</I></A></P>
  <LI>
  <P>It is now possible to create user-defined functions within the stylesheet, 
  that can be called from XPath expressions. See <A 
  href="REC-xslt20-20070123.htm#stylesheet-functions"><I>10.3 
  Stylesheet Functions</I></A>.</P>
  <LI>
  <P>A transformation is allowed to produce multiple result trees. See <A 
  href="REC-xslt20-20070123.htm#creating-result-trees"><I>19.1 
  Creating Final Result Trees</I></A>.</P>
  <LI>
  <P>A new instruction <A 
  href="REC-xslt20-20070123.htm#element-analyze-string"><CODE>xsl:analyze-string</CODE></A> 
  is provided to process text by matching it against a regular expression.</P>
  <LI>
  <P>It is possible to declare the types of variables and parameters, and the 
  result types of templates and functions. The types may either be built-in 
  types, or user-defined types imported from a schema using a new <A 
  href="REC-xslt20-20070123.htm#element-import-schema"><CODE>xsl:import-schema</CODE></A> 
  declaration.</P>
  <LI>
  <P>A stylesheet is able to attach type annotations to elements and attributes 
  in a result tree, and also in temporary trees, and to make use of any type 
  annotations that exist in a source tree. Result trees and temporary trees can 
  be validated against a schema.</P>
  <LI>
  <P>A transformation may now be invoked by calling a named template. This 
  creates the potential for a transformation to process large collections of 
  input documents. <SPAN>The input to such a transformation may be obtained 
  using the <A 
  href="http://www.w3.org/TR/xpath-functions/#func-collection"><CODE>collection</CODE></A><SUP><SMALL>FO</SMALL></SUP> 
  function defined in <A 
  href="REC-xslt20-20070123.htm#xpath-functions">[Functions 
  and Operators]</A>, or it may be supplied as a <A title="stylesheet parameter" 
  href="REC-xslt20-20070123.htm#dt-stylesheet-parameter">stylesheet 
  parameter</A>.</SPAN></P>
  <LI>
  <P>Comparisons between values used for grouping, for sorting, and for keys can 
  be performed using the rules for any supported data type, including the 
  ability to select named collations for performing string comparison. These 
  complement the new facilities in XPath 2.0, which are also invoked 
  automatically when matching template rules.</P>
  <LI>
  <P>The <A 
  href="REC-xslt20-20070123.htm#element-for-each"><CODE>xsl:for-each</CODE></A> 
  instruction is able to process any sequence, not only a sequence of nodes.</P>
  <LI>
  <P>An XHTML output method has been added. The details are described in <A 
  href="REC-xslt20-20070123.htm#xslt-xquery-serialization">[XSLT 
  and XQuery Serialization]</A>.</P>
  <LI>
  <P>A <CODE>collation</CODE> attribute has been added to the <A 
  href="REC-xslt20-20070123.htm#element-sort"><CODE>xsl:sort</CODE></A> 
  element to allow sorting using a user-defined collation.</P>
  <LI>
  <P>A new <A 
  href="REC-xslt20-20070123.htm#element-next-match"><CODE>xsl:next-match</CODE></A> 
  is provided to allow multiple template rules to be applied to the same source 
  node.</P>
  <LI>
  <P>A new <A 
  href="REC-xslt20-20070123.htm#element-character-map"><CODE>xsl:character-map</CODE></A> 
  declaration is available to control the serialization of individual 
  characters. This is intended as a replacement for some use-cases where 
  <CODE>disable-output-escaping</CODE> was previously necessary.</P>
  <LI>
  <P>Functions have been added for formatting dates and times. See <A 
  href="REC-xslt20-20070123.htm#format-date"><I>16.5 
  Formatting Dates and Times</I></A></P>
  <LI>
  <P>The new facility of <A title="tunnel parameter" 
  href="REC-xslt20-20070123.htm#dt-tunnel-parameter">tunnel 
  parameters</A> allows parameters to be set that affect an entire phase of the 
  transformation, without requiring them to be passed explicitly in every 
  template call.</P>
  <LI>
  <P>Many instructions that previously constructed a value using child 
  instructions can now alternatively construct the value using a 
  <CODE>select</CODE> attribute; and conversely, instructions that previously 
  required a <CODE>select</CODE> attribute can now use child instructions.</P>
  <LI>
  <P>The <A 
  href="REC-xslt20-20070123.htm#element-template"><CODE>xsl:template</CODE></A> 
  declaration can now declare a template rule that applies to several different 
  modes; and the <A 
  href="REC-xslt20-20070123.htm#element-apply-templates"><CODE>xsl:apply-templates</CODE></A> 
  instruction can cause processing to continue in the current 
mode.</P></LI></UL></DIV>
<DIV class=div3>
<H4><A id=minor-changes name=minor-changes></A>J.2.3 Minor Changes</H4>
<UL>
  <LI>
  <P>Instead of allowing the output method complete freedom to add namespace 
  nodes, a process of namespace fixup is applied to the result tree before it is 
  output; this same namespace fixup process is also applied to documents 
  constructed using variable-binding elements with content (see <A 
  href="REC-xslt20-20070123.htm#namespace-fixup"><I>5.7.3 
  Namespace Fixup</I></A>).</P>
  <LI>
  <P>Support for XML Base has been added.</P>
  <LI>
  <P>An <A 
  href="REC-xslt20-20070123.htm#element-apply-imports"><CODE>xsl:apply-imports</CODE></A> 
  element is allowed to have parameters (see <A 
  href="REC-xslt20-20070123.htm#apply-imports"><I>6.7 
  Overriding Template Rules</I></A> and <A 
  href="REC-xslt20-20070123.htm#with-param"><I>10.1.1 
  Passing Parameters to Templates</I></A>).</P>
  <LI>
  <P><A title="extension function" 
  href="REC-xslt20-20070123.htm#dt-extension-function">Extension 
  functions</A> are allowed to return external objects, which do not have any of 
  the builtin XPath types.</P>
  <LI>
  <P>The specification for patterns (<A 
  href="REC-xslt20-20070123.htm#patterns"><I>5.5 
  Patterns</I></A>) has been revised to align it with the new XPath grammar. The 
  formal semantics of patterns has been simplified: this became possible because 
  of the extra compositionality now available in the expression grammar. The 
  syntax and semantics of patterns remains essentially unchanged, except that 
  XPath 2.0 expressions can be used within predicates.</P>
  <LI>
  <P>A backwards-compatible processing mode is introduced. See <A 
  href="REC-xslt20-20070123.htm#backwards"><I>3.8 
  Backwards-Compatible Processing</I></A></P>
  <LI>
  <P>The <A 
  href="REC-xslt20-20070123.htm#function-system-property"><CODE>system-property</CODE></A> 
  function now always returns a string. Several new system properties have been 
  defined. See <A 
  href="REC-xslt20-20070123.htm#system-property"><I>16.6.5 
  system-property</I></A>.</P>
  <LI>
  <P>With <CODE>&lt;xsl:message terminate="yes"&gt;</CODE>, the processor now 
  <EM><SPAN class=verb>must</SPAN></EM> terminate processing. Previously the 
  word <EM><SPAN class=verb>should</SPAN></EM> was used. See <A 
  href="REC-xslt20-20070123.htm#message"><I>17 
  Messages</I></A>.</P>
  <LI>
  <P>A number of new serialization parameters have been introduced.</P>
  <LI>
  <P>A new instruction <A 
  href="REC-xslt20-20070123.htm#element-namespace"><CODE>xsl:namespace</CODE></A> 
  is available, for creating namespace nodes: see <A 
  href="REC-xslt20-20070123.htm#creating-namespace-nodes"><I>11.7 
  Creating Namespace Nodes</I></A>.</P>
  <LI>
  <P>A new instruction <A 
  href="REC-xslt20-20070123.htm#element-perform-sort"><CODE>xsl:perform-sort</CODE></A> 
  is available, for returning a sorted sequence.</P>
  <LI>
  <P>A new <CODE>[xsl:]xpath-default-namespace</CODE> attribute is available to 
  define the default namespace for unqualified names in an XPath expression or 
  XSLT pattern.</P>
  <LI>
  <P>The attributes <CODE>[xsl:]version</CODE>, 
  <CODE>[xsl:]exclude-result-prefixes</CODE>, and 
  <CODE>[xsl:]extension-element-prefixes</CODE>, as well as the new 
  <CODE>[xsl:]xpath-default-namespace</CODE> and 
  <CODE>[xsl:]default-collation</CODE>, can be used on any <A 
  title="XSLT element" 
  href="REC-xslt20-20070123.htm#dt-xslt-element">XSLT 
  element</A>, not only on <A 
  href="REC-xslt20-20070123.htm#element-stylesheet"><CODE>xsl:stylesheet</CODE></A> 
  and on literal result elements as before. In particular, they can now be used 
  on the <A 
  href="REC-xslt20-20070123.htm#element-template"><CODE>xsl:template</CODE></A> 
  element.</P>
  <LI>
  <P>A new <A 
  href="REC-xslt20-20070123.htm#function-unparsed-text"><CODE>unparsed-text</CODE></A> 
  function is introduced. It allows the contents of an external text file to be 
  read as a string.</P>
  <LI>
  <P>Restrictions on the use of variables within patterns and key definitions 
  have been removed; in their place a more general statement of the restrictions 
  preventing circularity has been formulated. The <A 
  href="REC-xslt20-20070123.htm#function-current"><CODE>current</CODE></A> 
  function may also now be used within patterns.</P>
  <LI>
  <P>The built-in templates for element and document nodes now pass any supplied 
  parameter values on to the templates that they call.</P>
  <LI>
  <P>A detailed specification of the <A 
  href="REC-xslt20-20070123.htm#function-format-number"><CODE>format-number</CODE></A> 
  function is now provided, removing the reliance on specifications in Java JDK 
  1.1.</P></LI></UL></DIV>
<DIV class=div3>
<H4><A id=changes-2007-01 name=changes-2007-01></A>J.2.4 Changes since Proposed 
Recommendation</H4>
<P>The following changes have been made since publication of the <A 
href="http://www.w3.org/TR/2006/PR-xslt20-20061121/">Proposed 
Recommendation</A>. Each change contains a reference to its discussion and 
rationale, for example the relevant issue number in the <A 
href="http://www.w3.org/Bugs/Public/">W3C public Bugzilla database</A>.</P>
<UL>
  <LI>
  <P>In <A 
  href="REC-xslt20-20070123.htm#analyze-string"><I>15.1 
  The xsl:analyze-string instruction</I></A>, the paragraph describing the 
  permitted contents of the instruction has been clarified. (The sentence "Both 
  elements are optional, and neither may appear more than once." was considered 
  awkward). This editorial change was made in response to a <A 
  href="http://lists.w3.org/Archives/Public/public-qt-comments/2006Jan/0083">public 
  comment</A> made during the Candidate Recommendation phase.</P>
  <LI>
  <P>In <A 
  href="REC-xslt20-20070123.htm#result-trees"><I>19 Final 
  Result Trees</I></A> it was stated that the result of a transformation 
  consisted of zero or more result trees; while <A 
  href="REC-xslt20-20070123.htm#executing-a-transformation"><I>2.4 
  Executing a Transformation</I></A> stated (correctly) that it consisted of one 
  or more. The former statement has been revised. A cross-reference between the 
  two sections has been added for clarification. (Bugzilla 4031)</P>
  <LI>
  <P>Some trivial syntax errors in examples have been fixed. (Bugzilla 
  4149)</P></LI></UL>
<P>The <A href="http://www.w3.org/TR/2006/PR-xslt20-20061121/">Proposed 
Recommendation</A> contains a complete list of published working drafts prepared 
during the development of this specification, and a detailed history of changes 
may be assembled by viewing the change log present in each draft. For most of 
the drafts, a version is available in which changes are visually 
highlighted.</P></DIV></DIV></DIV></DIV></BODY></HTML>
