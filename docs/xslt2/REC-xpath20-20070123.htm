<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0047)http://www.w3.org/TR/2007/REC-xpath20-20070123/ -->
<?xml version="1.0" encoding="utf-8"?><HTML lang=EN xml:lang="EN" 
xmlns="http://www.w3.org/1999/xhtml"><HEAD><TITLE>XML Path Language (XPath) 2.0</TITLE>
<META http-equiv=Content-Type content="text/html; charset=utf-8">
<META content="MSHTML 6.00.2900.3020" name=GENERATOR>
<STYLE type=text/css>CODE {
	FONT-FAMILY: monospace
}
DIV.constraint {
	MARGIN-LEFT: 2em
}
DIV.issue {
	MARGIN-LEFT: 2em
}
DIV.note {
	MARGIN-LEFT: 2em
}
DIV.notice {
	MARGIN-LEFT: 2em
}
DIV.issue P.title {
	MARGIN-LEFT: -2em
}
OL.enumar {
	LIST-STYLE-TYPE: decimal
}
OL.enumla {
	LIST-STYLE-TYPE: lower-alpha
}
OL.enumlr {
	LIST-STYLE-TYPE: lower-roman
}
OL.enumua {
	LIST-STYLE-TYPE: upper-alpha
}
OL.enumur {
	LIST-STYLE-TYPE: upper-roman
}
LI P {
	MARGIN-TOP: 0.3em; MARGIN-BOTTOM: 0.3em
}
SUP SMALL {
	COLOR: #8f8f8f; FONT-STYLE: italic
}
DIV.exampleInner PRE {
	MARGIN-TOP: 0em; MARGIN-BOTTOM: 0em; MARGIN-LEFT: 1em
}
DIV.exampleOuter {
	BORDER-RIGHT: gray 4px double; PADDING-RIGHT: 0em; BORDER-TOP: gray 4px double; PADDING-LEFT: 0em; PADDING-BOTTOM: 0em; MARGIN: 0em; BORDER-LEFT: gray 4px double; PADDING-TOP: 0em; BORDER-BOTTOM: gray 4px double
}
DIV.exampleInner {
	PADDING-RIGHT: 4px; BORDER-TOP: #d3d3d3 4px double; PADDING-LEFT: 4px; PADDING-BOTTOM: 4px; MARGIN: 0em; PADDING-TOP: 4px; BORDER-BOTTOM: #d3d3d3 4px double; BACKGROUND-COLOR: #d5dee3
}
DIV.exampleWrapper {
	MARGIN: 4px
}
DIV.exampleHeader {
	FONT-WEIGHT: bold; MARGIN: 4px
}
DIV.issue {
	MARGIN-BOTTOM: 20pt; BORDER-BOTTOM: black 1pt solid
}
TH.issue-toc-head {
	BORDER-BOTTOM: black 1pt solid
}
TABLE.small {
	FONT-SIZE: x-small
}
</STYLE>
<LINK href="REC-xpath20-20070123_files/W3C-REC.css" type=text/css 
rel=stylesheet></HEAD>
<BODY>
<DIV class=head>
<P><A href="http://www.w3.org/"><IMG height=48 alt=W3C 
src="REC-xpath20-20070123_files/w3c_home.png" width=72></A></P>
<H1><A id=title name=title></A>XML Path Language (XPath) 2.0</H1>
<H2><A id=w3c-doctype name=w3c-doctype></A>W3C Recommendation 23 January 
2007</H2>
<DL>
  <DT>This version: 
  <DD><SPAN class=xpath><A 
  href="http://www.w3.org/TR/2007/REC-xpath20-20070123/">http://www.w3.org/TR/2007/REC-xpath20-20070123/</A></SPAN> 

  <DT>Latest version: 
  <DD><SPAN class=xpath><A 
  href="http://www.w3.org/TR/xpath20/">http://www.w3.org/TR/xpath20/</A></SPAN> 
  <DT>Previous version: 
  <DD><SPAN class=xpath><A 
  href="http://www.w3.org/TR/2006/PR-xpath20-20061121/">http://www.w3.org/TR/2006/PR-xpath20-20061121/</A></SPAN> 

  <DT>Editors: 
  <DD class=xpath>Anders Berglund (XSL WG), IBM Research <A 
  href="mailto:alrb@us.ibm.com">mailto:alrb@us.ibm.com</A> 
  <DD>Scott Boag (XSL WG), IBM Research <A 
  href="mailto:scott_boag@us.ibm.com">mailto:scott_boag@us.ibm.com</A> 
  <DD>Don Chamberlin (XML Query WG), IBM Almaden Research Center, via <A 
  href="http://www.almaden.ibm.com/cs/people/chamberlin/">http://www.almaden.ibm.com/cs/people/chamberlin/</A> 

  <DD>Mary F. Fernández (XML Query WG), AT&amp;T Labs <A 
  href="mailto:mff@research.att.com">mailto:mff@research.att.com</A> 
  <DD class=xpath>Michael Kay (XSL WG), Saxonica, via <A 
  href="http://www.saxonica.com/">http://www.saxonica.com/</A> 
  <DD>Jonathan Robie (XML Query WG), <SPAN><A 
  href="http://www.xquery.com/">DataDirect Technologies</A></SPAN>, via <A 
  href="http://www.ibiblio.org/jwrobie/">http://www.ibiblio.org/jwrobie/</A> 
  <DD>Jérôme Siméon (XML Query WG), IBM T.J. Watson Research Center <A 
  href="mailto:simeon@us.ibm.com">mailto:simeon@us.ibm.com</A> </DD></DL>
<P>Please refer to the <A 
href="http://www.w3.org/XML/2007/qt-errata/xpath20-errata.html"><STRONG>errata</STRONG></A> 
for this document, which may include some normative corrections.</P>
<P>See also <A 
href="http://www.w3.org/2003/03/Translations/byTechnology?technology=xpath20"><STRONG>translations</STRONG></A>.</P>
<P>This document is also available in these non-normative formats: <SPAN 
class=xpath><A 
href="http://www.w3.org/TR/2007/REC-xpath20-20070123/xpath20.xml">XML</A></SPAN>.</P>
<P class=copyright><A 
href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</A>&nbsp;©&nbsp;2007&nbsp;<A 
href="http://www.w3.org/"> <ACRONYM 
title="World Wide Web Consortium">W3C</ACRONYM></A><SUP>®</SUP> (<A 
href="http://www.csail.mit.edu/"><ACRONYM 
title="Massachusetts Institute of Technology">MIT</ACRONYM></A>, <A 
href="http://www.ercim.org/"><ACRONYM 
title="European Research Consortium for Informatics and Mathematics">ERCIM</ACRONYM></A>, 
<A href="http://www.keio.ac.jp/">Keio</A>), All Rights Reserved. W3C <A 
href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</A>, 
<A 
href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</A> 
and <A href="http://www.w3.org/Consortium/Legal/copyright-documents">document 
use</A> rules apply.</P></DIV>
<HR>

<DIV>
<H2><A id=abstract name=abstract></A>Abstract</H2>
<DIV class=xpath>
<P class=xpath>XPath 2.0 is an expression language that allows the processing of 
values conforming to the data model defined in <A 
href="http://www.w3.org/TR/2007/REC-xpath20-20070123/#datamodel">[XQuery/XPath 
Data Model (XDM)]</A>. The data model provides a tree representation of XML 
documents as well as atomic values such as integers, strings, and booleans, and 
sequences that may contain both references to nodes in an XML document and 
atomic values. The result of an XPath expression may be a selection of nodes 
from the input documents, or an atomic value, or more generally, any sequence 
allowed by the data model. The name of the language derives from its most 
distinctive feature, the path expression, which provides a means of hierarchic 
addressing of the nodes in an XML tree. XPath 2.0 is a superset of <A 
href="http://www.w3.org/TR/2007/REC-xpath20-20070123/#XPath">[XPath 1.0]</A>, 
with the added capability to support a richer set of data types, and to take 
advantage of the type information that becomes available when documents are 
validated using XML Schema. A backwards compatibility mode is provided to ensure 
that nearly all XPath 1.0 expressions continue to deliver the same result with 
XPath 2.0; exceptions to this policy are noted in [<A 
href="http://www.w3.org/TR/2007/REC-xpath20-20070123/#id-backwards-compatibility"><B>I 
Backwards Compatibility with XPath 1.0</B></A>].</P></DIV></DIV>
<DIV>
<H2><A id=status name=status></A>Status of this Document</H2>
<P><EM>This section describes the status of this document at the time of its 
publication. Other documents may supersede this document. A list of current W3C 
publications and the latest revision of this technical report can be found in 
the <A href="http://www.w3.org/TR/">W3C technical reports index</A> at 
http://www.w3.org/TR/.</EM></P>
<P>This is one document in a set of eight documents that have progressed to 
Recommendation together (XQuery 1.0, XQueryX 1.0, XSLT 2.0, Data Model, 
Functions and Operators, Formal Semantics, Serialization, XPath 2.0).</P>
<P>This is a <A 
href="http://www.w3.org/2004/02/Process-20040205/tr.html#RecsW3C">Recommendation</A> 
of the W3C. It <SPAN class=xpath><SPAN class=xpath>has been jointly developed by 
the W3C <A href="http://www.w3.org/Style/XSL">XSL Working Group</A> and the W3C 
<A href="http://www.w3.org/XML/Query">XML Query Working Group</A>, each of which 
is part of the <A href="http://www.w3.org/XML/Activity">XML 
Activity</A>.</SPAN></SPAN></P>
<P>This document has been reviewed by W3C Members, by software developers, and 
by other W3C groups and interested parties, and is endorsed by the Director as a 
W3C Recommendation. It is a stable document and may be used as reference 
material or cited from another document. W3C's role in making the Recommendation 
is to draw attention to the specification and to promote its widespread 
deployment. This enhances the functionality and interoperability of the Web.</P>
<P><SPAN class=xpath><SPAN class=xpath>No substantive changes have been made to 
this specification since its publication as a Proposed 
Recommendation.</SPAN></SPAN></P>
<P>Please report errors in this document using W3C's <A 
href="http://www.w3.org/Bugs/Public/">public Bugzilla system</A> (instructions 
can be found at <A 
href="http://www.w3.org/XML/2005/04/qt-bugzilla">http://www.w3.org/XML/2005/04/qt-bugzilla</A>). 
If access to that system is not feasible, you may send your comments to the W3C 
XSLT/XPath/XQuery public comments mailing list, <A 
href="mailto:public-qt-comments@w3.org">public-qt-comments@w3.org</A>. It will 
be very helpful if you include the string “[<SPAN class=xpath><SPAN 
class=xpath>XPath</SPAN></SPAN>]” in the subject line of your report, whether 
made in Bugzilla or in email. Each Bugzilla entry and email message should 
contain only one error report. Archives of the comments and responses are 
available at <A 
href="http://lists.w3.org/Archives/Public/public-qt-comments/">http://lists.w3.org/Archives/Public/public-qt-comments/</A>.</P>
<P>This document was produced by <SPAN class=xpath><SPAN 
class=xpath>groups</SPAN></SPAN> operating under the <A 
href="http://www.w3.org/Consortium/Patent-Policy-20040205/">5 February 2004 W3C 
Patent Policy</A>. W3C maintains a <A 
href="http://www.w3.org/2004/01/pp-impl/18797/status#disclosures">public list of 
any patent disclosures</A> made in connection with the deliverables of the <SPAN 
class=xpath><SPAN class=xpath>XML Query Working Group</SPAN></SPAN> <SPAN 
class=xpath><SPAN class=xpath>and also maintains a <A 
href="http://www.w3.org/2004/01/pp-impl/19552/status#disclosures">public list of 
any patent disclosures</A> made in connection with the deliverables of the XSL 
Working Group; those pages also include</SPAN></SPAN> instructions for 
disclosing a patent. An individual who has actual knowledge of a patent which 
the individual believes contains <A 
href="http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">Essential 
Claim(s)</A> must disclose the information in accordance with <A 
href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">section 
6 of the W3C Patent Policy</A>.</P></DIV>
<DIV class=toc>
<H2><A id=contents name=contents></A>Table of Contents</H2>
<P class=toc>1 <A 
href="http://www.w3.org/TR/2007/REC-xpath20-20070123/#id-introduction">Introduction</A><BR>2 
<A 
href="REC-xpath20-20070123.htm#id-basics">Basics</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;2.1 
<A href="../REC-xpath20-20070123.htm#context">Expression 
Context</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.1.1 <A 
href="REC-xpath20-20070123.htm#static_context">Static 
Context</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.1.2 <A 
href="REC-xpath20-20070123.htm#eval_context">Dynamic 
Context</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;2.2 <A 
href="REC-xpath20-20070123.htm#id-processing-model">Processing 
Model</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.2.1 <A 
href="REC-xpath20-20070123.htm#id-data-model-generation">Data 
Model Generation</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.2.2 <A 
href="REC-xpath20-20070123.htm#id-schema-import-processing">Schema 
Import Processing</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.2.3 
<A 
href="REC-xpath20-20070123.htm#id-expression-processing">Expression 
Processing</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.2.3.1 
<A 
href="REC-xpath20-20070123.htm#id-static-analysis">Static 
Analysis 
Phase</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.2.3.2 
<A 
href="REC-xpath20-20070123.htm#id-dynamic-evaluation">Dynamic 
Evaluation Phase</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.2.4 <A 
href="REC-xpath20-20070123.htm#id-serialization">Serialization</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.2.5 
<A 
href="REC-xpath20-20070123.htm#id-consistency-constraints">Consistency 
Constraints</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;2.3 <A 
href="REC-xpath20-20070123.htm#errors">Error 
Handling</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.3.1 <A 
href="REC-xpath20-20070123.htm#id-kinds-of-errors">Kinds 
of Errors</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.3.2 <A 
href="REC-xpath20-20070123.htm#id-identifying-errors">Identifying 
and Reporting 
Errors</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.3.3 <A 
href="REC-xpath20-20070123.htm#id-handling-dynamic">Handling 
Dynamic Errors</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.3.4 <A 
href="REC-xpath20-20070123.htm#id-errors-and-opt">Errors 
and Optimization</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;2.4 <A 
href="REC-xpath20-20070123.htm#id-important-concepts">Concepts</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.4.1 
<A 
href="REC-xpath20-20070123.htm#id-document-order">Document 
Order</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.4.2 <A 
href="REC-xpath20-20070123.htm#id-atomization">Atomization</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.4.3 
<A href="REC-xpath20-20070123.htm#id-ebv">Effective 
Boolean Value</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.4.4 <A 
href="REC-xpath20-20070123.htm#id-input-sources">Input 
Sources</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;2.5 <A 
href="REC-xpath20-20070123.htm#id-types">Types</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.5.1 
<A 
href="REC-xpath20-20070123.htm#id-predefined-types">Predefined 
Schema Types</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.5.2 <A 
href="REC-xpath20-20070123.htm#id-typed-value">Typed 
Value and String 
Value</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.5.3 <A 
href="REC-xpath20-20070123.htm#id-sequencetype-syntax">SequenceType 
Syntax</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.5.4 <A 
href="REC-xpath20-20070123.htm#id-sequencetype-matching">SequenceType 
Matching</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.5.4.1 
<A 
href="REC-xpath20-20070123.htm#id-matching-value">Matching 
a SequenceType and a 
Value</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.5.4.2 
<A 
href="REC-xpath20-20070123.htm#id-matching-item">Matching 
an ItemType and an 
Item</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.5.4.3 
<A 
href="REC-xpath20-20070123.htm#id-element-test">Element 
Test</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.5.4.4 
<A 
href="REC-xpath20-20070123.htm#id-schema-element-test">Schema 
Element 
Test</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.5.4.5 
<A 
href="REC-xpath20-20070123.htm#id-attribute-test">Attribute 
Test</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.5.4.6 
<A 
href="REC-xpath20-20070123.htm#id-schema-attribute-test">Schema 
Attribute Test</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;2.6 <A 
href="REC-xpath20-20070123.htm#comments">Comments</A><BR>3 
<A 
href="REC-xpath20-20070123.htm#id-expressions">Expressions</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;3.1 
<A 
href="REC-xpath20-20070123.htm#id-primary-expressions">Primary 
Expressions</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.1.1 <A 
href="REC-xpath20-20070123.htm#id-literals">Literals</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.1.2 
<A href="REC-xpath20-20070123.htm#id-variables">Variable 
References</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.1.3 <A 
href="REC-xpath20-20070123.htm#id-paren-expressions">Parenthesized 
Expressions</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.1.4 <A 
href="REC-xpath20-20070123.htm#id-context-item-expression">Context 
Item Expression</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.1.5 <A 
href="REC-xpath20-20070123.htm#id-function-calls">Function 
Calls</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;3.2 <A 
href="REC-xpath20-20070123.htm#id-path-expressions">Path 
Expressions</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.2.1 <A 
href="REC-xpath20-20070123.htm#id-steps">Steps</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.2.1.1 
<A 
href="REC-xpath20-20070123.htm#axes">Axes</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.2.1.2 
<A href="REC-xpath20-20070123.htm#node-tests">Node 
Tests</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.2.2 <A 
href="REC-xpath20-20070123.htm#id-predicates">Predicates</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.2.3 
<A href="REC-xpath20-20070123.htm#unabbrev">Unabbreviated 
Syntax</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.2.4 <A 
href="REC-xpath20-20070123.htm#abbrev">Abbreviated 
Syntax</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;3.3 <A 
href="REC-xpath20-20070123.htm#id-sequence-expressions">Sequence 
Expressions</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.3.1 <A 
href="REC-xpath20-20070123.htm#construct_seq">Constructing 
Sequences</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.3.2 <A 
href="REC-xpath20-20070123.htm#id-filter-expr">Filter 
Expressions</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.3.3 <A 
href="REC-xpath20-20070123.htm#combining_seq">Combining 
Node Sequences</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;3.4 <A 
href="REC-xpath20-20070123.htm#id-arithmetic">Arithmetic 
Expressions</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;3.5 <A 
href="REC-xpath20-20070123.htm#id-comparisons">Comparison 
Expressions</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.5.1 <A 
href="REC-xpath20-20070123.htm#id-value-comparisons">Value 
Comparisons</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.5.2 <A 
href="REC-xpath20-20070123.htm#id-general-comparisons">General 
Comparisons</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.5.3 <A 
href="REC-xpath20-20070123.htm#id-node-comparisons">Node 
Comparisons</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;3.6 <A 
href="REC-xpath20-20070123.htm#id-logical-expressions">Logical 
Expressions</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;3.7 <A 
href="REC-xpath20-20070123.htm#id-for-expressions">For 
Expressions</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;3.8 <A 
href="REC-xpath20-20070123.htm#id-conditionals">Conditional 
Expressions</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;3.9 <A 
href="REC-xpath20-20070123.htm#id-quantified-expressions">Quantified 
Expressions</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;3.10 <A 
href="REC-xpath20-20070123.htm#id-expressions-on-datatypes">Expressions 
on SequenceTypes</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.10.1 
<A 
href="REC-xpath20-20070123.htm#id-instance-of">Instance 
Of</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.10.2 <A 
href="REC-xpath20-20070123.htm#id-cast">Cast</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.10.3 
<A 
href="REC-xpath20-20070123.htm#id-castable">Castable</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.10.4 
<A 
href="REC-xpath20-20070123.htm#id-constructor-functions">Constructor 
Functions</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.10.5 <A 
href="REC-xpath20-20070123.htm#id-treat">Treat</A><BR></P>
<H3><A id=appendices name=appendices></A>Appendices</H3>
<P class=toc>A <A 
href="REC-xpath20-20070123.htm#nt-bnf">XPath 
Grammar</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;A.1 <A 
href="REC-xpath20-20070123.htm#id-grammar">EBNF</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.1.1 
<A 
href="REC-xpath20-20070123.htm#EBNFNotation">Notation</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.1.2 
<A 
href="REC-xpath20-20070123.htm#extra-grammatical-constraints">Extra-grammatical 
Constraints</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.1.3 <A 
href="REC-xpath20-20070123.htm#notes-on-parsing">Grammar 
Notes</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;A.2 <A 
href="REC-xpath20-20070123.htm#lexical-structure">Lexical 
structure</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.2.1 <A 
href="REC-xpath20-20070123.htm#terminal-symbols">Terminal 
Symbols</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.2.2 <A 
href="REC-xpath20-20070123.htm#id-terminal-delimitation">Terminal 
Delimitation</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.2.3 <A 
href="REC-xpath20-20070123.htm#id-eol-handling">End-of-Line 
Handling</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.2.3.1 
<A 
href="REC-xpath20-20070123.htm#id-xml10-eol-handling">XML 
1.0 End-of-Line 
Handling</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.2.3.2 
<A 
href="REC-xpath20-20070123.htm#id-xml11-eol-handling">XML 
1.1 End-of-Line 
Handling</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.2.4 <A 
href="REC-xpath20-20070123.htm#whitespace-rules">Whitespace 
Rules</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.2.4.1 
<A 
href="REC-xpath20-20070123.htm#DefaultWhitespaceHandling">Default 
Whitespace 
Handling</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.2.4.2 
<A 
href="REC-xpath20-20070123.htm#ExplicitWhitespaceHandling">Explicit 
Whitespace Handling</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;A.3 <A 
href="REC-xpath20-20070123.htm#id-reserved-fn-names">Reserved 
Function Names</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;A.4 <A 
href="REC-xpath20-20070123.htm#id-precedence-order">Precedence 
Order</A><BR>B <A 
href="REC-xpath20-20070123.htm#id-type-promotion-and-operator-mapping">Type 
Promotion and Operator Mapping</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;B.1 <A 
href="REC-xpath20-20070123.htm#promotion">Type 
Promotion</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;B.2 <A 
href="REC-xpath20-20070123.htm#mapping">Operator 
Mapping</A><BR>C <A 
href="REC-xpath20-20070123.htm#id-xp-context-components">Context 
Components</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;C.1 <A 
href="REC-xpath20-20070123.htm#id-xp-static-context-components">Static 
Context Components</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;C.2 <A 
href="REC-xpath20-20070123.htm#id-xp-evaluation-context-components">Dynamic 
Context Components</A><BR>D <A 
href="REC-xpath20-20070123.htm#id-impl-defined-items">Implementation-Defined 
Items</A><BR>E <A 
href="REC-xpath20-20070123.htm#id-references">References</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;E.1 
<A 
href="REC-xpath20-20070123.htm#id-normative-references">Normative 
References</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;E.2 <A 
href="REC-xpath20-20070123.htm#id-non-normative-references">Non-normative 
References</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;E.3 <A 
href="REC-xpath20-20070123.htm#id-background-material">Background 
Material</A><BR>F <A 
href="REC-xpath20-20070123.htm#id-xpath-conformance">Conformance</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;F.1 
<A 
href="REC-xpath20-20070123.htm#id-xpath-static-typing">Static 
Typing Feature</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;F.1.1 <A 
href="REC-xpath20-20070123.htm#id-xpath-static-extensions">Static 
Typing Extensions</A><BR>G <A 
href="REC-xpath20-20070123.htm#id-errors">Error 
Conditions</A><BR>H <A 
href="REC-xpath20-20070123.htm#id-glossary">Glossary</A> 
(Non-Normative)<BR>I <A 
href="REC-xpath20-20070123.htm#id-backwards-compatibility">Backwards 
Compatibility with XPath 1.0</A> (Non-Normative)<BR>&nbsp;&nbsp;&nbsp;&nbsp;I.1 
<A 
href="REC-xpath20-20070123.htm#id-incompat-in-true-mode">Incompatibilities 
when Compatibility Mode is true</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;I.2 <A 
href="REC-xpath20-20070123.htm#id-incompat-in-false-mode">Incompatibilities 
when Compatibility Mode is false</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;I.3 <A 
href="REC-xpath20-20070123.htm#id-incompat-when-using-schema">Incompatibilities 
when using a Schema</A><BR>J <A 
href="REC-xpath20-20070123.htm#id-revisions-log">Revision 
Log</A> (Non-Normative)<BR></P></DIV>
<HR>

<DIV class=body>
<DIV class=div1>
<H2><A id=id-introduction name=id-introduction></A>1 Introduction</H2>
<DIV class=xpath>
<P class=xpath>The primary purpose of XPath is to address the nodes of <A 
href="REC-xpath20-20070123.htm#XML">[XML 1.0]</A> or <A 
href="REC-xpath20-20070123.htm#XML1.1">[XML 1.1]</A> 
trees. XPath gets its name from its use of a path notation for navigating 
through the hierarchical structure of an XML document. XPath uses a compact, 
non-XML syntax to facilitate use of XPath within URIs and XML attribute 
values.</P></DIV>
<P>[<A id=dt-datamodel title="data model" name=dt-datamodel>Definition</A>: 
XPath operates on the abstract, logical structure of an XML document, rather 
than its surface syntax. This logical structure, known as the <B>data model</B>, 
is defined in <A 
href="REC-xpath20-20070123.htm#datamodel">[XQuery/XPath 
Data Model (XDM)]</A>.]</P>
<DIV class=xpath>
<P class=xpath>XPath is designed to be embedded in a <B>host language</B> such 
as <A href="REC-xpath20-20070123.htm#XSLT">[XSLT 2.0]</A> 
or <A 
href="REC-xpath20-20070123.htm#xquery">[XQuery]</A>. 
XPath has a natural subset that can be used for matching (testing whether or not 
a node matches a pattern); this use of XPath is described in <A 
href="REC-xpath20-20070123.htm#XSLT">[XSLT 
2.0]</A>.</P></DIV>
<P>XQuery Version 1.0 is an extension of XPath Version 2.0. Any expression that 
is syntactically valid and executes successfully in both XPath 2.0 and XQuery 
1.0 will return the same result in both languages. Since these languages are so 
closely related, their grammars and language descriptions are generated from a 
common source to ensure consistency, and the editors of these specifications 
work together closely.</P>
<P>XPath also depends on and is closely related to the following 
specifications:</P>
<UL>
  <LI>
  <P><A 
  href="REC-xpath20-20070123.htm#datamodel">[XQuery/XPath 
  Data Model (XDM)]</A> defines the data model that underlies all XPath 
  expressions.</P>
  <LI>
  <P><A 
  href="REC-xpath20-20070123.htm#XQueryFormalSemantics">[XQuery 
  1.0 and XPath 2.0 Formal Semantics]</A> defines the static semantics of XPath 
  and also contains a formal but non-normative description of the dynamic 
  semantics that may be useful for implementors and others who require a formal 
  definition.</P>
  <LI>
  <P>The type system of XPath is based on <A 
  href="REC-xpath20-20070123.htm#XMLSchema">[XML 
  Schema]</A>.</P>
  <LI>
  <P>The built-in function library and the operators supported by XPath are 
  defined in <A 
  href="REC-xpath20-20070123.htm#FunctionsAndOperators">[XQuery 
  1.0 and XPath 2.0 Functions and Operators]</A>.</P></LI></UL>
<P>This document specifies a grammar for XPath, using the same basic EBNF 
notation used in <A 
href="REC-xpath20-20070123.htm#XML">[XML 1.0]</A>. Unless 
otherwise noted (see <A 
href="REC-xpath20-20070123.htm#lexical-structure"><B>A.2 
Lexical structure</B></A>), whitespace is not significant in <SPAN 
class=xpath><SPAN class=xpath>expressions</SPAN></SPAN>. Grammar productions are 
introduced together with the features that they describe, and a complete grammar 
is also presented in the appendix [<A 
href="REC-xpath20-20070123.htm#nt-bnf"><B>A XPath 
Grammar</B></A>]. The appendix is the normative version.</P>
<P>In the grammar productions in this document, named symbols are underlined and 
literal text is enclosed in double quotes. For example, the following production 
describes the syntax of a function call:</P>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=fakeid_doc-xpath-FunctionCall 
      name=fakeid_doc-xpath-FunctionCall></A>[48]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>FunctionCall</CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-QName">QName</A> 
      "(" (<A 
      href="REC-xpath20-20070123.htm#doc-xpath-ExprSingle">ExprSingle</A> 
      ("," <A 
      href="REC-xpath20-20070123.htm#doc-xpath-ExprSingle">ExprSingle</A>)*)? 
      ")"</CODE></TD></TR></TBODY></TABLE>
<P>The production should be read as follows: A function call consists of a QName 
followed by an open-parenthesis. The open-parenthesis is followed by an optional 
argument list. The argument list (if present) consists of one or more 
expressions, separated by commas. The optional argument list is followed by a 
close-parenthesis.</P>
<P>Certain aspects of language processing are described in this specification as 
<B>implementation-defined</B> or <B>implementation-dependent</B>.</P>
<UL>
  <LI>
  <P>[<A id=dt-implementation-defined title="implementation defined" 
  name=dt-implementation-defined>Definition</A>: <B>Implementation-defined</B> 
  indicates an aspect that may differ between implementations, but must be 
  specified by the implementor for each particular implementation.]</P>
  <LI>
  <P>[<A id=dt-implementation-dependent title="implementation dependent" 
  name=dt-implementation-dependent>Definition</A>: 
  <B>Implementation-dependent</B> indicates an aspect that may differ between 
  implementations, is not specified by this or any W3C specification, and is not 
  required to be specified by the implementor for any particular 
  implementation.]</P></LI></UL>
<DIV class=xpath>
<P class=xpath>A language aspect described in this specification as 
<B>implementation-defined</B> or <B>implementation dependent</B> may be further 
constrained by the specifications of a host language in which XPath is 
embedded.</P></DIV>
<P>This document normatively defines the dynamic semantics of XPath. The static 
semantics of XPath are normatively defined in <A 
href="REC-xpath20-20070123.htm#XQueryFormalSemantics">[XQuery 
1.0 and XPath 2.0 Formal Semantics]</A>. In this document, examples and material 
labeled as "Note" are provided for explanatory purposes and are not 
normative.</P></DIV>
<DIV class=div1>
<H2><A id=id-basics name=id-basics></A>2 Basics</H2>
<P>The basic building block of XPath is the <B>expression</B>, which is a string 
of <A 
href="REC-xpath20-20070123.htm#Unicode">[Unicode]</A> 
characters (the version of Unicode to be used is <A 
title="implementation defined" 
href="REC-xpath20-20070123.htm#dt-implementation-defined">implementation-defined</A>.) 
The language provides several kinds of expressions which may be constructed from 
keywords, symbols, and operands. In general, the operands of an expression are 
other expressions. XPath allows expressions to be nested with full 
generality.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>This specification contains no assumptions or requirements regarding the 
character set encoding of strings of <A 
href="REC-xpath20-20070123.htm#Unicode">[Unicode]</A> 
characters.</P></DIV>
<P>Like XML, XPath is a case-sensitive language. Keywords in XPath use 
lower-case characters and are not reserved—that is, names in XPath expressions 
are allowed to be the same as language keywords, except for certain unprefixed 
function-names listed in <A 
href="REC-xpath20-20070123.htm#id-reserved-fn-names"><B>A.3 
Reserved Function Names</B></A>.</P>
<P>[<A id=dt-value title=value name=dt-value>Definition</A>: In the <A 
title="data model" 
href="REC-xpath20-20070123.htm#dt-datamodel">data 
model</A>, a <B>value</B> is always a <A title=sequence 
href="REC-xpath20-20070123.htm#dt-sequence">sequence</A>.] 
[<A id=dt-sequence title=sequence name=dt-sequence>Definition</A>: A 
<B>sequence</B> is an ordered collection of zero or more <A title=item 
href="REC-xpath20-20070123.htm#dt-item">items</A>.] [<A 
id=dt-item title=item name=dt-item>Definition</A>: An <B>item</B> is either an 
<A title="atomic value" 
href="REC-xpath20-20070123.htm#dt-atomic-value">atomic 
value</A> or a <A title=node 
href="REC-xpath20-20070123.htm#dt-node">node</A>.] [<A 
id=dt-atomic-value title="atomic value" name=dt-atomic-value>Definition</A>: An 
<B>atomic value</B> is a value in the value space of an <B>atomic type</B>, as 
defined in <A 
href="REC-xpath20-20070123.htm#XMLSchema">[XML 
Schema]</A>.] [<A id=dt-node title=node name=dt-node>Definition</A>: A 
<B>node</B> is an instance of one of the <B>node kinds</B> defined in <A 
href="REC-xpath20-20070123.htm#datamodel">[XQuery/XPath 
Data Model (XDM)]</A>.] Each node has a unique <B>node identity</B>, a <B>typed 
value</B>, and a <B>string value</B>. In addition, some nodes have a 
<B>name</B>. The <B>typed value</B> of a node is a sequence of zero or more 
atomic values. The <B>string value</B> of a node is a value of type 
<CODE>xs:string</CODE>. The <B>name</B> of a node is a value of type 
<CODE>xs:QName</CODE>.</P>
<P>[<A id=dt-singleton title=singleton name=dt-singleton>Definition</A>: A 
sequence containing exactly one item is called a <B>singleton</B>.] An item is 
identical to a singleton sequence containing that item. Sequences are never 
nested—for example, combining the values 1, (2, 3), and ( ) into a single 
sequence results in the sequence (1, 2, 3). [<A id=dt-empty-sequence 
title="empty sequence" name=dt-empty-sequence>Definition</A>: A sequence 
containing zero items is called an <B>empty sequence</B>.]</P>
<P>[<A id=dt-data-model-instance title="XDM instance" 
name=dt-data-model-instance>Definition</A>: The term <B>XDM instance</B> is 
used, synonymously with the term <B>value</B>, to denote an unconstrained 
sequence of <A title=node 
href="REC-xpath20-20070123.htm#dt-node">nodes</A> and/or 
<A title="atomic value" 
href="REC-xpath20-20070123.htm#dt-atomic-value">atomic 
values</A> in the <A title="data model" 
href="REC-xpath20-20070123.htm#dt-datamodel">data 
model</A>.]</P>
<P>Names in XPath are called <B>QNames</B>, and conform to the syntax in <A 
href="REC-xpath20-20070123.htm#XMLNAMES">[XML Names]</A>. 
[<A id=dt-qname title=QName name=dt-qname>Definition</A>: Lexically, a 
<B>QName</B> consists of an optional namespace prefix and a local name. If the 
namespace prefix is present, it is separated from the local name by a colon.] A 
lexical QName can be converted into an <B>expanded QName</B> by resolving its 
namespace prefix to a namespace URI, using the <A 
title="statically known namespaces" 
href="REC-xpath20-20070123.htm#dt-static-namespaces">statically 
known namespaces</A> [<A title=err:XPST0081 
href="REC-xpath20-20070123.htm#ERRXPST0081">err:XPST0081</A>]. 
[<A id=dt-expanded-qname title="expanded QName" 
name=dt-expanded-qname>Definition</A>: An <B>expanded QName</B> consists of an 
optional namespace URI and a local name. An expanded QName also retains its 
original namespace prefix (if any), to facilitate casting the expanded QName 
into a string.] The namespace URI value is whitespace normalized according to 
the rules for the <CODE>xs:anyURI</CODE> type in <A 
href="REC-xpath20-20070123.htm#XMLSchema">[XML 
Schema]</A>. Two expanded QNames are equal if their namespace URIs are equal and 
their local names are equal (even if their namespace prefixes are not equal). 
Namespace URIs and local names are compared on a codepoint basis, without 
further normalization.</P>
<P><SPAN class=xpath><SPAN class=xpath>This document uses the following 
namespace prefixes to represent the namespace URIs with which they are listed. 
Use of these namespace prefix bindings in this document is not 
normative.</SPAN></SPAN></P>
<UL>
  <LI>
  <P><CODE>xs = http://www.w3.org/2001/XMLSchema</CODE></P>
  <LI>
  <P><CODE>fn = http://www.w3.org/2005/xpath-functions</CODE></P>
  <LI class=xpath>
  <P><CODE>err = http://www.w3.org/2005/xqt-errors</CODE> (see <A 
  href="REC-xpath20-20070123.htm#id-identifying-errors"><B>2.3.2 
  Identifying and Reporting Errors</B></A>).</P></LI></UL>
<P>Element nodes have a property called <B>in-scope namespaces</B>. [<A 
id=dt-in-scope-namespaces title="in-scope namespaces" 
name=dt-in-scope-namespaces>Definition</A>: The <B>in-scope namespaces</B> 
property of an element node is a set of <B>namespace bindings</B>, each of which 
associates a namespace prefix with a URI, thus defining the set of namespace 
prefixes that are available for interpreting QNames within the scope of the 
element. For a given element, one namespace binding may have an empty prefix; 
the URI of this namespace binding is the default namespace within the scope of 
the element.]</P>
<DIV class=xpath>
<P class=xpath>In <A 
href="REC-xpath20-20070123.htm#XPath">[XPath 1.0]</A>, 
the in-scope namespaces of an element node are represented by a collection of 
<B>namespace nodes</B> arranged on a <B>namespace axis</B>. In XPath Version 
2.0, the namespace axis is deprecated and need not be supported by a host 
language. A host language that does not support the namespace axis need not 
represent namespace bindings in the form of nodes.</P></DIV>
<P>[<A id=dt-URI title=URI name=dt-URI>Definition</A>: Within this 
specification, the term <B>URI</B> refers to a Universal Resource Identifier as 
defined in <A 
href="REC-xpath20-20070123.htm#RFC3986">[RFC3986]</A> and 
extended in <A 
href="REC-xpath20-20070123.htm#RFC3987">[RFC3987]</A> 
with the new name <B>IRI</B>.] The term URI has been retained in preference to 
IRI to avoid introducing new names for concepts such as "Base URI" that are 
defined or referenced across the whole family of XML specifications.</P>
<DIV class=div2>
<H3><A id=context name=context></A>2.1 Expression Context</H3>
<P>[<A id=dt-expression-context title="expression context" 
name=dt-expression-context>Definition</A>: The <B>expression context</B> for a 
given expression consists of all the information that can affect the result of 
the expression.] This information is organized into two categories called the <A 
title="static context" 
href="REC-xpath20-20070123.htm#dt-static-context">static 
context</A> and the <A title="dynamic context" 
href="REC-xpath20-20070123.htm#dt-dynamic-context">dynamic 
context</A>.</P>
<DIV class=div3>
<H4><A id=static_context name=static_context></A>2.1.1 Static Context</H4>
<P>[<A id=dt-static-context title="static context" 
name=dt-static-context>Definition</A>: The <B>static context</B> of an 
expression is the information that is available during static analysis of the 
expression, prior to its evaluation.] This information can be used to decide 
whether the expression contains a <A title="static error" 
href="REC-xpath20-20070123.htm#dt-static-error">static 
error</A>. If analysis of an expression relies on some component of the <A 
title="static context" 
href="REC-xpath20-20070123.htm#dt-static-context">static 
context</A> that has not been assigned a value, a <A title="static error" 
href="REC-xpath20-20070123.htm#dt-static-error">static 
error</A> is raised [<A title=err:XPST0001 
href="REC-xpath20-20070123.htm#ERRXPST0001">err:XPST0001</A>].</P>
<P>The individual components of the <A title="static context" 
href="REC-xpath20-20070123.htm#dt-static-context">static 
context</A> are summarized below. <SPAN class=xpath><SPAN class=xpath>A default 
initial value for each component may be specified by the host language. The 
scope of each component is specified in <A 
href="REC-xpath20-20070123.htm#id-xp-static-context-components"><B>C.1 
Static Context Components</B></A>.</SPAN></SPAN></P>
<UL>
  <LI>
  <P>[<A id=dt-xpath-compat-mode title="XPath 1.0 compatibility mode" 
  name=dt-xpath-compat-mode>Definition</A>: <B>XPath 1.0 compatibility mode.</B> 
  <SPAN class=xpath><SPAN class=xpath>This value is <CODE>true</CODE> if rules 
  for backward compatibility with XPath Version 1.0 are in effect; otherwise it 
  is <CODE>false</CODE>.</SPAN></SPAN>]</P>
  <LI>
  <P>[<A id=dt-static-namespaces title="statically known namespaces" 
  name=dt-static-namespaces>Definition</A>: <B>Statically known namespaces.</B> 
  This is a set of (prefix, URI) pairs that define all the namespaces that are 
  known during static processing of a given expression.] The URI value is 
  whitespace normalized according to the rules for the <CODE>xs:anyURI</CODE> 
  type in <A 
  href="REC-xpath20-20070123.htm#XMLSchema">[XML 
  Schema]</A>. Note the difference between <A title="in-scope namespaces" 
  href="REC-xpath20-20070123.htm#dt-in-scope-namespaces">in-scope 
  namespaces</A>, which is a dynamic property of an element node, and <A 
  title="statically known namespaces" 
  href="REC-xpath20-20070123.htm#dt-static-namespaces">statically 
  known namespaces</A>, which is a static property of an expression.</P>
  <LI>
  <P>[<A id=dt-def-elemtype-ns title="default element/type namespace" 
  name=dt-def-elemtype-ns>Definition</A>: <B>Default element/type namespace.</B> 
  This is a namespace URI or "none". The namespace URI, if present, is used for 
  any unprefixed QName appearing in a position where an element or type name is 
  expected.] The URI value is whitespace normalized according to the rules for 
  the <CODE>xs:anyURI</CODE> type in <A 
  href="REC-xpath20-20070123.htm#XMLSchema">[XML 
  Schema]</A>.</P>
  <LI>
  <P>[<A id=dt-def-fn-ns title="default function namespace" 
  name=dt-def-fn-ns>Definition</A>: <B>Default function namespace.</B> This is a 
  namespace URI or "none". The namespace URI, if present, is used for any 
  unprefixed QName appearing in a position where a function name is expected.] 
  The URI value is whitespace normalized according to the rules for the 
  <CODE>xs:anyURI</CODE> type in <A 
  href="REC-xpath20-20070123.htm#XMLSchema">[XML 
  Schema]</A>.</P>
  <LI>
  <P>[<A id=dt-issd title="in-scope schema definitions" 
  name=dt-issd>Definition</A>: <B>In-scope schema definitions.</B> This is a 
  generic term for all the element declarations, attribute declarations, and 
  schema type definitions that are in scope during processing of an expression.] 
  It includes the following three parts:</P>
  <UL>
    <LI>
    <P>[<A id=dt-is-types title="in-scope schema type" 
    name=dt-is-types>Definition</A>: <B>In-scope schema types.</B> Each schema 
    type definition is identified either by an <A title="expanded QName" 
    href="REC-xpath20-20070123.htm#dt-expanded-qname">expanded 
    QName</A> (for a <B>named type</B>) or by an <A 
    title="implementation dependent" 
    href="REC-xpath20-20070123.htm#dt-implementation-dependent">implementation-dependent</A> 
    type identifier (for an <B>anonymous type</B>). The in-scope schema types 
    include the predefined schema types described in <A 
    href="REC-xpath20-20070123.htm#id-predefined-types"><B>2.5.1 
    Predefined Schema Types</B></A>. ]</P>
    <LI>
    <P>[<A id=dt-is-elems title="in-scope element declarations" 
    name=dt-is-elems>Definition</A>: <B>In-scope element declarations.</B> Each 
    element declaration is identified either by an <A title="expanded QName" 
    href="REC-xpath20-20070123.htm#dt-expanded-qname">expanded 
    QName</A> (for a top-level element declaration) or by an <A 
    title="implementation dependent" 
    href="REC-xpath20-20070123.htm#dt-implementation-dependent">implementation-dependent</A> 
    element identifier (for a local element declaration). ] An element 
    declaration includes information about the element's <A 
    title="substitution group" 
    href="REC-xpath20-20070123.htm#dt-substitution-group">substitution 
    group</A> affiliation.</P>
    <P>[<A id=dt-substitution-group title="substitution group" 
    name=dt-substitution-group>Definition</A>: <B>Substitution groups</B> are 
    defined in <A 
    href="REC-xpath20-20070123.htm#XMLSchema">[XML 
    Schema]</A> Part 1, Section 2.2.2.2. Informally, the substitution group 
    headed by a given element (called the <B>head element</B>) consists of the 
    set of elements that can be substituted for the head element without 
    affecting the outcome of schema validation.]</P>
    <LI>
    <P>[<A id=dt-is-attrs title="in-scope attribute declarations" 
    name=dt-is-attrs>Definition</A>: <B>In-scope attribute declarations.</B> 
    Each attribute declaration is identified either by an <A 
    title="expanded QName" 
    href="REC-xpath20-20070123.htm#dt-expanded-qname">expanded 
    QName</A> (for a top-level attribute declaration) or by an <A 
    title="implementation dependent" 
    href="REC-xpath20-20070123.htm#dt-implementation-dependent">implementation-dependent</A> 
    attribute identifier (for a local attribute declaration). ]</P></LI></UL>
  <LI>
  <P>[<A id=dt-in-scope-variables title="in-scope variables" 
  name=dt-in-scope-variables>Definition</A>: <B>In-scope variables.</B> This is 
  a set of (expanded QName, type) pairs. It defines the set of variables that 
  are available for reference within an expression. The <A 
  title="expanded QName" 
  href="REC-xpath20-20070123.htm#dt-expanded-qname">expanded 
  QName</A> is the name of the variable, and the type is the <A 
  title="static type" 
  href="REC-xpath20-20070123.htm#dt-static-type">static 
  type</A> of the variable.]</P>
  <P>An expression that binds a variable (such as a <CODE>for</CODE>, 
  <CODE>some</CODE>, or <CODE>every</CODE> expression) extends the <A 
  title="in-scope variables" 
  href="REC-xpath20-20070123.htm#dt-in-scope-variables">in-scope 
  variables</A> of its subexpressions with the new bound variable and its 
  type.</P>
  <LI>
  <P>[<A id=dt-context-item-static-type title="context item static type" 
  name=dt-context-item-static-type>Definition</A>: <B>Context item static 
  type.</B> This component defines the <A title="static type" 
  href="REC-xpath20-20070123.htm#dt-static-type">static 
  type</A> of the context item within the scope of a given expression.]</P>
  <LI>
  <P>[<A id=dt-function-signature title="function signature" 
  name=dt-function-signature>Definition</A>: <B>Function signatures.</B> This 
  component defines the set of functions that are available to be called from 
  within an expression. Each function is uniquely identified by its <A 
  title="expanded QName" 
  href="REC-xpath20-20070123.htm#dt-expanded-qname">expanded 
  QName</A> and its arity (number of parameters).] In addition to the name and 
  arity, each function signature specifies the <A title="static type" 
  href="REC-xpath20-20070123.htm#dt-static-type">static 
  types</A> of the function parameters and result.</P>
  <P>The <A title="function signature" 
  href="REC-xpath20-20070123.htm#dt-function-signature">function 
  signatures</A> include the signatures of <A title="constructor function" 
  href="REC-xpath20-20070123.htm#dt-constructor-function">constructor 
  functions</A>, which are discussed in <A 
  href="REC-xpath20-20070123.htm#id-constructor-functions"><B>3.10.4 
  Constructor Functions</B></A>.</P>
  <LI>
  <P>[<A id=dt-static-collations title="statically known collations" 
  name=dt-static-collations>Definition</A>: <B>Statically known collations.</B> 
  This is an <A title="implementation defined" 
  href="REC-xpath20-20070123.htm#dt-implementation-defined">implementation-defined</A> 
  set of (URI, collation) pairs. It defines the names of the collations that are 
  available for use in processing expressions.] [<A id=dt-collation 
  title=collation name=dt-collation>Definition</A>: A <B>collation</B> is a 
  specification of the manner in which strings and URIs are compared and, by 
  extension, ordered. For a more complete definition of collation, see <A 
  href="REC-xpath20-20070123.htm#FunctionsAndOperators">[XQuery 
  1.0 and XPath 2.0 Functions and Operators]</A>.]</P>
  <LI>
  <P>[<A id=dt-def-collation title="default collation" 
  name=dt-def-collation>Definition</A>: <B>Default collation.</B> This 
  identifies one of the collations in <A title="statically known collations" 
  href="REC-xpath20-20070123.htm#dt-static-collations">statically 
  known collations</A> as the collation to be used by functions and operators 
  for comparing and ordering values of type <CODE>xs:string</CODE> and 
  <CODE>xs:anyURI</CODE> (and types derived from them) when no explicit 
  collation is specified.]</P>
  <LI>
  <P>[<A id=dt-base-uri title="base URI" name=dt-base-uri>Definition</A>: 
  <B>Base URI.</B> This is an absolute URI, used when necessary in the 
  resolution of relative URIs (for example, by the <CODE>fn:resolve-uri</CODE> 
  function.)] The URI value is whitespace normalized according to the rules for 
  the <CODE>xs:anyURI</CODE> type in <A 
  href="REC-xpath20-20070123.htm#XMLSchema">[XML 
  Schema]</A>.</P>
  <LI>
  <P>[<A id=dt-known-docs title="statically known documents" 
  name=dt-known-docs>Definition</A>: <B>Statically known documents.</B> This is 
  a mapping from strings onto types. The string represents the absolute URI of a 
  resource that is potentially available using the <CODE>fn:doc</CODE> function. 
  The type is the <A title="static type" 
  href="REC-xpath20-20070123.htm#dt-static-type">static 
  type</A> of a call to <CODE>fn:doc</CODE> with the given URI as its literal 
  argument. ] If the argument to <CODE>fn:doc</CODE> is a string literal that is 
  not present in <B>statically known documents</B>, then the <A 
  title="static type" 
  href="REC-xpath20-20070123.htm#dt-static-type">static 
  type</A> of <CODE>fn:doc</CODE> is <CODE>document-node()?</CODE>.</P>
  <DIV class=note>
  <P class=prefix><B>Note:</B></P>
  <P>The purpose of the <B>statically known documents</B> is to provide static 
  type information, not to determine which documents are available. A URI need 
  not be found in the <B>statically known documents</B> to be accessed using 
  <CODE>fn:doc</CODE>.</P></DIV>
  <LI>
  <P>[<A id=dt-known-collections title="statically known collections" 
  name=dt-known-collections>Definition</A>: <B>Statically known collections.</B> 
  This is a mapping from strings onto types. The string represents the absolute 
  URI of a resource that is potentially available using the 
  <CODE>fn:collection</CODE> function. The type is the type of the sequence of 
  nodes that would result from calling the <CODE>fn:collection</CODE> function 
  with this URI as its argument.] If the argument to <CODE>fn:collection</CODE> 
  is a string literal that is not present in <B>statically known 
  collections</B>, then the <A title="static type" 
  href="REC-xpath20-20070123.htm#dt-static-type">static 
  type</A> of <CODE>fn:collection</CODE> is <CODE>node()*</CODE>.</P>
  <DIV class=note>
  <P class=prefix><B>Note:</B></P>
  <P>The purpose of the <B>statically known collections</B> is to provide static 
  type information, not to determine which collections are available. A URI need 
  not be found in the <B>statically known collections</B> to be accessed using 
  <CODE>fn:collection</CODE>.</P></DIV>
  <LI>
  <P>[<A id=dt-known-default-collection 
  title="statically known default collection type" 
  name=dt-known-default-collection>Definition</A>: <B>Statically known default 
  collection type.</B> This is the type of the sequence of nodes that would 
  result from calling the <CODE>fn:collection</CODE> function with no 
  arguments.] Unless initialized to some other value by an implementation, the 
  value of <B>statically known default collection type</B> is 
  <CODE>node()*</CODE>.</P></LI></UL></DIV>
<DIV class=div3>
<H4><A id=eval_context name=eval_context></A>2.1.2 Dynamic Context</H4>
<P>[<A id=dt-dynamic-context title="dynamic context" 
name=dt-dynamic-context>Definition</A>: The <B>dynamic context</B> of an 
expression is defined as information that is available at the time the 
expression is evaluated.] If evaluation of an expression relies on some part of 
the <A title="dynamic context" 
href="REC-xpath20-20070123.htm#dt-dynamic-context">dynamic 
context</A> that has not been assigned a value, a <A title="dynamic error" 
href="REC-xpath20-20070123.htm#dt-dynamic-error">dynamic 
error</A> is raised [<A title=err:XPDY0002 
href="REC-xpath20-20070123.htm#ERRXPDY0002">err:XPDY0002</A>].</P>
<P>The individual components of the <A title="dynamic context" 
href="REC-xpath20-20070123.htm#dt-dynamic-context">dynamic 
context</A> are summarized below. Further rules governing the semantics of these 
components can be found in <A 
href="REC-xpath20-20070123.htm#id-xp-evaluation-context-components"><B>C.2 
Dynamic Context Components</B></A>.</P>
<P>The <A title="dynamic context" 
href="REC-xpath20-20070123.htm#dt-dynamic-context">dynamic 
context</A> consists of all the components of the <A title="static context" 
href="REC-xpath20-20070123.htm#dt-static-context">static 
context</A>, and the additional components listed below.</P>
<P>[<A id=dt-focus title=focus name=dt-focus>Definition</A>: The first three 
components of the <A title="dynamic context" 
href="REC-xpath20-20070123.htm#dt-dynamic-context">dynamic 
context</A> (context item, context position, and context size) are called the 
<B>focus</B> of the expression. ] The focus enables the processor to keep track 
of which items are being processed by the expression.</P>
<P>Certain language constructs, notably the <A title="path expression" 
href="REC-xpath20-20070123.htm#dt-path-expression">path 
expression</A> <CODE>E1/E2</CODE> and the <A title=predicate 
href="REC-xpath20-20070123.htm#dt-predicate">predicate</A> 
<CODE>E1[E2]</CODE>, create a new focus for the evaluation of a sub-expression. 
In these constructs, <CODE>E2</CODE> is evaluated once for each item in the 
sequence that results from evaluating <CODE>E1</CODE>. Each time <CODE>E2</CODE> 
is evaluated, it is evaluated with a different focus. The focus for evaluating 
<CODE>E2</CODE> is referred to below as the <B>inner focus</B>, while the focus 
for evaluating <CODE>E1</CODE> is referred to as the <B>outer focus</B>. The 
inner focus exists only while <CODE>E2</CODE> is being evaluated. When this 
evaluation is complete, evaluation of the containing expression continues with 
its original focus unchanged.</P>
<UL>
  <LI>
  <P>[<A id=dt-context-item title="context item" 
  name=dt-context-item>Definition</A>: The <B>context item</B> is the item 
  currently being processed. An item is either an atomic value or a node.][<A 
  id=dt-context-node title="context node" name=dt-context-node>Definition</A>: 
  When the context item is a node, it can also be referred to as the <B>context 
  node</B>.] The context item is returned by an expression consisting of a 
  single dot (<CODE>.</CODE>). When an expression <CODE>E1/E2</CODE> or 
  <CODE>E1[E2]</CODE> is evaluated, each item in the sequence obtained by 
  evaluating <CODE>E1</CODE> becomes the context item in the inner focus for an 
  evaluation of <CODE>E2</CODE>.</P>
  <LI>
  <P>[<A id=dt-context-position title="context position" 
  name=dt-context-position>Definition</A>: The <B>context position</B> is the 
  position of the context item within the sequence of items currently being 
  processed.] It changes whenever the context item changes. When the focus is 
  defined, the value of the context position is an integer greater than zero. 
  The context position is returned by the expression <CODE>fn:position()</CODE>. 
  When an expression <CODE>E1/E2</CODE> or <CODE>E1[E2]</CODE> is evaluated, the 
  context position in the inner focus for an evaluation of <CODE>E2</CODE> is 
  the position of the context item in the sequence obtained by evaluating 
  <CODE>E1</CODE>. The position of the first item in a sequence is always 1 
  (one). The context position is always less than or equal to the context 
  size.</P>
  <LI>
  <P>[<A id=dt-context-size title="context size" 
  name=dt-context-size>Definition</A>: The <B>context size</B> is the number of 
  items in the sequence of items currently being processed.] Its value is always 
  an integer greater than zero. The context size is returned by the expression 
  <CODE>fn:last()</CODE>. When an expression <CODE>E1/E2</CODE> or 
  <CODE>E1[E2]</CODE> is evaluated, the context size in the inner focus for an 
  evaluation of <CODE>E2</CODE> is the number of items in the sequence obtained 
  by evaluating <CODE>E1</CODE>.</P>
  <LI>
  <P>[<A id=dt-variable-values title="variable values" 
  name=dt-variable-values>Definition</A>: <B>Variable values</B>. This is a set 
  of (expanded QName, value) pairs. It contains the same <A 
  title="expanded QName" 
  href="REC-xpath20-20070123.htm#dt-expanded-qname">expanded 
  QNames</A> as the <A title="in-scope variables" 
  href="REC-xpath20-20070123.htm#dt-in-scope-variables">in-scope 
  variables</A> in the <A title="static context" 
  href="REC-xpath20-20070123.htm#dt-static-context">static 
  context</A> for the expression. The expanded QName is the name of the variable 
  and the value is the dynamic value of the variable, which includes its <A 
  title="dynamic type" 
  href="REC-xpath20-20070123.htm#dt-dynamic-type">dynamic 
  type</A>.]</P>
  <LI>
  <P>[<A id=dt-function-implementation title="function implementation" 
  name=dt-function-implementation>Definition</A>: <B>Function 
  implementations</B>. Each function in <A title="function signature" 
  href="REC-xpath20-20070123.htm#dt-function-signature">function 
  signatures</A> has a function implementation that enables the function to map 
  instances of its parameter types into an instance of its result type. ]</P>
  <LI>
  <P>[<A id=dt-date-time title="current dateTime" 
  name=dt-date-time>Definition</A>: <B>Current dateTime.</B> This information 
  represents an <A title="implementation dependent" 
  href="REC-xpath20-20070123.htm#dt-implementation-dependent">implementation-dependent</A> 
  point in time during the processing of <SPAN class=xpath><SPAN class=xpath>an 
  expression</SPAN></SPAN>, and includes an explicit timezone. It can be 
  retrieved by the <CODE>fn:current-dateTime</CODE> function. If invoked 
  multiple times during the execution of <SPAN class=xpath><SPAN class=xpath>an 
  expression</SPAN></SPAN>, this function always returns the same result.]</P>
  <LI>
  <P>[<A id=dt-timezone title="implicit timezone" 
  name=dt-timezone>Definition</A>: <B>Implicit timezone.</B> This is the 
  timezone to be used when a date, time, or dateTime value that does not have a 
  timezone is used in a comparison or arithmetic operation. The implicit 
  timezone is an <A title="implementation defined" 
  href="REC-xpath20-20070123.htm#dt-implementation-defined">implementation-defined</A> 
  value of type <CODE>xs:dayTimeDuration</CODE>. See <A 
  href="REC-xpath20-20070123.htm#XMLSchema">[XML 
  Schema]</A> for the range of legal values of a timezone.]</P>
  <LI>
  <P>[<A id=dt-available-docs title="available documents" 
  name=dt-available-docs>Definition</A>: <B>Available documents.</B> This is a 
  mapping of strings onto document nodes. The string represents the absolute URI 
  of a resource. The document node is the root of a tree that represents that 
  resource using the <A title="data model" 
  href="REC-xpath20-20070123.htm#dt-datamodel">data 
  model</A>. The document node is returned by the <CODE>fn:doc</CODE> function 
  when applied to that URI.] The set of available documents is not limited to 
  the set of <A title="statically known documents" 
  href="REC-xpath20-20070123.htm#dt-known-docs">statically 
  known documents</A>, and it may be empty.</P>
  <P>If there are one or more URIs in <A title="available documents" 
  href="REC-xpath20-20070123.htm#dt-available-docs">available 
  documents</A> that map to a document node <CODE>D</CODE>, then the 
  document-uri property of <CODE>D</CODE> must either be absent, or must be one 
  of these URIs.</P>
  <DIV class=note>
  <P class=prefix><B>Note:</B></P>
  <P>This means that given a document node <CODE>$N</CODE>, the result of 
  <CODE>fn:doc(fn:document-uri($N)) is $N</CODE> will always be True, unless 
  <CODE>fn:document-uri($N)</CODE> is an empty sequence.</P></DIV>
  <LI>
  <P>[<A id=dt-available-collections title="available collections" 
  name=dt-available-collections>Definition</A>: <B>Available collections.</B> 
  This is a mapping of strings onto sequences of nodes. The string represents 
  the absolute URI of a resource. The sequence of nodes represents the result of 
  the <CODE>fn:collection</CODE> function when that URI is supplied as the 
  argument. ] The set of available collections is not limited to the set of <A 
  title="statically known collections" 
  href="REC-xpath20-20070123.htm#dt-known-collections">statically 
  known collections</A>, and it may be empty.</P>
  <P>For every document node <CODE>D</CODE> that is in the target of a mapping 
  in <A title="available collections" 
  href="REC-xpath20-20070123.htm#dt-available-collections">available 
  collections</A>, or that is the root of a tree containing such a node, the 
  document-uri property of <CODE>D</CODE> must either be absent, or must be a 
  URI <CODE>U</CODE> such that <A title="available documents" 
  href="REC-xpath20-20070123.htm#dt-available-docs">available 
  documents</A> contains a mapping from <CODE>U</CODE> to <CODE>D</CODE>."</P>
  <DIV class=note>
  <P class=prefix><B>Note:</B></P>
  <P>This means that for any document node <CODE>$N</CODE> retrieved using the 
  <CODE>fn:collection</CODE> function, either directly or by navigating to the 
  root of a node that was returned, the result of 
  <CODE>fn:doc(fn:document-uri($N)) is $N</CODE> will always be True, unless 
  <CODE>fn:document-uri($N)</CODE> is an empty sequence. This implies a 
  requirement for the <CODE>fn:doc</CODE> and <CODE>fn:collection</CODE> 
  functions to be consistent in their effect. If the implementation uses 
  catalogs or user-supplied URI resolvers to dereference URIs supplied to the 
  <CODE>fn:doc</CODE> function, the implementation of the 
  <CODE>fn:collection</CODE> function must take these mechanisms into account. 
  For example, an implementation might achieve this by mapping the collection 
  URI to a set of document URIs, which are then resolved using the same catalog 
  or URI resolver that is used by the <CODE>fn:doc</CODE> function.</P></DIV>
  <LI>
  <P>[<A id=dt-default-collection title="default collection" 
  name=dt-default-collection>Definition</A>: <B>Default collection.</B> This is 
  the sequence of nodes that would result from calling the 
  <CODE>fn:collection</CODE> function with no arguments.] The value of 
  <B>default collection</B> may be initialized by the 
implementation.</P></LI></UL></DIV></DIV>
<DIV class=div2>
<H3><A id=id-processing-model name=id-processing-model></A>2.2 Processing 
Model</H3>
<P>XPath is defined in terms of the <A title="data model" 
href="REC-xpath20-20070123.htm#dt-datamodel">data 
model</A> and the <A title="expression context" 
href="REC-xpath20-20070123.htm#dt-expression-context">expression 
context</A>.</P><IMG alt="Processing Model Overview" 
src="REC-xpath20-20070123_files/ProcMod-XPath.gif"> 
<P>Figure 1: Processing Model Overview</P>
<P>Figure 1 provides a schematic overview of the processing steps that are 
discussed in detail below. Some of these steps are completely outside the domain 
of XPath; in Figure 1, these are depicted outside the line that represents the 
boundaries of the language, an area labeled <B>external processing</B>. The 
external processing domain includes generation of an <A title="XDM instance" 
href="REC-xpath20-20070123.htm#dt-data-model-instance">XDM 
instance</A> that represents the data to be queried (see <A 
href="REC-xpath20-20070123.htm#id-data-model-generation"><B>2.2.1 
Data Model Generation</B></A>), schema import processing (see <A 
href="REC-xpath20-20070123.htm#id-schema-import-processing"><B>2.2.2 
Schema Import Processing</B></A>) and serialization (see <A 
href="REC-xpath20-20070123.htm#id-serialization"><B>2.2.4 
Serialization</B></A>). The area inside the boundaries of the language is known 
as the <SPAN class=xpath><SPAN class=xpath><B>XPath processing 
domain</B></SPAN></SPAN>, which includes the static analysis and dynamic 
evaluation phases (see <A 
href="REC-xpath20-20070123.htm#id-expression-processing"><B>2.2.3 
Expression Processing</B></A>). Consistency constraints on the <SPAN 
class=xpath><SPAN class=xpath>XPath</SPAN></SPAN> processing domain are defined 
in <A 
href="REC-xpath20-20070123.htm#id-consistency-constraints"><B>2.2.5 
Consistency Constraints</B></A>.</P>
<DIV class=div3>
<H4><A id=id-data-model-generation name=id-data-model-generation></A>2.2.1 Data 
Model Generation</H4>
<P>Before <SPAN class=xpath><SPAN class=xpath>an expression</SPAN></SPAN> can be 
processed, its input data must be represented as an <A title="XDM instance" 
href="REC-xpath20-20070123.htm#dt-data-model-instance">XDM 
instance</A>. This process occurs outside the domain of XPath, which is why 
Figure 1 represents it in the external processing domain. Here are some steps by 
which an XML document might be converted to an <A title="XDM instance" 
href="REC-xpath20-20070123.htm#dt-data-model-instance">XDM 
instance</A>:</P>
<OL class=enumar>
  <LI>
  <P>A document may be parsed using an XML parser that generates an <B>XML 
  Information Set</B> (see <A 
  href="REC-xpath20-20070123.htm#XINFO">[XML 
  Infoset]</A>). The parsed document may then be validated against one or more 
  schemas. This process, which is described in <A 
  href="REC-xpath20-20070123.htm#XMLSchema">[XML 
  Schema]</A>, results in an abstract information structure called the 
  <B>Post-Schema Validation Infoset</B> (PSVI). If a document has no associated 
  schema, its Information Set is preserved. (See DM1 in Fig. 1.)</P>
  <LI>
  <P>The Information Set or PSVI may be transformed into an <A 
  title="XDM instance" 
  href="REC-xpath20-20070123.htm#dt-data-model-instance">XDM 
  instance</A> by a process described in <A 
  href="REC-xpath20-20070123.htm#datamodel">[XQuery/XPath 
  Data Model (XDM)]</A>. (See DM2 in Fig. 1.)</P></LI></OL>
<P>The above steps provide an example of how an <A title="XDM instance" 
href="REC-xpath20-20070123.htm#dt-data-model-instance">XDM 
instance</A> might be constructed. An XDM instance might also be synthesized 
directly from a relational database, or constructed in some other way (see DM3 
in Fig. 1.) XPath is defined in terms of the <A title="data model" 
href="REC-xpath20-20070123.htm#dt-datamodel">data 
model</A>, but it does not place any constraints on how XDM instances are 
constructed.</P>
<P>[<A id=dt-type-annotation title="type annotation" 
name=dt-type-annotation>Definition</A>: Each element node and attribute node in 
an <A title="XDM instance" 
href="REC-xpath20-20070123.htm#dt-data-model-instance">XDM 
instance</A> has a <B>type annotation</B> (referred to in <A 
href="REC-xpath20-20070123.htm#datamodel">[XQuery/XPath 
Data Model (XDM)]</A> as its <CODE>type-name</CODE> property.) The type 
annotation of a node is a <A title="schema type" 
href="REC-xpath20-20070123.htm#dt-schema-type">schema 
type</A> that describes the relationship between the <A title="string value" 
href="REC-xpath20-20070123.htm#dt-string-value">string 
value</A> of the node and its <A title="typed value" 
href="REC-xpath20-20070123.htm#dt-typed-value">typed 
value</A>.] If the <A title="XDM instance" 
href="REC-xpath20-20070123.htm#dt-data-model-instance">XDM 
instance</A> was derived from a validated XML document as described in <A 
href="http://www.w3.org/TR/xpath-datamodel/#const-psvi">Section 3.3 Construction 
from a PSVI</A><SUP><SMALL>DM</SMALL></SUP>, the type annotations of the element 
and attribute nodes are derived from schema validation. XPath does not provide a 
way to directly access the type annotation of an element or attribute node.</P>
<P>The value of an attribute is represented directly within the attribute node. 
An attribute node whose type is unknown (such as might occur in a schemaless 
document) is given the <A title="type annotation" 
href="REC-xpath20-20070123.htm#dt-type-annotation">type 
annotation</A> <CODE>xs:untypedAtomic</CODE>.</P>
<P>The value of an element is represented by the children of the element node, 
which may include text nodes and other element nodes. The <A 
title="type annotation" 
href="REC-xpath20-20070123.htm#dt-type-annotation">type 
annotation</A> of an element node indicates how the values in its child text 
nodes are to be interpreted. An element that has not been validated (such as 
might occur in a schemaless document) is annotated with the schema type 
<CODE>xs:untyped</CODE>. An element that has been validated and found to be 
partially valid is annotated with the schema type <CODE>xs:anyType</CODE>. If an 
element node is annotated as <CODE>xs:untyped</CODE>, all its descendant element 
nodes are also annotated as <CODE>xs:untyped</CODE>. However, if an element node 
is annotated as <CODE>xs:anyType</CODE>, some of its descendant element nodes 
may have a more specific <A title="type annotation" 
href="REC-xpath20-20070123.htm#dt-type-annotation">type 
annotation</A>.</P></DIV>
<DIV class=div3>
<H4><A id=id-schema-import-processing name=id-schema-import-processing></A>2.2.2 
Schema Import Processing</H4>
<DIV class=xpath>
<P class=xpath>The <A title="in-scope schema definitions" 
href="REC-xpath20-20070123.htm#dt-issd">in-scope schema 
definitions</A> in the <A title="static context" 
href="REC-xpath20-20070123.htm#dt-static-context">static 
context</A> are provided by the host language (see step SI1 in Figure 1) and 
must satisfy the consistency constraints defined in <A 
href="REC-xpath20-20070123.htm#id-consistency-constraints"><B>2.2.5 
Consistency Constraints</B></A>.</P></DIV></DIV>
<DIV class=div3>
<H4><A id=id-expression-processing name=id-expression-processing></A>2.2.3 
Expression Processing</H4>
<P>XPath defines two phases of processing called the <A 
title="static analysis phase" 
href="REC-xpath20-20070123.htm#dt-static-analysis">static 
analysis phase</A> and the <A title="dynamic evaluation phase" 
href="REC-xpath20-20070123.htm#dt-dynamic-evaluation">dynamic 
evaluation phase</A> (see Fig. 1). During the static analysis phase, <A 
title="static error" 
href="REC-xpath20-20070123.htm#dt-static-error">static 
errors</A>, <A title="dynamic error" 
href="REC-xpath20-20070123.htm#dt-dynamic-error">dynamic 
errors</A>, or <A title="type error" 
href="REC-xpath20-20070123.htm#dt-type-error">type 
errors</A> may be raised. During the dynamic evaluation phase, only <A 
title="dynamic error" 
href="REC-xpath20-20070123.htm#dt-dynamic-error">dynamic 
errors</A> or <A title="type error" 
href="REC-xpath20-20070123.htm#dt-type-error">type 
errors</A> may be raised. These kinds of errors are defined in <A 
href="REC-xpath20-20070123.htm#id-kinds-of-errors"><B>2.3.1 
Kinds of Errors</B></A>.</P>
<P>Within each phase, an implementation is free to use any strategy or algorithm 
whose result conforms to the specifications in this document.</P>
<DIV class=div4>
<H5><A id=id-static-analysis name=id-static-analysis></A>2.2.3.1 Static Analysis 
Phase</H5>
<P>[<A id=dt-static-analysis title="static analysis phase" 
name=dt-static-analysis>Definition</A>: The <B>static analysis phase</B> depends 
on the expression itself and on the <A title="static context" 
href="REC-xpath20-20070123.htm#dt-static-context">static 
context</A>. The <B>static analysis phase</B> does not depend on input data 
(other than schemas).]</P>
<P>During the static analysis phase, the <SPAN class=xpath><SPAN 
class=xpath>XPath expression</SPAN></SPAN> is parsed into an internal 
representation called the <B>operation tree</B> (step SQ1 in Figure 1). A parse 
error is raised as a <A title="static error" 
href="REC-xpath20-20070123.htm#dt-static-error">static 
error</A> [<A title=err:XPST0003 
href="REC-xpath20-20070123.htm#ERRXPST0003">err:XPST0003</A>]. 
The <A title="static context" 
href="REC-xpath20-20070123.htm#dt-static-context">static 
context</A> is initialized by the implementation (step SQ2). The <A 
title="static context" 
href="REC-xpath20-20070123.htm#dt-static-context">static 
context</A> is used to resolve schema type names, function names, namespace 
prefixes, and variable names (step SQ4). If a name of one of these kinds in the 
<B>operation tree</B> is not found in the <A title="static context" 
href="REC-xpath20-20070123.htm#dt-static-context">static 
context</A>, a <A title="static error" 
href="REC-xpath20-20070123.htm#dt-static-error">static 
error</A> ([<A title=err:XPST0008 
href="REC-xpath20-20070123.htm#ERRXPST0008">err:XPST0008</A>] 
or [<A title=err:XPST0017 
href="REC-xpath20-20070123.htm#ERRXPST0017">err:XPST0017</A>]) 
is raised (however, see exceptions to this rule in <A 
href="REC-xpath20-20070123.htm#id-element-test"><B>2.5.4.3 
Element Test</B></A> and <A 
href="REC-xpath20-20070123.htm#id-attribute-test"><B>2.5.4.5 
Attribute Test</B></A>.)</P>
<P>The <B>operation tree</B> is then <B>normalized</B> by making explicit the 
implicit operations such as <A title=atomization 
href="REC-xpath20-20070123.htm#dt-atomization">atomization</A> 
and extraction of <A title="effective boolean value" 
href="REC-xpath20-20070123.htm#dt-ebv">Effective Boolean 
Values</A> (step SQ5). The normalization process is described in <A 
href="REC-xpath20-20070123.htm#XQueryFormalSemantics">[XQuery 
1.0 and XPath 2.0 Formal Semantics]</A>.</P>
<P>Each expression is then assigned a <A title="static type" 
href="REC-xpath20-20070123.htm#dt-static-type">static 
type</A> (step SQ6). [<A id=dt-static-type title="static type" 
name=dt-static-type>Definition</A>: The <B>static type</B> of an expression is a 
type such that, when the expression is evaluated, the resulting value will 
always conform to the static type.] If the <A title="static typing feature" 
href="REC-xpath20-20070123.htm#dt-xpath-static-typing-feature">Static 
Typing Feature</A> is supported, the <A title="static type" 
href="REC-xpath20-20070123.htm#dt-static-type">static 
types</A> of various expressions are inferred according to the rules described 
in <A 
href="REC-xpath20-20070123.htm#XQueryFormalSemantics">[XQuery 
1.0 and XPath 2.0 Formal Semantics]</A>. If the <A title="static typing feature" 
href="REC-xpath20-20070123.htm#dt-xpath-static-typing-feature">Static 
Typing Feature</A> is not supported, the static types that are assigned are <A 
title="implementation dependent" 
href="REC-xpath20-20070123.htm#dt-implementation-dependent">implementation-dependent</A>.</P>
<P>During the <A title="static analysis phase" 
href="REC-xpath20-20070123.htm#dt-static-analysis">static 
analysis phase</A>, if the <A title="static typing feature" 
href="REC-xpath20-20070123.htm#dt-xpath-static-typing-feature">Static 
Typing Feature</A> is in effect and an operand of an expression is found to have 
a <A title="static type" 
href="REC-xpath20-20070123.htm#dt-static-type">static 
type</A> that is not appropriate for that operand, a <A title="type error" 
href="REC-xpath20-20070123.htm#dt-type-error">type 
error</A> is raised [<A title=err:XPTY0004 
href="REC-xpath20-20070123.htm#ERRXPTY0004">err:XPTY0004</A>]. 
If static type checking raises no errors and assigns a <A title="static type" 
href="REC-xpath20-20070123.htm#dt-static-type">static 
type</A> T to an expression, then execution of the expression on valid input 
data is guaranteed either to produce a value of type T or to raise a <A 
title="dynamic error" 
href="REC-xpath20-20070123.htm#dt-dynamic-error">dynamic 
error</A>.</P>
<P>The purpose of the <A title="static typing feature" 
href="REC-xpath20-20070123.htm#dt-xpath-static-typing-feature">Static 
Typing Feature</A> is to provide early detection of <A title="type error" 
href="REC-xpath20-20070123.htm#dt-type-error">type 
errors</A> and to infer type information that may be useful in optimizing the 
evaluation of an expression.</P></DIV>
<DIV class=div4>
<H5><A id=id-dynamic-evaluation name=id-dynamic-evaluation></A>2.2.3.2 Dynamic 
Evaluation Phase</H5>
<P>[<A id=dt-dynamic-evaluation title="dynamic evaluation phase" 
name=dt-dynamic-evaluation>Definition</A>: The <B>dynamic evaluation phase</B> 
is the phase during which the value of an expression is computed.] It occurs 
after completion of the <A title="static analysis phase" 
href="REC-xpath20-20070123.htm#dt-static-analysis">static 
analysis phase</A>.</P>
<P>The dynamic evaluation phase can occur only if no errors were detected during 
the <A title="static analysis phase" 
href="REC-xpath20-20070123.htm#dt-static-analysis">static 
analysis phase</A>. If the <A title="static typing feature" 
href="REC-xpath20-20070123.htm#dt-xpath-static-typing-feature">Static 
Typing Feature</A> is in effect, all <A title="type error" 
href="REC-xpath20-20070123.htm#dt-type-error">type 
errors</A> are detected during static analysis and serve to inhibit the dynamic 
evaluation phase.</P>
<P>The dynamic evaluation phase depends on the <B>operation tree</B> of the 
expression being evaluated (step DQ1), on the input data (step DQ4), and on the 
<A title="dynamic context" 
href="REC-xpath20-20070123.htm#dt-dynamic-context">dynamic 
context</A> (step DQ5), which in turn draws information from the external 
environment (step DQ3) and the <A title="static context" 
href="REC-xpath20-20070123.htm#dt-static-context">static 
context</A> (step DQ2). The dynamic evaluation phase may create new data-model 
values (step DQ4) and it may extend the <A title="dynamic context" 
href="REC-xpath20-20070123.htm#dt-dynamic-context">dynamic 
context</A> (step DQ5)—for example, by binding values to variables.</P>
<P>[<A id=dt-dynamic-type title="dynamic type" 
name=dt-dynamic-type>Definition</A>: A <B>dynamic type</B> is associated with 
each value as it is computed. The dynamic type of a value may be more specific 
than the <A title="static type" 
href="REC-xpath20-20070123.htm#dt-static-type">static 
type</A> of the expression that computed it (for example, the static type of an 
expression might be <CODE>xs:integer*</CODE>, denoting a sequence of zero or 
more integers, but at evaluation time its value may have the dynamic type 
<CODE>xs:integer</CODE>, denoting exactly one integer.)]</P>
<P>If an operand of an expression is found to have a <A title="dynamic type" 
href="REC-xpath20-20070123.htm#dt-dynamic-type">dynamic 
type</A> that is not appropriate for that operand, a <A title="type error" 
href="REC-xpath20-20070123.htm#dt-type-error">type 
error</A> is raised [<A title=err:XPTY0004 
href="REC-xpath20-20070123.htm#ERRXPTY0004">err:XPTY0004</A>].</P>
<P>Even though static typing can catch many <A title="type error" 
href="REC-xpath20-20070123.htm#dt-type-error">type 
errors</A> before an expression is executed, it is possible for an expression to 
raise an error during evaluation that was not detected by static analysis. For 
example, an expression may contain a cast of a string into an integer, which is 
statically valid. However, if the actual value of the string at run time cannot 
be cast into an integer, a <A title="dynamic error" 
href="REC-xpath20-20070123.htm#dt-dynamic-error">dynamic 
error</A> will result. Similarly, an expression may apply an arithmetic operator 
to a value whose <A title="static type" 
href="REC-xpath20-20070123.htm#dt-static-type">static 
type</A> is <CODE>xs:untypedAtomic</CODE>. This is not a <A title="static error" 
href="REC-xpath20-20070123.htm#dt-static-error">static 
error</A>, but at run time, if the value cannot be successfully cast to a <A 
title=numeric 
href="REC-xpath20-20070123.htm#dt-numeric">numeric</A> 
type, a <A title="dynamic error" 
href="REC-xpath20-20070123.htm#dt-dynamic-error">dynamic 
error</A> will be raised.</P>
<P>When the <A title="static typing feature" 
href="REC-xpath20-20070123.htm#dt-xpath-static-typing-feature">Static 
Typing Feature</A> is in effect, it is also possible for static analysis of an 
expression to raise a <A title="type error" 
href="REC-xpath20-20070123.htm#dt-type-error">type 
error</A>, even though execution of the expression on certain inputs would be 
successful. For example, an expression might contain a function that requires an 
element as its parameter, and the static analysis phase might infer the <A 
title="static type" 
href="REC-xpath20-20070123.htm#dt-static-type">static 
type</A> of the function parameter to be an optional element. This case is 
treated as a <A title="type error" 
href="REC-xpath20-20070123.htm#dt-type-error">type 
error</A> and inhibits evaluation, even though the function call would have been 
successful for input data in which the optional element is 
present.</P></DIV></DIV>
<DIV class=div3>
<H4><A id=id-serialization name=id-serialization></A>2.2.4 Serialization</H4>
<P>[<A id=dt-serialization title=serialization 
name=dt-serialization>Definition</A>: <B>Serialization</B> is the process of 
converting an <A title="XDM instance" 
href="REC-xpath20-20070123.htm#dt-data-model-instance">XDM 
instance</A> into a sequence of octets (step DM4 in Figure 1.) ] The general 
framework for serialization is described in <A 
href="REC-xpath20-20070123.htm#serialization">[XSLT 2.0 
and XQuery 1.0 Serialization]</A>.</P>
<DIV class=xpath>
<P class=xpath>The host language may provide a serialization 
option.</P></DIV></DIV>
<DIV class=div3>
<H4><A id=id-consistency-constraints name=id-consistency-constraints></A>2.2.5 
Consistency Constraints</H4>
<P>In order for XPath to be well defined, the input <A title="XDM instance" 
href="REC-xpath20-20070123.htm#dt-data-model-instance">XDM 
instance</A>, the <A title="static context" 
href="REC-xpath20-20070123.htm#dt-static-context">static 
context</A>, and the <A title="dynamic context" 
href="REC-xpath20-20070123.htm#dt-dynamic-context">dynamic 
context</A> must be mutually consistent. The consistency constraints listed 
below are prerequisites for correct functioning of an XPath implementation. 
Enforcement of these consistency constraints is beyond the scope of this 
specification. This specification does not define the result of <SPAN 
class=xpath><SPAN class=xpath>an expression</SPAN></SPAN> under any condition in 
which one or more of these constraints is not satisfied.</P>
<P>Some of the consistency constraints use the term <B>data model schema</B>. 
[<A id=dt-data-model-schema title="data model schema" 
name=dt-data-model-schema>Definition</A>: For a given node in an <A 
title="XDM instance" 
href="REC-xpath20-20070123.htm#dt-data-model-instance">XDM 
instance</A>, the <B>data model schema</B> is defined as the schema from which 
the <A title="type annotation" 
href="REC-xpath20-20070123.htm#dt-type-annotation">type 
annotation</A> of that node was derived.] For a node that was constructed by 
some process other than schema validation, the <B>data model schema</B> consists 
simply of the schema type definition that is represented by the <A 
title="type annotation" 
href="REC-xpath20-20070123.htm#dt-type-annotation">type 
annotation</A> of the node.</P>
<UL>
  <LI>
  <P>For every node that has a type annotation, if that type annotation is found 
  in the <A title="in-scope schema definitions" 
  href="REC-xpath20-20070123.htm#dt-issd">in-scope schema 
  definitions</A> (ISSD), then its definition in the ISSD must be equivalent to 
  its definition in the <A title="data model schema" 
  href="REC-xpath20-20070123.htm#dt-data-model-schema">data 
  model schema</A>. Furthermore, all types that are derived by extension from 
  the given type in the <A title="data model schema" 
  href="REC-xpath20-20070123.htm#dt-data-model-schema">data 
  model schema</A> must also be known by equivalent definitions in the ISSD.</P>
  <LI>
  <P>For every element name <EM>EN</EM> that is found both in an <A 
  title="XDM instance" 
  href="REC-xpath20-20070123.htm#dt-data-model-instance">XDM 
  instance</A> and in the <A title="in-scope schema definitions" 
  href="REC-xpath20-20070123.htm#dt-issd">in-scope schema 
  definitions</A> (ISSD), all elements that are known in the <A 
  title="data model schema" 
  href="REC-xpath20-20070123.htm#dt-data-model-schema">data 
  model schema</A> to be in the <A title="substitution group" 
  href="REC-xpath20-20070123.htm#dt-substitution-group">substitution 
  group</A> headed by <EM>EN</EM> must also be known in the ISSD to be in the <A 
  title="substitution group" 
  href="REC-xpath20-20070123.htm#dt-substitution-group">substitution 
  group</A> headed by <EM>EN</EM>.</P>
  <LI>
  <P>Every element name, attribute name, or schema type name referenced in <A 
  title="in-scope variables" 
  href="REC-xpath20-20070123.htm#dt-in-scope-variables">in-scope 
  variables</A> or <A title="function signature" 
  href="REC-xpath20-20070123.htm#dt-function-signature">function 
  signatures</A> must be in the <A title="in-scope schema definitions" 
  href="REC-xpath20-20070123.htm#dt-issd">in-scope schema 
  definitions</A>, unless it is an element name referenced as part of an <A 
  href="REC-xpath20-20070123.htm#doc-xpath-ElementTest">ElementTest</A> 
  or an attribute name referenced as part of an <A 
  href="REC-xpath20-20070123.htm#doc-xpath-AttributeTest">AttributeTest</A>.</P>
  <LI>
  <P>Any reference to a global element, attribute, or type name in the <A 
  title="in-scope schema definitions" 
  href="REC-xpath20-20070123.htm#dt-issd">in-scope schema 
  definitions</A> must have a corresponding element, attribute or type 
  definition in the <A title="in-scope schema definitions" 
  href="REC-xpath20-20070123.htm#dt-issd">in-scope schema 
  definitions</A>.</P>
  <LI>
  <P>For each mapping of a string to a document node in <A 
  title="available documents" 
  href="REC-xpath20-20070123.htm#dt-available-docs">available 
  documents</A>, if there exists a mapping of the same string to a document type 
  in <A title="statically known documents" 
  href="REC-xpath20-20070123.htm#dt-known-docs">statically 
  known documents</A>, the document node must match the document type, using the 
  matching rules in <A 
  href="REC-xpath20-20070123.htm#id-sequencetype-matching"><B>2.5.4 
  SequenceType Matching</B></A>.</P>
  <LI>
  <P>For each mapping of a string to a sequence of nodes in <A 
  title="available collections" 
  href="REC-xpath20-20070123.htm#dt-available-collections">available 
  collections</A>, if there exists a mapping of the same string to a type in <A 
  title="statically known collections" 
  href="REC-xpath20-20070123.htm#dt-known-collections">statically 
  known collections</A>, the sequence of nodes must match the type, using the 
  matching rules in <A 
  href="REC-xpath20-20070123.htm#id-sequencetype-matching"><B>2.5.4 
  SequenceType Matching</B></A>.</P>
  <LI>
  <P>The sequence of nodes in the <A title="default collection" 
  href="REC-xpath20-20070123.htm#dt-default-collection">default 
  collection</A> must match the <A 
  title="statically known default collection type" 
  href="REC-xpath20-20070123.htm#dt-known-default-collection">statically 
  known default collection type</A>, using the matching rules in <A 
  href="REC-xpath20-20070123.htm#id-sequencetype-matching"><B>2.5.4 
  SequenceType Matching</B></A>.</P>
  <LI>
  <P>The value of the <A title="context item" 
  href="REC-xpath20-20070123.htm#dt-context-item">context 
  item</A> must match the <A title="context item static type" 
  href="REC-xpath20-20070123.htm#dt-context-item-static-type">context 
  item static type</A>, using the matching rules in <A 
  href="REC-xpath20-20070123.htm#id-sequencetype-matching"><B>2.5.4 
  SequenceType Matching</B></A>.</P>
  <LI>
  <P>For each (variable, type) pair in <A title="in-scope variables" 
  href="REC-xpath20-20070123.htm#dt-in-scope-variables">in-scope 
  variables</A> and the corresponding (variable, value) pair in <A 
  title="variable values" 
  href="REC-xpath20-20070123.htm#dt-variable-values">variable 
  values</A> such that the variable names are equal, the value must match the 
  type, using the matching rules in <A 
  href="REC-xpath20-20070123.htm#id-sequencetype-matching"><B>2.5.4 
  SequenceType Matching</B></A>.</P>
  <LI>
  <P>In the <A title="statically known namespaces" 
  href="REC-xpath20-20070123.htm#dt-static-namespaces">statically 
  known namespaces</A>, the prefix <CODE>xml</CODE> must not be bound to any 
  namespace URI other than <CODE>http://www.w3.org/XML/1998/namespace</CODE>, 
  and no prefix other than <CODE>xml</CODE> may be bound to this namespace 
  URI.</P></LI></UL></DIV></DIV>
<DIV class=div2>
<H3><A id=errors name=errors></A>2.3 Error Handling</H3>
<DIV class=div3>
<H4><A id=id-kinds-of-errors name=id-kinds-of-errors></A>2.3.1 Kinds of 
Errors</H4>
<P>As described in <A 
href="REC-xpath20-20070123.htm#id-expression-processing"><B>2.2.3 
Expression Processing</B></A>, XPath defines a <A title="static analysis phase" 
href="REC-xpath20-20070123.htm#dt-static-analysis">static 
analysis phase</A>, which does not depend on input data, and a <A 
title="dynamic evaluation phase" 
href="REC-xpath20-20070123.htm#dt-dynamic-evaluation">dynamic 
evaluation phase</A>, which does depend on input data. Errors may be raised 
during each phase.</P>
<P>[<A id=dt-static-error title="static error" 
name=dt-static-error>Definition</A>: A <B>static error</B> is an error that must 
be detected during the static analysis phase. A syntax error is an example of a 
<A title="static error" 
href="REC-xpath20-20070123.htm#dt-static-error">static 
error</A>.]</P>
<P>[<A id=dt-dynamic-error title="dynamic error" 
name=dt-dynamic-error>Definition</A>: A <B>dynamic error</B> is an error that 
must be detected during the dynamic evaluation phase and may be detected during 
the static analysis phase. Numeric overflow is an example of a dynamic error. 
]</P>
<P>[<A id=dt-type-error title="type error" name=dt-type-error>Definition</A>: A 
<B>type error</B> may be raised during the static analysis phase or the dynamic 
evaluation phase. During the static analysis phase, a <A title="type error" 
href="REC-xpath20-20070123.htm#dt-type-error">type 
error</A> occurs when the <A title="static type" 
href="REC-xpath20-20070123.htm#dt-static-type">static 
type</A> of an expression does not match the expected type of the context in 
which the expression occurs. During the dynamic evaluation phase, a <A 
title="type error" 
href="REC-xpath20-20070123.htm#dt-type-error">type 
error</A> occurs when the <A title="dynamic type" 
href="REC-xpath20-20070123.htm#dt-dynamic-type">dynamic 
type</A> of a value does not match the expected type of the context in which the 
value occurs.]</P>
<P>The outcome of the <A title="static analysis phase" 
href="REC-xpath20-20070123.htm#dt-static-analysis">static 
analysis phase</A> is either success or one or more <A title="type error" 
href="REC-xpath20-20070123.htm#dt-type-error">type 
errors</A>, <A title="static error" 
href="REC-xpath20-20070123.htm#dt-static-error">static 
errors</A>, or statically-detected <A title="dynamic error" 
href="REC-xpath20-20070123.htm#dt-dynamic-error">dynamic 
errors</A>. The result of the <A title="dynamic evaluation phase" 
href="REC-xpath20-20070123.htm#dt-dynamic-evaluation">dynamic 
evaluation phase</A> is either a result value, a <A title="type error" 
href="REC-xpath20-20070123.htm#dt-type-error">type 
error</A>, or a <A title="dynamic error" 
href="REC-xpath20-20070123.htm#dt-dynamic-error">dynamic 
error</A>.</P>
<P>If more than one error is present, or if an error condition comes within the 
scope of more than one error defined in this specification, then any non-empty 
subset of these errors may be reported.</P>
<P>During the <A title="static analysis phase" 
href="REC-xpath20-20070123.htm#dt-static-analysis">static 
analysis phase</A>, if the <A title="static typing feature" 
href="REC-xpath20-20070123.htm#dt-xpath-static-typing-feature">Static 
Typing Feature</A> is in effect and the <A title="static type" 
href="REC-xpath20-20070123.htm#dt-static-type">static 
type</A> assigned to an expression other than <CODE>()</CODE> or 
<CODE>data(())</CODE> is <CODE>empty-sequence()</CODE>, a <A 
title="static error" 
href="REC-xpath20-20070123.htm#dt-static-error">static 
error</A> is raised [<A title=err:XPST0005 
href="REC-xpath20-20070123.htm#ERRXPST0005">err:XPST0005</A>]. 
This catches cases in which a query refers to an element or attribute that is 
not present in the <A title="in-scope schema definitions" 
href="REC-xpath20-20070123.htm#dt-issd">in-scope schema 
definitions</A>, possibly because of a spelling error.</P>
<P>Independently of whether the <A title="static typing feature" 
href="REC-xpath20-20070123.htm#dt-xpath-static-typing-feature">Static 
Typing Feature</A> is in effect, if an implementation can determine during the 
<A title="static analysis phase" 
href="REC-xpath20-20070123.htm#dt-static-analysis">static 
analysis phase</A> that an expression, if evaluated, would necessarily raise a 
<A title="type error" 
href="REC-xpath20-20070123.htm#dt-type-error">type 
error</A> or a <A title="dynamic error" 
href="REC-xpath20-20070123.htm#dt-dynamic-error">dynamic 
error</A>, the implementation may (but is not required to) report that error 
during the <A title="static analysis phase" 
href="REC-xpath20-20070123.htm#dt-static-analysis">static 
analysis phase</A>. However, the <CODE>fn:error()</CODE> function must not be 
evaluated during the <A title="static analysis phase" 
href="REC-xpath20-20070123.htm#dt-static-analysis">static 
analysis phase</A>.</P>
<P>[<A id=dt-warning title=warning name=dt-warning>Definition</A>: In addition 
to <A title="static error" 
href="REC-xpath20-20070123.htm#dt-static-error">static 
errors</A>, <A title="dynamic error" 
href="REC-xpath20-20070123.htm#dt-dynamic-error">dynamic 
errors</A>, and <A title="type error" 
href="REC-xpath20-20070123.htm#dt-type-error">type 
errors</A>, an XPath implementation may raise <B>warnings</B>, either during the 
<A title="static analysis phase" 
href="REC-xpath20-20070123.htm#dt-static-analysis">static 
analysis phase</A> or the <A title="dynamic evaluation phase" 
href="REC-xpath20-20070123.htm#dt-dynamic-evaluation">dynamic 
evaluation phase</A>. The circumstances in which warnings are raised, and the 
ways in which warnings are handled, are <A title="implementation defined" 
href="REC-xpath20-20070123.htm#dt-implementation-defined">implementation-defined</A>.]</P>
<P>In addition to the errors defined in this specification, an implementation 
may raise a <A title="dynamic error" 
href="REC-xpath20-20070123.htm#dt-dynamic-error">dynamic 
error</A> for a reason beyond the scope of this specification. For example, 
limitations may exist on the maximum numbers or sizes of various objects. Any 
such limitations, and the consequences of exceeding them, are <A 
title="implementation dependent" 
href="REC-xpath20-20070123.htm#dt-implementation-dependent">implementation-dependent</A>.</P></DIV>
<DIV class=div3>
<H4><A id=id-identifying-errors name=id-identifying-errors></A>2.3.2 Identifying 
and Reporting Errors</H4>
<P>The errors defined in this specification are identified by QNames that have 
the form <CODE>err:XPYYnnnn</CODE>, where:</P>
<UL>
  <LI>
  <P><CODE>err</CODE> denotes the namespace for XPath and XQuery errors, 
  <CODE>http://www.w3.org/2005/xqt-errors</CODE>. This binding of the namespace 
  prefix <CODE>err</CODE> is used for convenience in this document, and is not 
  normative.</P>
  <LI class=xpath>
  <P><CODE>XP</CODE> identifies the error as an XPath error.</P>
  <LI>
  <P><CODE>YY</CODE> denotes the error category, using the following 
  encoding:</P>
  <UL>
    <LI>
    <P><CODE>ST</CODE> denotes a static error.</P>
    <LI>
    <P><CODE>DY</CODE> denotes a dynamic error.</P>
    <LI>
    <P><CODE>TY</CODE> denotes a type error.</P></LI></UL>
  <LI>
  <P><CODE>nnnn</CODE> is a unique numeric code.</P></LI></UL>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>The namespace URI for XPath and XQuery errors is not expected to change from 
one version of XPath to another. However, the contents of this namespace may be 
extended to include additional error definitions.</P></DIV>
<P>The method by which an XPath processor reports error information to the 
external environment is <A title="implementation defined" 
href="REC-xpath20-20070123.htm#dt-implementation-defined">implementation-defined</A>.</P>
<P>An error can be represented by a URI reference that is derived from the error 
QName as follows: an error with namespace URI <EM><CODE>NS</CODE></EM> and local 
part <EM><CODE>LP</CODE></EM> can be represented as the URI reference 
<EM><CODE>NS</CODE></EM><CODE>#</CODE><EM><CODE>LP</CODE></EM>. For example, an 
error whose QName is <CODE>err:XPST0017</CODE> could be represented as 
<CODE>http://www.w3.org/2005/xqt-errors#XPST0017</CODE>.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>Along with a code identifying an error, implementations may wish to return 
additional information, such as the location of the error or the processing 
phase in which it was detected. If an implementation chooses to do so, then the 
mechanism that it uses to return this information is <A 
title="implementation defined" 
href="REC-xpath20-20070123.htm#dt-implementation-defined">implementation-defined</A>.</P></DIV></DIV>
<DIV class=div3>
<H4><A id=id-handling-dynamic name=id-handling-dynamic></A>2.3.3 Handling 
Dynamic Errors</H4>
<P>Except as noted in this document, if any operand of an expression raises a <A 
title="dynamic error" 
href="REC-xpath20-20070123.htm#dt-dynamic-error">dynamic 
error</A>, the expression also raises a <A title="dynamic error" 
href="REC-xpath20-20070123.htm#dt-dynamic-error">dynamic 
error</A>. If an expression can validly return a value or raise a dynamic error, 
the implementation may choose to return the value or raise the dynamic error. 
For example, the logical expression <CODE>expr1 and expr2</CODE> may return the 
value <CODE>false</CODE> if either operand returns <CODE>false</CODE>, or may 
raise a dynamic error if either operand raises a dynamic error.</P>
<P>If more than one operand of an expression raises an error, the implementation 
may choose which error is raised by the expression. For example, in this 
expression:</P>
<DIV class=parse-test>
<DIV class=exampleInner><PRE>($x div $y) + xs:decimal($z)
</PRE></DIV></DIV>
<P>both the sub-expressions <CODE>($x div $y)</CODE> and 
<CODE>xs:decimal($z)</CODE> may raise an error. The implementation may choose 
which error is raised by the "<CODE>+</CODE>" expression. Once one operand 
raises an error, the implementation is not required, but is permitted, to 
evaluate any other operands.</P>
<P>[<A id=dt-error-value title="error value" name=dt-error-value>Definition</A>: 
In addition to its identifying QName, a dynamic error may also carry a 
descriptive string and one or more additional values called <B>error 
values</B>.] An implementation may provide a mechanism whereby an 
application-defined error handler can process error values and produce 
diagnostic messages.</P>
<P>A dynamic error may be raised by a <A title="built-in function" 
href="REC-xpath20-20070123.htm#dt-built-in-function">built-in 
function</A> or operator. For example, the <CODE>div</CODE> operator raises an 
error if its operands are <CODE>xs:decimal</CODE> values and its second operand 
is equal to zero. Errors raised by built-in functions and operators are defined 
in <A 
href="REC-xpath20-20070123.htm#FunctionsAndOperators">[XQuery 
1.0 and XPath 2.0 Functions and Operators]</A>.</P>
<P>A dynamic error can also be raised explicitly by calling the 
<CODE>fn:error</CODE> function, which only raises an error and never returns a 
value. This function is defined in <A 
href="REC-xpath20-20070123.htm#FunctionsAndOperators">[XQuery 
1.0 and XPath 2.0 Functions and Operators]</A>. For example, the following 
function call raises a dynamic error, providing a QName that identifies the 
error, a descriptive string, and a diagnostic value (assuming that the prefix 
<CODE>app</CODE> is bound to a namespace containing application-defined error 
codes):</P>
<DIV class=parse-test>
<DIV class=exampleInner><PRE>fn:error(xs:QName("app:err057"), "Unexpected value", fn:string($v))
</PRE></DIV></DIV></DIV>
<DIV class=div3>
<H4><A id=id-errors-and-opt name=id-errors-and-opt></A>2.3.4 Errors and 
Optimization</H4>
<P>Because different implementations may choose to evaluate or optimize an 
expression in different ways, certain aspects of the detection and reporting of 
<A title="dynamic error" 
href="REC-xpath20-20070123.htm#dt-dynamic-error">dynamic 
errors</A> are <A title="implementation dependent" 
href="REC-xpath20-20070123.htm#dt-implementation-dependent">implementation-dependent</A>, 
as described in this section.</P>
<P>An implementation is always free to evaluate the operands of an operator in 
any order.</P>
<P>In some cases, a processor can determine the result of an expression without 
accessing all the data that would be implied by the formal expression semantics. 
For example, the formal description of <A title="filter expression" 
href="REC-xpath20-20070123.htm#dt-filter-expression">filter 
expressions</A> suggests that <CODE>$s[1]</CODE> should be evaluated by 
examining all the items in sequence <CODE>$s</CODE>, and selecting all those 
that satisfy the predicate <CODE>position()=1</CODE>. In practice, many 
implementations will recognize that they can evaluate this expression by taking 
the first item in the sequence and then exiting. If <CODE>$s</CODE> is defined 
by an expression such as <CODE>//book[author eq 'Berners-Lee']</CODE>, then this 
strategy may avoid a complete scan of a large document and may therefore greatly 
improve performance. However, a consequence of this strategy is that a dynamic 
error or type error that would be detected if the expression semantics were 
followed literally might not be detected at all if the evaluation exits early. 
In this example, such an error might occur if there is a <CODE>book</CODE> 
element in the input data with more than one <CODE>author</CODE> subelement.</P>
<P>The extent to which a processor may optimize its access to data, at the cost 
of not detecting errors, is defined by the following rules.</P>
<P>Consider an expression <EM>Q</EM> that has an operand (sub-expression) 
<EM>E</EM>. In general the value of <EM>E</EM> is a sequence. At an intermediate 
stage during evaluation of the sequence, some of its items will be known and 
others will be unknown. If, at such an intermediate stage of evaluation, a 
processor is able to establish that there are only two possible outcomes of 
evaluating <EM>Q</EM>, namely the value <EM>V</EM> or an error, then the 
processor may deliver the result <EM>V</EM> without evaluating further items in 
the operand <EM>E</EM>. For this purpose, two values are considered to represent 
the same outcome if their items are pairwise the same, where nodes are the same 
if they have the same identity, and values are the same if they are equal and 
have exactly the same type.</P>
<P>There is an exception to this rule: If a processor evaluates an operand 
<EM>E</EM> (wholly or in part), then it is required to establish that the actual 
value of the operand <EM>E</EM> does not violate any constraints on its 
cardinality. For example, the expression <CODE>$e eq 0</CODE> results in a type 
error if the value of <CODE>$e</CODE> contains two or more items. A processor is 
not allowed to decide, after evaluating the first item in the value of 
<CODE>$e</CODE> and finding it equal to zero, that the only possible outcomes 
are the value <CODE>true</CODE> or a type error caused by the cardinality 
violation. It must establish that the value of <CODE>$e</CODE> contains no more 
than one item.</P>
<P>These rules apply to all the operands of an expression considered in 
combination: thus if an expression has two operands <EM>E1</EM> and <EM>E2</EM>, 
it may be evaluated using any samples of the respective sequences that satisfy 
the above rules.</P>
<P>The rules cascade: if <EM>A</EM> is an operand of <EM>B</EM> and <EM>B</EM> 
is an operand of <EM>C</EM>, then the processor needs to evaluate only a 
sufficient sample of <EM>B</EM> to determine the value of <EM>C</EM>, and needs 
to evaluate only a sufficient sample of <EM>A</EM> to determine this sample of 
<EM>B</EM>.</P>
<P>The effect of these rules is that the processor is free to stop examining 
further items in a sequence as soon as it can establish that further items would 
not affect the result except possibly by causing an error. For example, the 
processor may return <CODE>true</CODE> as the result of the expression <CODE>S1 
= S2</CODE> as soon as it finds a pair of equal values from the two 
sequences.</P>
<P>Another consequence of these rules is that where none of the items in a 
sequence contributes to the result of an expression, the processor is not 
obliged to evaluate any part of the sequence. Again, however, the processor 
cannot dispense with a required cardinality check: if an empty sequence is not 
permitted in the relevant context, then the processor must ensure that the 
operand is not an empty sequence.</P>
<P>Examples:</P>
<UL>
  <LI>
  <P>If an implementation can find (for example, by using an index) that at 
  least one item returned by <CODE>$expr1</CODE> in the following example has 
  the value <CODE>47</CODE>, it is allowed to return <CODE>true</CODE> as the 
  result of the <CODE>some</CODE> expression, without searching for another item 
  returned by <CODE>$expr1</CODE> that would raise an error if it were 
  evaluated.</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>some $x in $expr1 satisfies $x = 47
</PRE></DIV></DIV>
  <LI>
  <P>In the following example, if an implementation can find (for example, by 
  using an index) the <CODE>product</CODE> element-nodes that have an 
  <CODE>id</CODE> child with the value <CODE>47</CODE>, it is allowed to return 
  these nodes as the result of the <A title="path expression" 
  href="REC-xpath20-20070123.htm#dt-path-expression">path 
  expression</A>, without searching for another <CODE>product</CODE> node that 
  would raise an error because it has an <CODE>id</CODE> child whose value is 
  not an integer.</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>//product[id = 47]
</PRE></DIV></DIV></LI></UL>
<P>For a variety of reasons, including optimization, implementations are free to 
rewrite expressions into equivalent expressions. Other than the raising or not 
raising of errors, the result of evaluating an equivalent expression must be the 
same as the result of evaluating the original expression. Expression rewrite is 
illustrated by the following examples.</P>
<UL>
  <LI>
  <P>Consider the expression <CODE>//part[color eq "Red"]</CODE>. An 
  implementation might choose to rewrite this expression as <CODE>//part[color = 
  "Red"][color eq "Red"]</CODE>. The implementation might then process the 
  expression as follows: First process the "<CODE>=</CODE>" predicate by probing 
  an index on parts by color to quickly find all the parts that have a Red 
  color; then process the "<CODE>eq</CODE>" predicate by checking each of these 
  parts to make sure it has only a single color. The result would be as 
  follows:</P>
  <UL>
    <LI>
    <P>Parts that have exactly one color that is Red are returned.</P>
    <LI>
    <P>If some part has color Red together with some other color, an error is 
    raised.</P>
    <LI>
    <P>The existence of some part that has no color Red but has multiple non-Red 
    colors does not trigger an error.</P></LI></UL>
  <LI>
  <P>The expression in the following example cannot raise a casting error if it 
  is evaluated exactly as written (i.e., left to right). Since neither predicate 
  depends on the context position, an implementation might choose to reorder the 
  predicates to achieve better performance (for example, by taking advantage of 
  an index). This reordering could cause the expression to raise an error.</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>$N[@x castable as xs:date][xs:date(@x) gt xs:date("2000-01-01")]
</PRE></DIV></DIV>
  <P>To avoid unexpected errors caused by expression rewrite, tests that are 
  designed to prevent dynamic errors should be expressed using conditional 
  expressions. Conditional expressions raise only dynamic errors that occur in 
  the branch that is actually selected. Thus, unlike the previous example, the 
  following example cannot raise a dynamic error if <CODE>@x</CODE> is not 
  castable into an <CODE>xs:date</CODE>:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>$N[if (@x castable as xs:date)
   then xs:date(@x) gt xs:date("2000-01-01")
   else false()]
</PRE></DIV></DIV></LI></UL></DIV></DIV>
<DIV class=div2>
<H3><A id=id-important-concepts name=id-important-concepts></A>2.4 Concepts</H3>
<P>This section explains some concepts that are important to the processing of 
XPath expressions.</P>
<DIV class=div3>
<H4><A id=id-document-order name=id-document-order></A>2.4.1 Document Order</H4>
<P>An ordering called <B>document order</B> is defined among all the nodes 
accessible during processing of a given <SPAN class=xpath><SPAN 
class=xpath>expression</SPAN></SPAN>, which may consist of one or more 
<B>trees</B> (documents or fragments). Document order is defined in <A 
href="REC-xpath20-20070123.htm#datamodel">[XQuery/XPath 
Data Model (XDM)]</A>, and its definition is repeated here for convenience. [<A 
id=dt-reverse-document-order title="reverse document order" 
name=dt-reverse-document-order>Definition</A>: The node ordering that is the 
reverse of document order is called <B>reverse document order</B>.]</P>
<P>Document order is a total ordering, although the relative order of some nodes 
is <A title="implementation dependent" 
href="REC-xpath20-20070123.htm#dt-implementation-dependent">implementation-dependent</A>. 
[<A id=dt-document-order title="document order" 
name=dt-document-order>Definition</A>: Informally, <B>document order</B> is the 
order in which nodes appear in the XML serialization of a document.] [<A 
id=stable title=stable name=stable>Definition</A>: Document order is 
<B>stable</B>, which means that the relative order of two nodes will not change 
during the processing of a given <SPAN class=xpath><SPAN 
class=xpath>expression</SPAN></SPAN>, even if this order is <A 
title="implementation dependent" 
href="REC-xpath20-20070123.htm#dt-implementation-dependent">implementation-dependent</A>.]</P>
<P>Within a tree, document order satisfies the following constraints:</P>
<OL class=enumar>
  <LI>
  <P>The root node is the first node.</P>
  <LI>
  <P>Every node occurs before all of its children and descendants.</P>
  <LI class=xpath>
  <P>Namespace nodes immediately follow the element node with which they are 
  associated. The relative order of namespace nodes is stable but <A 
  title="implementation dependent" 
  href="REC-xpath20-20070123.htm#dt-implementation-dependent">implementation-dependent</A>.</P>
  <LI>
  <P>Attribute nodes immediately follow the <SPAN class=xpath><SPAN 
  class=xpath>namespace nodes of the</SPAN></SPAN> element node with which they 
  are associated. The relative order of attribute nodes is stable but <A 
  title="implementation dependent" 
  href="REC-xpath20-20070123.htm#dt-implementation-dependent">implementation-dependent</A>.</P>
  <LI>
  <P>The relative order of siblings is the order in which they occur in the 
  <CODE>children</CODE> property of their parent node.</P>
  <LI>
  <P>Children and descendants occur before following siblings.</P></LI></OL>
<P>The relative order of nodes in distinct trees is stable but <A 
title="implementation dependent" 
href="REC-xpath20-20070123.htm#dt-implementation-dependent">implementation-dependent</A>, 
subject to the following constraint: If any node in a given tree T1 is before 
any node in a different tree T2, then all nodes in tree T1 are before all nodes 
in tree T2.</P></DIV>
<DIV class=div3>
<H4><A id=id-atomization name=id-atomization></A>2.4.2 Atomization</H4>
<P>The semantics of some XPath operators depend on a process called <A 
title=atomization 
href="REC-xpath20-20070123.htm#dt-atomization">atomization</A>. 
Atomization is applied to a value when the value is used in a context in which a 
sequence of atomic values is required. The result of atomization is either a 
sequence of atomic values or a <A title="type error" 
href="REC-xpath20-20070123.htm#dt-type-error">type 
error</A> [err:FOTY0012]. [<A id=dt-atomization title=atomization 
name=dt-atomization>Definition</A>: <B>Atomization</B> of a sequence is defined 
as the result of invoking the <CODE>fn:data</CODE> function on the sequence, as 
defined in <A 
href="REC-xpath20-20070123.htm#FunctionsAndOperators">[XQuery 
1.0 and XPath 2.0 Functions and Operators]</A>.]</P>
<P>The semantics of <CODE>fn:data</CODE> are repeated here for convenience. The 
result of <CODE>fn:data</CODE> is the sequence of atomic values produced by 
applying the following rules to each item in the input sequence:</P>
<UL>
  <LI>
  <P>If the item is an atomic value, it is returned.</P>
  <LI>
  <P>If the item is a node, its <A title="typed value" 
  href="REC-xpath20-20070123.htm#dt-typed-value">typed 
  value</A> is returned (err:FOTY0012 is raised if the node has no typed 
  value.)</P></LI></UL>
<P>Atomization is used in processing the following types of expressions:</P>
<UL>
  <LI>
  <P>Arithmetic expressions</P>
  <LI>
  <P>Comparison expressions</P>
  <LI>
  <P>Function calls and returns</P>
  <LI>
  <P>Cast expressions</P></LI></UL></DIV>
<DIV class=div3>
<H4><A id=id-ebv name=id-ebv></A>2.4.3 Effective Boolean Value</H4>
<P>Under certain circumstances (listed below), it is necessary to find the <A 
title="effective boolean value" 
href="REC-xpath20-20070123.htm#dt-ebv">effective boolean 
value</A> of a value. [<A id=dt-ebv title="effective boolean value" 
name=dt-ebv>Definition</A>: The <B>effective boolean value</B> of a value is 
defined as the result of applying the <CODE>fn:boolean</CODE> function to the 
value, as defined in <A 
href="REC-xpath20-20070123.htm#FunctionsAndOperators">[XQuery 
1.0 and XPath 2.0 Functions and Operators]</A>.]</P>
<P>The dynamic semantics of <CODE>fn:boolean</CODE> are repeated here for 
convenience:</P>
<OL class=enumar>
  <LI>
  <P>If its operand is an empty sequence, <CODE>fn:boolean</CODE> returns 
  <CODE>false</CODE>.</P>
  <LI>
  <P>If its operand is a sequence whose first item is a node, 
  <CODE>fn:boolean</CODE> returns <CODE>true</CODE>.</P>
  <LI>
  <P>If its operand is a <A title=singleton 
  href="REC-xpath20-20070123.htm#dt-singleton">singleton</A> 
  value of type <CODE>xs:boolean</CODE> or derived from <CODE>xs:boolean</CODE>, 
  <CODE>fn:boolean</CODE> returns the value of its operand unchanged.</P>
  <LI>
  <P>If its operand is a <A title=singleton 
  href="REC-xpath20-20070123.htm#dt-singleton">singleton</A> 
  value of type <CODE>xs:string</CODE>, <CODE>xs:anyURI</CODE>, 
  <CODE>xs:untypedAtomic</CODE>, or a type derived from one of these, 
  <CODE>fn:boolean</CODE> returns <CODE>false</CODE> if the operand value has 
  zero length; otherwise it returns <CODE>true</CODE>.</P>
  <LI>
  <P>If its operand is a <A title=singleton 
  href="REC-xpath20-20070123.htm#dt-singleton">singleton</A> 
  value of any <A title=numeric 
  href="REC-xpath20-20070123.htm#dt-numeric">numeric</A> 
  type or derived from a numeric type, <CODE>fn:boolean</CODE> returns 
  <CODE>false</CODE> if the operand value is <CODE>NaN</CODE> or is numerically 
  equal to zero; otherwise it returns <CODE>true</CODE>.</P>
  <LI>
  <P>In all other cases, <CODE>fn:boolean</CODE> raises a type error 
  [err:FORG0006].</P></LI></OL>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>The static semantics of <CODE>fn:boolean</CODE> are defined in <A 
href="http://www.w3.org/TR/xquery-semantics/#sec_fn_boolean">Section 7.2.4 The 
fn:boolean function</A><SUP><SMALL>FS</SMALL></SUP>.</P></DIV>
<P>The <A title="effective boolean value" 
href="REC-xpath20-20070123.htm#dt-ebv">effective boolean 
value</A> of a sequence is computed implicitly during processing of the 
following types of expressions:</P>
<UL>
  <LI>
  <P>Logical expressions (<CODE>and</CODE>, <CODE>or</CODE>)</P>
  <LI>
  <P>The <CODE>fn:not</CODE> function</P>
  <LI>
  <P>Certain types of <A title=predicate 
  href="REC-xpath20-20070123.htm#dt-predicate">predicates</A>, 
  such as <CODE>a[b]</CODE></P>
  <LI>
  <P>Conditional expressions (<CODE>if</CODE>)</P>
  <LI>
  <P>Quantified expressions (<CODE>some</CODE>, <CODE>every</CODE>)</P>
  <LI class=xpath>
  <P>General comparisons, in <A title="XPath 1.0 compatibility mode" 
  href="REC-xpath20-20070123.htm#dt-xpath-compat-mode">XPath 
  1.0 compatibility mode</A>.</P></LI></UL>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>The definition of <A title="effective boolean value" 
href="REC-xpath20-20070123.htm#dt-ebv">effective boolean 
value</A> is <EM>not</EM> used when casting a value to the type 
<CODE>xs:boolean</CODE>, for example in a <CODE>cast</CODE> expression or when 
passing a value to a function whose expected parameter is of type 
<CODE>xs:boolean</CODE>.</P></DIV></DIV>
<DIV class=div3>
<H4><A id=id-input-sources name=id-input-sources></A>2.4.4 Input Sources</H4>
<P>XPath has a set of functions that provide access to input data. These 
functions are of particular importance because they provide a way in which an 
expression can reference a document or a collection of documents. The input 
functions are described informally here; they are defined in <A 
href="REC-xpath20-20070123.htm#FunctionsAndOperators">[XQuery 
1.0 and XPath 2.0 Functions and Operators]</A>.</P>
<P>An expression can access input data either by calling one of the input 
functions or by referencing some part of the <A title="dynamic context" 
href="REC-xpath20-20070123.htm#dt-dynamic-context">dynamic 
context</A> that is initialized by the external environment, such as a <A 
title="variable values" 
href="REC-xpath20-20070123.htm#dt-variable-values">variable</A> 
or <A title="context item" 
href="REC-xpath20-20070123.htm#dt-context-item">context 
item</A>.</P>
<P>The input functions supported by XPath are as follows:</P>
<UL>
  <LI>
  <P>The <CODE>fn:doc</CODE> function takes a string containing a URI. If that 
  URI is associated with a document in <A title="available documents" 
  href="REC-xpath20-20070123.htm#dt-available-docs">available 
  documents</A>, <CODE>fn:doc</CODE> returns a document node whose content is 
  the <A title="data model" 
  href="REC-xpath20-20070123.htm#dt-datamodel">data 
  model</A> representation of the given document; otherwise it raises a <A 
  title="dynamic error" 
  href="REC-xpath20-20070123.htm#dt-dynamic-error">dynamic 
  error</A> (see <A 
  href="REC-xpath20-20070123.htm#FunctionsAndOperators">[XQuery 
  1.0 and XPath 2.0 Functions and Operators]</A> for details).</P>
  <LI>
  <P>The <CODE>fn:collection</CODE> function with one argument takes a string 
  containing a URI. If that URI is associated with a collection in <A 
  title="available collections" 
  href="REC-xpath20-20070123.htm#dt-available-collections">available 
  collections</A>, <CODE>fn:collection</CODE> returns the data model 
  representation of that collection; otherwise it raises a <A 
  title="dynamic error" 
  href="REC-xpath20-20070123.htm#dt-dynamic-error">dynamic 
  error</A> (see <A 
  href="REC-xpath20-20070123.htm#FunctionsAndOperators">[XQuery 
  1.0 and XPath 2.0 Functions and Operators]</A> for details). A collection may 
  be any sequence of nodes. For example, the expression 
  <CODE>fn:collection("http://example.org")//customer</CODE> identifies all the 
  <CODE>customer</CODE> elements that are descendants of nodes found in the 
  collection whose URI is <CODE>http://example.org</CODE>.</P>
  <LI>
  <P>The <CODE>fn:collection</CODE> function with zero arguments returns the <A 
  title="default collection" 
  href="REC-xpath20-20070123.htm#dt-default-collection">default 
  collection</A>, an <A title="implementation dependent" 
  href="REC-xpath20-20070123.htm#dt-implementation-dependent">implementation-dependent</A> 
  sequence of nodes.</P></LI></UL></DIV></DIV>
<DIV class=div2>
<H3><A id=id-types name=id-types></A>2.5 Types</H3>
<P>The type system of XPath is based on <A 
href="REC-xpath20-20070123.htm#XMLSchema">[XML 
Schema]</A>, and is formally defined in <A 
href="REC-xpath20-20070123.htm#XQueryFormalSemantics">[XQuery 
1.0 and XPath 2.0 Formal Semantics]</A>.</P>
<P>[<A id=dt-sequence-type title="sequence type" 
name=dt-sequence-type>Definition</A>: A <B>sequence type</B> is a type that can 
be expressed using the <A 
href="REC-xpath20-20070123.htm#doc-xpath-SequenceType">SequenceType</A> 
syntax. Sequence types are used whenever it is necessary to refer to a type in 
an XPath expression. The term <B>sequence type</B> suggests that this syntax is 
used to describe the type of an XPath value, which is always a sequence.]</P>
<P>[<A id=dt-schema-type title="schema type" name=dt-schema-type>Definition</A>: 
A <B>schema type</B> is a type that is (or could be) defined using the 
facilities of <A 
href="REC-xpath20-20070123.htm#XMLSchema">[XML 
Schema]</A> (including the built-in types of <A 
href="REC-xpath20-20070123.htm#XMLSchema">[XML 
Schema]</A>).] A schema type can be used as a type annotation on an element or 
attribute node (unless it is a non-instantiable type such as 
<CODE>xs:NOTATION</CODE> or <CODE>xs:anyAtomicType</CODE>, in which case its 
derived types can be so used). Every schema type is either a <B>complex type</B> 
or a <B>simple type</B>; simple types are further subdivided into <B>list 
types</B>, <B>union types</B>, and <B>atomic types</B> (see <A 
href="REC-xpath20-20070123.htm#XMLSchema">[XML 
Schema]</A> for definitions and explanations of these terms.)</P>
<P>Atomic types represent the intersection between the categories of <A 
title="sequence type" 
href="REC-xpath20-20070123.htm#dt-sequence-type">sequence 
type</A> and <A title="schema type" 
href="REC-xpath20-20070123.htm#dt-schema-type">schema 
type</A>. An atomic type, such as <CODE>xs:integer</CODE> or 
<CODE>my:hatsize</CODE>, is both a <A title="sequence type" 
href="REC-xpath20-20070123.htm#dt-sequence-type">sequence 
type</A> and a <A title="schema type" 
href="REC-xpath20-20070123.htm#dt-schema-type">schema 
type</A>.</P>
<DIV class=div3>
<H4><A id=id-predefined-types name=id-predefined-types></A>2.5.1 Predefined 
Schema Types</H4>
<DIV class=xpath>
<P class=xpath>The <A title="in-scope schema type" 
href="REC-xpath20-20070123.htm#dt-is-types">in-scope 
schema types</A> in the <A title="static context" 
href="REC-xpath20-20070123.htm#dt-static-context">static 
context</A> are initialized with a set of predefined schema types that is 
determined by the host language. This set may include some or all of the schema 
types in the namespace <CODE>http://www.w3.org/2001/XMLSchema</CODE>, 
represented in this document by the namespace prefix <CODE>xs</CODE>. The schema 
types in this namespace are defined in <A 
href="REC-xpath20-20070123.htm#XMLSchema">[XML 
Schema]</A> and augmented by additional types defined in <A 
href="REC-xpath20-20070123.htm#datamodel">[XQuery/XPath 
Data Model (XDM)]</A>. The schema types defined in <A 
href="REC-xpath20-20070123.htm#datamodel">[XQuery/XPath 
Data Model (XDM)]</A> are summarized below.</P></DIV>
<OL class=enumar>
  <LI>
  <P>[<A id=dt-untyped title=xs:untyped name=dt-untyped>Definition</A>: 
  <CODE>xs:untyped</CODE> is used as the <A title="type annotation" 
  href="REC-xpath20-20070123.htm#dt-type-annotation">type 
  annotation</A> of an element node that has not been validated, or has been 
  validated in <CODE>skip</CODE> mode.] No predefined schema types are derived 
  from <CODE>xs:untyped</CODE>.</P>
  <LI>
  <P>[<A id=dt-untypedAtomic title=xs:untypedAtomic 
  name=dt-untypedAtomic>Definition</A>: <CODE>xs:untypedAtomic</CODE> is an 
  atomic type that is used to denote untyped atomic data, such as text that has 
  not been assigned a more specific type.] An attribute that has been validated 
  in <CODE>skip</CODE> mode is represented in the <A title="data model" 
  href="REC-xpath20-20070123.htm#dt-datamodel">data 
  model</A> by an attribute node with the <A title="type annotation" 
  href="REC-xpath20-20070123.htm#dt-type-annotation">type 
  annotation</A> <CODE>xs:untypedAtomic</CODE>. No predefined schema types are 
  derived from <CODE>xs:untypedAtomic</CODE>.</P>
  <LI>
  <P>[<A id=dt-dayTimeDuration title=xs:dayTimeDuration 
  name=dt-dayTimeDuration>Definition</A>: <CODE>xs:dayTimeDuration</CODE> is 
  derived by restriction from <CODE>xs:duration</CODE>. The lexical 
  representation of <CODE>xs:dayTimeDuration</CODE> is restricted to contain 
  only day, hour, minute, and second components.]</P>
  <LI>
  <P>[<A id=dt-yearMonthDuration title=xs:yearMonthDuration 
  name=dt-yearMonthDuration>Definition</A>: <CODE>xs:yearMonthDuration</CODE> is 
  derived by restriction from <CODE>xs:duration</CODE>. The lexical 
  representation of <CODE>xs:yearMonthDuration</CODE> is restricted to contain 
  only year and month components.]</P>
  <LI>
  <P>[<A id=dt-anyAtomicType title=xs:anyAtomicType 
  name=dt-anyAtomicType>Definition</A>: <CODE>xs:anyAtomicType</CODE> is an 
  atomic type that includes all atomic values (and no values that are not 
  atomic). Its base type is <CODE>xs:anySimpleType</CODE> from which all simple 
  types, including atomic, list, and union types, are derived. All primitive 
  atomic types, such as <CODE>xs:integer</CODE>, <CODE>xs:string</CODE>, and 
  <CODE>xs:untypedAtomic</CODE>, have <CODE>xs:anyAtomicType</CODE> as their 
  base type.]</P>
  <DIV class=note>
  <P class=prefix><B>Note:</B></P>
  <P><CODE>xs:anyAtomicType</CODE> will not appear as the type of an actual 
  value in an <A title="XDM instance" 
  href="REC-xpath20-20070123.htm#dt-data-model-instance">XDM 
  instance</A>.</P></DIV></LI></OL>
<P>The relationships among the schema types in the <CODE>xs</CODE> namespace are 
illustrated in Figure 2. A more complete description of the XPath type hierarchy 
can be found in <A 
href="REC-xpath20-20070123.htm#FunctionsAndOperators">[XQuery 
1.0 and XPath 2.0 Functions and Operators]</A>.</P><IMG 
alt="Type Hierarchy Diagram" src="REC-xpath20-20070123_files/types.jpg"> 
<P>Figure 2: Hierarchy of Schema Types used in XPath</P></DIV>
<DIV class=div3>
<H4><A id=id-typed-value name=id-typed-value></A>2.5.2 Typed Value and String 
Value</H4>
<P>Every node has a <B>typed value</B> and a <B>string value</B>. [<A 
id=dt-typed-value title="typed value" name=dt-typed-value>Definition</A>: The 
<B>typed value</B> of a node is a sequence of atomic values and can be extracted 
by applying the <CODE>fn:data</CODE> function to the node.] [<A 
id=dt-string-value title="string value" name=dt-string-value>Definition</A>: The 
<B>string value</B> of a node is a string and can be extracted by applying the 
<CODE>fn:string</CODE> function to the node.] Definitions of 
<CODE>fn:data</CODE> and <CODE>fn:string</CODE> can be found in <A 
href="REC-xpath20-20070123.htm#FunctionsAndOperators">[XQuery 
1.0 and XPath 2.0 Functions and Operators]</A>.</P>
<P>An implementation may store both the <A title="typed value" 
href="REC-xpath20-20070123.htm#dt-typed-value">typed 
value</A> and the <A title="string value" 
href="REC-xpath20-20070123.htm#dt-string-value">string 
value</A> of a node, or it may store only one of these and derive the other as 
needed. The string value of a node must be a valid lexical representation of the 
typed value of the node, but the node is not required to preserve the string 
representation from the original source document. For example, if the typed 
value of a node is the <CODE>xs:integer</CODE> value <CODE>30</CODE>, its string 
value might be "<CODE>30</CODE>" or "<CODE>0030</CODE>".</P>
<DIV class=xpath>
<P class=xpath>The <A title="typed value" 
href="REC-xpath20-20070123.htm#dt-typed-value">typed 
value</A>, <A title="string value" 
href="REC-xpath20-20070123.htm#dt-string-value">string 
value</A>, and <A title="type annotation" 
href="REC-xpath20-20070123.htm#dt-type-annotation">type 
annotation</A> of a node are closely related. If the node was created by mapping 
from an Infoset or PSVI, the relationships among these properties are defined by 
rules in <A 
href="REC-xpath20-20070123.htm#datamodel">[XQuery/XPath 
Data Model (XDM)]</A>.</P></DIV>
<P>As a convenience to the reader, the relationship between <A 
title="typed value" 
href="REC-xpath20-20070123.htm#dt-typed-value">typed 
value</A> and <A title="string value" 
href="REC-xpath20-20070123.htm#dt-string-value">string 
value</A> for various kinds of nodes is summarized and illustrated by examples 
below.</P>
<OL class=enumar>
  <LI>
  <P>For text and document nodes, the typed value of the node is the same as its 
  string value, as an instance of the type <CODE>xs:untypedAtomic</CODE>. The 
  string value of a document node is formed by concatenating the string values 
  of all its descendant text nodes, in <A title="document order" 
  href="REC-xpath20-20070123.htm#dt-document-order">document 
  order</A>.</P>
  <LI>
  <P>The typed value of a comment<SPAN class=xpath><SPAN class=xpath>, 
  namespace,</SPAN></SPAN> or processing instruction node is the same as its 
  string value. It is an instance of the type <CODE>xs:string</CODE>.</P>
  <LI>
  <P>The typed value of an attribute node with the <A title="type annotation" 
  href="REC-xpath20-20070123.htm#dt-type-annotation">type 
  annotation</A> <CODE>xs:anySimpleType</CODE> or <CODE>xs:untypedAtomic</CODE> 
  is the same as its string value, as an instance of 
  <CODE>xs:untypedAtomic</CODE>. The typed value of an attribute node with any 
  other type annotation is derived from its string value and type annotation 
  using the lexical-to-value-space mapping defined in <A 
  href="REC-xpath20-20070123.htm#XMLSchema">[XML 
  Schema]</A> Part 2 for the relevant type.</P>
  <P>Example: A1 is an attribute having string value <CODE>"3.14E-2"</CODE> and 
  type annotation <CODE>xs:double</CODE>. The typed value of A1 is the 
  <CODE>xs:double</CODE> value whose lexical representation is 
  <CODE>3.14E-2</CODE>.</P>
  <P>Example: A2 is an attribute with type annotation <CODE>xs:IDREFS</CODE>, 
  which is a list datatype whose item type is the atomic datatype 
  <CODE>xs:IDREF</CODE>. Its string value is "<CODE>bar baz faz</CODE>". The 
  typed value of A2 is a sequence of three atomic values ("<CODE>bar</CODE>", 
  "<CODE>baz</CODE>", "<CODE>faz</CODE>"), each of type <CODE>xs:IDREF</CODE>. 
  The typed value of a node is never treated as an instance of a named list 
  type. Instead, if the type annotation of a node is a list type (such as 
  <CODE>xs:IDREFS</CODE>), its typed value is treated as a sequence of the 
  atomic type from which it is derived (such as <CODE>xs:IDREF</CODE>).</P>
  <LI>
  <P>For an element node, the relationship between typed value and string value 
  depends on the node's <A title="type annotation" 
  href="REC-xpath20-20070123.htm#dt-type-annotation">type 
  annotation</A>, as follows:</P>
  <OL class=enumla>
    <LI>
    <P>If the type annotation is <CODE>xs:untyped</CODE> or 
    <CODE>xs:anySimpleType</CODE> or denotes a complex type with mixed content 
    (including <CODE>xs:anyType</CODE>), then the typed value of the node is 
    equal to its string value, as an instance of <CODE>xs:untypedAtomic</CODE>. 
    However, if the <CODE>nilled</CODE> property of the node is 
    <CODE>true</CODE>, then its typed value is the empty sequence.</P>
    <P>Example: E1 is an element node having type annotation 
    <CODE>xs:untyped</CODE> and string value "<CODE>1999-05-31</CODE>". The 
    typed value of E1 is "<CODE>1999-05-31</CODE>", as an instance of 
    <CODE>xs:untypedAtomic</CODE>.</P>
    <P>Example: E2 is an element node with the type annotation 
    <CODE>formula</CODE>, which is a complex type with mixed content. The 
    content of E2 consists of the character "<CODE>H</CODE>", a child element 
    named <CODE>subscript</CODE> with string value "<CODE>2</CODE>", and the 
    character "<CODE>O</CODE>". The typed value of E2 is "<CODE>H2O</CODE>" as 
    an instance of <CODE>xs:untypedAtomic</CODE>.</P>
    <LI>
    <P>If the type annotation denotes a simple type or a complex type with 
    simple content, then the typed value of the node is derived from its string 
    value and its type annotation in a way that is consistent with schema 
    validation. However, if the <CODE>nilled</CODE> property of the node is 
    <CODE>true</CODE>, then its typed value is the empty sequence.</P>
    <P>Example: E3 is an element node with the type annotation 
    <CODE>cost</CODE>, which is a complex type that has several attributes and a 
    simple content type of <CODE>xs:decimal</CODE>. The string value of E3 is 
    "<CODE>74.95</CODE>". The typed value of E3 is <CODE>74.95</CODE>, as an 
    instance of <CODE>xs:decimal</CODE>.</P>
    <P>Example: E4 is an element node with the type annotation 
    <CODE>hatsizelist</CODE>, which is a simple type derived from the atomic 
    type <CODE>hatsize</CODE>, which in turn is derived from 
    <CODE>xs:integer</CODE>. The string value of E4 is "<CODE>7 8 9</CODE>". The 
    typed value of E4 is a sequence of three values (<CODE>7</CODE>, 
    <CODE>8</CODE>, <CODE>9</CODE>), each of type <CODE>hatsize</CODE>.</P>
    <P>Example: E5 is an element node with the type annotation 
    <CODE>my:integer-or-string</CODE> which is a union type with member types 
    <CODE>xs:integer</CODE> and <CODE>xs:string</CODE>. The string value of E5 
    is "<CODE>47</CODE>". The typed value of E5 is <CODE>47</CODE> as an 
    <CODE>xs:integer</CODE>, since <CODE>xs:integer</CODE> is the member type 
    that validated the content of E5. In general, when the type annotation of a 
    node is a union type, the typed value of the node will be an instance of one 
    of the member types of the union.</P>
    <DIV class=note>
    <P class=prefix><B>Note:</B></P>
    <P>If an implementation stores only the string value of a node, and the type 
    annotation of the node is a union type, the implementation must be able to 
    deliver the typed value of the node as an instance of the appropriate member 
    type.</P></DIV>
    <LI>
    <P>If the type annotation denotes a complex type with empty content, then 
    the typed value of the node is the empty sequence and its string value is 
    the zero-length string.</P>
    <LI>
    <P>If the type annotation denotes a complex type with element-only content, 
    then the typed value of the node is undefined. The <CODE>fn:data</CODE> 
    function raises a <A title="type error" 
    href="REC-xpath20-20070123.htm#dt-type-error">type 
    error</A> [err:FOTY0012] when applied to such a node. The string value of 
    such a node is equal to the concatenated string values of all its text node 
    descendants, in document order.</P>
    <P>Example: E6 is an element node with the type annotation 
    <CODE>weather</CODE>, which is a complex type whose content type specifies 
    <CODE>element-only</CODE>. E6 has two child elements named 
    <CODE>temperature</CODE> and <CODE>precipitation</CODE>. The typed value of 
    E6 is undefined, and the <CODE>fn:data</CODE> function applied to E6 raises 
    an error.</P></LI></OL></LI></OL></DIV>
<DIV class=div3>
<H4><A id=id-sequencetype-syntax name=id-sequencetype-syntax></A>2.5.3 
SequenceType Syntax</H4>
<P>Whenever it is necessary to refer to a type in an XPath expression, the <A 
href="REC-xpath20-20070123.htm#doc-xpath-SequenceType">SequenceType</A> 
syntax is used.</P>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-SequenceType 
      name=doc-xpath-SequenceType></A>[50]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-SequenceType">SequenceType</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>("empty-sequence" "(" ")")<BR>| (<A 
      href="REC-xpath20-20070123.htm#doc-xpath-ItemType">ItemType</A> 
      <A 
      href="REC-xpath20-20070123.htm#doc-xpath-OccurrenceIndicator">OccurrenceIndicator</A>?)</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-ItemType 
    name=doc-xpath-ItemType></A>[52]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-ItemType">ItemType</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-KindTest">KindTest</A> 
      | ("item" "(" ")") | <A 
      href="REC-xpath20-20070123.htm#doc-xpath-AtomicType">AtomicType</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-OccurrenceIndicator 
      name=doc-xpath-OccurrenceIndicator></A>[51]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-OccurrenceIndicator">OccurrenceIndicator</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"?" | "*" | "+"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-AtomicType 
      name=doc-xpath-AtomicType></A>[53]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-AtomicType">AtomicType</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-QName">QName</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-KindTest 
    name=doc-xpath-KindTest></A>[54]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-KindTest">KindTest</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-DocumentTest">DocumentTest</A><BR>| 
      <A 
      href="REC-xpath20-20070123.htm#doc-xpath-ElementTest">ElementTest</A><BR>| 
      <A 
      href="REC-xpath20-20070123.htm#doc-xpath-AttributeTest">AttributeTest</A><BR>| 
      <A 
      href="REC-xpath20-20070123.htm#doc-xpath-SchemaElementTest">SchemaElementTest</A><BR>| 
      <A 
      href="REC-xpath20-20070123.htm#doc-xpath-SchemaAttributeTest">SchemaAttributeTest</A><BR>| 
      <A 
      href="REC-xpath20-20070123.htm#doc-xpath-PITest">PITest</A><BR>| 
      <A 
      href="REC-xpath20-20070123.htm#doc-xpath-CommentTest">CommentTest</A><BR>| 
      <A 
      href="REC-xpath20-20070123.htm#doc-xpath-TextTest">TextTest</A><BR>| 
      <A 
      href="REC-xpath20-20070123.htm#doc-xpath-AnyKindTest">AnyKindTest</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-DocumentTest 
      name=doc-xpath-DocumentTest></A>[56]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-DocumentTest">DocumentTest</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"document-node" "(" (<A 
      href="REC-xpath20-20070123.htm#doc-xpath-ElementTest">ElementTest</A> 
      | <A 
      href="REC-xpath20-20070123.htm#doc-xpath-SchemaElementTest">SchemaElementTest</A>)? 
      ")"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-ElementTest 
      name=doc-xpath-ElementTest></A>[64]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-ElementTest">ElementTest</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"element" "(" (<A 
      href="REC-xpath20-20070123.htm#doc-xpath-ElementNameOrWildcard">ElementNameOrWildcard</A> 
      ("," <A 
      href="REC-xpath20-20070123.htm#doc-xpath-TypeName">TypeName</A> 
      "?"?)?)? ")"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-SchemaElementTest 
      name=doc-xpath-SchemaElementTest></A>[66]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-SchemaElementTest">SchemaElementTest</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"schema-element" "(" <A 
      href="REC-xpath20-20070123.htm#doc-xpath-ElementDeclaration">ElementDeclaration</A> 
      ")"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-ElementDeclaration 
      name=doc-xpath-ElementDeclaration></A>[67]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-ElementDeclaration">ElementDeclaration</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-ElementName">ElementName</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-AttributeTest 
      name=doc-xpath-AttributeTest></A>[60]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-AttributeTest">AttributeTest</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"attribute" "(" (<A 
      href="REC-xpath20-20070123.htm#doc-xpath-AttribNameOrWildcard">AttribNameOrWildcard</A> 
      ("," <A 
      href="REC-xpath20-20070123.htm#doc-xpath-TypeName">TypeName</A>)?)? 
      ")"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-SchemaAttributeTest 
      name=doc-xpath-SchemaAttributeTest></A>[62]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-SchemaAttributeTest">SchemaAttributeTest</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"schema-attribute" "(" <A 
      href="REC-xpath20-20070123.htm#doc-xpath-AttributeDeclaration">AttributeDeclaration</A> 
      ")"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-AttributeDeclaration 
      name=doc-xpath-AttributeDeclaration></A>[63]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-AttributeDeclaration">AttributeDeclaration</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-AttributeName">AttributeName</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-ElementNameOrWildcard 
      name=doc-xpath-ElementNameOrWildcard></A>[65]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-ElementNameOrWildcard">ElementNameOrWildcard</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-ElementName">ElementName</A> 
      | "*"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-ElementName 
      name=doc-xpath-ElementName></A>[69]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-ElementName">ElementName</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-QName">QName</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-AttribNameOrWildcard 
      name=doc-xpath-AttribNameOrWildcard></A>[61]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-AttribNameOrWildcard">AttribNameOrWildcard</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-AttributeName">AttributeName</A> 
      | "*"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-AttributeName 
      name=doc-xpath-AttributeName></A>[68]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-AttributeName">AttributeName</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-QName">QName</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-TypeName 
    name=doc-xpath-TypeName></A>[70]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-TypeName">TypeName</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-QName">QName</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-PITest 
    name=doc-xpath-PITest></A>[59]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-PITest">PITest</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"processing-instruction" "(" (<A 
      href="REC-xpath20-20070123.htm#prod-xpath-NCName">NCName</A> 
      | <A 
      href="REC-xpath20-20070123.htm#doc-xpath-StringLiteral">StringLiteral</A>)? 
      ")"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-CommentTest 
      name=doc-xpath-CommentTest></A>[58]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-CommentTest">CommentTest</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"comment" "(" ")"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-TextTest 
    name=doc-xpath-TextTest></A>[57]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-TextTest">TextTest</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"text" "(" ")"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-AnyKindTest 
      name=doc-xpath-AnyKindTest></A>[55]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-AnyKindTest">AnyKindTest</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"node" "(" ")"</CODE></TD></TR></TBODY></TABLE>
<P>With the exception of the special type <CODE>empty-sequence()</CODE>, a <A 
title="sequence type" 
href="REC-xpath20-20070123.htm#dt-sequence-type">sequence 
type</A> consists of an <B>item type</B> that constrains the type of each item 
in the sequence, and a <B>cardinality</B> that constrains the number of items in 
the sequence. Apart from the item type <CODE>item()</CODE>, which permits any 
kind of item, item types divide into <B>node types</B> (such as 
<CODE>element()</CODE>) and <B>atomic types</B> (such as 
<CODE>xs:integer</CODE>).</P>
<P>Item types representing element and attribute nodes may specify the required 
<A title="type annotation" 
href="REC-xpath20-20070123.htm#dt-type-annotation">type 
annotations</A> of those nodes, in the form of a <A title="schema type" 
href="REC-xpath20-20070123.htm#dt-schema-type">schema 
type</A>. Thus the item type <CODE>element(*, us:address)</CODE> denotes any 
element node whose type annotation is (or is derived from) the schema type named 
<CODE>us:address</CODE>.</P>
<P>Here are some examples of <A title="sequence type" 
href="REC-xpath20-20070123.htm#dt-sequence-type">sequence 
types</A> that might be used in XPath expressions:</P>
<UL>
  <LI>
  <P><CODE>xs:date</CODE> refers to the built-in atomic schema type named 
  <CODE>xs:date</CODE></P>
  <LI>
  <P><CODE>attribute()?</CODE> refers to an optional attribute node</P>
  <LI>
  <P><CODE>element()</CODE> refers to any element node</P>
  <LI>
  <P><CODE>element(po:shipto, po:address)</CODE> refers to an element node that 
  has the name <CODE>po:shipto</CODE> and has the type annotation 
  <CODE>po:address</CODE> (or a schema type derived from 
  <CODE>po:address</CODE>)</P>
  <LI>
  <P><CODE>element(*, po:address)</CODE> refers to an element node of any name 
  that has the type annotation <CODE>po:address</CODE> (or a type derived from 
  <CODE>po:address</CODE>)</P>
  <LI>
  <P><CODE>element(customer)</CODE> refers to an element node named 
  <CODE>customer</CODE> with any type annotation</P>
  <LI>
  <P><CODE>schema-element(customer)</CODE> refers to an element node whose name 
  is <CODE>customer</CODE> (or is in the substitution group headed by 
  <CODE>customer</CODE>) and whose type annotation matches the schema type 
  declared for a <CODE>customer</CODE> element in the <A 
  title="in-scope element declarations" 
  href="REC-xpath20-20070123.htm#dt-is-elems">in-scope 
  element declarations</A></P>
  <LI>
  <P><CODE>node()*</CODE> refers to a sequence of zero or more nodes of any 
  kind</P>
  <LI>
  <P><CODE>item()+</CODE> refers to a sequence of one or more nodes or atomic 
  values</P></LI></UL></DIV>
<DIV class=div3>
<H4><A id=id-sequencetype-matching name=id-sequencetype-matching></A>2.5.4 
SequenceType Matching</H4>
<P>[<A id=dt-sequencetype-matching title="SequenceType matching" 
name=dt-sequencetype-matching>Definition</A>: During evaluation of an 
expression, it is sometimes necessary to determine whether a value with a known 
<A title="dynamic type" 
href="REC-xpath20-20070123.htm#dt-dynamic-type">dynamic 
type</A> "matches" an expected <A title="sequence type" 
href="REC-xpath20-20070123.htm#dt-sequence-type">sequence 
type</A>. This process is known as <B>SequenceType matching</B>.] For example, 
an <CODE>instance of</CODE> expression returns <CODE>true</CODE> if the <A 
title="dynamic type" 
href="REC-xpath20-20070123.htm#dt-dynamic-type">dynamic 
type</A> of a given value matches a given <A title="sequence type" 
href="REC-xpath20-20070123.htm#dt-sequence-type">sequence 
type</A>, or <CODE>false</CODE> if it does not.</P>
<P>QNames appearing in a <A title="sequence type" 
href="REC-xpath20-20070123.htm#dt-sequence-type">sequence 
type</A> have their prefixes expanded to namespace URIs by means of the <A 
title="statically known namespaces" 
href="REC-xpath20-20070123.htm#dt-static-namespaces">statically 
known namespaces</A> and (where applicable) the <A 
title="default element/type namespace" 
href="REC-xpath20-20070123.htm#dt-def-elemtype-ns">default 
element/type namespace</A>. An unprefixed attribute QName is in no namespace. 
Equality of QNames is defined by the <CODE>eq</CODE> operator.</P>
<P>The rules for <A title="SequenceType matching" 
href="REC-xpath20-20070123.htm#dt-sequencetype-matching">SequenceType 
matching</A> compare the <A title="dynamic type" 
href="REC-xpath20-20070123.htm#dt-dynamic-type">dynamic 
type</A> of a value with an expected <A title="sequence type" 
href="REC-xpath20-20070123.htm#dt-sequence-type">sequence 
type</A>. These rules are a subset of the formal rules that match a value with 
an expected type defined in <A 
href="REC-xpath20-20070123.htm#XQueryFormalSemantics">[XQuery 
1.0 and XPath 2.0 Formal Semantics]</A>, because the Formal Semantics must be 
able to match values against types that are not expressible using the <A 
href="REC-xpath20-20070123.htm#doc-xpath-SequenceType">SequenceType</A> 
syntax.</P>
<P>Some of the rules for <A title="SequenceType matching" 
href="REC-xpath20-20070123.htm#dt-sequencetype-matching">SequenceType 
matching</A> require determining whether a given schema type is the same as or 
derived from an expected schema type. The given schema type may be "known" 
(defined in the <A title="in-scope schema definitions" 
href="REC-xpath20-20070123.htm#dt-issd">in-scope schema 
definitions</A>), or "unknown" (not defined in the <A 
title="in-scope schema definitions" 
href="REC-xpath20-20070123.htm#dt-issd">in-scope schema 
definitions</A>). An unknown schema type might be encountered, for example, if a 
source document has been validated using a schema that was not imported into the 
<A title="static context" 
href="REC-xpath20-20070123.htm#dt-static-context">static 
context</A>. In this case, an implementation is allowed (but is not required) to 
provide an <A title="implementation dependent" 
href="REC-xpath20-20070123.htm#dt-implementation-dependent">implementation-dependent</A> 
mechanism for determining whether the unknown schema type is derived from the 
expected schema type. For example, an implementation might maintain a data 
dictionary containing information about type hierarchies.</P>
<P>[<A id=dt-subtype-substitution title="subtype substitution" 
name=dt-subtype-substitution>Definition</A>: The use of a value whose <A 
title="dynamic type" 
href="REC-xpath20-20070123.htm#dt-dynamic-type">dynamic 
type</A> is derived from an expected type is known as <B>subtype 
substitution</B>.] Subtype substitution does not change the actual type of a 
value. For example, if an <CODE>xs:integer</CODE> value is used where an 
<CODE>xs:decimal</CODE> value is expected, the value retains its type as 
<CODE>xs:integer</CODE>.</P>
<P>The definition of <A title="SequenceType matching" 
href="REC-xpath20-20070123.htm#dt-sequencetype-matching">SequenceType 
matching</A> relies on a pseudo-function named <CODE>derives-from(</CODE><EM>AT, 
ET</EM><CODE>)</CODE>, which takes an actual simple or complex schema type 
<EM>AT</EM> and an expected simple or complex schema type <EM>ET</EM>, and 
either returns a boolean value or raises a <A title="type error" 
href="REC-xpath20-20070123.htm#dt-type-error">type 
error</A> [<A title=err:XPTY0004 
href="REC-xpath20-20070123.htm#ERRXPTY0004">err:XPTY0004</A>]. 
The pseudo-function <CODE>derives-from</CODE> is defined below and is defined 
formally in <A 
href="REC-xpath20-20070123.htm#XQueryFormalSemantics">[XQuery 
1.0 and XPath 2.0 Formal Semantics]</A>.</P>
<UL>
  <LI>
  <P><CODE>derives-from(</CODE><EM>AT</EM>, <EM>ET</EM><CODE>)</CODE> returns 
  <CODE>true</CODE> if <EM>ET</EM> is a known type and any of the following 
  three conditions is true:</P>
  <OL class=enumar>
    <LI>
    <P><EM>AT</EM> is a schema type found in the <A 
    title="in-scope schema definitions" 
    href="REC-xpath20-20070123.htm#dt-issd">in-scope 
    schema definitions</A>, and is the same as <EM>ET</EM> or is derived by 
    restriction or extension from <EM>ET</EM></P>
    <LI>
    <P><EM>AT</EM> is a schema type not found in the <A 
    title="in-scope schema definitions" 
    href="REC-xpath20-20070123.htm#dt-issd">in-scope 
    schema definitions</A>, and an <A title="implementation dependent" 
    href="REC-xpath20-20070123.htm#dt-implementation-dependent">implementation-dependent</A> 
    mechanism is able to determine that <EM>AT</EM> is derived by restriction 
    from <EM>ET</EM></P>
    <LI>
    <P>There exists some schema type <EM>IT</EM> such that 
    <CODE>derives-from(</CODE><EM>IT, ET</EM><CODE>)</CODE> and 
    <CODE>derives-from(</CODE><EM>AT, IT</EM><CODE>)</CODE> are 
true.</P></LI></OL>
  <LI>
  <P><CODE>derives-from(</CODE><EM>AT</EM>, <EM>ET</EM><CODE>)</CODE> returns 
  <CODE>false</CODE> if <EM>ET</EM> is a known type and either the first and 
  third or the second and third of the following conditions are true:</P>
  <OL class=enumar>
    <LI>
    <P><EM>AT</EM> is a schema type found in the <A 
    title="in-scope schema definitions" 
    href="REC-xpath20-20070123.htm#dt-issd">in-scope 
    schema definitions</A>, and is not the same as <EM>ET</EM>, and is not 
    derived by restriction or extension from <EM>ET</EM></P>
    <LI>
    <P><EM>AT</EM> is a schema type not found in the <A 
    title="in-scope schema definitions" 
    href="REC-xpath20-20070123.htm#dt-issd">in-scope 
    schema definitions</A>, and an <A title="implementation dependent" 
    href="REC-xpath20-20070123.htm#dt-implementation-dependent">implementation-dependent</A> 
    mechanism is able to determine that <EM>AT</EM> is not derived by 
    restriction from <EM>ET</EM></P>
    <LI>
    <P>No schema type <EM>IT</EM> exists such that 
    <CODE>derives-from(</CODE><EM>IT, ET</EM><CODE>)</CODE> and 
    <CODE>derives-from(</CODE><EM>AT, IT</EM><CODE>)</CODE> are 
true.</P></LI></OL>
  <LI>
  <P><CODE>derives-from(</CODE><EM>AT</EM>, <EM>ET</EM><CODE>)</CODE> raises a 
  <A title="type error" 
  href="REC-xpath20-20070123.htm#dt-type-error">type 
  error</A> [<A title=err:XPTY0004 
  href="REC-xpath20-20070123.htm#ERRXPTY0004">err:XPTY0004</A>] 
  if:</P>
  <OL class=enumar>
    <LI>
    <P><EM>ET</EM> is an unknown type, or</P>
    <LI>
    <P><EM>AT</EM> is an unknown type, and the implementation is not able to 
    determine whether <EM>AT</EM> is derived by restriction from 
    <EM>ET</EM>.</P></LI></OL></LI></UL>
<P>The rules for <A title="SequenceType matching" 
href="REC-xpath20-20070123.htm#dt-sequencetype-matching">SequenceType 
matching</A> are given below, with examples (the examples are for purposes of 
illustration, and do not cover all possible cases).</P>
<DIV class=div4>
<H5><A id=id-matching-value name=id-matching-value></A>2.5.4.1 Matching a 
SequenceType and a Value</H5>
<UL>
  <LI>
  <P>The <A title="sequence type" 
  href="REC-xpath20-20070123.htm#dt-sequence-type">sequence 
  type</A> <CODE>empty-sequence()</CODE> matches a value that is the empty 
  sequence.</P>
  <LI>
  <P>An <A 
  href="REC-xpath20-20070123.htm#doc-xpath-ItemType">ItemType</A> 
  with no <A 
  href="REC-xpath20-20070123.htm#doc-xpath-OccurrenceIndicator">OccurrenceIndicator</A> 
  matches any value that contains exactly one item if the <A 
  href="REC-xpath20-20070123.htm#doc-xpath-ItemType">ItemType</A> 
  matches that item (see <A 
  href="REC-xpath20-20070123.htm#id-matching-item"><B>2.5.4.2 
  Matching an ItemType and an Item</B></A>).</P>
  <LI>
  <P>An <A 
  href="REC-xpath20-20070123.htm#doc-xpath-ItemType">ItemType</A> 
  with an <A 
  href="REC-xpath20-20070123.htm#doc-xpath-OccurrenceIndicator">OccurrenceIndicator</A> 
  matches a value if the number of items in the value matches the <A 
  href="REC-xpath20-20070123.htm#doc-xpath-OccurrenceIndicator">OccurrenceIndicator</A> 
  and the <A 
  href="REC-xpath20-20070123.htm#doc-xpath-ItemType">ItemType</A> 
  matches each of the items in the value.</P></LI></UL>
<P>An <A 
href="REC-xpath20-20070123.htm#doc-xpath-OccurrenceIndicator">OccurrenceIndicator</A> 
specifies the number of items in a sequence, as follows:</P>
<UL>
  <LI>
  <P><CODE>?</CODE> matches zero or one items</P>
  <LI>
  <P><CODE>*</CODE> matches zero or more items</P>
  <LI>
  <P><CODE>+</CODE> matches one or more items</P></LI></UL>
<P>As a consequence of these rules, any <A title="sequence type" 
href="REC-xpath20-20070123.htm#dt-sequence-type">sequence 
type</A> whose <A 
href="REC-xpath20-20070123.htm#doc-xpath-OccurrenceIndicator">OccurrenceIndicator</A> 
is <CODE>*</CODE> or <CODE>?</CODE> matches a value that is an empty 
sequence.</P></DIV>
<DIV class=div4>
<H5><A id=id-matching-item name=id-matching-item></A>2.5.4.2 Matching an 
ItemType and an Item</H5>
<UL>
  <LI>
  <P>An <A 
  href="REC-xpath20-20070123.htm#doc-xpath-ItemType">ItemType</A> 
  consisting simply of a QName is interpreted as an <A 
  href="REC-xpath20-20070123.htm#doc-xpath-AtomicType">AtomicType</A>. 
  An AtomicType <EM>AtomicType</EM> matches an atomic value whose actual type is 
  <EM>AT</EM> if <CODE>derives-from(</CODE><EM>AT, AtomicType</EM><CODE>)</CODE> 
  is <CODE>true</CODE>. If a QName that is used as an <A 
  href="REC-xpath20-20070123.htm#doc-xpath-AtomicType">AtomicType</A> 
  is not defined as an atomic type in the <A title="in-scope schema type" 
  href="REC-xpath20-20070123.htm#dt-is-types">in-scope 
  schema types</A>, a <A title="static error" 
  href="REC-xpath20-20070123.htm#dt-static-error">static 
  error</A> is raised [<A title=err:XPST0051 
  href="REC-xpath20-20070123.htm#ERRXPST0051">err:XPST0051</A>].</P>
  <P>Example: The <A 
  href="REC-xpath20-20070123.htm#doc-xpath-AtomicType">AtomicType</A> 
  <CODE>xs:decimal</CODE> matches the value <CODE>12.34</CODE> (a decimal 
  literal). <CODE>xs:decimal</CODE> also matches a value whose type is 
  <CODE>shoesize</CODE>, if <CODE>shoesize</CODE> is an atomic type derived by 
  restriction from <CODE>xs:decimal</CODE>.</P>
  <DIV class=note>
  <P class=prefix><B>Note:</B></P>
  <P>The names of non-atomic types such as <CODE>xs:IDREFS</CODE> are not 
  accepted in this context, but can often be replaced by an atomic type with an 
  occurrence indicator, such as <CODE>xs:IDREF+</CODE>.</P></DIV>
  <LI>
  <P><CODE>item()</CODE> matches any single item.</P>
  <P>Example: <CODE>item()</CODE> matches the atomic value <CODE>1</CODE> or the 
  element <CODE>&lt;a/&gt;</CODE>.</P>
  <LI>
  <P><CODE>node()</CODE> matches any node.</P>
  <LI>
  <P><CODE>text()</CODE> matches any text node.</P>
  <LI>
  <P><CODE>processing-instruction()</CODE> matches any processing-instruction 
  node.</P>
  <LI>
  <P><CODE>processing-instruction(</CODE><EM>N</EM><CODE>)</CODE> matches any 
  processing-instruction node whose name (called its "PITarget" in XML) is equal 
  to <EM>N</EM>, where <EM>N</EM> is an NCName.</P>
  <P>Example: <CODE>processing-instruction(xml-stylesheet)</CODE> matches any 
  processing instruction whose PITarget is <CODE>xml-stylesheet</CODE>.</P>
  <P>For backward compatibility with XPath 1.0, the PITarget of a processing 
  instruction may also be expressed as a string literal, as in this example: 
  <CODE>processing-instruction("xml-stylesheet")</CODE>.</P>
  <LI>
  <P><CODE>comment()</CODE> matches any comment node.</P>
  <LI>
  <P><CODE>document-node()</CODE> matches any document node.</P>
  <LI>
  <P><CODE>document-node(</CODE><EM>E</EM><CODE>)</CODE> matches any document 
  node that contains exactly one element node, optionally accompanied by one or 
  more comment and processing instruction nodes, if <EM>E</EM> is an <A 
  href="REC-xpath20-20070123.htm#doc-xpath-ElementTest">ElementTest</A> 
  or <A 
  href="REC-xpath20-20070123.htm#doc-xpath-SchemaElementTest">SchemaElementTest</A> 
  that matches the element node (see <A 
  href="REC-xpath20-20070123.htm#id-element-test"><B>2.5.4.3 
  Element Test</B></A> and <A 
  href="REC-xpath20-20070123.htm#id-schema-element-test"><B>2.5.4.4 
  Schema Element Test</B></A>).</P>
  <P>Example: <CODE>document-node(element(book))</CODE> matches a document node 
  containing exactly one element node that is matched by the ElementTest 
  <CODE>element(book)</CODE>.</P>
  <LI>
  <P>An <A 
  href="REC-xpath20-20070123.htm#doc-xpath-ItemType">ItemType</A> 
  that is an <A 
  href="REC-xpath20-20070123.htm#doc-xpath-ElementTest">ElementTest</A>, 
  <A 
  href="REC-xpath20-20070123.htm#doc-xpath-SchemaElementTest">SchemaElementTest</A>, 
  <A 
  href="REC-xpath20-20070123.htm#doc-xpath-AttributeTest">AttributeTest</A>, 
  or <A 
  href="REC-xpath20-20070123.htm#doc-xpath-SchemaAttributeTest">SchemaAttributeTest</A> 
  matches an element or attribute node as described in the following 
  sections.</P></LI></UL></DIV>
<DIV class=div4>
<H5><A id=id-element-test name=id-element-test></A>2.5.4.3 Element Test</H5>
<P>An <A 
href="REC-xpath20-20070123.htm#doc-xpath-ElementTest">ElementTest</A> 
is used to match an element node by its name and/or <A title="type annotation" 
href="REC-xpath20-20070123.htm#dt-type-annotation">type 
annotation</A>. An <A 
href="REC-xpath20-20070123.htm#doc-xpath-ElementTest">ElementTest</A> 
may take any of the following forms. In these forms, <A 
href="REC-xpath20-20070123.htm#doc-xpath-ElementName">ElementName</A> 
need not be present in the <A title="in-scope element declarations" 
href="REC-xpath20-20070123.htm#dt-is-elems">in-scope 
element declarations</A>, but <A 
href="REC-xpath20-20070123.htm#doc-xpath-TypeName">TypeName</A> 
must be present in the <A title="in-scope schema type" 
href="REC-xpath20-20070123.htm#dt-is-types">in-scope 
schema types</A> [<A title=err:XPST0008 
href="REC-xpath20-20070123.htm#ERRXPST0008">err:XPST0008</A>]. 
Note that <A title="substitution group" 
href="REC-xpath20-20070123.htm#dt-substitution-group">substitution 
groups</A> do not affect the semantics of <A 
href="REC-xpath20-20070123.htm#doc-xpath-ElementTest">ElementTest</A>.</P>
<OL class=enumar>
  <LI>
  <P><CODE>element()</CODE> and <CODE>element(*)</CODE> match any single element 
  node, regardless of its name or type annotation.</P>
  <LI>
  <P><CODE>element(</CODE><A 
  href="REC-xpath20-20070123.htm#doc-xpath-ElementName">ElementName</A><CODE>)</CODE> 
  matches any element node whose name is <A 
  href="REC-xpath20-20070123.htm#doc-xpath-ElementName">ElementName</A>, 
  regardless of its type annotation or <CODE>nilled</CODE> property.</P>
  <P>Example: <CODE>element(person)</CODE> matches any element node whose name 
  is <CODE>person</CODE>.</P>
  <LI>
  <P><CODE>element(</CODE><A 
  href="REC-xpath20-20070123.htm#doc-xpath-ElementName">ElementName</A><CODE>,</CODE> 
  <A 
  href="REC-xpath20-20070123.htm#doc-xpath-TypeName">TypeName</A><CODE>)</CODE> 
  matches an element node whose name is <A 
  href="REC-xpath20-20070123.htm#doc-xpath-ElementName">ElementName</A> 
  if <CODE>derives-from(</CODE><EM>AT</EM>, <A 
  href="REC-xpath20-20070123.htm#doc-xpath-TypeName">TypeName</A> 
  <CODE>)</CODE> is <CODE>true</CODE>, where <EM>AT</EM> is the type annotation 
  of the element node, and the <CODE>nilled</CODE> property of the node is 
  <CODE>false</CODE>.</P>
  <P>Example: <CODE>element(person, surgeon)</CODE> matches a non-nilled element 
  node whose name is <CODE>person</CODE> and whose type annotation is 
  <CODE>surgeon</CODE> (or is derived from <CODE>surgeon</CODE>).</P>
  <LI>
  <P><CODE>element(</CODE><A 
  href="REC-xpath20-20070123.htm#doc-xpath-ElementName">ElementName</A>, 
  <A 
  href="REC-xpath20-20070123.htm#doc-xpath-TypeName">TypeName</A> 
  <CODE>?)</CODE> matches an element node whose name is <A 
  href="REC-xpath20-20070123.htm#doc-xpath-ElementName">ElementName</A> 
  if <CODE>derives-from(</CODE><EM>AT</EM>, <A 
  href="REC-xpath20-20070123.htm#doc-xpath-TypeName">TypeName</A><CODE>)</CODE> 
  is <CODE>true</CODE>, where <EM>AT</EM> is the type annotation of the element 
  node. The <CODE>nilled</CODE> property of the node may be either 
  <CODE>true</CODE> or <CODE>false</CODE>.</P>
  <P>Example: <CODE>element(person, surgeon?)</CODE> matches a nilled or 
  non-nilled element node whose name is <CODE>person</CODE> and whose type 
  annotation is <CODE>surgeon</CODE> (or is derived from 
  <CODE>surgeon</CODE>).</P>
  <LI>
  <P><CODE>element(*,</CODE> <A 
  href="REC-xpath20-20070123.htm#doc-xpath-TypeName">TypeName</A><CODE>)</CODE> 
  matches an element node regardless of its name, if 
  <CODE>derives-from(</CODE><EM>AT</EM>, <A 
  href="REC-xpath20-20070123.htm#doc-xpath-TypeName">TypeName</A> 
  <CODE>)</CODE> is <CODE>true</CODE>, where <EM>AT</EM> is the type annotation 
  of the element node, and the <CODE>nilled</CODE> property of the node is 
  <CODE>false</CODE>.</P>
  <P>Example: <CODE>element(*, surgeon)</CODE> matches any non-nilled element 
  node whose type annotation is <CODE>surgeon</CODE> (or is derived from 
  <CODE>surgeon</CODE>), regardless of its name.</P>
  <LI>
  <P><CODE>element(*,</CODE> <A 
  href="REC-xpath20-20070123.htm#doc-xpath-TypeName">TypeName</A> 
  <CODE>?)</CODE> matches an element node regardless of its name, if 
  <CODE>derives-from(</CODE><EM>AT</EM>, <A 
  href="REC-xpath20-20070123.htm#doc-xpath-TypeName">TypeName</A> 
  <CODE>)</CODE> is <CODE>true</CODE>, where <EM>AT</EM> is the type annotation 
  of the element node. The <CODE>nilled</CODE> property of the node may be 
  either <CODE>true</CODE> or <CODE>false</CODE>.</P>
  <P>Example: <CODE>element(*, surgeon?)</CODE> matches any nilled or non-nilled 
  element node whose type annotation is <CODE>surgeon</CODE> (or is derived from 
  <CODE>surgeon</CODE>), regardless of its name.</P></LI></OL></DIV>
<DIV class=div4>
<H5><A id=id-schema-element-test name=id-schema-element-test></A>2.5.4.4 Schema 
Element Test</H5>
<P>A <A 
href="REC-xpath20-20070123.htm#doc-xpath-SchemaElementTest">SchemaElementTest</A> 
matches an element node against a corresponding element declaration found in the 
<A title="in-scope element declarations" 
href="REC-xpath20-20070123.htm#dt-is-elems">in-scope 
element declarations</A>. It takes the following form:</P>
<P><CODE>schema-element(</CODE><A 
href="REC-xpath20-20070123.htm#doc-xpath-ElementName">ElementName</A><CODE>)</CODE></P>
<P>If the <A 
href="REC-xpath20-20070123.htm#doc-xpath-ElementName">ElementName</A> 
specified in the <A 
href="REC-xpath20-20070123.htm#doc-xpath-SchemaElementTest">SchemaElementTest</A> 
is not found in the <A title="in-scope element declarations" 
href="REC-xpath20-20070123.htm#dt-is-elems">in-scope 
element declarations</A>, a <A title="static error" 
href="REC-xpath20-20070123.htm#dt-static-error">static 
error</A> is raised [<A title=err:XPST0008 
href="REC-xpath20-20070123.htm#ERRXPST0008">err:XPST0008</A>].</P>
<P>A <A 
href="REC-xpath20-20070123.htm#doc-xpath-SchemaElementTest">SchemaElementTest</A> 
matches a candidate element node if all three of the following conditions are 
satisfied:</P>
<OL class=enumar>
  <LI>
  <P>The name of the candidate node matches the specified <A 
  href="REC-xpath20-20070123.htm#doc-xpath-ElementName">ElementName</A> 
  or matches the name of an element in a <A title="substitution group" 
  href="REC-xpath20-20070123.htm#dt-substitution-group">substitution 
  group</A> headed by an element named <A 
  href="REC-xpath20-20070123.htm#doc-xpath-ElementName">ElementName</A>.</P>
  <LI>
  <P><CODE>derives-from(</CODE><EM>AT, ET</EM><CODE>)</CODE> is 
  <CODE>true</CODE>, where <EM>AT</EM> is the type annotation of the candidate 
  node and <EM>ET</EM> is the schema type declared for element <A 
  href="REC-xpath20-20070123.htm#doc-xpath-ElementName">ElementName</A> 
  in the <A title="in-scope element declarations" 
  href="REC-xpath20-20070123.htm#dt-is-elems">in-scope 
  element declarations</A>.</P>
  <LI>
  <P>If the element declaration for <A 
  href="REC-xpath20-20070123.htm#doc-xpath-ElementName">ElementName</A> 
  in the <A title="in-scope element declarations" 
  href="REC-xpath20-20070123.htm#dt-is-elems">in-scope 
  element declarations</A> is not <CODE>nillable</CODE>, then the 
  <CODE>nilled</CODE> property of the candidate node is 
  <CODE>false</CODE>.</P></LI></OL>
<P>Example: The <A 
href="REC-xpath20-20070123.htm#doc-xpath-SchemaElementTest">SchemaElementTest</A> 
<CODE>schema-element(customer)</CODE> matches a candidate element node if 
<CODE>customer</CODE> is a top-level element declaration in the <A 
title="in-scope element declarations" 
href="REC-xpath20-20070123.htm#dt-is-elems">in-scope 
element declarations</A>, the name of the candidate node is 
<CODE>customer</CODE> or is in a <A title="substitution group" 
href="REC-xpath20-20070123.htm#dt-substitution-group">substitution 
group</A> headed by <CODE>customer</CODE>, the type annotation of the candidate 
node is the same as or derived from the schema type declared for the 
<CODE>customer</CODE> element, and either the candidate node is not 
<CODE>nilled</CODE> or <CODE>customer</CODE> is declared to be 
<CODE>nillable</CODE>.</P></DIV>
<DIV class=div4>
<H5><A id=id-attribute-test name=id-attribute-test></A>2.5.4.5 Attribute 
Test</H5>
<P>An <A 
href="REC-xpath20-20070123.htm#doc-xpath-AttributeTest">AttributeTest</A> 
is used to match an attribute node by its name and/or <A title="type annotation" 
href="REC-xpath20-20070123.htm#dt-type-annotation">type 
annotation</A>. An <A 
href="REC-xpath20-20070123.htm#doc-xpath-AttributeTest">AttributeTest</A> 
any take any of the following forms. In these forms, <A 
href="REC-xpath20-20070123.htm#doc-xpath-AttributeName">AttributeName</A> 
need not be present in the <A title="in-scope attribute declarations" 
href="REC-xpath20-20070123.htm#dt-is-attrs">in-scope 
attribute declarations</A>, but <A 
href="REC-xpath20-20070123.htm#doc-xpath-TypeName">TypeName</A> 
must be present in the <A title="in-scope schema type" 
href="REC-xpath20-20070123.htm#dt-is-types">in-scope 
schema types</A> [<A title=err:XPST0008 
href="REC-xpath20-20070123.htm#ERRXPST0008">err:XPST0008</A>].</P>
<OL class=enumar>
  <LI>
  <P><CODE>attribute()</CODE> and <CODE>attribute(*)</CODE> match any single 
  attribute node, regardless of its name or type annotation.</P>
  <LI>
  <P><CODE>attribute(</CODE><A 
  href="REC-xpath20-20070123.htm#doc-xpath-AttributeName">AttributeName</A><CODE>)</CODE> 
  matches any attribute node whose name is <A 
  href="REC-xpath20-20070123.htm#doc-xpath-AttributeName">AttributeName</A>, 
  regardless of its type annotation.</P>
  <P>Example: <CODE>attribute(price)</CODE> matches any attribute node whose 
  name is <CODE>price</CODE>.</P>
  <LI>
  <P><CODE>attribute(</CODE><A 
  href="REC-xpath20-20070123.htm#doc-xpath-AttributeName">AttributeName</A>, 
  <A 
  href="REC-xpath20-20070123.htm#doc-xpath-TypeName">TypeName</A><CODE>)</CODE> 
  matches an attribute node whose name is <A 
  href="REC-xpath20-20070123.htm#doc-xpath-AttributeName">AttributeName</A> 
  if <CODE>derives-from(</CODE><EM>AT</EM>, <A 
  href="REC-xpath20-20070123.htm#doc-xpath-TypeName">TypeName</A> 
  <CODE>)</CODE> is <CODE>true</CODE>, where <EM>AT</EM> is the type annotation 
  of the attribute node.</P>
  <P>Example: <CODE>attribute(price, currency)</CODE> matches an attribute node 
  whose name is <CODE>price</CODE> and whose type annotation is 
  <CODE>currency</CODE> (or is derived from <CODE>currency</CODE>).</P>
  <LI>
  <P><CODE>attribute(*,</CODE> <A 
  href="REC-xpath20-20070123.htm#doc-xpath-TypeName">TypeName</A><CODE>)</CODE> 
  matches an attribute node regardless of its name, if 
  <CODE>derives-from(</CODE><EM>AT</EM>, <A 
  href="REC-xpath20-20070123.htm#doc-xpath-TypeName">TypeName</A><CODE>)</CODE> 
  is <CODE>true</CODE>, where <EM>AT</EM> is the type annotation of the 
  attribute node.</P>
  <P>Example: <CODE>attribute(*, currency)</CODE> matches any attribute node 
  whose type annotation is <CODE>currency</CODE> (or is derived from 
  <CODE>currency</CODE>), regardless of its name.</P></LI></OL></DIV>
<DIV class=div4>
<H5><A id=id-schema-attribute-test name=id-schema-attribute-test></A>2.5.4.6 
Schema Attribute Test</H5>
<P>A <A 
href="REC-xpath20-20070123.htm#doc-xpath-SchemaAttributeTest">SchemaAttributeTest</A> 
matches an attribute node against a corresponding attribute declaration found in 
the <A title="in-scope attribute declarations" 
href="REC-xpath20-20070123.htm#dt-is-attrs">in-scope 
attribute declarations</A>. It takes the following form:</P>
<P><CODE>schema-attribute(</CODE><A 
href="REC-xpath20-20070123.htm#doc-xpath-AttributeName">AttributeName</A><CODE>)</CODE></P>
<P>If the <A 
href="REC-xpath20-20070123.htm#doc-xpath-AttributeName">AttributeName</A> 
specified in the <A 
href="REC-xpath20-20070123.htm#doc-xpath-SchemaAttributeTest">SchemaAttributeTest</A> 
is not found in the <A title="in-scope attribute declarations" 
href="REC-xpath20-20070123.htm#dt-is-attrs">in-scope 
attribute declarations</A>, a <A title="static error" 
href="REC-xpath20-20070123.htm#dt-static-error">static 
error</A> is raised [<A title=err:XPST0008 
href="REC-xpath20-20070123.htm#ERRXPST0008">err:XPST0008</A>].</P>
<P>A <A 
href="REC-xpath20-20070123.htm#doc-xpath-SchemaAttributeTest">SchemaAttributeTest</A> 
matches a candidate attribute node if both of the following conditions are 
satisfied:</P>
<OL class=enumar>
  <LI>
  <P>The name of the candidate node matches the specified <A 
  href="REC-xpath20-20070123.htm#doc-xpath-AttributeName">AttributeName</A>.</P>
  <LI>
  <P><CODE>derives-from(</CODE><EM>AT, ET</EM><CODE>)</CODE> is 
  <CODE>true</CODE>, where <EM>AT</EM> is the type annotation of the candidate 
  node and <EM>ET</EM> is the schema type declared for attribute <A 
  href="REC-xpath20-20070123.htm#doc-xpath-AttributeName">AttributeName</A> 
  in the <A title="in-scope attribute declarations" 
  href="REC-xpath20-20070123.htm#dt-is-attrs">in-scope 
  attribute declarations</A>.</P></LI></OL>
<P>Example: The <A 
href="REC-xpath20-20070123.htm#doc-xpath-SchemaAttributeTest">SchemaAttributeTest</A> 
<CODE>schema-attribute(color)</CODE> matches a candidate attribute node if 
<CODE>color</CODE> is a top-level attribute declaration in the <A 
title="in-scope attribute declarations" 
href="REC-xpath20-20070123.htm#dt-is-attrs">in-scope 
attribute declarations</A>, the name of the candidate node is 
<CODE>color</CODE>, and the type annotation of the candidate node is the same as 
or derived from the schema type declared for the <CODE>color</CODE> 
attribute.</P></DIV></DIV></DIV>
<DIV class=div2>
<H3><A id=comments name=comments></A>2.6 Comments</H3>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-Comment 
    name=doc-xpath-Comment></A>[77]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-Comment">Comment</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"(:" (<A 
      href="REC-xpath20-20070123.htm#doc-xpath-CommentContents">CommentContents</A> 
      | <A 
      href="REC-xpath20-20070123.htm#doc-xpath-Comment">Comment</A>)* 
      ":)"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-CommentContents 
      name=doc-xpath-CommentContents></A>[82]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-CommentContents">CommentContents</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>(<A 
      href="REC-xpath20-20070123.htm#prod-xpath-Char">Char</A>+ 
      - (Char* ('(:' | ':)') Char*))</CODE></TD></TR></TBODY></TABLE>
<P>Comments may be used to provide informative annotation for <SPAN 
class=xpath><SPAN class=xpath>an expression</SPAN></SPAN>. Comments are lexical 
constructs only, and do not affect <SPAN class=xpath><SPAN 
class=xpath>expression</SPAN></SPAN> processing.</P>
<P>Comments are strings, delimited by the symbols <CODE>(:</CODE> and 
<CODE>:)</CODE>. Comments may be nested.</P>
<P>A comment may be used anywhere <A title="ignorable whitespace" 
href="REC-xpath20-20070123.htm#IgnorableWhitespace">ignorable 
whitespace</A> is allowed (see <A 
href="REC-xpath20-20070123.htm#DefaultWhitespaceHandling"><B>A.2.4.1 
Default Whitespace Handling</B></A>).</P>
<P>The following is an example of a comment:</P>
<DIV class=exampleInner><PRE>(: Houston, we have a problem :)
</PRE></DIV></DIV></DIV>
<DIV class=div1>
<H2><A id=id-expressions name=id-expressions></A>3 Expressions</H2>
<P>This section discusses each of the basic kinds of expression. Each kind of 
expression has a name such as <CODE>PathExpr</CODE>, which is introduced on the 
left side of the grammar production that defines the expression. Since XPath is 
a composable language, each kind of expression is defined in terms of other 
expressions whose operators have a higher precedence. In this way, the 
precedence of operators is represented explicitly in the grammar.</P>
<P>The order in which expressions are discussed in this document does not 
reflect the order of operator precedence. In general, this document introduces 
the simplest kinds of expressions first, followed by more complex expressions. 
For the complete grammar, see Appendix [<A 
href="REC-xpath20-20070123.htm#nt-bnf"><B>A XPath 
Grammar</B></A>].</P>
<P><SPAN class=xpath><SPAN class=xpath>The highest-level symbol in the XPath 
grammar is XPath.</SPAN></SPAN></P>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-XPath 
name=doc-xpath-XPath></A>[1]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-XPath">XPath</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-Expr">Expr</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-Expr name=doc-xpath-Expr></A>[2]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-Expr">Expr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-ExprSingle">ExprSingle</A> 
      ("," <A 
      href="REC-xpath20-20070123.htm#doc-xpath-ExprSingle">ExprSingle</A>)*</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-ExprSingle 
      name=doc-xpath-ExprSingle></A>[3]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-ExprSingle">ExprSingle</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-ForExpr">ForExpr</A><BR>| 
      <A 
      href="REC-xpath20-20070123.htm#doc-xpath-QuantifiedExpr">QuantifiedExpr</A><BR>| 
      <A 
      href="REC-xpath20-20070123.htm#doc-xpath-IfExpr">IfExpr</A><BR>| 
      <A 
      href="REC-xpath20-20070123.htm#doc-xpath-OrExpr">OrExpr</A></CODE></TD></TR></TBODY></TABLE>
<P>The XPath operator that has lowest precedence is the <A 
title="comma operator" 
href="REC-xpath20-20070123.htm#dt-comma-operator">comma 
operator</A>, which is used to combine two operands to form a sequence. As shown 
in the grammar, a general expression (<A 
href="REC-xpath20-20070123.htm#doc-xpath-Expr">Expr</A>) 
can consist of multiple <A 
href="REC-xpath20-20070123.htm#doc-xpath-ExprSingle">ExprSingle</A> 
operands, separated by commas. The name <A 
href="REC-xpath20-20070123.htm#doc-xpath-ExprSingle">ExprSingle</A> 
denotes an expression that does not contain a top-level <A 
title="comma operator" 
href="REC-xpath20-20070123.htm#dt-comma-operator">comma 
operator</A> (despite its name, an <A 
href="REC-xpath20-20070123.htm#doc-xpath-ExprSingle">ExprSingle</A> 
may evaluate to a sequence containing more than one item.)</P>
<P>The symbol <A 
href="REC-xpath20-20070123.htm#doc-xpath-ExprSingle">ExprSingle</A> 
is used in various places in the grammar where an expression is not allowed to 
contain a top-level comma. For example, each of the arguments of a function call 
must be an <A 
href="REC-xpath20-20070123.htm#doc-xpath-ExprSingle">ExprSingle</A>, 
because commas are used to separate the arguments of a function call.</P>
<P>After the comma, the expressions that have next lowest precedence are <SPAN 
class=xpath><SPAN class=xpath><A 
href="REC-xpath20-20070123.htm#doc-xpath-ForExpr">ForExpr</A>,</SPAN></SPAN> 
<A 
href="REC-xpath20-20070123.htm#doc-xpath-QuantifiedExpr">QuantifiedExpr</A>, 
<A 
href="REC-xpath20-20070123.htm#doc-xpath-IfExpr">IfExpr</A>, 
and <A 
href="REC-xpath20-20070123.htm#doc-xpath-OrExpr">OrExpr</A>. 
Each of these expressions is described in a separate section of this 
document.</P>
<DIV class=div2>
<H3><A id=id-primary-expressions name=id-primary-expressions></A>3.1 Primary 
Expressions</H3>
<P>[<A id=dt-primary-expression title="primary expression" 
name=dt-primary-expression>Definition</A>: <B>Primary expressions</B> are the 
basic primitives of the language. They include literals, variable references, 
context item expressions, and function calls. A primary expression may also be 
created by enclosing any expression in parentheses, which is sometimes helpful 
in controlling the precedence of operators.]</P>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-PrimaryExpr 
      name=doc-xpath-PrimaryExpr></A>[41]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-PrimaryExpr">PrimaryExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-Literal">Literal</A> 
      | <A 
      href="REC-xpath20-20070123.htm#doc-xpath-VarRef">VarRef</A> 
      | <A 
      href="REC-xpath20-20070123.htm#doc-xpath-ParenthesizedExpr">ParenthesizedExpr</A> 
      | <A 
      href="REC-xpath20-20070123.htm#doc-xpath-ContextItemExpr">ContextItemExpr</A> 
      | <A 
      href="REC-xpath20-20070123.htm#doc-xpath-FunctionCall">FunctionCall</A></CODE></TD></TR></TBODY></TABLE>
<DIV class=div3>
<H4><A id=id-literals name=id-literals></A>3.1.1 Literals</H4>
<P>[<A id=dt-literal title=literal name=dt-literal>Definition</A>: A 
<B>literal</B> is a direct syntactic representation of an atomic value.] XPath 
supports two kinds of literals: numeric literals and string literals.</P>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-Literal 
    name=doc-xpath-Literal></A>[42]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-Literal">Literal</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-NumericLiteral">NumericLiteral</A> 
      | <A 
      href="REC-xpath20-20070123.htm#doc-xpath-StringLiteral">StringLiteral</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-NumericLiteral 
      name=doc-xpath-NumericLiteral></A>[43]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-NumericLiteral">NumericLiteral</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-IntegerLiteral">IntegerLiteral</A> 
      | <A 
      href="REC-xpath20-20070123.htm#doc-xpath-DecimalLiteral">DecimalLiteral</A> 
      | <A 
      href="REC-xpath20-20070123.htm#doc-xpath-DoubleLiteral">DoubleLiteral</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-IntegerLiteral 
      name=doc-xpath-IntegerLiteral></A>[71]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-IntegerLiteral">IntegerLiteral</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-Digits">Digits</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-DecimalLiteral 
      name=doc-xpath-DecimalLiteral></A>[72]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-DecimalLiteral">DecimalLiteral</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>("." <A 
      href="REC-xpath20-20070123.htm#doc-xpath-Digits">Digits</A>) 
      | (<A 
      href="REC-xpath20-20070123.htm#doc-xpath-Digits">Digits</A> 
      "." [0-9]*)</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-DoubleLiteral 
      name=doc-xpath-DoubleLiteral></A>[73]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-DoubleLiteral">DoubleLiteral</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>(("." <A 
      href="REC-xpath20-20070123.htm#doc-xpath-Digits">Digits</A>) 
      | (<A 
      href="REC-xpath20-20070123.htm#doc-xpath-Digits">Digits</A> 
      ("." [0-9]*)?)) [eE] [+-]? <A 
      href="REC-xpath20-20070123.htm#doc-xpath-Digits">Digits</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-StringLiteral 
      name=doc-xpath-StringLiteral></A>[74]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-StringLiteral">StringLiteral</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>('"' (<A 
      href="REC-xpath20-20070123.htm#doc-xpath-EscapeQuot">EscapeQuot</A> 
      | [^"])* '"') | ("'" (<A 
      href="REC-xpath20-20070123.htm#doc-xpath-EscapeApos">EscapeApos</A> 
      | [^'])* "'")</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-EscapeQuot 
      name=doc-xpath-EscapeQuot></A>[75]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-EscapeQuot">EscapeQuot</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>'""'</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-EscapeApos 
      name=doc-xpath-EscapeApos></A>[76]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-EscapeApos">EscapeApos</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"''"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-Digits 
    name=doc-xpath-Digits></A>[81]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-Digits">Digits</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>[0-9]+</CODE></TD></TR></TBODY></TABLE>
<P>The value of a <B>numeric literal</B> containing no "<CODE>.</CODE>" and no 
<CODE>e</CODE> or <CODE>E</CODE> character is an atomic value of type 
<CODE>xs:integer</CODE>. The value of a numeric literal containing 
"<CODE>.</CODE>" but no <CODE>e</CODE> or <CODE>E</CODE> character is an atomic 
value of type <CODE>xs:decimal</CODE>. The value of a numeric literal containing 
an <CODE>e</CODE> or <CODE>E</CODE> character is an atomic value of type 
<CODE>xs:double</CODE>. The value of the numeric literal is determined by 
casting it to the appropriate type according to the rules for casting from 
<CODE>xs:untypedAtomic</CODE> to a numeric type as specified in <A 
href="http://www.w3.org/TR/xpath-functions/#casting-from-strings">Section 17.1.1 
Casting from xs:string and xs:untypedAtomic</A><SUP><SMALL>FO</SMALL></SUP>.</P>
<P>The value of a <B>string literal</B> is an atomic value whose type is 
<CODE>xs:string</CODE> and whose value is the string denoted by the characters 
between the delimiting apostrophes or quotation marks. If the literal is 
delimited by apostrophes, two adjacent apostrophes within the literal are 
interpreted as a single apostrophe. Similarly, if the literal is delimited by 
quotation marks, two adjacent quotation marks within the literal are interpreted 
as one quotation mark.</P>
<P>Here are some examples of literal expressions:</P>
<UL>
  <LI>
  <P><CODE>"12.5"</CODE> denotes the string containing the characters '1', '2', 
  '.', and '5'.</P>
  <LI>
  <P><CODE>12</CODE> denotes the <CODE>xs:integer</CODE> value twelve.</P>
  <LI>
  <P><CODE>12.5</CODE> denotes the <CODE>xs:decimal</CODE> value twelve and one 
  half.</P>
  <LI>
  <P><CODE>125E2</CODE> denotes the <CODE>xs:double</CODE> value twelve 
  thousand, five hundred.</P>
  <LI>
  <P><CODE>"He said, ""I don't like it."""</CODE> denotes a string containing 
  two quotation marks and one apostrophe.</P>
  <DIV class=note>
  <P class=prefix><B>Note:</B></P>
  <P>When XPath expressions are embedded in contexts where quotation marks have 
  special significance, such as inside XML attributes, additional escaping may 
  be needed.</P></DIV></LI></UL>
<P>The <CODE>xs:boolean</CODE> values <CODE>true</CODE> and <CODE>false</CODE> 
can be represented by calls to the <A title="built-in function" 
href="REC-xpath20-20070123.htm#dt-built-in-function">built-in 
functions</A> <CODE>fn:true()</CODE> and <CODE>fn:false()</CODE>, 
respectively.</P>
<P>Values of other atomic types can be constructed by calling the <A 
title="constructor function" 
href="REC-xpath20-20070123.htm#dt-constructor-function">constructor 
function</A> for the given type. The constructor functions for XML Schema 
built-in types are defined in <A 
href="REC-xpath20-20070123.htm#FunctionsAndOperators">[XQuery 
1.0 and XPath 2.0 Functions and Operators]</A>. In general, the name of a 
constructor function for a given type is the same as the name of the type 
(including its namespace). For example:</P>
<UL>
  <LI>
  <P><CODE>xs:integer("12")</CODE> returns the integer value twelve.</P>
  <LI>
  <P><CODE>xs:date("2001-08-25")</CODE> returns an item whose type is 
  <CODE>xs:date</CODE> and whose value represents the date 25th August 2001.</P>
  <LI>
  <P><CODE>xs:dayTimeDuration("PT5H")</CODE> returns an item whose type is 
  <CODE>xs:dayTimeDuration</CODE> and whose value represents a duration of five 
  hours.</P></LI></UL>
<P>Constructor functions can also be used to create special values that have no 
literal representation, as in the following examples:</P>
<UL>
  <LI>
  <P><CODE>xs:float("NaN")</CODE> returns the special floating-point value, "Not 
  a Number."</P>
  <LI>
  <P><CODE>xs:double("INF")</CODE> returns the special double-precision value, 
  "positive infinity."</P></LI></UL>
<P>It is also possible to construct values of various types by using a 
<CODE>cast</CODE> expression. For example:</P>
<UL>
  <LI>
  <P><CODE>9 cast as hatsize</CODE> returns the atomic value <CODE>9</CODE> 
  whose type is <CODE>hatsize</CODE>.</P></LI></UL></DIV>
<DIV class=div3>
<H4><A id=id-variables name=id-variables></A>3.1.2 Variable References</H4>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-VarRef 
    name=doc-xpath-VarRef></A>[44]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-VarRef">VarRef</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"$" <A 
      href="REC-xpath20-20070123.htm#doc-xpath-VarName">VarName</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-VarName 
    name=doc-xpath-VarName></A>[45]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-VarName">VarName</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-QName">QName</A></CODE></TD></TR></TBODY></TABLE>
<P>[<A id=dt-variable-reference title="variable reference" 
name=dt-variable-reference>Definition</A>: A <B>variable reference</B> is a 
QName preceded by a $-sign.] Two variable references are equivalent if their 
local names are the same and their namespace prefixes are bound to the same 
namespace URI in the <A title="statically known namespaces" 
href="REC-xpath20-20070123.htm#dt-static-namespaces">statically 
known namespaces</A>. An unprefixed variable reference is in no namespace.</P>
<P>Every variable reference must match a name in the <A 
title="in-scope variables" 
href="REC-xpath20-20070123.htm#dt-in-scope-variables">in-scope 
variables</A>, which include variables from the following sources:</P>
<OL class=enumar>
  <LI>
  <P>The <A title="in-scope variables" 
  href="REC-xpath20-20070123.htm#dt-in-scope-variables">in-scope 
  variables</A> may be augmented by <A title="implementation defined" 
  href="REC-xpath20-20070123.htm#dt-implementation-defined">implementation-defined</A> 
  variables.</P>
  <LI>
  <P>A variable may be bound by an XPath expression. <SPAN class=xpath><SPAN 
  class=xpath>The kinds of expressions that can bind variables are 
  <CODE>for</CODE> expressions (<A 
  href="REC-xpath20-20070123.htm#id-for-expressions"><B>3.7 
  For Expressions</B></A>) and quantified expressions (<A 
  href="REC-xpath20-20070123.htm#id-quantified-expressions"><B>3.9 
  Quantified Expressions</B></A>).</SPAN></SPAN></P></LI></OL>
<P>Every variable binding has a static scope. The scope defines where references 
to the variable can validly occur. It is a <A title="static error" 
href="REC-xpath20-20070123.htm#dt-static-error">static 
error</A> [<A title=err:XPST0008 
href="REC-xpath20-20070123.htm#ERRXPST0008">err:XPST0008</A>] 
to reference a variable that is not in scope. If a variable is bound in the <A 
title="static context" 
href="REC-xpath20-20070123.htm#dt-static-context">static 
context</A> for an expression, that variable is in scope for the entire 
expression.</P>
<P>If a variable reference matches two or more variable bindings that are in 
scope, then the reference is taken as referring to the inner binding, that is, 
the one whose scope is smaller. At evaluation time, the value of a variable 
reference is the value of the expression to which the relevant variable is 
bound. The scope of a variable binding is defined separately for each kind of 
expression that can bind variables.</P></DIV>
<DIV class=div3>
<H4><A id=id-paren-expressions name=id-paren-expressions></A>3.1.3 Parenthesized 
Expressions</H4>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-ParenthesizedExpr 
      name=doc-xpath-ParenthesizedExpr></A>[46]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-ParenthesizedExpr">ParenthesizedExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"(" <A 
      href="REC-xpath20-20070123.htm#doc-xpath-Expr">Expr</A>? 
      ")"</CODE></TD></TR></TBODY></TABLE>
<P>Parentheses may be used to enforce a particular evaluation order in 
expressions that contain multiple operators. For example, the expression 
<CODE>(2 + 4) * 5</CODE> evaluates to thirty, since the parenthesized expression 
<CODE>(2 + 4)</CODE> is evaluated first and its result is multiplied by five. 
Without parentheses, the expression <CODE>2 + 4 * 5</CODE> evaluates to 
twenty-two, because the multiplication operator has higher precedence than the 
addition operator.</P>
<P>Empty parentheses are used to denote an empty sequence, as described in <A 
href="REC-xpath20-20070123.htm#construct_seq"><B>3.3.1 
Constructing Sequences</B></A>.</P></DIV>
<DIV class=div3>
<H4><A id=id-context-item-expression name=id-context-item-expression></A>3.1.4 
Context Item Expression</H4>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-ContextItemExpr 
      name=doc-xpath-ContextItemExpr></A>[47]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-ContextItemExpr">ContextItemExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"."</CODE></TD></TR></TBODY></TABLE>
<P>A <B>context item expression</B> evaluates to the <A title="context item" 
href="REC-xpath20-20070123.htm#dt-context-item">context 
item</A>, which may be either a node (as in the expression 
<CODE>fn:doc("bib.xml")/books/book[fn:count(./author)&gt;1]</CODE>) or an atomic 
value (as in the expression <CODE>(1 to 100)[. mod 5 eq 0]</CODE>).</P>
<P>If the <A title="context item" 
href="REC-xpath20-20070123.htm#dt-context-item">context 
item</A> is undefined, a context item expression raises a dynamic error [<A 
title=err:XPDY0002 
href="REC-xpath20-20070123.htm#ERRXPDY0002">err:XPDY0002</A>].</P></DIV>
<DIV class=div3>
<H4><A id=id-function-calls name=id-function-calls></A>3.1.5 Function Calls</H4>
<P>[<A id=dt-built-in-function title="built-in function" 
name=dt-built-in-function>Definition</A>: The <B>built-in functions</B> 
supported by XPath are defined in <A 
href="REC-xpath20-20070123.htm#FunctionsAndOperators">[XQuery 
1.0 and XPath 2.0 Functions and Operators]</A>.] <SPAN class=xpath><SPAN 
class=xpath>Additional functions may be provided in the <A 
title="static context" 
href="REC-xpath20-20070123.htm#dt-static-context">static 
context</A>. XPath per se does not provide a way to declare functions, but a 
host language may provide such a mechanism.</SPAN></SPAN></P>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-FunctionCall 
      name=doc-xpath-FunctionCall></A>[48]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-FunctionCall">FunctionCall</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-QName">QName</A> 
      "(" (<A 
      href="REC-xpath20-20070123.htm#doc-xpath-ExprSingle">ExprSingle</A> 
      ("," <A 
      href="REC-xpath20-20070123.htm#doc-xpath-ExprSingle">ExprSingle</A>)*)? 
      ")"</CODE></TD></TR></TBODY></TABLE>
<P>A <B>function call</B> consists of a QName followed by a parenthesized list 
of zero or more expressions, called <B>arguments</B>. If the QName in the 
function call has no namespace prefix, it is considered to be in the <A 
title="default function namespace" 
href="REC-xpath20-20070123.htm#dt-def-fn-ns">default 
function namespace.</A></P>
<P>If the <A title="expanded QName" 
href="REC-xpath20-20070123.htm#dt-expanded-qname">expanded 
QName</A> and number of arguments in a function call do not match the name and 
arity of a <A title="function signature" 
href="REC-xpath20-20070123.htm#dt-function-signature">function 
signature</A> in the <A title="static context" 
href="REC-xpath20-20070123.htm#dt-static-context">static 
context</A>, a <A title="static error" 
href="REC-xpath20-20070123.htm#dt-static-error">static 
error</A> is raised [<A title=err:XPST0017 
href="REC-xpath20-20070123.htm#ERRXPST0017">err:XPST0017</A>].</P>
<P>A function call is evaluated as follows:</P>
<OL class=enumar>
  <LI>
  <P>Argument expressions are evaluated, producing argument values. The order of 
  argument evaluation is <A title="implementation dependent" 
  href="REC-xpath20-20070123.htm#dt-implementation-dependent">implementation-dependent</A> 
  and a function need not evaluate an argument if the function can evaluate its 
  body without evaluating that argument.</P>
  <LI>
  <P>Each argument value is converted by applying the function conversion rules 
  listed below.</P>
  <LI class=xpath>
  <P>The function is evaluated using the converted argument values. The result 
  is either an instance of the function's declared return type or a dynamic 
  error. The <A title="dynamic type" 
  href="REC-xpath20-20070123.htm#dt-dynamic-type">dynamic 
  type</A> of a function result may be a type that is derived from the declared 
  return type. Errors raised by functions are defined in <A 
  href="REC-xpath20-20070123.htm#FunctionsAndOperators">[XQuery 
  1.0 and XPath 2.0 Functions and Operators]</A>.</P></LI></OL>
<P>The <B>function conversion rules</B> are used to convert an argument value to 
its expected type; that is, to the declared type of the function <SPAN 
class=xpath><SPAN class=xpath>parameter.</SPAN></SPAN> The expected type is 
expressed as a <A title="sequence type" 
href="REC-xpath20-20070123.htm#dt-sequence-type">sequence 
type</A>. The function conversion rules are applied to a given value as 
follows:</P>
<UL>
  <LI class=xpath>
  <P>If <A title="XPath 1.0 compatibility mode" 
  href="REC-xpath20-20070123.htm#dt-xpath-compat-mode">XPath 
  1.0 compatibility mode</A> is <CODE>true</CODE> and an argument is not of the 
  expected type, then the following conversions are applied sequentially to the 
  argument value V:</P>
  <OL class=enumar>
    <LI>
    <P>If the expected type calls for a single item or optional single item 
    (examples: <CODE>xs:string</CODE>, <CODE>xs:string?</CODE>, 
    <CODE>xs:untypedAtomic</CODE>, <CODE>xs:untypedAtomic?</CODE>, 
    <CODE>node()</CODE>, <CODE>node()?</CODE>, <CODE>item()</CODE>, 
    <CODE>item()?</CODE>), then the value V is effectively replaced by V[1].</P>
    <LI>
    <P>If the expected type is <CODE>xs:string</CODE> or 
    <CODE>xs:string?</CODE>, then the value <CODE>V</CODE> is effectively 
    replaced by <CODE>fn:string(V)</CODE>.</P>
    <LI>
    <P>If the expected type is <CODE>xs:double</CODE> or 
    <CODE>xs:double?</CODE>, then the value <CODE>V</CODE> is effectively 
    replaced by <CODE>fn:number(V)</CODE>.</P></LI></OL>
  <LI>
  <P>If the expected type is a sequence of an atomic type (possibly with an 
  occurrence indicator <CODE>*</CODE>, <CODE>+</CODE>, or <CODE>?</CODE>), the 
  following conversions are applied:</P>
  <OL class=enumar>
    <LI>
    <P><A title=atomization 
    href="REC-xpath20-20070123.htm#dt-atomization">Atomization</A> 
    is applied to the given value, resulting in a sequence of atomic values.</P>
    <LI>
    <P>Each item in the atomic sequence that is of type 
    <CODE>xs:untypedAtomic</CODE> is cast to the expected atomic type. For <A 
    title="built-in function" 
    href="REC-xpath20-20070123.htm#dt-built-in-function">built-in 
    functions</A> where the expected type is specified as <A title=numeric 
    href="REC-xpath20-20070123.htm#dt-numeric">numeric</A>, 
    arguments of type <CODE>xs:untypedAtomic</CODE> are cast to 
    <CODE>xs:double</CODE>.</P>
    <LI>
    <P>For each <A title=numeric 
    href="REC-xpath20-20070123.htm#dt-numeric">numeric</A> 
    item in the atomic sequence that can be <A title="type promotion" 
    href="REC-xpath20-20070123.htm#dt-type-promotion">promoted</A> 
    to the expected atomic type using numeric promotion as described in <A 
    href="REC-xpath20-20070123.htm#promotion"><B>B.1 Type 
    Promotion</B></A>, the promotion is done.</P>
    <LI>
    <P>For each item of type <CODE>xs:anyURI</CODE> in the atomic sequence that 
    can be <A title="type promotion" 
    href="REC-xpath20-20070123.htm#dt-type-promotion">promoted</A> 
    to the expected atomic type using URI promotion as described in <A 
    href="REC-xpath20-20070123.htm#promotion"><B>B.1 Type 
    Promotion</B></A>, the promotion is done.</P></LI></OL>
  <LI>
  <P>If, after the above conversions, the resulting value does not match the 
  expected type according to the rules for <A title="SequenceType matching" 
  href="REC-xpath20-20070123.htm#dt-sequencetype-matching">SequenceType 
  Matching</A>, a <A title="type error" 
  href="REC-xpath20-20070123.htm#dt-type-error">type 
  error</A> is raised [<A title=err:XPTY0004 
  href="REC-xpath20-20070123.htm#ERRXPTY0004">err:XPTY0004</A>]. 
  Note that the rules for <A title="SequenceType matching" 
  href="REC-xpath20-20070123.htm#dt-sequencetype-matching">SequenceType 
  Matching</A> permit a value of a derived type to be substituted for a value of 
  its base type.</P></LI></UL>
<P>Since the arguments of a function call are separated by commas, any argument 
expression that contains a top-level <A title="comma operator" 
href="REC-xpath20-20070123.htm#dt-comma-operator">comma 
operator</A> must be enclosed in parentheses. Here are some illustrative 
examples of function calls:</P>
<UL>
  <LI>
  <P><CODE>my:three-argument-function(1, 2, 3)</CODE> denotes a function call 
  with three arguments.</P>
  <LI>
  <P><CODE>my:two-argument-function((1, 2), 3)</CODE> denotes a function call 
  with two arguments, the first of which is a sequence of two values.</P>
  <LI>
  <P><CODE>my:two-argument-function(1, ())</CODE> denotes a function call with 
  two arguments, the second of which is an empty sequence.</P>
  <LI>
  <P><CODE>my:one-argument-function((1, 2, 3))</CODE> denotes a function call 
  with one argument that is a sequence of three values.</P>
  <LI>
  <P><CODE>my:one-argument-function(( ))</CODE> denotes a function call with one 
  argument that is an empty sequence.</P>
  <LI>
  <P><CODE>my:zero-argument-function( )</CODE> denotes a function call with zero 
  arguments.</P></LI></UL></DIV></DIV>
<DIV class=div2>
<H3><A id=id-path-expressions name=id-path-expressions></A>3.2 Path 
Expressions</H3>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-PathExpr 
    name=doc-xpath-PathExpr></A>[25]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-PathExpr">PathExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>("/" <A 
      href="REC-xpath20-20070123.htm#doc-xpath-RelativePathExpr">RelativePathExpr</A>?)<BR>| 
      ("//" <A 
      href="REC-xpath20-20070123.htm#doc-xpath-RelativePathExpr">RelativePathExpr</A>)<BR>| 
      <A 
      href="REC-xpath20-20070123.htm#doc-xpath-RelativePathExpr">RelativePathExpr</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-RelativePathExpr 
      name=doc-xpath-RelativePathExpr></A>[26]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-RelativePathExpr">RelativePathExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-StepExpr">StepExpr</A> 
      (("/" | "//") <A 
      href="REC-xpath20-20070123.htm#doc-xpath-StepExpr">StepExpr</A>)*</CODE></TD></TR></TBODY></TABLE>
<P>[<A id=dt-path-expression title="path expression" 
name=dt-path-expression>Definition</A>: A <B>path expression</B> can be used to 
locate nodes within trees. A path expression consists of a series of one or more 
<A title=step 
href="REC-xpath20-20070123.htm#dt-step">steps</A>, 
separated by "<CODE>/</CODE>" or "<CODE>//</CODE>", and optionally beginning 
with "<CODE>/</CODE>" or "<CODE>//</CODE>".] An initial "<CODE>/</CODE>" or 
"<CODE>//</CODE>" is an abbreviation for one or more initial steps that are 
implicitly added to the beginning of the path expression, as described 
below.</P>
<P>A path expression consisting of a single step is evaluated as described in <A 
href="REC-xpath20-20070123.htm#id-steps"><B>3.2.1 
Steps</B></A>.</P>
<P>A "<CODE>/</CODE>" at the beginning of a path expression is an abbreviation 
for the initial step <CODE>fn:root(self::node()) treat as 
document-node()/</CODE> (however, if the "<CODE>/</CODE>" is the entire path 
expression, the trailing "<CODE>/</CODE>" is omitted from the expansion.) The 
effect of this initial step is to begin the path at the root node of the tree 
that contains the context node. If the context item is not a node, a <A 
title="type error" 
href="REC-xpath20-20070123.htm#dt-type-error">type 
error</A> is raised [<A title=err:XPTY0020 
href="REC-xpath20-20070123.htm#ERRXPTY0020">err:XPTY0020</A>]. 
At evaluation time, if the root node above the context node is not a document 
node, a <A title="dynamic error" 
href="REC-xpath20-20070123.htm#dt-dynamic-error">dynamic 
error</A> is raised [<A title=err:XPDY0050 
href="REC-xpath20-20070123.htm#ERRXPDY0050">err:XPDY0050</A>].</P>
<P>A "<CODE>//</CODE>" at the beginning of a path expression is an abbreviation 
for the initial steps <CODE>fn:root(self::node()) treat as 
document-node()/descendant-or-self::node()/</CODE> (however, "<CODE>//</CODE>" 
by itself is not a valid path expression [<A title=err:XPST0003 
href="REC-xpath20-20070123.htm#ERRXPST0003">err:XPST0003</A>].) 
The effect of these initial steps is to establish an initial node sequence that 
contains the root of the tree in which the context node is found, plus all nodes 
descended from this root. This node sequence is used as the input to subsequent 
steps in the path expression. If the context item is not a node, a <A 
title="type error" 
href="REC-xpath20-20070123.htm#dt-type-error">type 
error</A> is raised [<A title=err:XPTY0020 
href="REC-xpath20-20070123.htm#ERRXPTY0020">err:XPTY0020</A>]. 
At evaluation time, if the root node above the context node is not a document 
node, a <A title="dynamic error" 
href="REC-xpath20-20070123.htm#dt-dynamic-error">dynamic 
error</A> is raised [<A title=err:XPDY0050 
href="REC-xpath20-20070123.htm#ERRXPDY0050">err:XPDY0050</A>].</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>The descendants of a node do not include attribute nodes <SPAN 
class=xpath><SPAN class=xpath>or namespace nodes</SPAN></SPAN>.</P></DIV>
<P>Each non-initial occurrence of "<CODE>//</CODE>" in a path expression is 
expanded as described in <A 
href="REC-xpath20-20070123.htm#abbrev"><B>3.2.4 
Abbreviated Syntax</B></A>, leaving a sequence of steps separated by 
"<CODE>/</CODE>". This sequence of steps is then evaluated from left to right. 
Each operation <CODE>E1/E2</CODE> is evaluated as follows: Expression 
<CODE>E1</CODE> is evaluated, and if the result is not a (possibly empty) 
sequence of nodes, a <A title="type error" 
href="REC-xpath20-20070123.htm#dt-type-error">type 
error</A> is raised [<A title=err:XPTY0019 
href="REC-xpath20-20070123.htm#ERRXPTY0019">err:XPTY0019</A>]. 
Each node resulting from the evaluation of <CODE>E1</CODE> then serves in turn 
to provide an <B>inner focus</B> for an evaluation of <CODE>E2</CODE>, as 
described in <A 
href="REC-xpath20-20070123.htm#eval_context"><B>2.1.2 
Dynamic Context</B></A>. The sequences resulting from all the evaluations of 
<CODE>E2</CODE> are combined as follows:</P>
<OL class=enumar>
  <LI>
  <P>If every evaluation of <CODE>E2</CODE> returns a (possibly empty) sequence 
  of nodes, these sequences are combined, and duplicate nodes are eliminated 
  based on node identity. <SPAN class=xpath><SPAN class=xpath>The resulting node 
  sequence is returned in <A title="document order" 
  href="REC-xpath20-20070123.htm#dt-document-order">document 
  order</A>.</SPAN></SPAN></P>
  <LI>
  <P>If every evaluation of <CODE>E2</CODE> returns a (possibly empty) sequence 
  of atomic values, these sequences are concatenated<SPAN class=xpath><SPAN 
  class=xpath>, in order,</SPAN></SPAN> and returned.</P>
  <LI>
  <P>If the multiple evaluations of <CODE>E2</CODE> return at least one node and 
  at least one atomic value, a <A title="type error" 
  href="REC-xpath20-20070123.htm#dt-type-error">type 
  error</A> is raised [<A title=err:XPTY0018 
  href="REC-xpath20-20070123.htm#ERRXPTY0018">err:XPTY0018</A>].</P></LI></OL>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>Since each step in a path provides context nodes for the following step, in 
effect, only the last step in a path is allowed to return a sequence of atomic 
values.</P></DIV>
<P>As an example of a path expression, <CODE>child::div1/child::para</CODE> 
selects the <CODE>para</CODE> element children of the <CODE>div1</CODE> element 
children of the context node, or, in other words, the <CODE>para</CODE> element 
grandchildren of the context node that have <CODE>div1</CODE> parents.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P id=Chg-slash-note>The "<CODE>/</CODE>" character can be used either as a 
complete path expression or as the beginning of a longer path expression such as 
"<CODE>/*</CODE>". Also, "<CODE>*</CODE>" is both the multiply operator and a 
wildcard in path expressions. This can cause parsing difficulties when 
"<CODE>/</CODE>" appears on the left hand side of "<CODE>*</CODE>". This is 
resolved using the <A 
href="REC-xpath20-20070123.htm#parse-note-leading-lone-slash">leading-lone-slash</A> 
constraint. For example, "<CODE>/*</CODE>" and "<CODE>/ *</CODE>" are valid path 
expressions containing wildcards, but "<CODE>/*5</CODE>" and "<CODE>/ * 
5</CODE>" raise syntax errors. Parentheses must be used when "<CODE>/</CODE>" is 
used on the left hand side of an operator, as in "<CODE>(/) * 5</CODE>". 
Similarly, "<CODE>4 + / * 5</CODE>" raises a syntax error, but "<CODE>4 + (/) * 
5</CODE>" is a valid expression. The expression "<CODE>4 + /</CODE>" is also 
valid, because <CODE>/</CODE> does not occur on the left hand side of the 
operator.</P></DIV>
<DIV class=div3>
<H4><A id=id-steps name=id-steps></A>3.2.1 Steps</H4>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-StepExpr 
    name=doc-xpath-StepExpr></A>[27]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-StepExpr">StepExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-FilterExpr">FilterExpr</A> 
      | <A 
      href="REC-xpath20-20070123.htm#doc-xpath-AxisStep">AxisStep</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-AxisStep 
    name=doc-xpath-AxisStep></A>[28]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-AxisStep">AxisStep</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>(<A 
      href="REC-xpath20-20070123.htm#doc-xpath-ReverseStep">ReverseStep</A> 
      | <A 
      href="REC-xpath20-20070123.htm#doc-xpath-ForwardStep">ForwardStep</A>) 
      <A 
      href="REC-xpath20-20070123.htm#doc-xpath-PredicateList">PredicateList</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-ForwardStep 
      name=doc-xpath-ForwardStep></A>[29]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-ForwardStep">ForwardStep</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>(<A 
      href="REC-xpath20-20070123.htm#doc-xpath-ForwardAxis">ForwardAxis</A> 
      <A 
      href="REC-xpath20-20070123.htm#doc-xpath-NodeTest">NodeTest</A>) 
      | <A 
      href="REC-xpath20-20070123.htm#doc-xpath-AbbrevForwardStep">AbbrevForwardStep</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-ReverseStep 
      name=doc-xpath-ReverseStep></A>[32]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-ReverseStep">ReverseStep</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>(<A 
      href="REC-xpath20-20070123.htm#doc-xpath-ReverseAxis">ReverseAxis</A> 
      <A 
      href="REC-xpath20-20070123.htm#doc-xpath-NodeTest">NodeTest</A>) 
      | <A 
      href="REC-xpath20-20070123.htm#doc-xpath-AbbrevReverseStep">AbbrevReverseStep</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-PredicateList 
      name=doc-xpath-PredicateList></A>[39]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-PredicateList">PredicateList</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-Predicate">Predicate</A>*</CODE></TD></TR></TBODY></TABLE>
<P>[<A id=dt-step title=step name=dt-step>Definition</A>: A <B>step</B> is a 
part of a <A title="path expression" 
href="REC-xpath20-20070123.htm#dt-path-expression">path 
expression</A> that generates a sequence of items and then filters the sequence 
by zero or more <A title=predicate 
href="REC-xpath20-20070123.htm#dt-predicate">predicates</A>. 
The value of the step consists of those items that satisfy the predicates, 
working from left to right. A step may be either an <A title="axis step" 
href="REC-xpath20-20070123.htm#dt-axis-step">axis 
step</A> or a <A title="filter expression" 
href="REC-xpath20-20070123.htm#dt-filter-expression">filter 
expression</A>.] Filter expressions are described in <A 
href="REC-xpath20-20070123.htm#id-filter-expr"><B>3.3.2 
Filter Expressions</B></A>.</P>
<P>[<A id=dt-axis-step title="axis step" name=dt-axis-step>Definition</A>: An 
<B>axis step</B> returns a sequence of nodes that are reachable from the context 
node via a specified axis. Such a step has two parts: an <B>axis</B>, which 
defines the "direction of movement" for the step, and a <A title="node test" 
href="REC-xpath20-20070123.htm#dt-node-test">node 
test</A>, which selects nodes based on their kind, name, and/or <A 
title="type annotation" 
href="REC-xpath20-20070123.htm#dt-type-annotation">type 
annotation</A>.] If the context item is a node, an axis step returns a sequence 
of zero or more nodes; otherwise, a <A title="type error" 
href="REC-xpath20-20070123.htm#dt-type-error">type 
error</A> is raised [<A title=err:XPTY0020 
href="REC-xpath20-20070123.htm#ERRXPTY0020">err:XPTY0020</A>]. 
<SPAN class=xpath><SPAN class=xpath>The resulting node sequence is returned in 
<A title="document order" 
href="REC-xpath20-20070123.htm#dt-document-order">document 
order</A>.</SPAN></SPAN> An axis step may be either a <B>forward step</B> or a 
<B>reverse step</B>, followed by zero or more <A title=predicate 
href="REC-xpath20-20070123.htm#dt-predicate">predicates</A>.</P>
<P>In the <B>abbreviated syntax</B> for a step, the axis can be omitted and 
other shorthand notations can be used as described in <A 
href="REC-xpath20-20070123.htm#abbrev"><B>3.2.4 
Abbreviated Syntax</B></A>.</P>
<P>The unabbreviated syntax for an axis step consists of the axis name and node 
test separated by a double colon. The result of the step consists of the nodes 
reachable from the context node via the specified axis that have the node kind, 
name, and/or <A title="type annotation" 
href="REC-xpath20-20070123.htm#dt-type-annotation">type 
annotation</A> specified by the node test. For example, the step 
<CODE>child::para</CODE> selects the <CODE>para</CODE> element children of the 
context node: <CODE>child</CODE> is the name of the axis, and <CODE>para</CODE> 
is the name of the element nodes to be selected on this axis. The available axes 
are described in <A 
href="REC-xpath20-20070123.htm#axes"><B>3.2.1.1 
Axes</B></A>. The available node tests are described in <A 
href="REC-xpath20-20070123.htm#node-tests"><B>3.2.1.2 
Node Tests</B></A>. Examples of steps are provided in <A 
href="REC-xpath20-20070123.htm#unabbrev"><B>3.2.3 
Unabbreviated Syntax</B></A> and <A 
href="REC-xpath20-20070123.htm#abbrev"><B>3.2.4 
Abbreviated Syntax</B></A>.</P>
<DIV class=div4>
<H5><A id=axes name=axes></A>3.2.1.1 Axes</H5>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-ForwardAxis 
      name=doc-xpath-ForwardAxis></A>[30]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-ForwardAxis">ForwardAxis</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>("child" "::")<BR>| ("descendant" "::")<BR>| ("attribute" 
      "::")<BR>| ("self" "::")<BR>| ("descendant-or-self" "::")<BR>| 
      ("following-sibling" "::")<BR>| ("following" "::")<BR>| ("namespace" 
      "::")</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-ReverseAxis 
      name=doc-xpath-ReverseAxis></A>[33]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-ReverseAxis">ReverseAxis</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>("parent" "::")<BR>| ("ancestor" "::")<BR>| ("preceding-sibling" 
      "::")<BR>| ("preceding" "::")<BR>| ("ancestor-or-self" 
  "::")</CODE></TD></TR></TBODY></TABLE>
<DIV class=xpath>
<P class=xpath>XPath defines a full set of <B>axes</B> for traversing documents, 
but a <B>host language</B> may define a subset of these axes. The following axes 
are defined:</P></DIV>
<UL>
  <LI>
  <P>The <CODE>child</CODE> axis contains the children of the context node, 
  which are the nodes returned by the <CODE>dm:children</CODE> accessor in <A 
  href="REC-xpath20-20070123.htm#datamodel">[XQuery/XPath 
  Data Model (XDM)]</A>.</P>
  <DIV class=note>
  <P class=prefix><B>Note:</B></P>
  <P>Only document nodes and element nodes have children. If the context node is 
  any other kind of node, or if the context node is an empty document or element 
  node, then the child axis is an empty sequence. The children of a document 
  node or element node may be element, processing instruction, comment, or text 
  nodes. Attribute<SPAN class=xpath><SPAN class=xpath>, namespace,</SPAN></SPAN> 
  and document nodes can never appear as children.</P></DIV>
  <LI>
  <P>the <CODE>descendant</CODE> axis is defined as the transitive closure of 
  the child axis; it contains the descendants of the context node (the children, 
  the children of the children, and so on)</P>
  <LI>
  <P>the <CODE>parent</CODE> axis contains the sequence returned by the 
  <CODE>dm:parent</CODE> accessor in <A 
  href="REC-xpath20-20070123.htm#datamodel">[XQuery/XPath 
  Data Model (XDM)]</A>, which returns the parent of the context node, or an 
  empty sequence if the context node has no parent</P>
  <DIV class=note>
  <P class=prefix><B>Note:</B></P>
  <P>An attribute node may have an element node as its parent, even though the 
  attribute node is not a child of the element node.</P></DIV>
  <LI>
  <P>the <CODE>ancestor</CODE> axis is defined as the transitive closure of the 
  parent axis; it contains the ancestors of the context node (the parent, the 
  parent of the parent, and so on)</P>
  <DIV class=note>
  <P class=prefix><B>Note:</B></P>
  <P>The ancestor axis includes the root node of the tree in which the context 
  node is found, unless the context node is the root node.</P></DIV>
  <LI>
  <P>the <CODE>following-sibling</CODE> axis contains the context node's 
  following siblings, those children of the context node's parent that occur 
  after the context node in <A title="document order" 
  href="REC-xpath20-20070123.htm#dt-document-order">document 
  order</A>; if the context node is an attribute <SPAN class=xpath><SPAN 
  class=xpath>or namespace</SPAN></SPAN> node, the 
  <CODE>following-sibling</CODE> axis is empty</P>
  <LI>
  <P>the <CODE>preceding-sibling</CODE> axis contains the context node's 
  preceding siblings, those children of the context node's parent that occur 
  before the context node in <A title="document order" 
  href="REC-xpath20-20070123.htm#dt-document-order">document 
  order</A>; if the context node is an attribute <SPAN class=xpath><SPAN 
  class=xpath>or namespace</SPAN></SPAN> node, the 
  <CODE>preceding-sibling</CODE> axis is empty</P>
  <LI>
  <P>the <CODE>following</CODE> axis contains all nodes that are descendants of 
  the root of the tree in which the context node is found, are not descendants 
  of the context node, and occur after the context node in <A 
  title="document order" 
  href="REC-xpath20-20070123.htm#dt-document-order">document 
  order</A></P>
  <LI>
  <P>the <CODE>preceding</CODE> axis contains all nodes that are descendants of 
  the root of the tree in which the context node is found, are not ancestors of 
  the context node, and occur before the context node in <A 
  title="document order" 
  href="REC-xpath20-20070123.htm#dt-document-order">document 
  order</A></P>
  <LI>
  <P>the <CODE>attribute</CODE> axis contains the attributes of the context 
  node, which are the nodes returned by the <CODE>dm:attributes</CODE> accessor 
  in <A 
  href="REC-xpath20-20070123.htm#datamodel">[XQuery/XPath 
  Data Model (XDM)]</A>; the axis will be empty unless the context node is an 
  element</P>
  <LI>
  <P>the <CODE>self</CODE> axis contains just the context node itself</P>
  <LI>
  <P>the <CODE>descendant-or-self</CODE> axis contains the context node and the 
  descendants of the context node</P>
  <LI>
  <P>the <CODE>ancestor-or-self</CODE> axis contains the context node and the 
  ancestors of the context node; thus, the ancestor-or-self axis will always 
  include the root node</P>
  <LI class=xpath>
  <P>the <CODE>namespace</CODE> axis contains the namespace nodes of the context 
  node, which are the nodes returned by the <CODE>dm:namespace-nodes</CODE> 
  accessor in <A 
  href="REC-xpath20-20070123.htm#datamodel">[XQuery/XPath 
  Data Model (XDM)]</A>; this axis is empty unless the context node is an 
  element node. The <CODE>namespace</CODE> axis is deprecated in XPath 2.0. If 
  <A title="XPath 1.0 compatibility mode" 
  href="REC-xpath20-20070123.htm#dt-xpath-compat-mode">XPath 
  1.0 compatibility mode</A> is <CODE>true</CODE>, the <CODE>namespace</CODE> 
  axis must be supported. If <A title="XPath 1.0 compatibility mode" 
  href="REC-xpath20-20070123.htm#dt-xpath-compat-mode">XPath 
  1.0 compatibility mode</A> is <CODE>false</CODE>, then support for the 
  <CODE>namespace</CODE> axis is <A title="implementation defined" 
  href="REC-xpath20-20070123.htm#dt-implementation-defined">implementation-defined</A>. 
  An implementation that does not support the <CODE>namespace</CODE> axis when 
  <A title="XPath 1.0 compatibility mode" 
  href="REC-xpath20-20070123.htm#dt-xpath-compat-mode">XPath 
  1.0 compatibility mode</A> is <CODE>false</CODE> must raise a <A 
  title="static error" 
  href="REC-xpath20-20070123.htm#dt-static-error">static 
  error</A> [<A title=err:XPST0010 
  href="REC-xpath20-20070123.htm#ERRXPST0010">err:XPST0010</A>] 
  if it is used. Applications needing information about the <A 
  title="in-scope namespaces" 
  href="REC-xpath20-20070123.htm#dt-in-scope-namespaces">in-scope 
  namespaces</A> of an element should use the functions 
  <CODE>fn:in-scope-prefixes</CODE> and <CODE>fn:namespace-uri-for-prefix</CODE> 
  defined in <A 
  href="REC-xpath20-20070123.htm#FunctionsAndOperators">[XQuery 
  1.0 and XPath 2.0 Functions and Operators]</A>.</P></LI></UL>
<P>Axes can be categorized as <B>forward axes</B> and <B>reverse axes</B>. An 
axis that only ever contains the context node or nodes that are after the 
context node in <A title="document order" 
href="REC-xpath20-20070123.htm#dt-document-order">document 
order</A> is a forward axis. An axis that only ever contains the context node or 
nodes that are before the context node in <A title="document order" 
href="REC-xpath20-20070123.htm#dt-document-order">document 
order</A> is a reverse axis.</P>
<P>The <CODE>parent</CODE>, <CODE>ancestor</CODE>, 
<CODE>ancestor-or-self</CODE>, <CODE>preceding</CODE>, and 
<CODE>preceding-sibling</CODE> axes are reverse axes; all other axes are forward 
axes. The <CODE>ancestor</CODE>, <CODE>descendant</CODE>, 
<CODE>following</CODE>, <CODE>preceding</CODE> and <CODE>self</CODE> axes 
partition a document (ignoring attribute <SPAN class=xpath><SPAN class=xpath>and 
namespace</SPAN></SPAN> nodes): they do not overlap and together they contain 
all the nodes in the document.</P>
<P>[<A id=dt-principal-node-kind title="principal node kind" 
name=dt-principal-node-kind>Definition</A>: Every axis has a <B>principal node 
kind</B>. If an axis can contain elements, then the principal node kind is 
element; otherwise, it is the kind of nodes that the axis can contain.] 
Thus:</P>
<UL>
  <LI>
  <P>For the attribute axis, the principal node kind is attribute.</P>
  <LI class=xpath>
  <P>For the namespace axis, the principal node kind is namespace.</P>
  <LI>
  <P>For all other axes, the principal node kind is element.</P></LI></UL></DIV>
<DIV class=div4>
<H5><A id=node-tests name=node-tests></A>3.2.1.2 Node Tests</H5>
<P>[<A id=dt-node-test title="node test" name=dt-node-test>Definition</A>: A 
<B>node test</B> is a condition that must be true for each node selected by a <A 
title=step 
href="REC-xpath20-20070123.htm#dt-step">step</A>.] The 
condition may be based on the kind of the node (element, attribute, text, 
document, comment, or processing instruction), the name of the node, or (in the 
case of element, attribute, and document nodes), the <A title="type annotation" 
href="REC-xpath20-20070123.htm#dt-type-annotation">type 
annotation</A> of the node.</P>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-NodeTest 
    name=doc-xpath-NodeTest></A>[35]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-NodeTest">NodeTest</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-KindTest">KindTest</A> 
      | <A 
      href="REC-xpath20-20070123.htm#doc-xpath-NameTest">NameTest</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-NameTest 
    name=doc-xpath-NameTest></A>[36]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-NameTest">NameTest</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-QName">QName</A> 
      | <A 
      href="REC-xpath20-20070123.htm#doc-xpath-Wildcard">Wildcard</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-Wildcard 
    name=doc-xpath-Wildcard></A>[37]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-Wildcard">Wildcard</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"*"<BR>| (<A 
      href="REC-xpath20-20070123.htm#prod-xpath-NCName">NCName</A> 
      ":" "*")<BR>| ("*" ":" <A 
      href="REC-xpath20-20070123.htm#prod-xpath-NCName">NCName</A>)</CODE></TD></TR></TBODY></TABLE>
<P>[<A id=dt-name-test title="name test" name=dt-name-test>Definition</A>: A 
node test that consists only of a QName or a Wildcard is called a <B>name 
test</B>.] A name test is true if and only if the <B>kind</B> of the node is the 
<A title="principal node kind" 
href="REC-xpath20-20070123.htm#dt-principal-node-kind">principal 
node kind</A> for the step axis and the <A title="expanded QName" 
href="REC-xpath20-20070123.htm#dt-expanded-qname">expanded 
QName</A> of the node is equal (as defined by the <CODE>eq</CODE> operator) to 
the <A title="expanded QName" 
href="REC-xpath20-20070123.htm#dt-expanded-qname">expanded 
QName</A> specified by the name test. For example, <CODE>child::para</CODE> 
selects the <CODE>para</CODE> element children of the context node; if the 
context node has no <CODE>para</CODE> children, it selects an empty set of 
nodes. <CODE>attribute::abc:href</CODE> selects the attribute of the context 
node with the QName <CODE>abc:href</CODE>; if the context node has no such 
attribute, it selects an empty set of nodes.</P>
<P>A QName in a name test is resolved into an <A title="expanded QName" 
href="REC-xpath20-20070123.htm#dt-expanded-qname">expanded 
QName</A> using the <A title="statically known namespaces" 
href="REC-xpath20-20070123.htm#dt-static-namespaces">statically 
known namespaces</A> in the expression context. It is a <A title="static error" 
href="REC-xpath20-20070123.htm#dt-static-error">static 
error</A> [<A title=err:XPST0081 
href="REC-xpath20-20070123.htm#ERRXPST0081">err:XPST0081</A>] 
if the QName has a prefix that does not correspond to any statically known 
namespace. An unprefixed QName, when used as a name test on an axis whose <A 
title="principal node kind" 
href="REC-xpath20-20070123.htm#dt-principal-node-kind">principal 
node kind</A> is element, has the namespace URI of the <A 
title="default element/type namespace" 
href="REC-xpath20-20070123.htm#dt-def-elemtype-ns">default 
element/type namespace</A> in the expression context; otherwise, it has no 
namespace URI.</P>
<P>A name test is not satisfied by an element node whose name does not match the 
<A title="expanded QName" 
href="REC-xpath20-20070123.htm#dt-expanded-qname">expanded 
QName</A> of the name test, even if it is in a <A title="substitution group" 
href="REC-xpath20-20070123.htm#dt-substitution-group">substitution 
group</A> whose head is the named element.</P>
<P>A node test <CODE>*</CODE> is true for any node of the <A 
title="principal node kind" 
href="REC-xpath20-20070123.htm#dt-principal-node-kind">principal 
node kind</A> of the step axis. For example, <CODE>child::*</CODE> will select 
all element children of the context node, and <CODE>attribute::*</CODE> will 
select all attributes of the context node.</P>
<P>A node test can have the form <CODE>NCName:*</CODE>. In this case, the prefix 
is expanded in the same way as with a QName, using the <A 
title="statically known namespaces" 
href="REC-xpath20-20070123.htm#dt-static-namespaces">statically 
known namespaces</A> in the <A title="static context" 
href="REC-xpath20-20070123.htm#dt-static-context">static 
context</A>. If the prefix is not found in the statically known namespaces, a <A 
title="static error" 
href="REC-xpath20-20070123.htm#dt-static-error">static 
error</A> is raised [<A title=err:XPST0081 
href="REC-xpath20-20070123.htm#ERRXPST0081">err:XPST0081</A>]. 
The node test is true for any node of the <A title="principal node kind" 
href="REC-xpath20-20070123.htm#dt-principal-node-kind">principal 
node kind</A> of the step axis whose <A title="expanded QName" 
href="REC-xpath20-20070123.htm#dt-expanded-qname">expanded 
QName</A> has the namespace URI to which the prefix is bound, regardless of the 
local part of the name.</P>
<P>A node test can also have the form <CODE>*:NCName</CODE>. In this case, the 
node test is true for any node of the <A title="principal node kind" 
href="REC-xpath20-20070123.htm#dt-principal-node-kind">principal 
node kind</A> of the step axis whose local name matches the given NCName, 
regardless of its namespace or lack of a namespace.</P>
<P>[<A id=dt-kind-test title="kind test" name=dt-kind-test>Definition</A>: An 
alternative form of a node test called a <B>kind test</B> can select nodes based 
on their kind, name, and <A title="type annotation" 
href="REC-xpath20-20070123.htm#dt-type-annotation">type 
annotation</A>.] The syntax and semantics of a kind test are described in <A 
href="REC-xpath20-20070123.htm#id-sequencetype-syntax"><B>2.5.3 
SequenceType Syntax</B></A> and <A 
href="REC-xpath20-20070123.htm#id-sequencetype-matching"><B>2.5.4 
SequenceType Matching</B></A>. When a kind test is used in a <A 
title="node test" 
href="REC-xpath20-20070123.htm#dt-node-test">node 
test</A>, only those nodes on the designated axis that match the kind test are 
selected. Shown below are several examples of kind tests that might be used in 
path expressions:</P>
<UL>
  <LI>
  <P><CODE>node()</CODE> matches any node.</P>
  <LI>
  <P><CODE>text()</CODE> matches any text node.</P>
  <LI>
  <P><CODE>comment()</CODE> matches any comment node.</P>
  <LI>
  <P><CODE>element()</CODE> matches any element node.</P>
  <LI>
  <P><CODE>schema-element(person)</CODE> matches any element node whose name is 
  <CODE>person</CODE> (or is in the <A title="substitution group" 
  href="REC-xpath20-20070123.htm#dt-substitution-group">substitution 
  group</A> headed by <CODE>person</CODE>), and whose type annotation is the 
  same as (or is derived from) the declared type of the <CODE>person</CODE> 
  element in the <A title="in-scope element declarations" 
  href="REC-xpath20-20070123.htm#dt-is-elems">in-scope 
  element declarations</A>.</P>
  <LI>
  <P><CODE>element(person)</CODE> matches any element node whose name is 
  <CODE>person</CODE>, regardless of its type annotation.</P>
  <LI>
  <P><CODE>element(person, surgeon)</CODE> matches any non-nilled element node 
  whose name is <CODE>person</CODE>, and whose type annotation is 
  <CODE>surgeon</CODE> or is derived from <CODE>surgeon</CODE>.</P>
  <LI>
  <P><CODE>element(*, surgeon)</CODE> matches any non-nilled element node whose 
  type annotation is <CODE>surgeon</CODE> (or is derived from 
  <CODE>surgeon</CODE>), regardless of its name.</P>
  <LI>
  <P><CODE>attribute()</CODE> matches any attribute node.</P>
  <LI>
  <P><CODE>attribute(price)</CODE> matches any attribute whose name is 
  <CODE>price</CODE>, regardless of its type annotation.</P>
  <LI>
  <P><CODE>attribute(*, xs:decimal)</CODE> matches any attribute whose type 
  annotation is <CODE>xs:decimal</CODE> (or is derived from 
  <CODE>xs:decimal</CODE>), regardless of its name.</P>
  <LI>
  <P><CODE>document-node()</CODE> matches any document node.</P>
  <LI>
  <P><CODE>document-node(element(book))</CODE> matches any document node whose 
  content consists of a single element node that satisfies the <A 
  title="kind test" 
  href="REC-xpath20-20070123.htm#dt-kind-test">kind 
  test</A> <CODE>element(book)</CODE>, interleaved with zero or more comments 
  and processing instructions.</P></LI></UL></DIV></DIV>
<DIV class=div3>
<H4><A id=id-predicates name=id-predicates></A>3.2.2 Predicates</H4>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-Predicate 
      name=doc-xpath-Predicate></A>[40]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-Predicate">Predicate</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"[" <A 
      href="REC-xpath20-20070123.htm#doc-xpath-Expr">Expr</A> 
      "]"</CODE></TD></TR></TBODY></TABLE>
<P>[<A id=dt-predicate title=predicate name=dt-predicate>Definition</A>: A 
<B>predicate</B> consists of an expression, called a <B>predicate 
expression</B>, enclosed in square brackets. A predicate serves to filter a 
sequence, retaining some items and discarding others.] In the case of multiple 
adjacent predicates, the predicates are applied from left to right, and the 
result of applying each predicate serves as the input sequence for the following 
predicate.</P>
<P>For each item in the input sequence, the predicate expression is evaluated 
using an <B>inner focus</B>, defined as follows: The context item is the item 
currently being tested against the predicate. The context size is the number of 
items in the input sequence. The context position is the position of the context 
item within the input sequence. For the purpose of evaluating the context 
position within a predicate, the input sequence is considered to be sorted as 
follows: into document order if the predicate is in a forward-axis step, into 
reverse document order if the predicate is in a reverse-axis step, or in its 
original order if the predicate is not in a step.</P>
<P>For each item in the input sequence, the result of the predicate expression 
is coerced to an <CODE>xs:boolean</CODE> value, called the <B>predicate truth 
value</B>, as described below. Those items for which the predicate truth value 
is <CODE>true</CODE> are retained, and those for which the predicate truth value 
is <CODE>false</CODE> are discarded.</P>
<P>The predicate truth value is derived by applying the following rules, in 
order:</P>
<OL class=enumar>
  <LI>
  <P>If the value of the predicate expression is a <A title=singleton 
  href="REC-xpath20-20070123.htm#dt-singleton">singleton</A> 
  atomic value of a <A title=numeric 
  href="REC-xpath20-20070123.htm#dt-numeric">numeric</A> 
  type or derived from a <A title=numeric 
  href="REC-xpath20-20070123.htm#dt-numeric">numeric</A> 
  type, the predicate truth value is <CODE>true</CODE> if the value of the 
  predicate expression is equal (by the <CODE>eq</CODE> operator) to the 
  <B>context position</B>, and is <CODE>false</CODE> otherwise. [<A 
  id=dt-numeric-predicate title="numeric predicate" 
  name=dt-numeric-predicate>Definition</A>: A predicate whose predicate 
  expression returns a numeric type is called a <B>numeric predicate</B>.]</P>
  <LI>
  <P>Otherwise, the predicate truth value is the <A 
  title="effective boolean value" 
  href="REC-xpath20-20070123.htm#dt-ebv">effective 
  boolean value</A> of the predicate expression.</P></LI></OL>
<P>Here are some examples of <A title="axis step" 
href="REC-xpath20-20070123.htm#dt-axis-step">axis 
steps</A> that contain predicates:</P>
<UL>
  <LI>
  <P>This example selects the second <CODE>chapter</CODE> element that is a 
  child of the context node:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>child::chapter[2]
</PRE></DIV></DIV>
  <LI>
  <P>This example selects all the descendants of the context node that are 
  elements named <CODE>"toy"</CODE> and whose <CODE>color</CODE> attribute has 
  the value <CODE>"red"</CODE>:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>descendant::toy[attribute::color = "red"]
</PRE></DIV></DIV>
  <LI>
  <P>This example selects all the <CODE>employee</CODE> children of the context 
  node that have both a <CODE>secretary</CODE> child element and an 
  <CODE>assistant</CODE> child element:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>child::employee[secretary][assistant]
</PRE></DIV></DIV></LI></UL>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>When using <A title=predicate 
href="REC-xpath20-20070123.htm#dt-predicate">predicates</A> 
with a sequence of nodes selected using a <B>reverse axis</B>, it is important 
to remember that the the context positions for such a sequence are assigned in 
<A title="reverse document order" 
href="REC-xpath20-20070123.htm#dt-reverse-document-order">reverse 
document order</A>. For example, <CODE>preceding::foo[1]</CODE> returns the 
first qualifying <CODE>foo</CODE> element in <A title="reverse document order" 
href="REC-xpath20-20070123.htm#dt-reverse-document-order">reverse 
document order</A>, because the predicate is part of an <A title="axis step" 
href="REC-xpath20-20070123.htm#dt-axis-step">axis 
step</A> using a reverse axis. By contrast, <CODE>(preceding::foo)[1]</CODE> 
returns the first qualifying <CODE>foo</CODE> element in <A 
title="document order" 
href="REC-xpath20-20070123.htm#dt-document-order">document 
order</A>, because the parentheses cause <CODE>(preceding::foo)</CODE> to be 
parsed as a <A title="primary expression" 
href="REC-xpath20-20070123.htm#dt-primary-expression">primary 
expression</A> in which context positions are assigned in document order. 
Similarly, <CODE>ancestor::*[1]</CODE> returns the nearest ancestor element, 
because the <CODE>ancestor</CODE> axis is a reverse axis, whereas 
<CODE>(ancestor::*)[1]</CODE> returns the root element (first ancestor in 
document order).</P>
<P>The fact that a reverse-axis step assigns context positions in reverse 
document order for the purpose of evaluating predicates does not alter the fact 
that the final result of the step is always in document order.</P></DIV></DIV>
<DIV class=div3>
<H4><A id=unabbrev name=unabbrev></A>3.2.3 Unabbreviated Syntax</H4>
<P>This section provides a number of examples of path expressions in which the 
axis is explicitly specified in each <A title=step 
href="REC-xpath20-20070123.htm#dt-step">step</A>. The 
syntax used in these examples is called the <B>unabbreviated syntax</B>. In many 
common cases, it is possible to write path expressions more concisely using an 
<B>abbreviated syntax</B>, as explained in <A 
href="REC-xpath20-20070123.htm#abbrev"><B>3.2.4 
Abbreviated Syntax</B></A>.</P>
<UL>
  <LI>
  <P><CODE>child::para</CODE> selects the <CODE>para</CODE> element children of 
  the context node</P>
  <LI>
  <P><CODE>child::*</CODE> selects all element children of the context node</P>
  <LI>
  <P><CODE>child::text()</CODE> selects all text node children of the context 
  node</P>
  <LI>
  <P><CODE>child::node()</CODE> selects all the children of the context node. 
  Note that no attribute nodes are returned, because attributes are not 
  children.</P>
  <LI>
  <P><CODE>attribute::name</CODE> selects the <CODE>name</CODE> attribute of the 
  context node</P>
  <LI>
  <P><CODE>attribute::*</CODE> selects all the attributes of the context 
node</P>
  <LI>
  <P><CODE>parent::node()</CODE> selects the parent of the context node. If the 
  context node is an attribute node, this expression returns the element node 
  (if any) to which the attribute node is attached.</P>
  <LI>
  <P><CODE>descendant::para</CODE> selects the <CODE>para</CODE> element 
  descendants of the context node</P>
  <LI>
  <P><CODE>ancestor::div</CODE> selects all <CODE>div</CODE> ancestors of the 
  context node</P>
  <LI>
  <P><CODE>ancestor-or-self::div</CODE> selects the <CODE>div</CODE> ancestors 
  of the context node and, if the context node is a <CODE>div</CODE> element, 
  the context node as well</P>
  <LI>
  <P><CODE>descendant-or-self::para</CODE> selects the <CODE>para</CODE> element 
  descendants of the context node and, if the context node is a 
  <CODE>para</CODE> element, the context node as well</P>
  <LI>
  <P><CODE>self::para</CODE> selects the context node if it is a 
  <CODE>para</CODE> element, and otherwise returns an empty sequence</P>
  <LI>
  <P><CODE>child::chapter/descendant::para</CODE> selects the <CODE>para</CODE> 
  element descendants of the <CODE>chapter</CODE> element children of the 
  context node</P>
  <LI>
  <P><CODE>child::*/child::para</CODE> selects all <CODE>para</CODE> 
  grandchildren of the context node</P>
  <LI>
  <P><CODE>/</CODE> selects the root of the tree that contains the context node, 
  but raises a dynamic error if this root is not a document node</P>
  <LI>
  <P><CODE>/descendant::para</CODE> selects all the <CODE>para</CODE> elements 
  in the same document as the context node</P>
  <LI>
  <P><CODE>/descendant::list/child::member</CODE> selects all the 
  <CODE>member</CODE> elements that have a <CODE>list</CODE> parent and that are 
  in the same document as the context node</P>
  <LI>
  <P><CODE>child::para[fn:position() = 1]</CODE> selects the first 
  <CODE>para</CODE> child of the context node</P>
  <LI>
  <P><CODE>child::para[fn:position() = fn:last()]</CODE> selects the last 
  <CODE>para</CODE> child of the context node</P>
  <LI>
  <P><CODE>child::para[fn:position() = fn:last()-1]</CODE> selects the last but 
  one <CODE>para</CODE> child of the context node</P>
  <LI>
  <P><CODE>child::para[fn:position() &gt; 1]</CODE> selects all the 
  <CODE>para</CODE> children of the context node other than the first 
  <CODE>para</CODE> child of the context node</P>
  <LI>
  <P><CODE>following-sibling::chapter[fn:position() = 1]</CODE>selects the next 
  <CODE>chapter</CODE> sibling of the context node</P>
  <LI>
  <P><CODE>preceding-sibling::chapter[fn:position() = 1]</CODE>selects the 
  previous <CODE>chapter</CODE> sibling of the context node</P>
  <LI>
  <P><CODE>/descendant::figure[fn:position() = 42]</CODE> selects the 
  forty-second <CODE>figure</CODE> element in the document containing the 
  context node</P>
  <LI>
  <P><CODE>/child::book/child::chapter[fn:position() = 
  5]/child::section[fn:position() = 2]</CODE> selects the second 
  <CODE>section</CODE> of the fifth <CODE>chapter</CODE> of the 
  <CODE>book</CODE> whose parent is the document node that contains the context 
  node</P>
  <LI>
  <P><CODE>child::para[attribute::type eq "warning"]</CODE>selects all 
  <CODE>para</CODE> children of the context node that have a <CODE>type</CODE> 
  attribute with value <CODE>warning</CODE></P>
  <LI>
  <P><CODE>child::para[attribute::type eq 'warning'][fn:position() = 
  5]</CODE>selects the fifth <CODE>para</CODE> child of the context node that 
  has a <CODE>type</CODE> attribute with value <CODE>warning</CODE></P>
  <LI>
  <P><CODE>child::para[fn:position() = 5][attribute::type eq 
  "warning"]</CODE>selects the fifth <CODE>para</CODE> child of the context node 
  if that child has a <CODE>type</CODE> attribute with value 
  <CODE>warning</CODE></P>
  <LI>
  <P><CODE>child::chapter[child::title = 'Introduction']</CODE>selects the 
  <CODE>chapter</CODE> children of the context node that have one or more 
  <CODE>title</CODE> children whose <A title="typed value" 
  href="REC-xpath20-20070123.htm#dt-typed-value">typed 
  value</A> is equal to the string <CODE>Introduction</CODE></P>
  <LI>
  <P><CODE>child::chapter[child::title]</CODE> selects the <CODE>chapter</CODE> 
  children of the context node that have one or more <CODE>title</CODE> 
  children</P>
  <LI>
  <P><CODE>child::*[self::chapter or self::appendix]</CODE> selects the 
  <CODE>chapter</CODE> and <CODE>appendix</CODE> children of the context 
node</P>
  <LI>
  <P><CODE>child::*[self::chapter or self::appendix][fn:position() = 
  fn:last()]</CODE> selects the last <CODE>chapter</CODE> or 
  <CODE>appendix</CODE> child of the context node</P></LI></UL></DIV>
<DIV class=div3>
<H4><A id=abbrev name=abbrev></A>3.2.4 Abbreviated Syntax</H4>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-AbbrevForwardStep 
      name=doc-xpath-AbbrevForwardStep></A>[31]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-AbbrevForwardStep">AbbrevForwardStep</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"@"? <A 
      href="REC-xpath20-20070123.htm#doc-xpath-NodeTest">NodeTest</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-AbbrevReverseStep 
      name=doc-xpath-AbbrevReverseStep></A>[34]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-AbbrevReverseStep">AbbrevReverseStep</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>".."</CODE></TD></TR></TBODY></TABLE>
<P>The abbreviated syntax permits the following abbreviations:</P>
<OL class=enumar>
  <LI>
  <P>The attribute axis <CODE>attribute::</CODE> can be abbreviated by 
  <CODE>@</CODE>. For example, a path expression 
  <CODE>para[@type="warning"]</CODE> is short for 
  <CODE>child::para[attribute::type="warning"]</CODE> and so selects 
  <CODE>para</CODE> children with a <CODE>type</CODE> attribute with value equal 
  to <CODE>warning</CODE>.</P>
  <LI>
  <P>If the axis name is omitted from an <A title="axis step" 
  href="REC-xpath20-20070123.htm#dt-axis-step">axis 
  step</A>, the default axis is <CODE>child</CODE> unless the axis step contains 
  an <A 
  href="REC-xpath20-20070123.htm#doc-xpath-AttributeTest">AttributeTest</A> 
  or <A 
  href="REC-xpath20-20070123.htm#doc-xpath-SchemaAttributeTest">SchemaAttributeTest</A>; 
  in that case, the default axis is <CODE>attribute</CODE>. For example, the 
  path expression <CODE>section/para</CODE> is an abbreviation for 
  <CODE>child::section/child::para</CODE>, and the path expression 
  <CODE>section/@id</CODE> is an abbreviation for 
  <CODE>child::section/attribute::id</CODE>. Similarly, 
  <CODE>section/attribute(id)</CODE> is an abbreviation for 
  <CODE>child::section/attribute::attribute(id)</CODE>. Note that the latter 
  expression contains both an axis specification and a <A title="node test" 
  href="REC-xpath20-20070123.htm#dt-node-test">node 
  test</A>.</P>
  <LI>
  <P>Each non-initial occurrence of <CODE>//</CODE> is effectively replaced by 
  <CODE>/descendant-or-self::node()/</CODE> during processing of a path 
  expression. For example, <CODE>div1//para</CODE> is short for 
  <CODE>child::div1/descendant-or-self::node()/child::para</CODE> and so will 
  select all <CODE>para</CODE> descendants of <CODE>div1</CODE> children.</P>
  <DIV class=note>
  <P class=prefix><B>Note:</B></P>
  <P>The path expression <CODE>//para[1]</CODE> does <EM>not</EM> mean the same 
  as the path expression <CODE>/descendant::para[1]</CODE>. The latter selects 
  the first descendant <CODE>para</CODE> element; the former selects all 
  descendant <CODE>para</CODE> elements that are the first <CODE>para</CODE> 
  children of their respective parents.</P></DIV>
  <LI>
  <P>A step consisting of <CODE>..</CODE> is short for 
  <CODE>parent::node()</CODE>. For example, <CODE>../title</CODE> is short for 
  <CODE>parent::node()/child::title</CODE> and so will select the 
  <CODE>title</CODE> children of the parent of the context node.</P>
  <DIV class=note>
  <P class=prefix><B>Note:</B></P>
  <P>The expression <CODE>.</CODE>, known as a <B>context item expression</B>, 
  is a <A title="primary expression" 
  href="REC-xpath20-20070123.htm#dt-primary-expression">primary 
  expression</A>, and is described in <A 
  href="REC-xpath20-20070123.htm#id-context-item-expression"><B>3.1.4 
  Context Item Expression</B></A>.</P></DIV></LI></OL>
<P>Here are some examples of path expressions that use the abbreviated 
syntax:</P>
<UL>
  <LI>
  <P><CODE>para</CODE> selects the <CODE>para</CODE> element children of the 
  context node</P>
  <LI>
  <P><CODE>*</CODE> selects all element children of the context node</P>
  <LI>
  <P><CODE>text()</CODE> selects all text node children of the context node</P>
  <LI>
  <P><CODE>@name</CODE> selects the <CODE>name</CODE> attribute of the context 
  node</P>
  <LI>
  <P><CODE>@*</CODE> selects all the attributes of the context node</P>
  <LI>
  <P><CODE>para[1]</CODE> selects the first <CODE>para</CODE> child of the 
  context node</P>
  <LI>
  <P><CODE>para[fn:last()]</CODE> selects the last <CODE>para</CODE> child of 
  the context node</P>
  <LI>
  <P><CODE>*/para</CODE> selects all <CODE>para</CODE> grandchildren of the 
  context node</P>
  <LI>
  <P><CODE>/book/chapter[5]/section[2]</CODE> selects the second 
  <CODE>section</CODE> of the fifth <CODE>chapter</CODE> of the 
  <CODE>book</CODE> whose parent is the document node that contains the context 
  node</P>
  <LI>
  <P><CODE>chapter//para</CODE> selects the <CODE>para</CODE> element 
  descendants of the <CODE>chapter</CODE> element children of the context 
  node</P>
  <LI>
  <P><CODE>//para</CODE> selects all the <CODE>para</CODE> descendants of the 
  root document node and thus selects all <CODE>para</CODE> elements in the same 
  document as the context node</P>
  <LI>
  <P><CODE>//@version</CODE> selects all the <CODE>version</CODE> attribute 
  nodes that are in the same document as the context node</P>
  <LI>
  <P><CODE>//list/member</CODE> selects all the <CODE>member</CODE> elements in 
  the same document as the context node that have a <CODE>list</CODE> parent</P>
  <LI>
  <P><CODE>.//para</CODE> selects the <CODE>para</CODE> element descendants of 
  the context node</P>
  <LI>
  <P><CODE>..</CODE> selects the parent of the context node</P>
  <LI>
  <P><CODE>../@lang</CODE> selects the <CODE>lang</CODE> attribute of the parent 
  of the context node</P>
  <LI>
  <P><CODE>para[@type="warning"]</CODE> selects all <CODE>para</CODE> children 
  of the context node that have a <CODE>type</CODE> attribute with value 
  <CODE>warning</CODE></P>
  <LI>
  <P><CODE>para[@type="warning"][5]</CODE> selects the fifth <CODE>para</CODE> 
  child of the context node that has a <CODE>type</CODE> attribute with value 
  <CODE>warning</CODE></P>
  <LI>
  <P><CODE>para[5][@type="warning"]</CODE> selects the fifth <CODE>para</CODE> 
  child of the context node if that child has a <CODE>type</CODE> attribute with 
  value <CODE>warning</CODE></P>
  <LI>
  <P><CODE>chapter[title="Introduction"]</CODE> selects the <CODE>chapter</CODE> 
  children of the context node that have one or more <CODE>title</CODE> children 
  whose <A title="typed value" 
  href="REC-xpath20-20070123.htm#dt-typed-value">typed 
  value</A> is equal to the string <CODE>Introduction</CODE></P>
  <LI>
  <P><CODE>chapter[title]</CODE> selects the <CODE>chapter</CODE> children of 
  the context node that have one or more <CODE>title</CODE> children</P>
  <LI>
  <P><CODE>employee[@secretary and @assistant]</CODE> selects all the 
  <CODE>employee</CODE> children of the context node that have both a 
  <CODE>secretary</CODE> attribute and an <CODE>assistant</CODE> attribute</P>
  <LI>
  <P><CODE>book/(chapter|appendix)/section</CODE> selects every 
  <CODE>section</CODE> element that has a parent that is either a 
  <CODE>chapter</CODE> or an <CODE>appendix</CODE> element, that in turn is a 
  child of a <CODE>book</CODE> element that is a child of the context node.</P>
  <LI>
  <P>If <CODE>E</CODE> is any expression that returns a sequence of nodes, then 
  the expression <CODE>E/.</CODE> returns the same nodes in <A 
  title="document order" 
  href="REC-xpath20-20070123.htm#dt-document-order">document 
  order</A>, with duplicates eliminated based on node 
identity.</P></LI></UL></DIV></DIV>
<DIV class=div2>
<H3><A id=id-sequence-expressions name=id-sequence-expressions></A>3.3 Sequence 
Expressions</H3>
<P>XPath supports operators to construct, filter, and combine <A title=sequence 
href="REC-xpath20-20070123.htm#dt-sequence">sequences</A> 
of <A title=item 
href="REC-xpath20-20070123.htm#dt-item">items</A>. 
Sequences are never nested—for example, combining the values <CODE>1</CODE>, 
<CODE>(2, 3)</CODE>, and <CODE>( )</CODE> into a single sequence results in the 
sequence <CODE>(1, 2, 3)</CODE>.</P>
<DIV class=div3>
<H4><A id=construct_seq name=construct_seq></A>3.3.1 Constructing Sequences</H4>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=noid_N12B39.doc-xpath-Expr 
      name=noid_N12B39.doc-xpath-Expr></A>[2]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-Expr">Expr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-ExprSingle">ExprSingle</A> 
      ("," <A 
      href="REC-xpath20-20070123.htm#doc-xpath-ExprSingle">ExprSingle</A>)*</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-RangeExpr 
      name=doc-xpath-RangeExpr></A>[11]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-RangeExpr">RangeExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-AdditiveExpr">AdditiveExpr</A> 
      ( "to" <A 
      href="REC-xpath20-20070123.htm#doc-xpath-AdditiveExpr">AdditiveExpr</A> 
      )?</CODE></TD></TR></TBODY></TABLE>
<P>[<A id=dt-comma-operator title="comma operator" 
name=dt-comma-operator>Definition</A>: One way to construct a sequence is by 
using the <B>comma operator</B>, which evaluates each of its operands and 
concatenates the resulting sequences, in order, into a single result sequence.] 
Empty parentheses can be used to denote an empty sequence.</P>
<P>A sequence may contain duplicate atomic values or nodes, but a sequence is 
never an item in another sequence. When a new sequence is created by 
concatenating two or more input sequences, the new sequence contains all the 
items of the input sequences and its length is the sum of the lengths of the 
input sequences.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>In places where the grammar calls for <A 
href="REC-xpath20-20070123.htm#doc-xpath-ExprSingle">ExprSingle</A>, 
such as the arguments of a function call, any expression that contains a 
top-level comma operator must be enclosed in parentheses.</P></DIV>
<P>Here are some examples of expressions that construct sequences:</P>
<UL>
  <LI>
  <P>The result of this expression is a sequence of five integers:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>(10, 1, 2, 3, 4)
</PRE></DIV></DIV>
  <LI>
  <P>This expression combines four sequences of length one, two, zero, and two, 
  respectively, into a single sequence of length five. The result of this 
  expression is the sequence <CODE>10, 1, 2, 3, 4</CODE>.</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>(10, (1, 2), (), (3, 4))
</PRE></DIV></DIV>
  <LI>
  <P>The result of this expression is a sequence containing all 
  <CODE>salary</CODE> children of the context node followed by all 
  <CODE>bonus</CODE> children.</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>(salary, bonus)
</PRE></DIV></DIV>
  <LI>
  <P>Assuming that <CODE>$price</CODE> is bound to the value <CODE>10.50</CODE>, 
  the result of this expression is the sequence <CODE>10.50, 10.50</CODE>.</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>($price, $price)
</PRE></DIV></DIV></LI></UL>
<P>A <B>range expression</B> can be used to construct a sequence of consecutive 
integers. Each of the operands of the <CODE>to</CODE> operator is converted as 
though it was an argument of a function with the expected parameter type 
<CODE>xs:integer?</CODE>. If either operand is an empty sequence, or if the 
integer derived from the first operand is greater than the integer derived from 
the second operand, the result of the range expression is an empty sequence. If 
the two operands convert to the same integer, the result of the range expression 
is that integer. Otherwise, the result is a sequence containing the two integer 
operands and every integer between the two operands, in increasing order.</P>
<UL>
  <LI>
  <P>This example uses a range expression as one operand in constructing a 
  sequence. It evaluates to the sequence <CODE>10, 1, 2, 3, 4</CODE>.</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>(10, 1 to 4)
</PRE></DIV></DIV>
  <LI>
  <P>This example constructs a sequence of length one containing the single 
  integer <CODE>10</CODE>.</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>10 to 10
</PRE></DIV></DIV>
  <LI>
  <P>The result of this example is a sequence of length zero.</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>15 to 10
</PRE></DIV></DIV>
  <LI>
  <P>This example uses the <CODE>fn:reverse</CODE> function to construct a 
  sequence of six integers in decreasing order. It evaluates to the sequence 
  <CODE>15, 14, 13, 12, 11, 10</CODE>.</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>fn:reverse(10 to 15)
</PRE></DIV></DIV></LI></UL></DIV>
<DIV class=div3>
<H4><A id=id-filter-expr name=id-filter-expr></A>3.3.2 Filter Expressions</H4>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-FilterExpr 
      name=doc-xpath-FilterExpr></A>[38]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-FilterExpr">FilterExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-PrimaryExpr">PrimaryExpr</A> 
      <A 
      href="REC-xpath20-20070123.htm#doc-xpath-PredicateList">PredicateList</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=noid_N12BE0.doc-xpath-PredicateList 
      name=noid_N12BE0.doc-xpath-PredicateList></A>[39]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-PredicateList">PredicateList</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-Predicate">Predicate</A>*</CODE></TD></TR></TBODY></TABLE>
<P>[<A id=dt-filter-expression title="filter expression" 
name=dt-filter-expression>Definition</A>: A <B>filter expression</B> consists 
simply of a <B>primary expression</B> followed by zero or more <A 
title=predicate 
href="REC-xpath20-20070123.htm#dt-predicate">predicates</A>. 
The result of the filter expression consists of the items returned by the 
primary expression, filtered by applying each predicate in turn, working from 
left to right.] If no predicates are specified, the result is simply the result 
of the primary expression. The ordering of the items returned by a filter 
expression is the same as their order in the result of the primary expression. 
Context positions are assigned to items based on their ordinal position in the 
result sequence. The first context position is 1.</P>
<P>Here are some examples of filter expressions:</P>
<UL>
  <LI>
  <P>Given a sequence of products in a variable, return only those products 
  whose price is greater than 100.</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>$products[price gt 100]
</PRE></DIV></DIV>
  <LI>
  <P>List all the integers from 1 to 100 that are divisible by 5. (See <A 
  href="REC-xpath20-20070123.htm#construct_seq"><B>3.3.1 
  Constructing Sequences</B></A> for an explanation of the <CODE>to</CODE> 
  operator.)</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>(1 to 100)[. mod 5 eq 0]
</PRE></DIV></DIV>
  <LI>
  <P>The result of the following expression is the integer 25:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>(21 to 29)[5]
</PRE></DIV></DIV>
  <LI>
  <P>The following example returns the fifth through ninth items in the sequence 
  bound to variable <CODE>$orders</CODE>.</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>$orders[fn:position() = (5 to 9)]
</PRE></DIV></DIV>
  <LI>
  <P>The following example illustrates the use of a filter expression as a <A 
  title=step 
  href="REC-xpath20-20070123.htm#dt-step">step</A> in a 
  <A title="path expression" 
  href="REC-xpath20-20070123.htm#dt-path-expression">path 
  expression</A>. It returns the last chapter or appendix within the book bound 
  to variable <CODE>$book</CODE>:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>$book/(chapter | appendix)[fn:last()]
</PRE></DIV></DIV>
  <LI>
  <P>The following example also illustrates the use of a filter expression as a 
  <A title=step 
  href="REC-xpath20-20070123.htm#dt-step">step</A> in a 
  <A title="path expression" 
  href="REC-xpath20-20070123.htm#dt-path-expression">path 
  expression</A>. It returns the element node within the specified document 
  whose ID value is <CODE>tiger</CODE>:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>fn:doc("zoo.xml")/fn:id('tiger')
</PRE></DIV></DIV></LI></UL></DIV>
<DIV class=div3>
<H4><A id=combining_seq name=combining_seq></A>3.3.3 Combining Node 
Sequences</H4>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-UnionExpr 
      name=doc-xpath-UnionExpr></A>[14]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-UnionExpr">UnionExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-IntersectExceptExpr">IntersectExceptExpr</A> 
      ( ("union" | "|") <A 
      href="REC-xpath20-20070123.htm#doc-xpath-IntersectExceptExpr">IntersectExceptExpr</A> 
      )*</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-IntersectExceptExpr 
      name=doc-xpath-IntersectExceptExpr></A>[15]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-IntersectExceptExpr">IntersectExceptExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-InstanceofExpr">InstanceofExpr</A> 
      ( ("intersect" | "except") <A 
      href="REC-xpath20-20070123.htm#doc-xpath-InstanceofExpr">InstanceofExpr</A> 
      )*</CODE></TD></TR></TBODY></TABLE>
<P>XPath provides the following operators for combining sequences of nodes:</P>
<UL>
  <LI>
  <P>The <CODE>union</CODE> and <CODE>|</CODE> operators are equivalent. They 
  take two node sequences as operands and return a sequence containing all the 
  nodes that occur in either of the operands.</P>
  <LI>
  <P>The <CODE>intersect</CODE> operator takes two node sequences as operands 
  and returns a sequence containing all the nodes that occur in both 
  operands.</P>
  <LI>
  <P>The <CODE>except</CODE> operator takes two node sequences as operands and 
  returns a sequence containing all the nodes that occur in the first operand 
  but not in the second operand.</P></LI></UL>
<P>All these operators eliminate duplicate nodes from their result sequences 
based on node identity. <SPAN class=xpath><SPAN class=xpath>The resulting 
sequence is returned in <A title="document order" 
href="REC-xpath20-20070123.htm#dt-document-order">document 
order</A>.</SPAN></SPAN></P>
<P>If an operand of <CODE>union</CODE>, <CODE>intersect</CODE>, or 
<CODE>except</CODE> contains an item that is not a node, a <A title="type error" 
href="REC-xpath20-20070123.htm#dt-type-error">type 
error</A> is raised [<A title=err:XPTY0004 
href="REC-xpath20-20070123.htm#ERRXPTY0004">err:XPTY0004</A>].</P>
<P>Here are some examples of expressions that combine sequences. Assume the 
existence of three element nodes that we will refer to by symbolic names A, B, 
and C. Assume that the variables <CODE>$seq1</CODE>, <CODE>$seq2</CODE> and 
<CODE>$seq3</CODE> are bound to the following sequences of these nodes:</P>
<UL>
  <LI>
  <P><CODE>$seq1</CODE> is bound to (A, B)</P>
  <LI>
  <P><CODE>$seq2</CODE> is bound to (A, B)</P>
  <LI>
  <P><CODE>$seq3</CODE> is bound to (B, C)</P></LI></UL>
<P>Then:</P>
<UL>
  <LI>
  <P><CODE>$seq1 union $seq2</CODE> evaluates to the sequence (A, B).</P>
  <LI>
  <P><CODE>$seq2 union $seq3</CODE> evaluates to the sequence (A, B, C).</P>
  <LI>
  <P><CODE>$seq1 intersect $seq2</CODE> evaluates to the sequence (A, B).</P>
  <LI>
  <P><CODE>$seq2 intersect $seq3</CODE> evaluates to the sequence containing B 
  only.</P>
  <LI>
  <P><CODE>$seq1 except $seq2</CODE> evaluates to the empty sequence.</P>
  <LI>
  <P><CODE>$seq2 except $seq3</CODE> evaluates to the sequence containing A 
  only.</P></LI></UL>
<P>In addition to the sequence operators described here, <A 
href="REC-xpath20-20070123.htm#FunctionsAndOperators">[XQuery 
1.0 and XPath 2.0 Functions and Operators]</A> includes functions for indexed 
access to items or sub-sequences of a sequence, for indexed insertion or removal 
of items in a sequence, and for removing duplicate items from a 
sequence.</P></DIV></DIV>
<DIV class=div2>
<H3><A id=id-arithmetic name=id-arithmetic></A>3.4 Arithmetic Expressions</H3>
<P>XPath provides arithmetic operators for addition, subtraction, 
multiplication, division, and modulus, in their usual binary and unary 
forms.</P>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-AdditiveExpr 
      name=doc-xpath-AdditiveExpr></A>[12]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-AdditiveExpr">AdditiveExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-MultiplicativeExpr">MultiplicativeExpr</A> 
      ( ("+" | "-") <A 
      href="REC-xpath20-20070123.htm#doc-xpath-MultiplicativeExpr">MultiplicativeExpr</A> 
      )*</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-MultiplicativeExpr 
      name=doc-xpath-MultiplicativeExpr></A>[13]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-MultiplicativeExpr">MultiplicativeExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-UnionExpr">UnionExpr</A> 
      ( ("*" | "div" | "idiv" | "mod") <A 
      href="REC-xpath20-20070123.htm#doc-xpath-UnionExpr">UnionExpr</A> 
      )*</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-UnaryExpr 
      name=doc-xpath-UnaryExpr></A>[20]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-UnaryExpr">UnaryExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>("-" | "+")* <A 
      href="REC-xpath20-20070123.htm#doc-xpath-ValueExpr">ValueExpr</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-ValueExpr 
      name=doc-xpath-ValueExpr></A>[21]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-ValueExpr">ValueExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-PathExpr">PathExpr</A></CODE></TD></TR></TBODY></TABLE>
<P>A subtraction operator must be preceded by whitespace if it could otherwise 
be interpreted as part of the previous token. For example, <CODE>a-b</CODE> will 
be interpreted as a name, but <CODE>a - b</CODE> and <CODE>a -b</CODE> will be 
interpreted as arithmetic expressions. (See <A 
href="REC-xpath20-20070123.htm#whitespace-rules"><B>A.2.4 
Whitespace Rules</B></A> for further details on whitespace handling.)</P>
<P>The first step in evaluating an arithmetic expression is to evaluate its 
operands. The order in which the operands are evaluated is <A 
title="implementation dependent" 
href="REC-xpath20-20070123.htm#dt-implementation-dependent">implementation-dependent</A>.</P>
<DIV class=xpath>
<P class=xpath>If <A title="XPath 1.0 compatibility mode" 
href="REC-xpath20-20070123.htm#dt-xpath-compat-mode">XPath 
1.0 compatibility mode</A> is <CODE>true</CODE>, each operand is evaluated by 
applying the following steps, in order:</P></DIV>
<DIV class=xpath>
<OL class=enumar>
  <LI>
  <P><A title=atomization 
  href="REC-xpath20-20070123.htm#dt-atomization">Atomization</A> 
  is applied to the operand. The result of this operation is called the 
  <B>atomized operand</B>.</P>
  <LI>
  <P>If the atomized operand is an empty sequence, the result of the arithmetic 
  expression is the <CODE>xs:double</CODE> value <CODE>NaN</CODE>, and the 
  implementation need not evaluate the other operand or apply the operator. 
  However, an implementation may choose to evaluate the other operand in order 
  to determine whether it raises an error.</P>
  <LI>
  <P>If the atomized operand is a sequence of length greater than one, any items 
  after the first item in the sequence are discarded.</P>
  <LI>
  <P>If the atomized operand is now an instance of type <CODE>xs:boolean</CODE>, 
  <CODE>xs:string</CODE>, <CODE>xs:decimal</CODE> (including 
  <CODE>xs:integer</CODE>), <CODE>xs:float</CODE>, or 
  <CODE>xs:untypedAtomic</CODE>, then it is converted to the type 
  <CODE>xs:double</CODE> by applying the <CODE>fn:number</CODE> function. (Note 
  that <CODE>fn:number</CODE> returns the value <CODE>NaN</CODE> if its operand 
  cannot be converted to a number.)</P></LI></OL></DIV>
<P><SPAN class=xpath><SPAN class=xpath>If <A 
title="XPath 1.0 compatibility mode" 
href="REC-xpath20-20070123.htm#dt-xpath-compat-mode">XPath 
1.0 compatibility mode</A> is <CODE>false</CODE>, each</SPAN></SPAN> operand is 
evaluated by applying the following steps, in order:</P>
<OL class=enumar>
  <LI>
  <P><A title=atomization 
  href="REC-xpath20-20070123.htm#dt-atomization">Atomization</A> 
  is applied to the operand. The result of this operation is called the 
  <B>atomized operand</B>.</P>
  <LI>
  <P>If the atomized operand is an empty sequence, the result of the arithmetic 
  expression is an empty sequence, and the implementation need not evaluate the 
  other operand or apply the operator. However, an implementation may choose to 
  evaluate the other operand in order to determine whether it raises an 
  error.</P>
  <LI>
  <P>If the atomized operand is a sequence of length greater than one, a <A 
  title="type error" 
  href="REC-xpath20-20070123.htm#dt-type-error">type 
  error</A> is raised [<A title=err:XPTY0004 
  href="REC-xpath20-20070123.htm#ERRXPTY0004">err:XPTY0004</A>].</P>
  <LI>
  <P>If the atomized operand is of type <CODE>xs:untypedAtomic</CODE>, it is 
  cast to <CODE>xs:double</CODE>. If the cast fails, a <A title="dynamic error" 
  href="REC-xpath20-20070123.htm#dt-dynamic-error">dynamic 
  error</A> is raised. [err:FORG0001]</P></LI></OL>
<P>After evaluation of the operands, if the types of the operands are a valid 
combination for the given arithmetic operator, the operator is applied to the 
operands, resulting in an atomic value or a <A title="dynamic error" 
href="REC-xpath20-20070123.htm#dt-dynamic-error">dynamic 
error</A> (for example, an error might result from dividing by zero.) The 
combinations of atomic types that are accepted by the various arithmetic 
operators, and their respective result types, are listed in <A 
href="REC-xpath20-20070123.htm#mapping"><B>B.2 Operator 
Mapping</B></A> together with the <A title="operator function" 
href="REC-xpath20-20070123.htm#dt-operator-function">operator 
functions</A> that define the semantics of the operator for each type 
combination, including the dynamic errors that can be raised by the operator. 
The definitions of the operator functions are found in <A 
href="REC-xpath20-20070123.htm#FunctionsAndOperators">[XQuery 
1.0 and XPath 2.0 Functions and Operators]</A>.</P>
<P>If the types of the operands, after evaluation, are not a valid combination 
for the given operator, according to the rules in <A 
href="REC-xpath20-20070123.htm#mapping"><B>B.2 Operator 
Mapping</B></A>, a <A title="type error" 
href="REC-xpath20-20070123.htm#dt-type-error">type 
error</A> is raised [<A title=err:XPTY0004 
href="REC-xpath20-20070123.htm#ERRXPTY0004">err:XPTY0004</A>].</P>
<P>XPath supports two division operators named <CODE>div</CODE> and 
<CODE>idiv</CODE>. Each of these operators accepts two operands of any <A 
title=numeric 
href="REC-xpath20-20070123.htm#dt-numeric">numeric</A> 
type. As described in <A 
href="REC-xpath20-20070123.htm#FunctionsAndOperators">[XQuery 
1.0 and XPath 2.0 Functions and Operators]</A>, <CODE>$arg1 idiv $arg2</CODE> is 
equivalent to <CODE>($arg1 div $arg2) cast as xs:integer?</CODE> except for 
error cases.</P>
<P>Here are some examples of arithmetic expressions:</P>
<UL>
  <LI>
  <P>The first expression below returns the <CODE>xs:decimal</CODE> value 
  <CODE>-1.5</CODE>, and the second expression returns the 
  <CODE>xs:integer</CODE> value <CODE>-1</CODE>:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>-3 div 2
-3 idiv 2
</PRE></DIV></DIV>
  <LI>
  <P>Subtraction of two date values results in a value of type 
  <CODE>xs:dayTimeDuration</CODE>:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>$emp/hiredate - $emp/birthdate
</PRE></DIV></DIV>
  <LI>
  <P>This example illustrates the difference between a subtraction operator and 
  a hyphen:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>$unit-price - $unit-discount
</PRE></DIV></DIV>
  <LI>
  <P>Unary operators have higher precedence than binary operators, subject of 
  course to the use of parentheses. Therefore, the following two examples have 
  different meanings:</P>
  <DIV class=exampleInner><PRE>-$bellcost + $whistlecost
-($bellcost + $whistlecost)
</PRE></DIV></LI></UL>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P id=note-consecutive-unary-ops>Multiple consecutive unary arithmetic operators 
are permitted by XPath for compatibility with <A 
href="REC-xpath20-20070123.htm#XPath">[XPath 
1.0]</A>.</P></DIV></DIV>
<DIV class=div2>
<H3><A id=id-comparisons name=id-comparisons></A>3.5 Comparison Expressions</H3>
<P>Comparison expressions allow two values to be compared. XPath provides three 
kinds of comparison expressions, called value comparisons, general comparisons, 
and node comparisons.</P>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-ComparisonExpr 
      name=doc-xpath-ComparisonExpr></A>[10]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-ComparisonExpr">ComparisonExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-RangeExpr">RangeExpr</A> 
      ( (<A 
      href="REC-xpath20-20070123.htm#doc-xpath-ValueComp">ValueComp</A><BR>| 
      <A 
      href="REC-xpath20-20070123.htm#doc-xpath-GeneralComp">GeneralComp</A><BR>| 
      <A 
      href="REC-xpath20-20070123.htm#doc-xpath-NodeComp">NodeComp</A>) 
      <A 
      href="REC-xpath20-20070123.htm#doc-xpath-RangeExpr">RangeExpr</A> 
      )?</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-ValueComp 
      name=doc-xpath-ValueComp></A>[23]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-ValueComp">ValueComp</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"eq" | "ne" | "lt" | "le" | "gt" | "ge"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-GeneralComp 
      name=doc-xpath-GeneralComp></A>[22]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-GeneralComp">GeneralComp</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"=" | "!=" | "&lt;" | "&lt;=" | "&gt;" | 
  "&gt;="</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-NodeComp 
    name=doc-xpath-NodeComp></A>[24]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-NodeComp">NodeComp</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"is" | "&lt;&lt;" | "&gt;&gt;"</CODE></TD></TR></TBODY></TABLE>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<DIV class=xpath>
<P class=xpath>When an XPath expression is written within an XML document, the 
XML escaping rules for special characters must be followed; thus 
"<CODE>&lt;</CODE>" must be written as "<CODE>&amp;lt;</CODE>".</P></DIV></DIV>
<DIV class=div3>
<H4><A id=id-value-comparisons name=id-value-comparisons></A>3.5.1 Value 
Comparisons</H4>
<P>The value comparison operators are <CODE>eq</CODE>, <CODE>ne</CODE>, 
<CODE>lt</CODE>, <CODE>le</CODE>, <CODE>gt</CODE>, and <CODE>ge</CODE>. Value 
comparisons are used for comparing single values.</P>
<P>The first step in evaluating a value comparison is to evaluate its operands. 
The order in which the operands are evaluated is <A 
title="implementation dependent" 
href="REC-xpath20-20070123.htm#dt-implementation-dependent">implementation-dependent</A>. 
Each operand is evaluated by applying the following steps, in order:</P>
<OL class=enumar>
  <LI>
  <P><A title=atomization 
  href="REC-xpath20-20070123.htm#dt-atomization">Atomization</A> 
  is applied to the operand. The result of this operation is called the 
  <B>atomized operand</B>.</P>
  <LI>
  <P>If the atomized operand is an empty sequence, the result of the value 
  comparison is an empty sequence, and the implementation need not evaluate the 
  other operand or apply the operator. However, an implementation may choose to 
  evaluate the other operand in order to determine whether it raises an 
  error.</P>
  <LI>
  <P>If the atomized operand is a sequence of length greater than one, a <A 
  title="type error" 
  href="REC-xpath20-20070123.htm#dt-type-error">type 
  error</A> is raised [<A title=err:XPTY0004 
  href="REC-xpath20-20070123.htm#ERRXPTY0004">err:XPTY0004</A>].</P>
  <LI>
  <P>If the atomized operand is of type <CODE>xs:untypedAtomic</CODE>, it is 
  cast to <CODE>xs:string</CODE>.</P>
  <DIV class=note>
  <P class=prefix><B>Note:</B></P>
  <P>The purpose of this rule is to make value comparisons transitive. Users 
  should be aware that the general comparison operators have a different rule 
  for casting of <CODE>xs:untypedAtomic</CODE> operands. Users should also be 
  aware that transitivity of value comparisons may be compromised by loss of 
  precision during type conversion (for example, two <CODE>xs:integer</CODE> 
  values that differ slightly may both be considered equal to the same 
  <CODE>xs:float</CODE> value because <CODE>xs:float</CODE> has less precision 
  than <CODE>xs:integer</CODE>).</P></DIV></LI></OL>
<P>Next, if possible, the two operands are converted to their least common type 
by a combination of <A title="type promotion" 
href="REC-xpath20-20070123.htm#dt-type-promotion">type 
promotion</A> and <A title="subtype substitution" 
href="REC-xpath20-20070123.htm#dt-subtype-substitution">subtype 
substitution</A>. For example, if the operands are of type <CODE>hatsize</CODE> 
(derived from <CODE>xs:integer</CODE>) and <CODE>shoesize</CODE> (derived from 
<CODE>xs:float</CODE>), their least common type is <CODE>xs:float</CODE>.</P>
<P>Finally, if the types of the operands are a valid combination for the given 
operator, the operator is applied to the operands. The combinations of atomic 
types that are accepted by the various value comparison operators, and their 
respective result types, are listed in <A 
href="REC-xpath20-20070123.htm#mapping"><B>B.2 Operator 
Mapping</B></A> together with the <A title="operator function" 
href="REC-xpath20-20070123.htm#dt-operator-function">operator 
functions</A> that define the semantics of the operator for each type 
combination. The definitions of the operator functions are found in <A 
href="REC-xpath20-20070123.htm#FunctionsAndOperators">[XQuery 
1.0 and XPath 2.0 Functions and Operators]</A>.</P>
<P>Informally, if both atomized operands consist of exactly one atomic value, 
then the result of the comparison is <CODE>true</CODE> if the value of the first 
operand is (equal, not equal, less than, less than or equal, greater than, 
greater than or equal) to the value of the second operand; otherwise the result 
of the comparison is <CODE>false</CODE>.</P>
<P>If the types of the operands, after evaluation, are not a valid combination 
for the given operator, according to the rules in <A 
href="REC-xpath20-20070123.htm#mapping"><B>B.2 Operator 
Mapping</B></A>, a <A title="type error" 
href="REC-xpath20-20070123.htm#dt-type-error">type 
error</A> is raised [<A title=err:XPTY0004 
href="REC-xpath20-20070123.htm#ERRXPTY0004">err:XPTY0004</A>].</P>
<P>Here are some examples of value comparisons:</P>
<UL>
  <LI>
  <P>The following comparison atomizes the node(s) that are returned by the 
  expression <CODE>$book/author</CODE>. The comparison is true only if the 
  result of atomization is the value "Kennedy" as an instance of 
  <CODE>xs:string</CODE> or <CODE>xs:untypedAtomic</CODE>. If the result of 
  atomization is an empty sequence, the result of the comparison is an empty 
  sequence. If the result of atomization is a sequence containing more than one 
  value, a <A title="type error" 
  href="REC-xpath20-20070123.htm#dt-type-error">type 
  error</A> is raised [<A title=err:XPTY0004 
  href="REC-xpath20-20070123.htm#ERRXPTY0004">err:XPTY0004</A>].</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>$book1/author eq "Kennedy"
</PRE></DIV></DIV>
  <LI>
  <P>The following <A title="path expression" 
  href="REC-xpath20-20070123.htm#dt-path-expression">path 
  expression</A> contains a predicate that selects products whose weight is 
  greater than 100. For any product that does not have a <CODE>weight</CODE> 
  subelement, the value of the predicate is the empty sequence, and the product 
  is not selected. This example assumes that <CODE>weight</CODE> is a validated 
  element with a numeric type.</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>//product[weight gt 100]
</PRE></DIV></DIV>
  <LI>
  <P>The following comparison is true if <CODE>my:hatsize</CODE> and 
  <CODE>my:shoesize</CODE> are both user-defined types that are derived by 
  restriction from a primitive <A title=numeric 
  href="REC-xpath20-20070123.htm#dt-numeric">numeric</A> 
  type:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>my:hatsize(5) eq my:shoesize(5)
</PRE></DIV></DIV>
  <LI>
  <P>The following comparison is true. The <CODE>eq</CODE> operator compares two 
  QNames by performing codepoint-comparisons of their namespace URIs and their 
  local names, ignoring their namespace prefixes.</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>fn:QName("http://example.com/ns1", "this:color")
   eq fn:QName("http://example.com/ns1", "that:color")
</PRE></DIV></DIV></LI></UL></DIV>
<DIV class=div3>
<H4><A id=id-general-comparisons name=id-general-comparisons></A>3.5.2 General 
Comparisons</H4>
<P>The general comparison operators are <CODE>=</CODE>, <CODE>!=</CODE>, 
<CODE>&lt;</CODE>, <CODE>&lt;=</CODE>, <CODE>&gt;</CODE>, and 
<CODE>&gt;=</CODE>. General comparisons are existentially quantified comparisons 
that may be applied to operand sequences of any length. The result of a general 
comparison that does not raise an error is always <CODE>true</CODE> or 
<CODE>false</CODE>.</P>
<DIV class=xpath>
<P class=xpath>If <A title="XPath 1.0 compatibility mode" 
href="REC-xpath20-20070123.htm#dt-xpath-compat-mode">XPath 
1.0 compatibility mode</A> is <CODE>true</CODE>, a general comparison is 
evaluated by applying the following rules, in order:</P></DIV>
<DIV class=xpath>
<OL class=enumar>
  <LI>
  <P>If either operand is a single atomic value that is an instance of 
  <CODE>xs:boolean</CODE>, then the other operand is converted to 
  <CODE>xs:boolean</CODE> by taking its <A title="effective boolean value" 
  href="REC-xpath20-20070123.htm#dt-ebv">effective 
  boolean value</A>.</P>
  <LI>
  <P><A title=atomization 
  href="REC-xpath20-20070123.htm#dt-atomization">Atomization</A> 
  is applied to each operand. After atomization, each operand is a sequence of 
  atomic values.</P>
  <LI>
  <P>If the comparison operator is <CODE>&lt;</CODE>, <CODE>&lt;=</CODE>, 
  <CODE>&gt;</CODE>, or <CODE>&gt;=</CODE>, then each item in both of the 
  operand sequences is converted to the type <CODE>xs:double</CODE> by applying 
  the <CODE>fn:number</CODE> function. (Note that <CODE>fn:number</CODE> returns 
  the value <CODE>NaN</CODE> if its operand cannot be converted to a 
number.)</P>
  <LI>
  <P>The result of the comparison is <CODE>true</CODE> if and only if there is a 
  pair of atomic values, one in the first operand sequence and the other in the 
  second operand sequence, that have the required <B>magnitude relationship</B>. 
  Otherwise the result of the comparison is <CODE>false</CODE>. The <B>magnitude 
  relationship</B> between two atomic values is determined by applying the 
  following rules. If a <CODE>cast</CODE> operation called for by these rules is 
  not successful, a dynamic error is raised. [err:FORG0001]</P>
  <OL class=enumla>
    <LI>
    <P>If at least one of the two atomic values is an instance of a <A 
    title=numeric 
    href="REC-xpath20-20070123.htm#dt-numeric">numeric</A> 
    type, then both atomic values are converted to the type 
    <CODE>xs:double</CODE> by applying the <CODE>fn:number</CODE> function.</P>
    <LI>
    <P>If at least one of the two atomic values is an instance of 
    <CODE>xs:string</CODE>, or if both atomic values are instances of 
    <CODE>xs:untypedAtomic</CODE>, then both atomic values are cast to the type 
    <CODE>xs:string</CODE>.</P>
    <LI>
    <P>If one of the atomic values is an instance of 
    <CODE>xs:untypedAtomic</CODE> and the other is not an instance of 
    <CODE>xs:string</CODE>, <CODE>xs:untypedAtomic</CODE>, or any <A 
    title=numeric 
    href="REC-xpath20-20070123.htm#dt-numeric">numeric</A> 
    type, then the <CODE>xs:untypedAtomic</CODE> value is cast to the <A 
    title="dynamic type" 
    href="REC-xpath20-20070123.htm#dt-dynamic-type">dynamic 
    type</A> of the other value.</P>
    <LI>
    <P>After performing the conversions described above, the atomic values are 
    compared using one of the value comparison operators <CODE>eq</CODE>, 
    <CODE>ne</CODE>, <CODE>lt</CODE>, <CODE>le</CODE>, <CODE>gt</CODE>, or 
    <CODE>ge</CODE>, depending on whether the general comparison operator was 
    <CODE>=</CODE>, <CODE>!=</CODE>, <CODE>&lt;</CODE>, <CODE>&lt;=</CODE>, 
    <CODE>&gt;</CODE>, or <CODE>&gt;=</CODE>. The values have the required 
    <B>magnitude relationship</B> if and only if the result of this value 
    comparison is <CODE>true</CODE>.</P></LI></OL></LI></OL></DIV>
<P><SPAN class=xpath><SPAN class=xpath>If <A 
title="XPath 1.0 compatibility mode" 
href="REC-xpath20-20070123.htm#dt-xpath-compat-mode">XPath 
1.0 compatibility mode</A> is <CODE>false</CODE>, a</SPAN></SPAN> general 
comparison is evaluated by applying the following rules, in order:</P>
<OL class=enumar>
  <LI>
  <P><A title=atomization 
  href="REC-xpath20-20070123.htm#dt-atomization">Atomization</A> 
  is applied to each operand. After atomization, each operand is a sequence of 
  atomic values.</P>
  <LI>
  <P>The result of the comparison is <CODE>true</CODE> if and only if there is a 
  pair of atomic values, one in the first operand sequence and the other in the 
  second operand sequence, that have the required <B>magnitude relationship</B>. 
  Otherwise the result of the comparison is <CODE>false</CODE>. The <B>magnitude 
  relationship</B> between two atomic values is determined by applying the 
  following rules. If a <CODE>cast</CODE> operation called for by these rules is 
  not successful, a dynamic error is raised. [err:FORG0001]</P>
  <OL class=enumla>
    <LI>
    <P>If one of the atomic values is an instance of 
    <CODE>xs:untypedAtomic</CODE> and the other is an instance of a <A 
    title=numeric 
    href="REC-xpath20-20070123.htm#dt-numeric">numeric</A> 
    type, then the <CODE>xs:untypedAtomic</CODE> value is cast to the type 
    <CODE>xs:double</CODE>.</P>
    <LI>
    <P>If one of the atomic values is an instance of 
    <CODE>xs:untypedAtomic</CODE> and the other is an instance of 
    <CODE>xs:untypedAtomic</CODE> or <CODE>xs:string</CODE>, then the 
    <CODE>xs:untypedAtomic</CODE> value (or values) is (are) cast to the type 
    <CODE>xs:string</CODE>.</P>
    <LI>
    <P>If one of the atomic values is an instance of 
    <CODE>xs:untypedAtomic</CODE> and the other is not an instance of 
    <CODE>xs:string</CODE>, <CODE>xs:untypedAtomic</CODE>, or any <A 
    title=numeric 
    href="REC-xpath20-20070123.htm#dt-numeric">numeric</A> 
    type, then the <CODE>xs:untypedAtomic</CODE> value is cast to the <A 
    title="dynamic type" 
    href="REC-xpath20-20070123.htm#dt-dynamic-type">dynamic 
    type</A> of the other value.</P>
    <LI>
    <P>After performing the conversions described above, the atomic values are 
    compared using one of the value comparison operators <CODE>eq</CODE>, 
    <CODE>ne</CODE>, <CODE>lt</CODE>, <CODE>le</CODE>, <CODE>gt</CODE>, or 
    <CODE>ge</CODE>, depending on whether the general comparison operator was 
    <CODE>=</CODE>, <CODE>!=</CODE>, <CODE>&lt;</CODE>, <CODE>&lt;=</CODE>, 
    <CODE>&gt;</CODE>, or <CODE>&gt;=</CODE>. The values have the required 
    <B>magnitude relationship</B> if and only if the result of this value 
    comparison is <CODE>true</CODE>.</P></LI></OL></LI></OL>
<P>When evaluating a general comparison in which either operand is a sequence of 
items, an implementation may return <CODE>true</CODE> as soon as it finds an 
item in the first operand and an item in the second operand that have the 
required <B>magnitude relationship</B>. Similarly, a general comparison may 
raise a <A title="dynamic error" 
href="REC-xpath20-20070123.htm#dt-dynamic-error">dynamic 
error</A> as soon as it encounters an error in evaluating either operand, or in 
comparing a pair of items from the two operands. As a result of these rules, the 
result of a general comparison is not deterministic in the presence of 
errors.</P>
<P>Here are some examples of general comparisons:</P>
<UL>
  <LI>
  <P>The following comparison is true if the <A title="typed value" 
  href="REC-xpath20-20070123.htm#dt-typed-value">typed 
  value</A> of any <CODE>author</CODE> subelement of <CODE>$book1</CODE> is 
  "Kennedy" as an instance of <CODE>xs:string</CODE> or 
  <CODE>xs:untypedAtomic</CODE>:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>$book1/author = "Kennedy"
</PRE></DIV></DIV>
  <LI>
  <P>The following example contains three general comparisons. The value of the 
  first two comparisons is <CODE>true</CODE>, and the value of the third 
  comparison is <CODE>false</CODE>. This example illustrates the fact that 
  general comparisons are not transitive.</P>
  <DIV class=exampleInner><PRE>(1, 2) = (2, 3)
(2, 3) = (3, 4)
(1, 2) = (3, 4)
</PRE></DIV>
  <LI>
  <P>The following example contains two general comparisons, both of which are 
  <CODE>true</CODE>. This example illustrates the fact that the <CODE>=</CODE> 
  and <CODE>!=</CODE> operators are not inverses of each other.</P>
  <DIV class=exampleInner><PRE>(1, 2) = (2, 3)
(1, 2) != (2, 3)
</PRE></DIV>
  <LI>
  <P>Suppose that <CODE>$a</CODE>, <CODE>$b</CODE>, and <CODE>$c</CODE> are 
  bound to element nodes with type annotation <CODE>xs:untypedAtomic</CODE>, 
  with <A title="string value" 
  href="REC-xpath20-20070123.htm#dt-string-value">string 
  values</A> "<CODE>1</CODE>", "<CODE>2</CODE>", and "<CODE>2.0</CODE>" 
  respectively. Then <CODE>($a, $b) = ($c, 3.0)</CODE> returns 
  <CODE>false</CODE>, because <CODE>$b</CODE> and <CODE>$c</CODE> are compared 
  as strings. However, <CODE>($a, $b) = ($c, 2.0)</CODE> returns 
  <CODE>true</CODE>, because <CODE>$b</CODE> and <CODE>2.0</CODE> are compared 
  as numbers.</P></LI></UL></DIV>
<DIV class=div3>
<H4><A id=id-node-comparisons name=id-node-comparisons></A>3.5.3 Node 
Comparisons</H4>
<P>Node comparisons are used to compare two nodes, by their identity or by their 
<A title="document order" 
href="REC-xpath20-20070123.htm#dt-document-order">document 
order</A>. The result of a node comparison is defined by the following 
rules:</P>
<OL class=enumar>
  <LI>
  <P>The operands of a node comparison are evaluated in <A 
  title="implementation dependent" 
  href="REC-xpath20-20070123.htm#dt-implementation-dependent">implementation-dependent</A> 
  order.</P>
  <LI>
  <P>If either operand is an empty sequence, the result of the comparison is an 
  empty sequence, and the implementation need not evaluate the other operand or 
  apply the operator. However, an implementation may choose to evaluate the 
  other operand in order to determine whether it raises an error.</P>
  <LI>
  <P>Each operand must be either a single node or an empty sequence; otherwise a 
  <A title="type error" 
  href="REC-xpath20-20070123.htm#dt-type-error">type 
  error</A> is raised [<A title=err:XPTY0004 
  href="REC-xpath20-20070123.htm#ERRXPTY0004">err:XPTY0004</A>].</P>
  <LI>
  <P>A comparison with the <CODE>is</CODE> operator is <CODE>true</CODE> if the 
  two operand nodes have the same identity, and are thus the same node; 
  otherwise it is <CODE>false</CODE>. See <A 
  href="REC-xpath20-20070123.htm#datamodel">[XQuery/XPath 
  Data Model (XDM)]</A> for a definition of node identity.</P>
  <LI>
  <P>A comparison with the <CODE>&lt;&lt;</CODE> operator returns 
  <CODE>true</CODE> if the left operand node precedes the right operand node in 
  <A title="document order" 
  href="REC-xpath20-20070123.htm#dt-document-order">document 
  order</A>; otherwise it returns <CODE>false</CODE>.</P>
  <LI>
  <P>A comparison with the <CODE>&gt;&gt;</CODE> operator returns 
  <CODE>true</CODE> if the left operand node follows the right operand node in 
  <A title="document order" 
  href="REC-xpath20-20070123.htm#dt-document-order">document 
  order</A>; otherwise it returns <CODE>false</CODE>.</P></LI></OL>
<P>Here are some examples of node comparisons:</P>
<UL>
  <LI>
  <P>The following comparison is true only if the left and right sides each 
  evaluate to exactly the same single node:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>/books/book[isbn="1558604820"] is /books/book[call="QA76.9 C3845"]
</PRE></DIV></DIV>
  <LI>
  <P>The following comparison is true only if the node identified by the left 
  side occurs before the node identified by the right side in document 
order:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>/transactions/purchase[parcel="28-451"] 
   &lt;&lt; /transactions/sale[parcel="33-870"]
</PRE></DIV></DIV></LI></UL></DIV></DIV>
<DIV class=div2>
<H3><A id=id-logical-expressions name=id-logical-expressions></A>3.6 Logical 
Expressions</H3>
<P>A <B>logical expression</B> is either an <B>and-expression</B> or an 
<B>or-expression</B>. If a logical expression does not raise an error, its value 
is always one of the boolean values <CODE>true</CODE> or <CODE>false</CODE>.</P>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-OrExpr 
    name=doc-xpath-OrExpr></A>[8]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-OrExpr">OrExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-AndExpr">AndExpr</A> 
      ( "or" <A 
      href="REC-xpath20-20070123.htm#doc-xpath-AndExpr">AndExpr</A> 
      )*</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-AndExpr 
    name=doc-xpath-AndExpr></A>[9]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-AndExpr">AndExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-ComparisonExpr">ComparisonExpr</A> 
      ( "and" <A 
      href="REC-xpath20-20070123.htm#doc-xpath-ComparisonExpr">ComparisonExpr</A> 
      )*</CODE></TD></TR></TBODY></TABLE>
<P>The first step in evaluating a logical expression is to find the <A 
title="effective boolean value" 
href="REC-xpath20-20070123.htm#dt-ebv">effective boolean 
value</A> of each of its operands (see <A 
href="REC-xpath20-20070123.htm#id-ebv"><B>2.4.3 Effective 
Boolean Value</B></A>).</P>
<P>The value of an and-expression is determined by the effective boolean values 
(EBV's) of its operands, as shown in the following table:</P>
<TABLE cellSpacing=1 cellPadding=4 width="80%" summary="AND EBV" border=1>
  <TBODY>
  <TR>
    <TD>AND:</TD>
    <TD>EBV<SUB>2</SUB> = <CODE>true</CODE></TD>
    <TD>EBV<SUB>2</SUB> = <CODE>false</CODE></TD>
    <TD>error in EBV<SUB>2</SUB></TD></TR>
  <TR>
    <TD>EBV<SUB>1</SUB> = <CODE>true</CODE></TD>
    <TD><CODE>true</CODE></TD>
    <TD><CODE>false</CODE></TD>
    <TD>error</TD></TR>
  <TR>
    <TD>EBV<SUB>1</SUB> = <CODE>false</CODE></TD>
    <TD><CODE>false</CODE></TD>
    <TD><CODE>false</CODE></TD>
    <TD><SPAN class=xpath><SPAN class=xpath>if <A 
      title="XPath 1.0 compatibility mode" 
      href="REC-xpath20-20070123.htm#dt-xpath-compat-mode">XPath 
      1.0 compatibility mode</A> is <CODE>true</CODE>, then <CODE>false</CODE>; 
      otherwise either <CODE>false</CODE> or error.</SPAN></SPAN></TD></TR>
  <TR>
    <TD>error in EBV<SUB>1</SUB></TD>
    <TD>error</TD>
    <TD><SPAN class=xpath><SPAN class=xpath>if <A 
      title="XPath 1.0 compatibility mode" 
      href="REC-xpath20-20070123.htm#dt-xpath-compat-mode">XPath 
      1.0 compatibility mode</A> is <CODE>true</CODE>, then error; otherwise 
      either <CODE>false</CODE> or error.</SPAN></SPAN></TD>
    <TD>error</TD></TR></TBODY></TABLE>
<P>The value of an or-expression is determined by the effective boolean values 
(EBV's) of its operands, as shown in the following table:</P>
<TABLE cellSpacing=1 cellPadding=4 width="80%" summary="OR EBV" border=1>
  <TBODY>
  <TR>
    <TD>OR:</TD>
    <TD>EBV<SUB>2</SUB> = <CODE>true</CODE></TD>
    <TD>EBV<SUB>2</SUB> = <CODE>false</CODE></TD>
    <TD>error in EBV<SUB>2</SUB></TD></TR>
  <TR>
    <TD>EBV<SUB>1</SUB> = <CODE>true</CODE></TD>
    <TD><CODE>true</CODE></TD>
    <TD><CODE>true</CODE></TD>
    <TD><SPAN class=xpath><SPAN class=xpath>if <A 
      title="XPath 1.0 compatibility mode" 
      href="REC-xpath20-20070123.htm#dt-xpath-compat-mode">XPath 
      1.0 compatibility mode</A> is <CODE>true</CODE>, then <CODE>true</CODE>; 
      otherwise either <CODE>true</CODE> or error.</SPAN></SPAN></TD></TR>
  <TR>
    <TD>EBV<SUB>1</SUB> = <CODE>false</CODE></TD>
    <TD><CODE>true</CODE></TD>
    <TD><CODE>false</CODE></TD>
    <TD>error</TD></TR>
  <TR>
    <TD>error in EBV<SUB>1</SUB></TD>
    <TD><SPAN class=xpath><SPAN class=xpath>if <A 
      title="XPath 1.0 compatibility mode" 
      href="REC-xpath20-20070123.htm#dt-xpath-compat-mode">XPath 
      1.0 compatibility mode</A> is <CODE>true</CODE>, then error; otherwise 
      either <CODE>true</CODE> or error.</SPAN></SPAN></TD>
    <TD>error</TD>
    <TD>error</TD></TR></TBODY></TABLE>
<DIV class=xpath>
<P class=xpath>If <A title="XPath 1.0 compatibility mode" 
href="REC-xpath20-20070123.htm#dt-xpath-compat-mode">XPath 
1.0 compatibility mode</A> is <CODE>true</CODE>, the order in which the operands 
of a logical expression are evaluated is effectively prescribed. Specifically, 
it is defined that when there is no need to evaluate the second operand in order 
to determine the result, then no error can occur as a result of evaluating the 
second operand.</P></DIV>
<P><SPAN class=xpath><SPAN class=xpath>If <A 
title="XPath 1.0 compatibility mode" 
href="REC-xpath20-20070123.htm#dt-xpath-compat-mode">XPath 
1.0 compatibility mode</A> is <CODE>false</CODE>, the order in which the 
operands of a logical expression are evaluated is <A 
title="implementation dependent" 
href="REC-xpath20-20070123.htm#dt-implementation-dependent">implementation-dependent</A>. 
In this case,</SPAN></SPAN> an or-expression can return <CODE>true</CODE> if the 
first expression evaluated is true, and it can raise an error if evaluation of 
the first expression raises an error. Similarly, an and-expression can return 
<CODE>false</CODE> if the first expression evaluated is false, and it can raise 
an error if evaluation of the first expression raises an error. As a result of 
these rules, a logical expression is not deterministic in the presence of 
errors, as illustrated in the examples below.</P>
<P>Here are some examples of logical expressions:</P>
<UL>
  <LI>
  <P>The following expressions return <CODE>true</CODE>:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>1 eq 1 and 2 eq 2
</PRE></DIV></DIV>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>1 eq 1 or 2 eq 3
</PRE></DIV></DIV>
  <LI>
  <P>The following expression may return either <CODE>false</CODE> or raise a <A 
  title="dynamic error" 
  href="REC-xpath20-20070123.htm#dt-dynamic-error">dynamic 
  error</A><SPAN class=xpath><SPAN class=xpath>(in <A 
  title="XPath 1.0 compatibility mode" 
  href="REC-xpath20-20070123.htm#dt-xpath-compat-mode">XPath 
  1.0 compatibility mode</A>, the result must be 
  <CODE>false</CODE>)</SPAN></SPAN>:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>1 eq 2 and 3 idiv 0 = 1
</PRE></DIV></DIV>
  <LI>
  <P>The following expression may return either <CODE>true</CODE> or raise a <A 
  title="dynamic error" 
  href="REC-xpath20-20070123.htm#dt-dynamic-error">dynamic 
  error</A><SPAN class=xpath><SPAN class=xpath>(in <A 
  title="XPath 1.0 compatibility mode" 
  href="REC-xpath20-20070123.htm#dt-xpath-compat-mode">XPath 
  1.0 compatibility mode</A>, the result must be 
  <CODE>true</CODE>)</SPAN></SPAN>:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>1 eq 1 or 3 idiv 0 = 1
</PRE></DIV></DIV>
  <LI>
  <P>The following expression must raise a <A title="dynamic error" 
  href="REC-xpath20-20070123.htm#dt-dynamic-error">dynamic 
  error</A>:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>1 eq 1 and 3 idiv 0 = 1
</PRE></DIV></DIV></LI></UL>
<P>In addition to and- and or-expressions, XPath provides a function named 
<CODE>fn:not</CODE> that takes a general sequence as parameter and returns a 
boolean value. The <CODE>fn:not</CODE> function is defined in <A 
href="REC-xpath20-20070123.htm#FunctionsAndOperators">[XQuery 
1.0 and XPath 2.0 Functions and Operators]</A>. The <CODE>fn:not</CODE> function 
reduces its parameter to an <A title="effective boolean value" 
href="REC-xpath20-20070123.htm#dt-ebv">effective boolean 
value</A>. It then returns <CODE>true</CODE> if the effective boolean value of 
its parameter is <CODE>false</CODE>, and <CODE>false</CODE> if the effective 
boolean value of its parameter is <CODE>true</CODE>. If an error is encountered 
in finding the effective boolean value of its operand, <CODE>fn:not</CODE> 
raises the same error.</P></DIV>
<DIV class=xpath>
<DIV class=div2>
<H3><A id=id-for-expressions name=id-for-expressions></A>3.7 For 
Expressions</H3>
<P>XPath provides an iteration facility called a <B>for expression</B>.</P>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-ForExpr 
    name=doc-xpath-ForExpr></A>[4]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xpath 
      href="REC-xpath20-20070123.htm#prod-xpath-ForExpr">ForExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-SimpleForClause">SimpleForClause</A> 
      "return" <A 
      href="REC-xpath20-20070123.htm#doc-xpath-ExprSingle">ExprSingle</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-SimpleForClause 
      name=doc-xpath-SimpleForClause></A>[5]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xpath 
      href="REC-xpath20-20070123.htm#prod-xpath-SimpleForClause">SimpleForClause</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"for" "$" <A 
      href="REC-xpath20-20070123.htm#doc-xpath-VarName">VarName</A> 
      "in" <A 
      href="REC-xpath20-20070123.htm#doc-xpath-ExprSingle">ExprSingle</A> 
      ("," "$" <A 
      href="REC-xpath20-20070123.htm#doc-xpath-VarName">VarName</A> 
      "in" <A 
      href="REC-xpath20-20070123.htm#doc-xpath-ExprSingle">ExprSingle</A>)*</CODE></TD></TR></TBODY></TABLE>
<P>A <CODE>for</CODE> expression is evaluated as follows:</P>
<OL class=enumar>
  <LI>
  <P>If the <CODE>for</CODE> expression uses multiple variables, it is first 
  expanded to a set of nested <CODE>for</CODE> expressions, each of which uses 
  only one variable. For example, the expression <CODE>for $x in X, $y in Y 
  return $x + $y</CODE> is expanded to <CODE>for $x in X return for $y in Y 
  return $x + $y</CODE>.</P>
  <LI>
  <P>In a single-variable <CODE>for</CODE> expression, the variable is called 
  the <B>range variable</B>, the value of the expression that follows the 
  <CODE>in</CODE> keyword is called the <B>binding sequence</B>, and the 
  expression that follows the <CODE>return</CODE> keyword is called the 
  <B>return expression</B>. The result of the <CODE>for</CODE> expression is 
  obtained by evaluating the <CODE>return</CODE> expression once for each item 
  in the binding sequence, with the range variable bound to that item. The 
  resulting sequences are concatenated (as if by the <A title="comma operator" 
  href="REC-xpath20-20070123.htm#dt-comma-operator">comma 
  operator</A>) in the order of the items in the binding sequence from which 
  they were derived.</P></LI></OL>
<DIV class=xpath>
<P class=xpath>The following example illustrates the use of a <CODE>for</CODE> 
expression in restructuring an input document. The example is based on the 
following input:</P></DIV>
<DIV class=exampleInner><PRE>&lt;bib&gt;
  &lt;book&gt;
    &lt;title&gt;TCP/IP Illustrated&lt;/title&gt;
    &lt;author&gt;Stevens&lt;/author&gt;
    &lt;publisher&gt;Addison-Wesley&lt;/publisher&gt;
  &lt;/book&gt;
  &lt;book&gt;
    &lt;title&gt;Advanced Programming in the Unix Environment&lt;/title&gt;
    &lt;author&gt;Stevens&lt;/author&gt;
    &lt;publisher&gt;Addison-Wesley&lt;/publisher&gt;
  &lt;/book&gt;
  &lt;book&gt;
    &lt;title&gt;Data on the Web&lt;/title&gt;
    &lt;author&gt;Abiteboul&lt;/author&gt;
    &lt;author&gt;Buneman&lt;/author&gt;
    &lt;author&gt;Suciu&lt;/author&gt;
  &lt;/book&gt;
&lt;/bib&gt;
</PRE></DIV>
<P>The following example transforms the input document into a list in which each 
author's name appears only once, followed by a list of titles of books written 
by that author. This example assumes that the context item is the 
<CODE>bib</CODE> element in the input document.</P>
<DIV class=parse-test>
<DIV class=exampleInner><PRE><SPAN class=parse-test><SPAN class=parse-test>for $a in fn:distinct-values(book/author)
return (book/author[. = $a][1], book[author = $a]/title)</SPAN></SPAN>
</PRE></DIV></DIV>
<P>The result of the above expression consists of the following sequence of 
elements. The titles of books written by a given author are listed after the 
name of the author. The ordering of <CODE>author</CODE> elements in the result 
is <A title="implementation dependent" 
href="REC-xpath20-20070123.htm#dt-implementation-dependent">implementation-dependent</A> 
due to the semantics of the <CODE>fn:distinct-values</CODE> function.</P>
<DIV class=exampleInner><PRE>&lt;author&gt;Stevens&lt;/author&gt; 
&lt;title&gt;TCP/IP Illustrated&lt;/title&gt;
&lt;title&gt;Advanced Programming in the Unix environment&lt;/title&gt;
&lt;author&gt;Abiteboul&lt;/author&gt;
&lt;title&gt;Data on the Web&lt;/title&gt;
&lt;author&gt;Buneman&lt;/author&gt;
&lt;title&gt;Data on the Web&lt;/title&gt;
&lt;author&gt;Suciu&lt;/author&gt;
&lt;title&gt;Data on the Web&lt;/title&gt;
</PRE></DIV>
<P>The following example illustrates a <CODE>for</CODE> expression containing 
more than one variable:</P>
<DIV class=parse-test>
<DIV class=exampleInner><PRE><SPAN class=parse-test><SPAN class=parse-test>for $i in (10, 20),
    $j in (1, 2)
return ($i + $j)</SPAN></SPAN>
</PRE></DIV></DIV>
<P>The result of the above expression, expressed as a sequence of numbers, is as 
follows: <CODE>11, 12, 21, 22</CODE></P>
<P>The scope of a variable bound in a <CODE>for</CODE> expression comprises all 
subexpressions of the <CODE>for</CODE> expression that appear after the variable 
binding. The scope does not include the expression to which the variable is 
bound. The following example illustrates how a variable binding may reference 
another variable bound earlier in the same <CODE>for</CODE> expression:</P>
<DIV class=parse-test>
<DIV class=exampleInner><PRE><SPAN class=parse-test><SPAN class=parse-test>for $x in $z, $y in f($x)
return g($x, $y)</SPAN></SPAN>
</PRE></DIV></DIV>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>The focus for evaluation of the <CODE>return</CODE> clause of a 
<CODE>for</CODE> expression is the same as the focus for evaluation of the 
<CODE>for</CODE> expression itself. The following example, which attempts to 
find the total value of a set of order-items, is therefore incorrect:</P>
<DIV class=error>
<DIV class=exampleInner><PRE>fn:sum(for $i in order-item return @price *
@qty)
</PRE></DIV></DIV>
<P>Instead, the expression must be written to use the variable bound in the 
<CODE>for</CODE> clause:</P>
<DIV class=parse-test>
<DIV class=exampleInner><PRE>fn:sum(for $i in order-item
    return $i/@price * $i/@qty)
</PRE></DIV></DIV></DIV></DIV></DIV>
<DIV class=div2>
<H3><A id=id-conditionals name=id-conditionals></A>3.8 Conditional 
Expressions</H3>
<P>XPath supports a conditional expression based on the keywords 
<CODE>if</CODE>, <CODE>then</CODE>, and <CODE>else</CODE>.</P>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-IfExpr 
    name=doc-xpath-IfExpr></A>[7]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-IfExpr">IfExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"if" "(" <A 
      href="REC-xpath20-20070123.htm#doc-xpath-Expr">Expr</A> 
      ")" "then" <A 
      href="REC-xpath20-20070123.htm#doc-xpath-ExprSingle">ExprSingle</A> 
      "else" <A 
      href="REC-xpath20-20070123.htm#doc-xpath-ExprSingle">ExprSingle</A></CODE></TD></TR></TBODY></TABLE>
<P>The expression following the <CODE>if</CODE> keyword is called the <B>test 
expression</B>, and the expressions following the <CODE>then</CODE> and 
<CODE>else</CODE> keywords are called the <B>then-expression</B> and 
<B>else-expression</B>, respectively.</P>
<P>The first step in processing a conditional expression is to find the <A 
title="effective boolean value" 
href="REC-xpath20-20070123.htm#dt-ebv">effective boolean 
value</A> of the test expression, as defined in <A 
href="REC-xpath20-20070123.htm#id-ebv"><B>2.4.3 Effective 
Boolean Value</B></A>.</P>
<P>The value of a conditional expression is defined as follows: If the effective 
boolean value of the test expression is <CODE>true</CODE>, the value of the 
then-expression is returned. If the effective boolean value of the test 
expression is <CODE>false</CODE>, the value of the else-expression is 
returned.</P>
<P>Conditional expressions have a special rule for propagating <A 
title="dynamic error" 
href="REC-xpath20-20070123.htm#dt-dynamic-error">dynamic 
errors</A>. If the effective value of the test expression is <CODE>true</CODE>, 
the conditional expression ignores (does not raise) any dynamic errors 
encountered in the else-expression. In this case, since the else-expression can 
have no observable effect, it need not be evaluated. Similarly, if the effective 
value of the test expression is <CODE>false</CODE>, the conditional expression 
ignores any <A title="dynamic error" 
href="REC-xpath20-20070123.htm#dt-dynamic-error">dynamic 
errors</A> encountered in the then-expression, and the then-expression need not 
be evaluated.</P>
<P>Here are some examples of conditional expressions:</P>
<UL>
  <LI>
  <P>In this example, the test expression is a comparison expression:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>if ($widget1/unit-cost &lt; $widget2/unit-cost) 
  then $widget1
  else $widget2
</PRE></DIV></DIV>
  <LI>
  <P>In this example, the test expression tests for the existence of an 
  attribute named <CODE>discounted</CODE>, independently of its value:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>if ($part/@discounted) 
  then $part/wholesale 
  else $part/retail
</PRE></DIV></DIV></LI></UL></DIV>
<DIV class=div2>
<H3><A id=id-quantified-expressions name=id-quantified-expressions></A>3.9 
Quantified Expressions</H3>
<P>Quantified expressions support existential and universal quantification. The 
value of a quantified expression is always <CODE>true</CODE> or 
<CODE>false</CODE>.</P>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-QuantifiedExpr 
      name=doc-xpath-QuantifiedExpr></A>[6]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-QuantifiedExpr">QuantifiedExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>("some" | "every") "$" <A 
      href="REC-xpath20-20070123.htm#doc-xpath-VarName">VarName</A> 
      "in" <A 
      href="REC-xpath20-20070123.htm#doc-xpath-ExprSingle">ExprSingle</A> 
      ("," "$" <A 
      href="REC-xpath20-20070123.htm#doc-xpath-VarName">VarName</A> 
      "in" <A 
      href="REC-xpath20-20070123.htm#doc-xpath-ExprSingle">ExprSingle</A>)* 
      "satisfies" <A 
      href="REC-xpath20-20070123.htm#doc-xpath-ExprSingle">ExprSingle</A></CODE></TD></TR></TBODY></TABLE>
<P>A <B>quantified expression</B> begins with a <B>quantifier</B>, which is the 
keyword <CODE>some</CODE> or <CODE>every</CODE>, followed by one or more 
in-clauses that are used to bind variables, followed by the keyword 
<CODE>satisfies</CODE> and a test expression. Each in-clause associates a 
variable with an expression that returns a sequence of items, called the 
<B>binding sequence</B> for that variable. The in-clauses generate tuples of 
variable bindings, including a tuple for each combination of items in the 
binding sequences of the respective variables. Conceptually, the test expression 
is evaluated for each tuple of variable bindings. Results depend on the <A 
title="effective boolean value" 
href="REC-xpath20-20070123.htm#dt-ebv">effective boolean 
value</A> of the test expressions, as defined in <A 
href="REC-xpath20-20070123.htm#id-ebv"><B>2.4.3 Effective 
Boolean Value</B></A>. The value of the quantified expression is defined by the 
following rules:</P>
<OL class=enumar>
  <LI>
  <P>If the quantifier is <CODE>some</CODE>, the quantified expression is 
  <CODE>true</CODE> if at least one evaluation of the test expression has the <A 
  title="effective boolean value" 
  href="REC-xpath20-20070123.htm#dt-ebv">effective 
  boolean value</A> <CODE>true</CODE>; otherwise the quantified expression is 
  <CODE>false</CODE>. This rule implies that, if the in-clauses generate zero 
  binding tuples, the value of the quantified expression is 
  <CODE>false</CODE>.</P>
  <LI>
  <P>If the quantifier is <CODE>every</CODE>, the quantified expression is 
  <CODE>true</CODE> if every evaluation of the test expression has the <A 
  title="effective boolean value" 
  href="REC-xpath20-20070123.htm#dt-ebv">effective 
  boolean value</A> <CODE>true</CODE>; otherwise the quantified expression is 
  <CODE>false</CODE>. This rule implies that, if the in-clauses generate zero 
  binding tuples, the value of the quantified expression is 
  <CODE>true</CODE>.</P></LI></OL>
<P>The scope of a variable bound in a quantified expression comprises all 
subexpressions of the quantified expression that appear after the variable 
binding. The scope does not include the expression to which the variable is 
bound.</P>
<P>The order in which test expressions are evaluated for the various binding 
tuples is <A title="implementation dependent" 
href="REC-xpath20-20070123.htm#dt-implementation-dependent">implementation-dependent</A>. 
If the quantifier is <CODE>some</CODE>, an implementation may return 
<CODE>true</CODE> as soon as it finds one binding tuple for which the test 
expression has an <A title="effective boolean value" 
href="REC-xpath20-20070123.htm#dt-ebv">effective boolean 
value</A> of <CODE>true</CODE>, and it may raise a <A title="dynamic error" 
href="REC-xpath20-20070123.htm#dt-dynamic-error">dynamic 
error</A> as soon as it finds one binding tuple for which the test expression 
raises an error. Similarly, if the quantifier is <CODE>every</CODE>, an 
implementation may return <CODE>false</CODE> as soon as it finds one binding 
tuple for which the test expression has an <A title="effective boolean value" 
href="REC-xpath20-20070123.htm#dt-ebv">effective boolean 
value</A> of <CODE>false</CODE>, and it may raise a <A title="dynamic error" 
href="REC-xpath20-20070123.htm#dt-dynamic-error">dynamic 
error</A> as soon as it finds one binding tuple for which the test expression 
raises an error. As a result of these rules, the value of a quantified 
expression is not deterministic in the presence of errors, as illustrated in the 
examples below.</P>
<P>Here are some examples of quantified expressions:</P>
<UL>
  <LI>
  <P>This expression is <CODE>true</CODE> if every <CODE>part</CODE> element has 
  a <CODE>discounted</CODE> attribute (regardless of the values of these 
  attributes):</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>every $part in /parts/part satisfies $part/@discounted
</PRE></DIV></DIV>
  <LI>
  <P>This expression is <CODE>true</CODE> if at least one <CODE>employee</CODE> 
  element satisfies the given comparison expression:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>some $emp in /emps/employee satisfies 
     ($emp/bonus &gt; 0.25 * $emp/salary)
</PRE></DIV></DIV>
  <LI>
  <P>In the following examples, each quantified expression evaluates its test 
  expression over nine tuples of variable bindings, formed from the Cartesian 
  product of the sequences <CODE>(1, 2, 3)</CODE> and <CODE>(2, 3, 4)</CODE>. 
  The expression beginning with <CODE>some</CODE> evaluates to 
  <CODE>true</CODE>, and the expression beginning with <CODE>every</CODE> 
  evaluates to <CODE>false</CODE>.</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE><SPAN class=parse-test><SPAN class=parse-test>some $x in (1, 2, 3), $y in (2, 3, 4) 
     satisfies $x + $y = 4</SPAN></SPAN>
</PRE></DIV></DIV>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE><SPAN class=parse-test><SPAN class=parse-test>every $x in (1, 2, 3), $y in (2, 3, 4) 
     satisfies $x + $y = 4</SPAN></SPAN>
</PRE></DIV></DIV>
  <LI>
  <P>This quantified expression may either return <CODE>true</CODE> or raise a 
  <A title="type error" 
  href="REC-xpath20-20070123.htm#dt-type-error">type 
  error</A>, since its test expression returns <CODE>true</CODE> for one 
  variable binding and raises a <A title="type error" 
  href="REC-xpath20-20070123.htm#dt-type-error">type 
  error</A> for another:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>some $x in (1, 2, "cat") satisfies $x * 2 = 4
</PRE></DIV></DIV>
  <LI>
  <P>This quantified expression may either return <CODE>false</CODE> or raise a 
  <A title="type error" 
  href="REC-xpath20-20070123.htm#dt-type-error">type 
  error</A>, since its test expression returns <CODE>false</CODE> for one 
  variable binding and raises a <A title="type error" 
  href="REC-xpath20-20070123.htm#dt-type-error">type 
  error</A> for another:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>every $x in (1, 2, "cat") satisfies $x * 2 = 4
</PRE></DIV></DIV></LI></UL></DIV>
<DIV class=div2>
<H3><A id=id-expressions-on-datatypes name=id-expressions-on-datatypes></A>3.10 
Expressions on SequenceTypes</H3>
<P><A title="sequence type" 
href="REC-xpath20-20070123.htm#dt-sequence-type">sequence 
types</A> are used in <CODE>instance of</CODE>, <CODE>cast</CODE>, 
<CODE>castable</CODE>, and <CODE>treat</CODE> expressions.</P>
<DIV class=div3>
<H4><A id=id-instance-of name=id-instance-of></A>3.10.1 Instance Of</H4>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-InstanceofExpr 
      name=doc-xpath-InstanceofExpr></A>[16]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-InstanceofExpr">InstanceofExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-TreatExpr">TreatExpr</A> 
      ( "instance" "of" <A 
      href="REC-xpath20-20070123.htm#doc-xpath-SequenceType">SequenceType</A> 
      )?</CODE></TD></TR></TBODY></TABLE>
<P>The boolean operator <CODE>instance of</CODE> returns <CODE>true</CODE> if 
the value of its first operand matches the <A 
href="REC-xpath20-20070123.htm#doc-xpath-SequenceType">SequenceType</A> 
in its second operand, according to the rules for <A 
title="SequenceType matching" 
href="REC-xpath20-20070123.htm#dt-sequencetype-matching">SequenceType 
matching</A>; otherwise it returns <CODE>false</CODE>. For example:</P>
<UL>
  <LI>
  <P><CODE>5 instance of xs:integer</CODE></P>
  <P>This example returns <CODE>true</CODE> because the given value is an 
  instance of the given type.</P>
  <LI>
  <P><CODE>5 instance of xs:decimal</CODE></P>
  <P>This example returns <CODE>true</CODE> because the given value is an 
  integer literal, and <CODE>xs:integer</CODE> is derived by restriction from 
  <CODE>xs:decimal</CODE>.</P>
  <LI>
  <P><CODE>(5, 6) instance of xs:integer+</CODE></P>
  <P>This example returns <CODE>true</CODE> because the given sequence contains 
  two integers, and is a valid instance of the specified type.</P>
  <LI>
  <P><CODE>. instance of element()</CODE></P>
  <P>This example returns <CODE>true</CODE> if the context item is an element 
  node or <CODE>false</CODE> if the context item is defined but is not an 
  element node. If the context item is undefined, a <A title="dynamic error" 
  href="REC-xpath20-20070123.htm#dt-dynamic-error">dynamic 
  error</A> is raised [<A title=err:XPDY0002 
  href="REC-xpath20-20070123.htm#ERRXPDY0002">err:XPDY0002</A>].</P></LI></UL></DIV>
<DIV class=div3>
<H4><A id=id-cast name=id-cast></A>3.10.2 Cast</H4>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-CastExpr 
    name=doc-xpath-CastExpr></A>[19]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-CastExpr">CastExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-UnaryExpr">UnaryExpr</A> 
      ( "cast" "as" <A 
      href="REC-xpath20-20070123.htm#doc-xpath-SingleType">SingleType</A> 
      )?</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-SingleType 
      name=doc-xpath-SingleType></A>[49]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-SingleType">SingleType</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-AtomicType">AtomicType</A> 
      "?"?</CODE></TD></TR></TBODY></TABLE>
<P>Occasionally it is necessary to convert a value to a specific datatype. For 
this purpose, XPath provides a <CODE>cast</CODE> expression that creates a new 
value of a specific type based on an existing value. A <CODE>cast</CODE> 
expression takes two operands: an <B>input expression</B> and a <B>target 
type</B>. The type of the input expression is called the <B>input type</B>. The 
target type must be an atomic type that is in the <A 
title="in-scope schema type" 
href="REC-xpath20-20070123.htm#dt-is-types">in-scope 
schema types</A> [<A title=err:XPST0051 
href="REC-xpath20-20070123.htm#ERRXPST0051">err:XPST0051</A>]. 
In addition, the target type cannot be <CODE>xs:NOTATION</CODE> or 
<CODE>xs:anyAtomicType</CODE> [<A title=err:XPST0080 
href="REC-xpath20-20070123.htm#ERRXPST0080">err:XPST0080</A>]. 
The optional occurrence indicator "<CODE>?</CODE>" denotes that an empty 
sequence is permitted. If the target type has no namespace prefix, it is 
considered to be in the <A title="default element/type namespace" 
href="REC-xpath20-20070123.htm#dt-def-elemtype-ns">default 
element/type namespace</A>. The semantics of the <CODE>cast</CODE> expression 
are as follows:</P>
<OL class=enumar>
  <LI>
  <P><A title=atomization 
  href="REC-xpath20-20070123.htm#dt-atomization">Atomization</A> 
  is performed on the input expression.</P>
  <LI>
  <P>If the result of atomization is a sequence of more than one atomic value, a 
  <A title="type error" 
  href="REC-xpath20-20070123.htm#dt-type-error">type 
  error</A> is raised [<A title=err:XPTY0004 
  href="REC-xpath20-20070123.htm#ERRXPTY0004">err:XPTY0004</A>].</P>
  <LI>
  <P>If the result of atomization is an empty sequence:</P>
  <OL class=enumla>
    <LI>
    <P>If <CODE>?</CODE> is specified after the target type, the result of the 
    <CODE>cast</CODE> expression is an empty sequence.</P>
    <LI>
    <P>If <CODE>?</CODE> is not specified after the target type, a <A 
    title="type error" 
    href="REC-xpath20-20070123.htm#dt-type-error">type 
    error</A> is raised [<A title=err:XPTY0004 
    href="REC-xpath20-20070123.htm#ERRXPTY0004">err:XPTY0004</A>].</P></LI></OL>
  <LI>
  <P>If the result of atomization is a single atomic value, the result of the 
  cast expression depends on the input type and the target type. In general, the 
  cast expression attempts to create a new value of the target type based on the 
  input value. Only certain combinations of input type and target type are 
  supported. A summary of the rules are listed below— the normative definition 
  of these rules is given in <A 
  href="REC-xpath20-20070123.htm#FunctionsAndOperators">[XQuery 
  1.0 and XPath 2.0 Functions and Operators]</A>. For the purpose of these 
  rules, an implementation may determine that one type is derived by restriction 
  from another type either by examining the <A 
  title="in-scope schema definitions" 
  href="REC-xpath20-20070123.htm#dt-issd">in-scope schema 
  definitions</A> or by using an alternative, <A 
  title="implementation dependent" 
  href="REC-xpath20-20070123.htm#dt-implementation-dependent">implementation-dependent</A> 
  mechanism such as a data dictionary.</P>
  <OL class=enumla>
    <LI>
    <P><CODE>cast</CODE> is supported for the combinations of input type and 
    target type listed in <A 
    href="http://www.w3.org/TR/xpath-functions/#casting-from-primitive-to-primitive">Section 
    17.1 Casting from primitive types to primitive 
    types</A><SUP><SMALL>FO</SMALL></SUP>. For each of these combinations, both 
    the input type and the target type are primitive <A title="schema type" 
    href="REC-xpath20-20070123.htm#dt-schema-type">schema 
    types</A>. For example, a value of type <CODE>xs:string</CODE> can be cast 
    into the schema type <CODE>xs:decimal</CODE>. For each of these built-in 
    combinations, the semantics of casting are specified in <A 
    href="REC-xpath20-20070123.htm#FunctionsAndOperators">[XQuery 
    1.0 and XPath 2.0 Functions and Operators]</A>.</P>
    <P>If the target type of a <CODE>cast</CODE> expression is 
    <CODE>xs:QName</CODE>, or is a type that is derived from 
    <CODE>xs:QName</CODE> or <CODE>xs:NOTATION</CODE>, and if the base type of 
    the input is not the same as the base type of the target type, then the 
    input expression must be a string literal [<A title=err:XPTY0004 
    href="REC-xpath20-20070123.htm#ERRXPTY0004">err:XPTY0004</A>].</P>
    <DIV class=note>
    <P class=prefix><B>Note:</B></P>
    <P>The reason for this rule is that construction of an instance of one of 
    these target types from a string requires knowledge about namespace 
    bindings. If the input expression is a non-literal string, it might be 
    derived from an input document whose namespace bindings are different from 
    the <A title="statically known namespaces" 
    href="REC-xpath20-20070123.htm#dt-static-namespaces">statically 
    known namespaces</A>.</P></DIV>
    <LI>
    <P><CODE>cast</CODE> is supported if the input type is a non-primitive 
    atomic type that is derived by restriction from the target type. In this 
    case, the input value is mapped into the value space of the target type, 
    unchanged except for its type. For example, if <CODE>shoesize</CODE> is 
    derived by restriction from <CODE>xs:integer</CODE>, a value of type 
    <CODE>shoesize</CODE> can be cast into the schema type 
    <CODE>xs:integer</CODE>.</P>
    <LI>
    <P><CODE>cast</CODE> is supported if the target type is a non-primitive 
    atomic type and the input type is <CODE>xs:string</CODE> or 
    <CODE>xs:untypedAtomic</CODE>. The input value is first converted to a value 
    in the lexical space of the target type by applying the whitespace 
    normalization rules for the target type (as defined in <A 
    href="REC-xpath20-20070123.htm#XMLSchema">[XML 
    Schema]</A>); a <A title="dynamic error" 
    href="REC-xpath20-20070123.htm#dt-dynamic-error">dynamic 
    error</A> [err:FORG0001] is raised if the resulting lexical value does not 
    satisfy the pattern facet of the target type. The lexical value is then 
    converted to the value space of the target type using the schema-defined 
    rules for the target type; a <A title="dynamic error" 
    href="REC-xpath20-20070123.htm#dt-dynamic-error">dynamic 
    error</A> [err:FORG0001] is raised if the resulting value does not satisfy 
    all the facets of the target type.</P>
    <LI>
    <P><CODE>cast</CODE> is supported if the target type is a non-primitive 
    atomic type that is derived by restriction from the input type. The input 
    value must satisfy all the facets of the target type (in the case of the 
    pattern facet, this is checked by generating a string representation of the 
    input value, using the rules for casting to <CODE>xs:string</CODE>). The 
    resulting value is the same as the input value, but with a different <A 
    title="dynamic type" 
    href="REC-xpath20-20070123.htm#dt-dynamic-type">dynamic 
    type</A>.</P>
    <LI>
    <P>If a primitive type P1 can be cast into a primitive type P2, then any 
    type derived by restriction from P1 can be cast into any type derived by 
    restriction from P2, provided that the facets of the target type are 
    satisfied. First the input value is cast to P1 using rule (b) above. Next, 
    the value of type P1 is cast to the type P2, using rule (a) above. Finally, 
    the value of type P2 is cast to the target type, using rule (d) above.</P>
    <LI>
    <P>For any combination of input type and target type that is not in the 
    above list, a <CODE>cast</CODE> expression raises a <A title="type error" 
    href="REC-xpath20-20070123.htm#dt-type-error">type 
    error</A> [<A title=err:XPTY0004 
    href="REC-xpath20-20070123.htm#ERRXPTY0004">err:XPTY0004</A>].</P></LI></OL></LI></OL>
<P>If casting from the input type to the target type is supported but 
nevertheless it is not possible to cast the input value into the value space of 
the target type, a <A title="dynamic error" 
href="REC-xpath20-20070123.htm#dt-dynamic-error">dynamic 
error</A> is raised. [err:FORG0001] This includes the case when any facet of the 
target type is not satisfied. For example, the expression <CODE>"2003-02-31" 
cast as xs:date</CODE> would raise a <A title="dynamic error" 
href="REC-xpath20-20070123.htm#dt-dynamic-error">dynamic 
error</A>.</P></DIV>
<DIV class=div3>
<H4><A id=id-castable name=id-castable></A>3.10.3 Castable</H4>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-CastableExpr 
      name=doc-xpath-CastableExpr></A>[18]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-CastableExpr">CastableExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-CastExpr">CastExpr</A> 
      ( "castable" "as" <A 
      href="REC-xpath20-20070123.htm#doc-xpath-SingleType">SingleType</A> 
      )?</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=noid_N149B5.doc-xpath-SingleType 
      name=noid_N149B5.doc-xpath-SingleType></A>[49]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-SingleType">SingleType</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-AtomicType">AtomicType</A> 
      "?"?</CODE></TD></TR></TBODY></TABLE>
<P>XPath provides an expression that tests whether a given value is castable 
into a given target type. The target type must be an atomic type that is in the 
<A title="in-scope schema type" 
href="REC-xpath20-20070123.htm#dt-is-types">in-scope 
schema types</A> [<A title=err:XPST0051 
href="REC-xpath20-20070123.htm#ERRXPST0051">err:XPST0051</A>]. 
In addition, the target type cannot be <CODE>xs:NOTATION</CODE> or 
<CODE>xs:anyAtomicType</CODE> [<A title=err:XPST0080 
href="REC-xpath20-20070123.htm#ERRXPST0080">err:XPST0080</A>]. 
The optional occurrence indicator "<CODE>?</CODE>" denotes that an empty 
sequence is permitted.</P>
<P>The expression <CODE>V castable as T</CODE> returns <CODE>true</CODE> if the 
value <CODE>V</CODE> can be successfully cast into the target type 
<CODE>T</CODE> by using a <CODE>cast</CODE> expression; otherwise it returns 
<CODE>false</CODE>. The <CODE>castable</CODE> expression can be used as a <A 
title=predicate 
href="REC-xpath20-20070123.htm#dt-predicate">predicate</A> 
to avoid errors at evaluation time. It can also be used to select an appropriate 
type for processing of a given value, as illustrated in the following 
example:</P>
<DIV class=parse-test>
<DIV class=exampleInner><PRE>if ($x castable as hatsize) 
   then $x cast as hatsize 
   else if ($x castable as IQ) 
   then $x cast as IQ 
   else $x cast as xs:string
</PRE></DIV></DIV>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>If the target type of a <CODE>castable</CODE> expression is 
<CODE>xs:QName</CODE>, or is a type that is derived from <CODE>xs:QName</CODE> 
or <CODE>xs:NOTATION</CODE>, and the input argument of the expression is of type 
<CODE>xs:string</CODE> but it is not a literal string, the result of the 
<CODE>castable</CODE> expression is <CODE>false</CODE>.</P></DIV></DIV>
<DIV class=div3>
<H4><A id=id-constructor-functions name=id-constructor-functions></A>3.10.4 
Constructor Functions</H4>
<P>For every atomic type in the <A title="in-scope schema type" 
href="REC-xpath20-20070123.htm#dt-is-types">in-scope 
schema types</A> (except <CODE>xs:NOTATION</CODE> and 
<CODE>xs:anyAtomicType</CODE>, which are not instantiable), a <B>constructor 
function</B> is implicitly defined. In each case, the name of the constructor 
function is the same as the name of its target type (including namespace). The 
signature of the constructor function for type <EM>T</EM> is as follows:</P>
<DIV class=exampleInner><PRE><EM>T</EM>($arg as xs:anyAtomicType?) as <EM>T?</EM>
</PRE></DIV>
<P>[<A id=dt-constructor-function title="constructor function" 
name=dt-constructor-function>Definition</A>: The <B>constructor function</B> for 
a given type is used to convert instances of other atomic types into the given 
type. The semantics of the constructor function call <CODE>T($arg)</CODE> are 
defined to be equivalent to the expression <CODE>(($arg) cast as 
T?)</CODE>.]</P>
<P>The constructor functions for <CODE>xs:QName</CODE> and for types derived 
from <CODE>xs:QName</CODE> and <CODE>xs:NOTATION</CODE> require their arguments 
to be string literals or to have a base type that is the same as the base type 
of the target type; otherwise a type error [<A title=err:XPTY0004 
href="REC-xpath20-20070123.htm#ERRXPTY0004">err:XPTY0004</A>] 
is raised. This rule is consistent with the semantics of <CODE>cast</CODE> 
expressions for these types, as defined in <A 
href="REC-xpath20-20070123.htm#id-cast"><B>3.10.2 
Cast</B></A>.</P>
<P>The following examples illustrate the use of constructor functions:</P>
<UL>
  <LI>
  <P>This example is equivalent to <CODE>("2000-01-01" cast as 
  xs:date?)</CODE>.</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>xs:date("2000-01-01")
</PRE></DIV></DIV>
  <LI>
  <P>This example is equivalent to <CODE>(($floatvalue * 0.2E-5) cast as 
  xs:decimal?)</CODE>.</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>xs:decimal($floatvalue * 0.2E-5)
</PRE></DIV></DIV>
  <LI>
  <P>This example returns a <CODE>xs:dayTimeDuration</CODE> value equal to 21 
  days. It is equivalent to <CODE>("P21D" cast as 
  xs:dayTimeDuration?)</CODE>.</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>xs:dayTimeDuration("P21D")
</PRE></DIV></DIV>
  <LI>
  <P>If <CODE>usa:zipcode</CODE> is a user-defined atomic type in the <A 
  title="in-scope schema type" 
  href="REC-xpath20-20070123.htm#dt-is-types">in-scope 
  schema types</A>, then the following expression is equivalent to the 
  expression <CODE>("12345" cast as usa:zipcode?)</CODE>.</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>usa:zipcode("12345")
</PRE></DIV></DIV></LI></UL>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>An instance of an atomic type that is not in a namespace can be constructed 
in either of the following ways:</P>
<UL>
  <LI>
  <P>By using a <CODE>cast</CODE> expression, if the <A 
  title="default element/type namespace" 
  href="REC-xpath20-20070123.htm#dt-def-elemtype-ns">default 
  element/type namespace</A> is "none".</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>17 cast as apple
</PRE></DIV></DIV>
  <LI>
  <P>By using a constructor function, if the <A 
  title="default function namespace" 
  href="REC-xpath20-20070123.htm#dt-def-fn-ns">default 
  function namespace</A> is "none".</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>apple(17)
</PRE></DIV></DIV></LI></UL></DIV></DIV>
<DIV class=div3>
<H4><A id=id-treat name=id-treat></A>3.10.5 Treat</H4>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xpath-TreatExpr 
      name=doc-xpath-TreatExpr></A>[17]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-TreatExpr">TreatExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-CastableExpr">CastableExpr</A> 
      ( "treat" "as" <A 
      href="REC-xpath20-20070123.htm#doc-xpath-SequenceType">SequenceType</A> 
      )?</CODE></TD></TR></TBODY></TABLE>
<P>XPath provides an expression called <CODE>treat</CODE> that can be used to 
modify the <A title="static type" 
href="REC-xpath20-20070123.htm#dt-static-type">static 
type</A> of its operand.</P>
<P>Like <CODE>cast</CODE>, the <CODE>treat</CODE> expression takes two operands: 
an expression and a <A 
href="REC-xpath20-20070123.htm#doc-xpath-SequenceType">SequenceType</A>. 
Unlike <CODE>cast</CODE>, however, <CODE>treat</CODE> does not change the <A 
title="dynamic type" 
href="REC-xpath20-20070123.htm#dt-dynamic-type">dynamic 
type</A> or value of its operand. Instead, the purpose of <CODE>treat</CODE> is 
to ensure that an expression has an expected dynamic type at evaluation 
time.</P>
<P>The semantics of <EM><CODE>expr1</CODE></EM> <CODE>treat as</CODE> 
<EM><CODE>type1</CODE></EM> are as follows:</P>
<UL>
  <LI>
  <P>During static analysis:</P>
  <P>The <A title="static type" 
  href="REC-xpath20-20070123.htm#dt-static-type">static 
  type</A> of the <CODE>treat</CODE> expression is <EM><CODE>type1</CODE></EM>. 
  This enables the expression to be used as an argument of a function that 
  requires a parameter of <EM><CODE>type1</CODE></EM>.</P>
  <LI>
  <P>During expression evaluation:</P>
  <P>If <EM><CODE>expr1</CODE></EM> matches <EM><CODE>type1</CODE></EM>, using 
  the rules for <A title="SequenceType matching" 
  href="REC-xpath20-20070123.htm#dt-sequencetype-matching">SequenceType 
  matching</A>, the <CODE>treat</CODE> expression returns the value of 
  <EM><CODE>expr1</CODE></EM>; otherwise, it raises a <A title="dynamic error" 
  href="REC-xpath20-20070123.htm#dt-dynamic-error">dynamic 
  error</A> [<A title=err:XPDY0050 
  href="REC-xpath20-20070123.htm#ERRXPDY0050">err:XPDY0050</A>]. 
  If the value of <EM><CODE>expr1</CODE></EM> is returned, its identity is 
  preserved. The <CODE>treat</CODE> expression ensures that the value of its 
  expression operand conforms to the expected type at run-time.</P>
  <LI>
  <P>Example:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>$myaddress treat as element(*, USAddress)
</PRE></DIV></DIV>
  <P>The <A title="static type" 
  href="REC-xpath20-20070123.htm#dt-static-type">static 
  type</A> of <CODE>$myaddress</CODE> may be <CODE>element(*, Address)</CODE>, a 
  less specific type than <CODE>element(*, USAddress)</CODE>. However, at 
  run-time, the value of <CODE>$myaddress</CODE> must match the type 
  <CODE>element(*, USAddress)</CODE> using rules for <A 
  title="SequenceType matching" 
  href="REC-xpath20-20070123.htm#dt-sequencetype-matching">SequenceType 
  matching</A>; otherwise a <A title="dynamic error" 
  href="REC-xpath20-20070123.htm#dt-dynamic-error">dynamic 
  error</A> is raised [<A title=err:XPDY0050 
  href="REC-xpath20-20070123.htm#ERRXPDY0050">err:XPDY0050</A>].</P></LI></UL></DIV></DIV></DIV></DIV>
<DIV class=back>
<DIV class=div1>
<H2><A id=nt-bnf name=nt-bnf></A>A XPath Grammar</H2>
<DIV class=div2>
<H3><A id=id-grammar name=id-grammar></A>A.1 EBNF</H3>
<P>The grammar of XPath uses the same simple Extended Backus-Naur Form (EBNF) 
notation as <A href="REC-xpath20-20070123.htm#XML">[XML 
1.0]</A> with the following minor differences.</P>
<UL>
  <LI>
  <P>All named symbols have a name that begins with an uppercase letter.</P>
  <LI>
  <P>It adds a notation for referring to productions in external specs.</P>
  <LI>
  <P>Comments or extra-grammatical constraints on grammar productions are 
  between '/*' and '*/' symbols.</P>
  <UL>
    <LI>
    <P>A 'xgc:' prefix is an extra-grammatical constraint, the details of which 
    are explained in <A 
    href="REC-xpath20-20070123.htm#extra-grammatical-constraints"><B>A.1.2 
    Extra-grammatical Constraints</B></A></P>
    <LI>
    <P>A 'ws:' prefix explains the whitespace rules for the production, the 
    details of which are explained in <A 
    href="REC-xpath20-20070123.htm#whitespace-rules"><B>A.2.4 
    Whitespace Rules</B></A></P>
    <LI>
    <P>A 'gn:' prefix means a 'Grammar Note', and is meant as a clarification 
    for parsing rules, and is explained in <A 
    href="REC-xpath20-20070123.htm#notes-on-parsing"><B>A.1.3 
    Grammar Notes</B></A>. These notes are not normative.</P></LI></UL></LI></UL>
<P>The terminal symbols for this grammar include the quoted strings used in the 
production rules below, and the terminal symbols defined in section <A 
href="REC-xpath20-20070123.htm#terminal-symbols"><B>A.2.1 
Terminal Symbols</B></A>.</P>
<P>The EBNF notation is described in more detail in <A 
href="REC-xpath20-20070123.htm#EBNFNotation"><B>A.1.1 
Notation</B></A>.</P>
<P>To increase readability, the EBNF in the main body of this document omits 
some of these notational features. This appendix is the normative version of the 
EBNF.</P>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-XPath 
    name=prod-xpath-XPath></A>[1]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-XPath">XPath</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-Expr">Expr</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-Expr 
name=prod-xpath-Expr></A>[2]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-Expr">Expr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-ExprSingle">ExprSingle</A> 
      ("," <A 
      href="REC-xpath20-20070123.htm#prod-xpath-ExprSingle">ExprSingle</A>)*</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-ExprSingle 
      name=prod-xpath-ExprSingle></A>[3]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-ExprSingle">ExprSingle</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-ForExpr">ForExpr</A><BR>| 
      <A 
      href="REC-xpath20-20070123.htm#prod-xpath-QuantifiedExpr">QuantifiedExpr</A><BR>| 
      <A 
      href="REC-xpath20-20070123.htm#prod-xpath-IfExpr">IfExpr</A><BR>| 
      <A 
      href="REC-xpath20-20070123.htm#prod-xpath-OrExpr">OrExpr</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-ForExpr 
    name=prod-xpath-ForExpr></A>[4]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-ForExpr">ForExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-SimpleForClause">SimpleForClause</A> 
      "return" <A 
      href="REC-xpath20-20070123.htm#prod-xpath-ExprSingle">ExprSingle</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-SimpleForClause 
      name=prod-xpath-SimpleForClause></A>[5]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-SimpleForClause">SimpleForClause</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"for" "$" <A 
      href="REC-xpath20-20070123.htm#prod-xpath-VarName">VarName</A> 
      "in" <A 
      href="REC-xpath20-20070123.htm#prod-xpath-ExprSingle">ExprSingle</A> 
      ("," "$" <A 
      href="REC-xpath20-20070123.htm#prod-xpath-VarName">VarName</A> 
      "in" <A 
      href="REC-xpath20-20070123.htm#prod-xpath-ExprSingle">ExprSingle</A>)*</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-QuantifiedExpr 
      name=prod-xpath-QuantifiedExpr></A>[6]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-QuantifiedExpr">QuantifiedExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>("some" | "every") "$" <A 
      href="REC-xpath20-20070123.htm#prod-xpath-VarName">VarName</A> 
      "in" <A 
      href="REC-xpath20-20070123.htm#prod-xpath-ExprSingle">ExprSingle</A> 
      ("," "$" <A 
      href="REC-xpath20-20070123.htm#prod-xpath-VarName">VarName</A> 
      "in" <A 
      href="REC-xpath20-20070123.htm#prod-xpath-ExprSingle">ExprSingle</A>)* 
      "satisfies" <A 
      href="REC-xpath20-20070123.htm#prod-xpath-ExprSingle">ExprSingle</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-IfExpr 
    name=prod-xpath-IfExpr></A>[7]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-IfExpr">IfExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"if" "(" <A 
      href="REC-xpath20-20070123.htm#prod-xpath-Expr">Expr</A> 
      ")" "then" <A 
      href="REC-xpath20-20070123.htm#prod-xpath-ExprSingle">ExprSingle</A> 
      "else" <A 
      href="REC-xpath20-20070123.htm#prod-xpath-ExprSingle">ExprSingle</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-OrExpr 
    name=prod-xpath-OrExpr></A>[8]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-OrExpr">OrExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-AndExpr">AndExpr</A> 
      ( "or" <A 
      href="REC-xpath20-20070123.htm#prod-xpath-AndExpr">AndExpr</A> 
      )*</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-AndExpr 
    name=prod-xpath-AndExpr></A>[9]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-AndExpr">AndExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-ComparisonExpr">ComparisonExpr</A> 
      ( "and" <A 
      href="REC-xpath20-20070123.htm#prod-xpath-ComparisonExpr">ComparisonExpr</A> 
      )*</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-ComparisonExpr 
      name=prod-xpath-ComparisonExpr></A>[10]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-ComparisonExpr">ComparisonExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-RangeExpr">RangeExpr</A> 
      ( (<A 
      href="REC-xpath20-20070123.htm#prod-xpath-ValueComp">ValueComp</A><BR>| 
      <A 
      href="REC-xpath20-20070123.htm#prod-xpath-GeneralComp">GeneralComp</A><BR>| 
      <A 
      href="REC-xpath20-20070123.htm#prod-xpath-NodeComp">NodeComp</A>) 
      <A 
      href="REC-xpath20-20070123.htm#prod-xpath-RangeExpr">RangeExpr</A> 
      )?</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-RangeExpr 
      name=prod-xpath-RangeExpr></A>[11]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-RangeExpr">RangeExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-AdditiveExpr">AdditiveExpr</A> 
      ( "to" <A 
      href="REC-xpath20-20070123.htm#prod-xpath-AdditiveExpr">AdditiveExpr</A> 
      )?</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-AdditiveExpr 
      name=prod-xpath-AdditiveExpr></A>[12]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-AdditiveExpr">AdditiveExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-MultiplicativeExpr">MultiplicativeExpr</A> 
      ( ("+" | "-") <A 
      href="REC-xpath20-20070123.htm#prod-xpath-MultiplicativeExpr">MultiplicativeExpr</A> 
      )*</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-MultiplicativeExpr 
      name=prod-xpath-MultiplicativeExpr></A>[13]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-MultiplicativeExpr">MultiplicativeExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-UnionExpr">UnionExpr</A> 
      ( ("*" | "div" | "idiv" | "mod") <A 
      href="REC-xpath20-20070123.htm#prod-xpath-UnionExpr">UnionExpr</A> 
      )*</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-UnionExpr 
      name=prod-xpath-UnionExpr></A>[14]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-UnionExpr">UnionExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-IntersectExceptExpr">IntersectExceptExpr</A> 
      ( ("union" | "|") <A 
      href="REC-xpath20-20070123.htm#prod-xpath-IntersectExceptExpr">IntersectExceptExpr</A> 
      )*</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-IntersectExceptExpr 
      name=prod-xpath-IntersectExceptExpr></A>[15]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-IntersectExceptExpr">IntersectExceptExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-InstanceofExpr">InstanceofExpr</A> 
      ( ("intersect" | "except") <A 
      href="REC-xpath20-20070123.htm#prod-xpath-InstanceofExpr">InstanceofExpr</A> 
      )*</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-InstanceofExpr 
      name=prod-xpath-InstanceofExpr></A>[16]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-InstanceofExpr">InstanceofExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-TreatExpr">TreatExpr</A> 
      ( "instance" "of" <A 
      href="REC-xpath20-20070123.htm#prod-xpath-SequenceType">SequenceType</A> 
      )?</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-TreatExpr 
      name=prod-xpath-TreatExpr></A>[17]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-TreatExpr">TreatExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-CastableExpr">CastableExpr</A> 
      ( "treat" "as" <A 
      href="REC-xpath20-20070123.htm#prod-xpath-SequenceType">SequenceType</A> 
      )?</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-CastableExpr 
      name=prod-xpath-CastableExpr></A>[18]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-CastableExpr">CastableExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-CastExpr">CastExpr</A> 
      ( "castable" "as" <A 
      href="REC-xpath20-20070123.htm#prod-xpath-SingleType">SingleType</A> 
      )?</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-CastExpr 
      name=prod-xpath-CastExpr></A>[19]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-CastExpr">CastExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-UnaryExpr">UnaryExpr</A> 
      ( "cast" "as" <A 
      href="REC-xpath20-20070123.htm#prod-xpath-SingleType">SingleType</A> 
      )?</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-UnaryExpr 
      name=prod-xpath-UnaryExpr></A>[20]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-UnaryExpr">UnaryExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>("-" | "+")* <A 
      href="REC-xpath20-20070123.htm#prod-xpath-ValueExpr">ValueExpr</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-ValueExpr 
      name=prod-xpath-ValueExpr></A>[21]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-ValueExpr">ValueExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-PathExpr">PathExpr</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-GeneralComp 
      name=prod-xpath-GeneralComp></A>[22]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-GeneralComp">GeneralComp</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"=" | "!=" | "&lt;" | "&lt;=" | "&gt;" | 
  "&gt;="</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-ValueComp 
      name=prod-xpath-ValueComp></A>[23]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-ValueComp">ValueComp</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"eq" | "ne" | "lt" | "le" | "gt" | "ge"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-NodeComp 
      name=prod-xpath-NodeComp></A>[24]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-NodeComp">NodeComp</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"is" | "&lt;&lt;" | "&gt;&gt;"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-PathExpr 
      name=prod-xpath-PathExpr></A>[25]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-PathExpr">PathExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>("/" <A 
      href="REC-xpath20-20070123.htm#prod-xpath-RelativePathExpr">RelativePathExpr</A>?)<BR>| 
      ("//" <A 
      href="REC-xpath20-20070123.htm#prod-xpath-RelativePathExpr">RelativePathExpr</A>)<BR>| 
      <A 
      href="REC-xpath20-20070123.htm#prod-xpath-RelativePathExpr">RelativePathExpr</A></CODE></TD>
    <TD><I>/* <A 
      href="REC-xpath20-20070123.htm#parse-note-leading-lone-slash">xgs: 
      leading-lone-slash</A> */</I></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-RelativePathExpr 
      name=prod-xpath-RelativePathExpr></A>[26]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-RelativePathExpr">RelativePathExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-StepExpr">StepExpr</A> 
      (("/" | "//") <A 
      href="REC-xpath20-20070123.htm#prod-xpath-StepExpr">StepExpr</A>)*</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-StepExpr 
      name=prod-xpath-StepExpr></A>[27]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-StepExpr">StepExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-FilterExpr">FilterExpr</A> 
      | <A 
      href="REC-xpath20-20070123.htm#prod-xpath-AxisStep">AxisStep</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-AxisStep 
      name=prod-xpath-AxisStep></A>[28]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-AxisStep">AxisStep</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>(<A 
      href="REC-xpath20-20070123.htm#prod-xpath-ReverseStep">ReverseStep</A> 
      | <A 
      href="REC-xpath20-20070123.htm#prod-xpath-ForwardStep">ForwardStep</A>) 
      <A 
      href="REC-xpath20-20070123.htm#prod-xpath-PredicateList">PredicateList</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-ForwardStep 
      name=prod-xpath-ForwardStep></A>[29]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-ForwardStep">ForwardStep</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>(<A 
      href="REC-xpath20-20070123.htm#prod-xpath-ForwardAxis">ForwardAxis</A> 
      <A 
      href="REC-xpath20-20070123.htm#prod-xpath-NodeTest">NodeTest</A>) 
      | <A 
      href="REC-xpath20-20070123.htm#prod-xpath-AbbrevForwardStep">AbbrevForwardStep</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-ForwardAxis 
      name=prod-xpath-ForwardAxis></A>[30]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-ForwardAxis">ForwardAxis</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>("child" "::")<BR>| ("descendant" "::")<BR>| ("attribute" 
      "::")<BR>| ("self" "::")<BR>| ("descendant-or-self" "::")<BR>| 
      ("following-sibling" "::")<BR>| ("following" "::")<BR>| ("namespace" 
      "::")</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-AbbrevForwardStep 
      name=prod-xpath-AbbrevForwardStep></A>[31]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-AbbrevForwardStep">AbbrevForwardStep</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"@"? <A 
      href="REC-xpath20-20070123.htm#prod-xpath-NodeTest">NodeTest</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-ReverseStep 
      name=prod-xpath-ReverseStep></A>[32]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-ReverseStep">ReverseStep</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>(<A 
      href="REC-xpath20-20070123.htm#prod-xpath-ReverseAxis">ReverseAxis</A> 
      <A 
      href="REC-xpath20-20070123.htm#prod-xpath-NodeTest">NodeTest</A>) 
      | <A 
      href="REC-xpath20-20070123.htm#prod-xpath-AbbrevReverseStep">AbbrevReverseStep</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-ReverseAxis 
      name=prod-xpath-ReverseAxis></A>[33]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-ReverseAxis">ReverseAxis</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>("parent" "::")<BR>| ("ancestor" "::")<BR>| ("preceding-sibling" 
      "::")<BR>| ("preceding" "::")<BR>| ("ancestor-or-self" 
  "::")</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-AbbrevReverseStep 
      name=prod-xpath-AbbrevReverseStep></A>[34]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-AbbrevReverseStep">AbbrevReverseStep</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>".."</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-NodeTest 
      name=prod-xpath-NodeTest></A>[35]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-NodeTest">NodeTest</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-KindTest">KindTest</A> 
      | <A 
      href="REC-xpath20-20070123.htm#prod-xpath-NameTest">NameTest</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-NameTest 
      name=prod-xpath-NameTest></A>[36]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-NameTest">NameTest</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-QName">QName</A> 
      | <A 
      href="REC-xpath20-20070123.htm#prod-xpath-Wildcard">Wildcard</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-Wildcard 
      name=prod-xpath-Wildcard></A>[37]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-Wildcard">Wildcard</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"*"<BR>| (<A 
      href="REC-xpath20-20070123.htm#prod-xpath-NCName">NCName</A> 
      ":" "*")<BR>| ("*" ":" <A 
      href="REC-xpath20-20070123.htm#prod-xpath-NCName">NCName</A>)</CODE></TD>
    <TD><I>/* <A 
      href="REC-xpath20-20070123.htm#ws-explicit">ws: 
      explicit</A> */</I></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-FilterExpr 
      name=prod-xpath-FilterExpr></A>[38]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-FilterExpr">FilterExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-PrimaryExpr">PrimaryExpr</A> 
      <A 
      href="REC-xpath20-20070123.htm#prod-xpath-PredicateList">PredicateList</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-PredicateList 
      name=prod-xpath-PredicateList></A>[39]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-PredicateList">PredicateList</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-Predicate">Predicate</A>*</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-Predicate 
      name=prod-xpath-Predicate></A>[40]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-Predicate">Predicate</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"[" <A 
      href="REC-xpath20-20070123.htm#prod-xpath-Expr">Expr</A> 
      "]"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-PrimaryExpr 
      name=prod-xpath-PrimaryExpr></A>[41]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-PrimaryExpr">PrimaryExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-Literal">Literal</A> 
      | <A 
      href="REC-xpath20-20070123.htm#prod-xpath-VarRef">VarRef</A> 
      | <A 
      href="REC-xpath20-20070123.htm#prod-xpath-ParenthesizedExpr">ParenthesizedExpr</A> 
      | <A 
      href="REC-xpath20-20070123.htm#prod-xpath-ContextItemExpr">ContextItemExpr</A> 
      | <A 
      href="REC-xpath20-20070123.htm#prod-xpath-FunctionCall">FunctionCall</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-Literal 
    name=prod-xpath-Literal></A>[42]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-Literal">Literal</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-NumericLiteral">NumericLiteral</A> 
      | <A 
      href="REC-xpath20-20070123.htm#prod-xpath-StringLiteral">StringLiteral</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-NumericLiteral 
      name=prod-xpath-NumericLiteral></A>[43]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-NumericLiteral">NumericLiteral</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-IntegerLiteral">IntegerLiteral</A> 
      | <A 
      href="REC-xpath20-20070123.htm#prod-xpath-DecimalLiteral">DecimalLiteral</A> 
      | <A 
      href="REC-xpath20-20070123.htm#prod-xpath-DoubleLiteral">DoubleLiteral</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-VarRef 
    name=prod-xpath-VarRef></A>[44]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-VarRef">VarRef</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"$" <A 
      href="REC-xpath20-20070123.htm#prod-xpath-VarName">VarName</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-VarName 
    name=prod-xpath-VarName></A>[45]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-VarName">VarName</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-QName">QName</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-ParenthesizedExpr 
      name=prod-xpath-ParenthesizedExpr></A>[46]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-ParenthesizedExpr">ParenthesizedExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"(" <A 
      href="REC-xpath20-20070123.htm#prod-xpath-Expr">Expr</A>? 
      ")"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-ContextItemExpr 
      name=prod-xpath-ContextItemExpr></A>[47]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-ContextItemExpr">ContextItemExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"."</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-FunctionCall 
      name=prod-xpath-FunctionCall></A>[48]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-FunctionCall">FunctionCall</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-QName">QName</A> 
      "(" (<A 
      href="REC-xpath20-20070123.htm#prod-xpath-ExprSingle">ExprSingle</A> 
      ("," <A 
      href="REC-xpath20-20070123.htm#prod-xpath-ExprSingle">ExprSingle</A>)*)? 
      ")"</CODE></TD>
    <TD><I>/* <A 
      href="REC-xpath20-20070123.htm#parse-note-reserved-function-names">xgs: 
      reserved-function-names</A> */</I></TD></TR>
  <TR vAlign=baseline>
    <TD></TD>
    <TD></TD>
    <TD></TD>
    <TD></TD>
    <TD><I>/* <A 
      href="REC-xpath20-20070123.htm#parse-note-parens">gn: 
      parens</A> */</I></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-SingleType 
      name=prod-xpath-SingleType></A>[49]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-SingleType">SingleType</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-AtomicType">AtomicType</A> 
      "?"?</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-SequenceType 
      name=prod-xpath-SequenceType></A>[50]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-SequenceType">SequenceType</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>("empty-sequence" "(" ")")<BR>| (<A 
      href="REC-xpath20-20070123.htm#prod-xpath-ItemType">ItemType</A> 
      <A 
      href="REC-xpath20-20070123.htm#prod-xpath-OccurrenceIndicator">OccurrenceIndicator</A>?)</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-OccurrenceIndicator 
      name=prod-xpath-OccurrenceIndicator></A>[51]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-OccurrenceIndicator">OccurrenceIndicator</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"?" | "*" | "+"</CODE></TD>
    <TD><I>/* <A 
      href="REC-xpath20-20070123.htm#parse-note-occurrence-indicators">xgs: 
      occurrence-indicators</A> */</I></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-ItemType 
      name=prod-xpath-ItemType></A>[52]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-ItemType">ItemType</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-KindTest">KindTest</A> 
      | ("item" "(" ")") | <A 
      href="REC-xpath20-20070123.htm#prod-xpath-AtomicType">AtomicType</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-AtomicType 
      name=prod-xpath-AtomicType></A>[53]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-AtomicType">AtomicType</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-QName">QName</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-KindTest 
      name=prod-xpath-KindTest></A>[54]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-KindTest">KindTest</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-DocumentTest">DocumentTest</A><BR>| 
      <A 
      href="REC-xpath20-20070123.htm#prod-xpath-ElementTest">ElementTest</A><BR>| 
      <A 
      href="REC-xpath20-20070123.htm#prod-xpath-AttributeTest">AttributeTest</A><BR>| 
      <A 
      href="REC-xpath20-20070123.htm#prod-xpath-SchemaElementTest">SchemaElementTest</A><BR>| 
      <A 
      href="REC-xpath20-20070123.htm#prod-xpath-SchemaAttributeTest">SchemaAttributeTest</A><BR>| 
      <A 
      href="REC-xpath20-20070123.htm#prod-xpath-PITest">PITest</A><BR>| 
      <A 
      href="REC-xpath20-20070123.htm#prod-xpath-CommentTest">CommentTest</A><BR>| 
      <A 
      href="REC-xpath20-20070123.htm#prod-xpath-TextTest">TextTest</A><BR>| 
      <A 
      href="REC-xpath20-20070123.htm#prod-xpath-AnyKindTest">AnyKindTest</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-AnyKindTest 
      name=prod-xpath-AnyKindTest></A>[55]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-AnyKindTest">AnyKindTest</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"node" "(" ")"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-DocumentTest 
      name=prod-xpath-DocumentTest></A>[56]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-DocumentTest">DocumentTest</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"document-node" "(" (<A 
      href="REC-xpath20-20070123.htm#prod-xpath-ElementTest">ElementTest</A> 
      | <A 
      href="REC-xpath20-20070123.htm#prod-xpath-SchemaElementTest">SchemaElementTest</A>)? 
      ")"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-TextTest 
      name=prod-xpath-TextTest></A>[57]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-TextTest">TextTest</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"text" "(" ")"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-CommentTest 
      name=prod-xpath-CommentTest></A>[58]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-CommentTest">CommentTest</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"comment" "(" ")"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-PITest 
    name=prod-xpath-PITest></A>[59]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-PITest">PITest</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"processing-instruction" "(" (<A 
      href="REC-xpath20-20070123.htm#prod-xpath-NCName">NCName</A> 
      | <A 
      href="REC-xpath20-20070123.htm#prod-xpath-StringLiteral">StringLiteral</A>)? 
      ")"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-AttributeTest 
      name=prod-xpath-AttributeTest></A>[60]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-AttributeTest">AttributeTest</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"attribute" "(" (<A 
      href="REC-xpath20-20070123.htm#prod-xpath-AttribNameOrWildcard">AttribNameOrWildcard</A> 
      ("," <A 
      href="REC-xpath20-20070123.htm#prod-xpath-TypeName">TypeName</A>)?)? 
      ")"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-AttribNameOrWildcard 
      name=prod-xpath-AttribNameOrWildcard></A>[61]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-AttribNameOrWildcard">AttribNameOrWildcard</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-AttributeName">AttributeName</A> 
      | "*"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-SchemaAttributeTest 
      name=prod-xpath-SchemaAttributeTest></A>[62]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-SchemaAttributeTest">SchemaAttributeTest</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"schema-attribute" "(" <A 
      href="REC-xpath20-20070123.htm#prod-xpath-AttributeDeclaration">AttributeDeclaration</A> 
      ")"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-AttributeDeclaration 
      name=prod-xpath-AttributeDeclaration></A>[63]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-AttributeDeclaration">AttributeDeclaration</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-AttributeName">AttributeName</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-ElementTest 
      name=prod-xpath-ElementTest></A>[64]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-ElementTest">ElementTest</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"element" "(" (<A 
      href="REC-xpath20-20070123.htm#prod-xpath-ElementNameOrWildcard">ElementNameOrWildcard</A> 
      ("," <A 
      href="REC-xpath20-20070123.htm#prod-xpath-TypeName">TypeName</A> 
      "?"?)?)? ")"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-ElementNameOrWildcard 
      name=prod-xpath-ElementNameOrWildcard></A>[65]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-ElementNameOrWildcard">ElementNameOrWildcard</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-ElementName">ElementName</A> 
      | "*"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-SchemaElementTest 
      name=prod-xpath-SchemaElementTest></A>[66]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-SchemaElementTest">SchemaElementTest</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"schema-element" "(" <A 
      href="REC-xpath20-20070123.htm#prod-xpath-ElementDeclaration">ElementDeclaration</A> 
      ")"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-ElementDeclaration 
      name=prod-xpath-ElementDeclaration></A>[67]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-ElementDeclaration">ElementDeclaration</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-ElementName">ElementName</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-AttributeName 
      name=prod-xpath-AttributeName></A>[68]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-AttributeName">AttributeName</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-QName">QName</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-ElementName 
      name=prod-xpath-ElementName></A>[69]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-ElementName">ElementName</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-QName">QName</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-TypeName 
      name=prod-xpath-TypeName></A>[70]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-TypeName">TypeName</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-QName">QName</A></CODE></TD></TR></TBODY></TABLE>
<DIV class=div3>
<H4><A id=EBNFNotation name=EBNFNotation></A>A.1.1 Notation</H4>
<P>The following definitions will be helpful in defining precisely this 
exposition.</P>
<P>[<A id=symbol title=symbol name=symbol>Definition</A>: Each rule in the 
grammar defines one <B>symbol</B>, using the following format:</P>
<DIV class=exampleInner><PRE>symbol ::= expression
</PRE></DIV>
<P>]</P>
<P>[<A id=terminal title=terminal name=terminal>Definition</A>: A 
<B>terminal</B> is a symbol or string or pattern that can appear in the 
right-hand side of a rule, but never appears on the left hand side in the main 
grammar, although it may appear on the left-hand side of a rule in the grammar 
for terminals.] The following constructs are used to match strings of one or 
more characters in a terminal:</P>
<DL>
  <DT class=label>[a-zA-Z] 
  <DD>
  <P>matches any <A 
  href="REC-xpath20-20070123.htm#prod-xpath-Char">Char</A> 
  with a value in the range(s) indicated (inclusive).</P>
  <DT class=label>[abc] 
  <DD>
  <P>matches any <A 
  href="REC-xpath20-20070123.htm#prod-xpath-Char">Char</A> 
  with a value among the characters enumerated.</P>
  <DT class=label>[^abc] 
  <DD>
  <P>matches any <A 
  href="REC-xpath20-20070123.htm#prod-xpath-Char">Char</A> 
  with a value not among the characters given.</P>
  <DT class=label>"string" 
  <DD>
  <P>matches the sequence of characters that appear inside the double 
quotes.</P>
  <DT class=label>'string' 
  <DD>
  <P>matches the sequence of characters that appear inside the single 
quotes.</P>
  <DT class=label>[http://www.w3.org/TR/REC-example/#NT-Example] 
  <DD>
  <P>matches any string matched by the production defined in the external 
  specification as per the provided reference.</P></DD></DL>
<P>Patterns (including the above constructs) can be combined with grammatical 
operators to form more complex patterns, matching more complex sets of character 
strings. In the examples that follow, A and B represent (sub-)patterns.</P>
<DL>
  <DT class=label>(A) 
  <DD>
  <P><CODE>A</CODE> is treated as a unit and may be combined as described in 
  this list.</P>
  <DT class=label>A? 
  <DD>
  <P>matches <CODE>A</CODE> or nothing; optional <CODE>A</CODE>.</P>
  <DT class=label>A B 
  <DD>
  <P>matches <CODE>A</CODE> followed by <CODE>B</CODE>. This operator has higher 
  precedence than alternation; thus <CODE>A B | C D</CODE> is identical to 
  <CODE>(A B) | (C D)</CODE>.</P>
  <DT class=label>A | B 
  <DD>
  <P>matches <CODE>A</CODE> or <CODE>B</CODE> but not both.</P>
  <DT class=label>A - B 
  <DD>
  <P>matches any string that matches <CODE>A</CODE> but does not match 
  <CODE>B</CODE>.</P>
  <DT class=label>A+ 
  <DD>
  <P>matches one or more occurrences of <CODE>A</CODE>. Concatenation has higher 
  precedence than alternation; thus <CODE>A+ | B+</CODE> is identical to 
  <CODE>(A+) | (B+)</CODE>.</P></DD></DL>
<DL>
  <DT class=label>A* 
  <DD>
  <P>matches zero or more occurrences of <CODE>A</CODE>. Concatenation has 
  higher precedence than alternation; thus <CODE>A* | B*</CODE> is identical to 
  <CODE>(A*) | (B*)</CODE></P></DD></DL></DIV>
<DIV class=div3>
<H4><A id=extra-grammatical-constraints 
name=extra-grammatical-constraints></A>A.1.2 Extra-grammatical Constraints</H4>
<P>This section contains constraints on the EBNF productions, which are required 
to parse legal sentences. The notes below are referenced from the right side of 
the production, with the notation: <EM>/* xgc: &lt;id&gt; */</EM>.</P>
<DIV class=constraint>
<P class=prefix><A id=parse-note-leading-lone-slash 
name=parse-note-leading-lone-slash></A><B>Constraint: leading-lone-slash</B></P>
<P>A single slash may appear either as a complete path expression or as the 
first part of a path expression in which it is followed by a <A 
href="REC-xpath20-20070123.htm#doc-xpath-RelativePathExpr">RelativePathExpr</A>, 
which can take the form of a <A 
href="REC-xpath20-20070123.htm#doc-xpath-NameTest">NameTest</A> 
("*" or a QName). In contexts where operators like "*", "union", etc., can 
occur, parsers may have difficulty distinguishing operators from NameTests. For 
example, without lookahead the first part of the expression "/ * 5", for example 
is easily taken to be a complete expression, "/ *", which has a very different 
interpretation (the child nodes of "/").</P>
<P>To reduce the need for lookahead, therefore, if the token immediately 
following a slash is "*" or a keyword, then the slash must be the beginning, but 
not the entirety, of a <A 
href="REC-xpath20-20070123.htm#doc-xpath-PathExpr">PathExpr</A> 
(and the following token must be a <A 
href="REC-xpath20-20070123.htm#doc-xpath-NameTest">NameTest</A>, 
not an operator).</P>
<P>A single slash may be used as the left-hand argument of an operator by 
parenthesizing it: <CODE>(/) * 5</CODE>. The expression <CODE>5 * /</CODE>, on 
the other hand, is legal without parentheses.</P></DIV>
<DIV class=constraint>
<P class=prefix><A id=parse-note-xml-version 
name=parse-note-xml-version></A><B>Constraint: xml-version</B></P>
<P>An implementation's choice to support the <A 
href="REC-xpath20-20070123.htm#XML">[XML 1.0]</A> and <A 
href="REC-xpath20-20070123.htm#XMLNAMES">[XML Names]</A>, 
or <A href="REC-xpath20-20070123.htm#XML1.1">[XML 
1.1]</A> and <A 
href="REC-xpath20-20070123.htm#XMLNAMES11">[XML Names 
1.1]</A> lexical specification determines the external document from which to 
obtain the definition for this production. The EBNF only has references to the 
1.0 versions. In some cases, the XML 1.0 and XML 1.1 definitions may be exactly 
the same. Also please note that these external productions follow the whitespace 
rules of their respective specifications, and not the rules of this 
specification, in particular <A 
href="REC-xpath20-20070123.htm#DefaultWhitespaceHandling"><B>A.2.4.1 
Default Whitespace Handling</B></A>. Thus <CODE>prefix : localname</CODE> is not 
a valid QName for purposes of this specification, just as it is not permitted in 
a XML document. Also, comments are not permissible on either side of the colon. 
Also extra-grammatical constraints such as well-formedness constraints must be 
taken into account.</P></DIV>
<DIV class=constraint>
<P class=prefix><A id=parse-note-reserved-function-names 
name=parse-note-reserved-function-names></A><B>Constraint: 
reserved-function-names</B></P>
<P>Unprefixed function names spelled the same way as language keywords could 
make the language harder to recognize. For instance, <CODE>if(foo)</CODE> could 
be taken either as a <A 
href="REC-xpath20-20070123.htm#doc-xpath-FunctionCall">FunctionCall</A> 
or as the beginning of an <A 
href="REC-xpath20-20070123.htm#doc-xpath-IfExpr">IfExpr</A>. 
Therefore it is not legal syntax for a user to invoke functions with unprefixed 
names which match any of the names in <A 
href="REC-xpath20-20070123.htm#id-reserved-fn-names"><B>A.3 
Reserved Function Names</B></A>.</P>
<P>A function named "if" can be called by binding its namespace to a prefix and 
using the prefixed form: "library:if(foo)" instead of "if(foo)".</P></DIV>
<DIV class=constraint>
<P class=prefix><A id=parse-note-occurrence-indicators 
name=parse-note-occurrence-indicators></A><B>Constraint: 
occurrence-indicators</B></P>
<P>As written, the grammar in <A 
href="REC-xpath20-20070123.htm#nt-bnf"><B>A XPath 
Grammar</B></A> is ambiguous for some forms using the '+' and '*' Kleene 
operators. The ambiguity is resolved as follows: these operators are tightly 
bound to the <A 
href="REC-xpath20-20070123.htm#doc-xpath-SequenceType">SequenceType</A> 
expression, and have higher precedence than other uses of these symbols. Any 
occurrence of '+' and '*', as well as '?', following a sequence type is assumed 
to be an occurrence indicator. That is, a "+", "*", or "?" immediately following 
an <A 
href="REC-xpath20-20070123.htm#doc-xpath-ItemType">ItemType</A> 
must be an <A 
href="REC-xpath20-20070123.htm#doc-xpath-OccurrenceIndicator">OccurrenceIndicator</A>. 
Thus, <CODE>4 treat as item() + - 5</CODE> must be interpreted as <CODE>(4 treat 
as item()+) - 5</CODE>, taking the '+' as an OccurrenceIndicator and the '-' as 
a subtraction operator. To force the interpretation of "+" as an addition 
operator (and the corresponding interpretation of the "-" as a unary minus), 
parentheses may be used: the form <CODE>(4 treat as item()) + -5</CODE> 
surrounds the <A 
href="REC-xpath20-20070123.htm#doc-xpath-SequenceType">SequenceType</A> 
expression with parentheses and leads to the desired interpretation.</P>
<P>This rule has as a consequence that certain forms which would otherwise be 
legal and unambiguous are not recognized: in "4 treat as item() + 5", the "+" is 
taken as an <A 
href="REC-xpath20-20070123.htm#doc-xpath-OccurrenceIndicator">OccurrenceIndicator</A>, 
and not as an operator, which means this is not a legal 
expression.</P></DIV></DIV>
<DIV class=div3>
<H4><A id=notes-on-parsing name=notes-on-parsing></A>A.1.3 Grammar Notes</H4>
<P>This section contains general notes on the EBNF productions, which may be 
helpful in understanding how to interpret and implement the EBNF. These notes 
are not normative. The notes below are referenced from the right side of the 
production, with the notation: <EM>/* gn: &lt;id&gt; */</EM>.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<DL>
  <DT class=label><A id=parse-note-parens 
  name=parse-note-parens></A>grammar-note: parens 
  <DD>
  <P>Look-ahead is required to distinguish <A 
  href="REC-xpath20-20070123.htm#doc-xpath-FunctionCall">FunctionCall</A> 
  from a QName or keyword followed by a <A 
  href="REC-xpath20-20070123.htm#doc-xpath-Comment">Comment</A>. 
  For example: <CODE>address (: this may be empty :)</CODE> may be mistaken for 
  a call to a function named "address" unless this lookahead is employed. 
  Another example is <CODE>for (: whom the bell :) $tolls in 3 return 
  $tolls</CODE>, where the keyword "for" must not be mistaken for a function 
  name.</P>
  <DT class=label><A id=parse-note-comments 
  name=parse-note-comments></A>grammar-note: comments 
  <DD>
  <P>Comments are allowed everywhere that <A title="ignorable whitespace" 
  href="REC-xpath20-20070123.htm#IgnorableWhitespace">ignorable 
  whitespace</A> is allowed, and the <A 
  href="REC-xpath20-20070123.htm#doc-xpath-Comment">Comment</A> 
  symbol does not explicity appear on the right-hand side of the grammar (except 
  in its own production). See <A 
  href="REC-xpath20-20070123.htm#DefaultWhitespaceHandling"><B>A.2.4.1 
  Default Whitespace Handling</B></A>.</P>
  <P>A comment can contain nested comments, as long as all "(:" and ":)" 
  patterns are balanced, no matter where they occur within the outer 
comment.</P>
  <DIV class=note>
  <P class=prefix><B>Note:</B></P>
  <P>Lexical analysis may typically handle nested comments by incrementing a 
  counter for each "(:" pattern, and decrementing the counter for each ":)" 
  pattern. The comment does not terminate until the counter is back to 
  zero.</P></DIV>
  <P>Some illustrative examples:</P>
  <UL>
    <LI>
    <P><CODE>(: commenting out a (: comment :) may be confusing, but often 
    helpful :)</CODE> is a legal Comment, since balanced nesting of comments is 
    allowed.</P>
    <LI>
    <P><CODE>"this is just a string :)"</CODE> is a legal expression. However, 
    <CODE>(: "this is just a string :)" :)</CODE> will cause a syntax error. 
    Likewise, <CODE>"this is another string (:"</CODE> is a legal expression, 
    but <CODE>(: "this is another string (:" :)</CODE> will cause a syntax 
    error. It is a limitation of nested comments that literal content can cause 
    unbalanced nesting of comments.</P>
    <LI>
    <P><CODE>for (: set up loop :) $i in $x return $i</CODE> is syntactically 
    legal, ignoring the comment.</P>
    <LI>
    <P><CODE>5 instance (: strange place for a comment :) of xs:integer</CODE> 
    is also syntactically legal.</P></LI></UL></DD></DL></DIV></DIV></DIV>
<DIV class=div2>
<H3><A id=lexical-structure name=lexical-structure></A>A.2 Lexical 
structure</H3>
<P>The terminal symbols assumed by the grammar above are described in this 
section.</P>
<P>Quoted strings appearing in production rules are terminal symbols.</P>
<P>Other terminal symbols are defined in <A 
href="REC-xpath20-20070123.htm#terminal-symbols"><B>A.2.1 
Terminal Symbols</B></A>.</P>
<DIV class=xpath>
<P class=xpath>A <B>host language</B> may choose whether the lexical rules of <A 
href="REC-xpath20-20070123.htm#XML">[XML 1.0]</A> and <A 
href="REC-xpath20-20070123.htm#XMLNAMES">[XML Names]</A> 
are followed, or alternatively, the lexical rules of <A 
href="REC-xpath20-20070123.htm#XML1.1">[XML 1.1]</A> and 
<A href="REC-xpath20-20070123.htm#XMLNAMES11">[XML Names 
1.1]</A> are followed.</P></DIV>
<P>When tokenizing, the longest possible match that is valid in the current 
context is used.</P>
<P>All keywords are case sensitive. Keywords are not reserved—that is, any QName 
may duplicate a keyword except as noted in <A 
href="REC-xpath20-20070123.htm#id-reserved-fn-names"><B>A.3 
Reserved Function Names</B></A>.</P>
<DIV class=div3>
<H4><A id=terminal-symbols name=terminal-symbols></A>A.2.1 Terminal Symbols</H4>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-IntegerLiteral 
      name=prod-xpath-IntegerLiteral></A>[71]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-IntegerLiteral">IntegerLiteral</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#prod-xpath-Digits">Digits</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-DecimalLiteral 
      name=prod-xpath-DecimalLiteral></A>[72]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-DecimalLiteral">DecimalLiteral</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>("." <A 
      href="REC-xpath20-20070123.htm#prod-xpath-Digits">Digits</A>) 
      | (<A 
      href="REC-xpath20-20070123.htm#prod-xpath-Digits">Digits</A> 
      "." [0-9]*)</CODE></TD>
    <TD><I>/* <A 
      href="REC-xpath20-20070123.htm#ws-explicit">ws: 
      explicit</A> */</I></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-DoubleLiteral 
      name=prod-xpath-DoubleLiteral></A>[73]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-DoubleLiteral">DoubleLiteral</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>(("." <A 
      href="REC-xpath20-20070123.htm#prod-xpath-Digits">Digits</A>) 
      | (<A 
      href="REC-xpath20-20070123.htm#prod-xpath-Digits">Digits</A> 
      ("." [0-9]*)?)) [eE] [+-]? <A 
      href="REC-xpath20-20070123.htm#prod-xpath-Digits">Digits</A></CODE></TD>
    <TD><I>/* <A 
      href="REC-xpath20-20070123.htm#ws-explicit">ws: 
      explicit</A> */</I></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-StringLiteral 
      name=prod-xpath-StringLiteral></A>[74]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-StringLiteral">StringLiteral</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>('"' (<A 
      href="REC-xpath20-20070123.htm#prod-xpath-EscapeQuot">EscapeQuot</A> 
      | [^"])* '"') | ("'" (<A 
      href="REC-xpath20-20070123.htm#prod-xpath-EscapeApos">EscapeApos</A> 
      | [^'])* "'")</CODE></TD>
    <TD><I>/* <A 
      href="REC-xpath20-20070123.htm#ws-explicit">ws: 
      explicit</A> */</I></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-EscapeQuot 
      name=prod-xpath-EscapeQuot></A>[75]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-EscapeQuot">EscapeQuot</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>'""'</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-EscapeApos 
      name=prod-xpath-EscapeApos></A>[76]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-EscapeApos">EscapeApos</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"''"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-Comment 
    name=prod-xpath-Comment></A>[77]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-Comment">Comment</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"(:" (<A 
      href="REC-xpath20-20070123.htm#prod-xpath-CommentContents">CommentContents</A> 
      | <A 
      href="REC-xpath20-20070123.htm#prod-xpath-Comment">Comment</A>)* 
      ":)"</CODE></TD>
    <TD><I>/* <A 
      href="REC-xpath20-20070123.htm#ws-explicit">ws: 
      explicit</A> */</I></TD></TR>
  <TR vAlign=baseline>
    <TD></TD>
    <TD></TD>
    <TD></TD>
    <TD></TD>
    <TD><I>/* <A 
      href="REC-xpath20-20070123.htm#parse-note-comments">gn: 
      comments</A> */</I></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-QName 
    name=prod-xpath-QName></A>[78]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>QName</CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="http://www.w3.org/TR/REC-xml-names/#NT-QName">[http://www.w3.org/TR/REC-xml-names/#NT-QName]</A><SUP> 
      <SMALL>Names</SMALL></SUP></CODE></TD>
    <TD><I>/* <A 
      href="REC-xpath20-20070123.htm#parse-note-xml-version">xgs: 
      xml-version</A> */</I></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-NCName 
    name=prod-xpath-NCName></A>[79]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>NCName</CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="http://www.w3.org/TR/REC-xml-names/#NT-NCName">[http://www.w3.org/TR/REC-xml-names/#NT-NCName]</A><SUP> 
      <SMALL>Names</SMALL></SUP></CODE></TD>
    <TD><I>/* <A 
      href="REC-xpath20-20070123.htm#parse-note-xml-version">xgs: 
      xml-version</A> */</I></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-Char 
    name=prod-xpath-Char></A>[80]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>Char</CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="http://www.w3.org/TR/REC-xml/#NT-Char">[http://www.w3.org/TR/REC-xml#NT-Char]</A><SUP> 
      <SMALL>XML</SMALL></SUP></CODE></TD>
    <TD><I>/* <A 
      href="REC-xpath20-20070123.htm#parse-note-xml-version">xgs: 
      xml-version</A> */</I></TD></TR></TBODY></TABLE>
<P>The following symbols are used only in the definition of terminal symbols; 
they are not terminal symbols in the grammar of <A 
href="REC-xpath20-20070123.htm#id-grammar"><B>A.1 
EBNF</B></A>.</P>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-Digits 
    name=prod-xpath-Digits></A>[81]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-Digits">Digits</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>[0-9]+</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xpath-CommentContents 
      name=prod-xpath-CommentContents></A>[82]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xpath20-20070123.htm#doc-xpath-CommentContents">CommentContents</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>(<A 
      href="REC-xpath20-20070123.htm#prod-xpath-Char">Char</A>+ 
      - (Char* ('(:' | ':)') Char*))</CODE></TD></TR></TBODY></TABLE></DIV>
<DIV class=div3>
<H4><A id=id-terminal-delimitation name=id-terminal-delimitation></A>A.2.2 
Terminal Delimitation</H4>
<P>XPath 2.0 expressions consist of <A 
href="REC-xpath20-20070123.htm#terminal-symbols">terminal 
symbols</A> and <A title="symbol separators" 
href="REC-xpath20-20070123.htm#symbolseparators">symbol 
separators</A>.</P>
<P>Terminal symbols that are not used exclusively in <A 
href="REC-xpath20-20070123.htm#ws-explicit">/* ws: 
explicit */</A> productions are of two kinds: delimiting and non-delimiting.</P>
<P>[<A id=delimiting-token title="delimiting terminal symbol" 
name=delimiting-token>Definition</A>: The <B>delimiting terminal symbols</B> 
are: "-", (comma), (colon), "::", "!=", "?", "/", "//", (dot), "..", <A 
href="REC-xpath20-20070123.htm#prod-xpath-StringLiteral">StringLiteral</A>, 
"(", ")", "[", "]", "@", "$", "*", "+", "&lt;", "&lt;&lt;", "&lt;=", "=", 
"&gt;", "&gt;=", "&gt;&gt;", "|"]</P>
<P>[<A id=non-delimiting-token title="non-delimiting terminal symbol" 
name=non-delimiting-token>Definition</A>: The <B>non-delimiting terminal 
symbols</B> are: <A 
href="REC-xpath20-20070123.htm#prod-xpath-IntegerLiteral">IntegerLiteral</A>, 
<A 
href="REC-xpath20-20070123.htm#prod-xpath-NCName">NCName</A>, 
<A 
href="REC-xpath20-20070123.htm#prod-xpath-QName">QName</A>, 
<A 
href="REC-xpath20-20070123.htm#prod-xpath-DecimalLiteral">DecimalLiteral</A>, 
<A 
href="REC-xpath20-20070123.htm#prod-xpath-DoubleLiteral">DoubleLiteral</A>, 
"ancestor", "ancestor-or-self", "and", "as", "attribute", "cast", "castable", 
"child", "comment", "descendant", "descendant-or-self", "div", "document-node", 
"element", "else", "empty-sequence", "eq", "every", "except", "external", 
"following", "following-sibling", "for", "ge", "gt", "idiv", "if", "in", 
"instance", "intersect", "is", "item", "le", "lt", "mod", "namespace", "ne", 
"node", "of", "or", "parent", "preceding", "preceding-sibling", 
"processing-instruction", "return", "satisfies", "schema-attribute", 
"schema-element", "self", "some", "text", "then", "to", "treat", "union"]</P>
<P>[<A id=symbolseparators title="symbol separators" 
name=symbolseparators>Definition</A>: <A title=whitespace 
href="REC-xpath20-20070123.htm#Whitespace">Whitespace</A> 
and <A 
href="REC-xpath20-20070123.htm#doc-xpath-Comment">Comments</A> 
function as <B>symbol separators</B>. For the most part, they are not mentioned 
in the grammar, and may occur between any two terminal symbols mentioned in the 
grammar, except where that is forbidden by the <A 
href="REC-xpath20-20070123.htm#ws-explicit">/* ws: 
explicit */</A> annotation in the EBNF, or by the <A 
href="REC-xpath20-20070123.htm#parse-note-xml-version">/* 
xgs: xml-version */</A> annotation. ]</P>
<P>It is customary to separate consecutive terminal symbols by <A 
title=whitespace 
href="REC-xpath20-20070123.htm#Whitespace">whitespace</A> 
and <A 
href="REC-xpath20-20070123.htm#doc-xpath-Comment">Comments</A>, 
but this is required only when otherwise two non-delimiting symbols would be 
adjacent to each other. There are two exceptions to this, that of "." and "-", 
which do require a <A title="symbol separators" 
href="REC-xpath20-20070123.htm#symbolseparators">symbol 
separator</A> if they follow a QName or NCName. Also, "." requires a separator 
if it precedes or follows a numeric literal.</P></DIV>
<DIV class=div3>
<H4><A id=id-eol-handling name=id-eol-handling></A>A.2.3 End-of-Line 
Handling</H4>
<P>The XPath processor must behave as if it normalized all line breaks on input, 
before parsing. The normalization should be done according to the choice to 
support either <A 
href="REC-xpath20-20070123.htm#XML">[XML 1.0]</A> or <A 
href="REC-xpath20-20070123.htm#XML1.1">[XML 1.1]</A> 
lexical processing.</P>
<DIV class=div4>
<H5><A id=id-xml10-eol-handling name=id-xml10-eol-handling></A>A.2.3.1 XML 1.0 
End-of-Line Handling</H5>
<P>For <A href="REC-xpath20-20070123.htm#XML">[XML 
1.0]</A> processing, all of the following must be translated to a single #xA 
character:</P>
<OL class=enumar>
  <LI>
  <P>the two-character sequence #xD #xA</P>
  <LI>
  <P>any #xD character that is not immediately followed by 
#xA.</P></LI></OL></DIV>
<DIV class=div4>
<H5><A id=id-xml11-eol-handling name=id-xml11-eol-handling></A>A.2.3.2 XML 1.1 
End-of-Line Handling</H5>
<P>For <A href="REC-xpath20-20070123.htm#XML1.1">[XML 
1.1]</A> processing, all of the following must be translated to a single #xA 
character:</P>
<OL class=enumar>
  <LI>
  <P>the two-character sequence #xD #xA</P>
  <LI>
  <P>the two-character sequence #xD #x85</P>
  <LI>
  <P>the single character #x85</P>
  <LI>
  <P>the single character #x2028</P>
  <LI>
  <P>any #xD character that is not immediately followed by #xA or 
#x85.</P></LI></OL></DIV></DIV>
<DIV class=div3>
<H4><A id=whitespace-rules name=whitespace-rules></A>A.2.4 Whitespace Rules</H4>
<DIV class=div4>
<H5><A id=DefaultWhitespaceHandling name=DefaultWhitespaceHandling></A>A.2.4.1 
Default Whitespace Handling</H5>
<P>[<A id=Whitespace title=whitespace name=Whitespace>Definition</A>: A 
<B>whitespace</B> character is any of the characters defined by <A 
href="http://www.w3.org/TR/REC-xml#NT-S">[http://www.w3.org/TR/REC-xml#NT-S]</A>.]</P>
<P>[<A id=IgnorableWhitespace title="ignorable whitespace" 
name=IgnorableWhitespace>Definition</A>: <B>Ignorable whitespace</B> consists of 
any <A title=whitespace 
href="REC-xpath20-20070123.htm#Whitespace">whitespace</A> 
characters that may occur between <A title=terminal 
href="REC-xpath20-20070123.htm#terminal">terminals</A>, 
unless these characters occur in the context of a production marked with a <A 
href="REC-xpath20-20070123.htm#ExplicitWhitespaceHandling">ws:explicit</A> 
annotation, in which case they can occur only where explicitly specified (see <A 
href="REC-xpath20-20070123.htm#ExplicitWhitespaceHandling"><B>A.2.4.2 
Explicit Whitespace Handling</B></A>).] Ignorable whitespace characters are not 
significant to the semantics of an expression. Whitespace is allowed before the 
first terminal and after the last terminal of a module. Whitespace is allowed 
between any two <A title=terminal 
href="REC-xpath20-20070123.htm#terminal">terminals</A>. 
<A 
href="REC-xpath20-20070123.htm#doc-xpath-Comment">Comments</A> 
may also act as "whitespace" to prevent two adjacent terminals from being 
recognized as one. Some illustrative examples are as follows:</P>
<UL>
  <LI>
  <P><CODE>foo- foo</CODE> results in a syntax error. "foo-" would be recognized 
  as a QName.</P>
  <LI>
  <P><CODE>foo -foo</CODE> is syntactically equivalent to <CODE>foo - 
  foo</CODE>, two QNames separated by a subtraction operator.</P>
  <LI>
  <P><CODE>foo(: This is a comment :)- foo</CODE> is syntactically equivalent to 
  <CODE>foo - foo</CODE>. This is because the comment prevents the two adjacent 
  terminals from being recognized as one.</P>
  <LI>
  <P><CODE>foo-foo</CODE> is syntactically equivalent to single QName. This is 
  because "-" is a valid character in a QName. When used as an operator after 
  the characters of a name, the "-" must be separated from the name, e.g. by 
  using whitespace or parentheses.</P>
  <LI>
  <P><CODE>10div 3</CODE> results in a syntax error.</P>
  <LI>
  <P><CODE>10 div3</CODE> also results in a syntax error.</P>
  <LI>
  <P><CODE>10div3</CODE> also results in a syntax error.</P></LI></UL></DIV>
<DIV class=div4>
<H5><A id=ExplicitWhitespaceHandling name=ExplicitWhitespaceHandling></A>A.2.4.2 
Explicit Whitespace Handling</H5>
<P>Explicit whitespace notation is specified with the EBNF productions, when it 
is different from the default rules, using the notation shown below. This 
notation is not inherited. In other words, if an EBNF rule is marked as /* ws: 
explicit */, the notation does not automatically apply to all the 'child' EBNF 
productions of that rule.</P>
<DL>
  <DT class=label><A id=ws-explicit name=ws-explicit></A>ws: explicit 
  <DD>
  <P>/* ws: explicit */ means that the EBNF notation explicitly notates, with 
  <CODE>S</CODE> or otherwise, where <A title=whitespace 
  href="REC-xpath20-20070123.htm#Whitespace">whitespace 
  characters</A> are allowed. In productions with the /* ws: explicit */ 
  annotation, <A 
  href="REC-xpath20-20070123.htm#DefaultWhitespaceHandling"><B>A.2.4.1 
  Default Whitespace Handling</B></A> does not apply. <A 
  href="REC-xpath20-20070123.htm#doc-xpath-Comment">Comments</A> 
  are also not allowed in these productions.</P></DD></DL></DIV></DIV></DIV>
<DIV class=div2>
<H3><A id=id-reserved-fn-names name=id-reserved-fn-names></A>A.3 Reserved 
Function Names</H3>
<P>The following names are not allowed as function names in an unprefixed form 
because expression syntax takes precedence.</P>
<UL>
  <LI>
  <P><CODE>attribute</CODE></P>
  <LI>
  <P><CODE>comment</CODE></P>
  <LI>
  <P><CODE>document-node</CODE></P>
  <LI>
  <P><CODE>element</CODE></P>
  <LI>
  <P><CODE>empty-sequence</CODE></P>
  <LI>
  <P><CODE>if</CODE></P>
  <LI>
  <P><CODE>item</CODE></P>
  <LI>
  <P><CODE>node</CODE></P>
  <LI>
  <P><CODE>processing-instruction</CODE></P>
  <LI>
  <P><CODE>schema-attribute</CODE></P>
  <LI>
  <P><CODE>schema-element</CODE></P>
  <LI>
  <P><CODE>text</CODE></P>
  <LI>
  <P><CODE>typeswitch</CODE></P>
  <DIV class=note>
  <P class=prefix><B>Note:</B></P>
  <P>Although the keyword <CODE>typeswitch</CODE> is not used in XPath, it is 
  considered a reserved function name for compatibility with 
  XQuery.</P></DIV></LI></UL></DIV>
<DIV class=div2>
<H3><A id=id-precedence-order name=id-precedence-order></A>A.4 Precedence 
Order</H3>
<P>The grammar in <A 
href="REC-xpath20-20070123.htm#id-grammar"><B>A.1 
EBNF</B></A> normatively defines built-in precedence among the operators of 
XPath. These operators are summarized here to make clear the order of their 
precedence from lowest to highest. Operators that have a lower precedence number 
cannot be contained by operators with a higher precedence number. The 
associativity column indicates the order in which operators of equal precedence 
in an expression are applied.</P>
<TABLE border=1>
  <TBODY>
  <TR>
    <TH>#</TH>
    <TH>Operator</TH>
    <TH>Associativity</TH></TR>
  <TR>
    <TD>1</TD>
    <TD>, (comma)</TD>
    <TD>left-to-right</TD></TR>
  <TR>
    <TD>3</TD>
    <TD><SPAN class=xpath><SPAN class=xpath><A 
      href="REC-xpath20-20070123.htm#doc-xpath-ForExpr">for</A>,</SPAN></SPAN> 
      <A 
      href="REC-xpath20-20070123.htm#doc-xpath-QuantifiedExpr">some, 
      every</A>, <A 
      href="REC-xpath20-20070123.htm#doc-xpath-IfExpr">if</A></TD>
    <TD>left-to-right</TD></TR>
  <TR>
    <TD>4</TD>
    <TD><A 
      href="REC-xpath20-20070123.htm#doc-xpath-OrExpr">or</A></TD>
    <TD>left-to-right</TD></TR>
  <TR>
    <TD>5</TD>
    <TD><A 
      href="REC-xpath20-20070123.htm#doc-xpath-AndExpr">and</A></TD>
    <TD>left-to-right</TD></TR>
  <TR>
    <TD>6</TD>
    <TD><A 
      href="REC-xpath20-20070123.htm#doc-xpath-ValueComp">eq, 
      ne, lt, le, gt, ge</A>, <A 
      href="REC-xpath20-20070123.htm#doc-xpath-GeneralComp">=, 
      !=, &lt;, &lt;=, &gt;, &gt;=</A>, <A 
      href="REC-xpath20-20070123.htm#doc-xpath-NodeComp">is</A>, 
      <A 
      href="REC-xpath20-20070123.htm#doc-xpath-NodeComp">&lt;&lt;, 
      &gt;&gt;</A></TD>
    <TD>left-to-right</TD></TR>
  <TR>
    <TD>7</TD>
    <TD><A 
      href="REC-xpath20-20070123.htm#doc-xpath-RangeExpr">to</A></TD>
    <TD>left-to-right</TD></TR>
  <TR>
    <TD>8</TD>
    <TD><A 
      href="REC-xpath20-20070123.htm#doc-xpath-AdditiveExpr">+, 
      -</A></TD>
    <TD>left-to-right</TD></TR>
  <TR>
    <TD>9</TD>
    <TD><A 
      href="REC-xpath20-20070123.htm#doc-xpath-MultiplicativeExpr">*, 
      div, idiv, mod</A></TD>
    <TD>left-to-right</TD></TR>
  <TR>
    <TD>10</TD>
    <TD><A 
      href="REC-xpath20-20070123.htm#doc-xpath-UnionExpr">union, 
      |</A></TD>
    <TD>left-to-right</TD></TR>
  <TR>
    <TD>11</TD>
    <TD><A 
      href="REC-xpath20-20070123.htm#doc-xpath-IntersectExceptExpr">intersect, 
      except</A></TD>
    <TD>left-to-right</TD></TR>
  <TR>
    <TD>12</TD>
    <TD><A 
      href="REC-xpath20-20070123.htm#doc-xpath-InstanceofExpr">instance 
      of</A></TD>
    <TD>left-to-right</TD></TR>
  <TR>
    <TD>13</TD>
    <TD><A 
      href="REC-xpath20-20070123.htm#doc-xpath-TreatExpr">treat</A></TD>
    <TD>left-to-right</TD></TR>
  <TR>
    <TD>14</TD>
    <TD><A 
      href="REC-xpath20-20070123.htm#doc-xpath-CastableExpr">castable</A></TD>
    <TD>left-to-right</TD></TR>
  <TR>
    <TD>15</TD>
    <TD><A 
      href="REC-xpath20-20070123.htm#doc-xpath-CastExpr">cast</A></TD>
    <TD>left-to-right</TD></TR>
  <TR>
    <TD>16</TD>
    <TD><A 
      href="REC-xpath20-20070123.htm#doc-xpath-UnaryExpr">-(unary), 
      +(unary)</A></TD>
    <TD>right-to-left</TD></TR>
  <TR>
    <TD>17</TD>
    <TD><A 
      href="REC-xpath20-20070123.htm#doc-xpath-OccurrenceIndicator">?, 
      *(OccurrenceIndicator), +(OccurrenceIndicator)</A></TD>
    <TD>left-to-right</TD></TR>
  <TR>
    <TD>18</TD>
    <TD><A 
      href="REC-xpath20-20070123.htm#doc-xpath-PathExpr">/, 
      //</A></TD>
    <TD>left-to-right</TD></TR>
  <TR>
    <TD>19</TD>
    <TD><A 
      href="REC-xpath20-20070123.htm#doc-xpath-Predicate">[ 
      ]</A>, <A 
      href="REC-xpath20-20070123.htm#doc-xpath-ParenthesizedExpr">( 
      )</A>, {}</TD>
    <TD>left-to-right</TD></TR></TBODY></TABLE></DIV></DIV>
<DIV class=div1>
<H2><A id=id-type-promotion-and-operator-mapping 
name=id-type-promotion-and-operator-mapping></A>B Type Promotion and Operator 
Mapping</H2>
<DIV class=div2>
<H3><A id=promotion name=promotion></A>B.1 Type Promotion</H3>
<P>[<A id=dt-type-promotion title="type promotion" 
name=dt-type-promotion>Definition</A>: Under certain circumstances, an atomic 
value can be promoted from one type to another. <B>Type promotion</B> is used in 
evaluating function calls (see <A 
href="REC-xpath20-20070123.htm#id-function-calls"><B>3.1.5 
Function Calls</B></A>) and operators that accept numeric or string operands 
(see <A href="REC-xpath20-20070123.htm#mapping"><B>B.2 
Operator Mapping</B></A>).] The following type promotions are permitted:</P>
<OL class=enumar>
  <LI>
  <P>Numeric type promotion:</P>
  <OL class=enumla>
    <LI>
    <P>A value of type <CODE>xs:float</CODE> (or any type derived by restriction 
    from <CODE>xs:float</CODE>) can be promoted to the type 
    <CODE>xs:double</CODE>. The result is the <CODE>xs:double</CODE> value that 
    is the same as the original value.</P>
    <LI>
    <P>A value of type <CODE>xs:decimal</CODE> (or any type derived by 
    restriction from <CODE>xs:decimal</CODE>) can be promoted to either of the 
    types <CODE>xs:float</CODE> or <CODE>xs:double</CODE>. The result of this 
    promotion is created by casting the original value to the required type. 
    This kind of promotion may cause loss of precision.</P></LI></OL>
  <LI>
  <P>URI type promotion: A value of type <CODE>xs:anyURI</CODE> (or any type 
  derived by restriction from <CODE>xs:anyURI</CODE>) can be promoted to the 
  type <CODE>xs:string</CODE>. The result of this promotion is created by 
  casting the original value to the type <CODE>xs:string</CODE>.</P>
  <DIV class=note>
  <P class=prefix><B>Note:</B></P>
  <P>Since <CODE>xs:anyURI</CODE> values can be promoted to 
  <CODE>xs:string</CODE>, functions and operators that compare strings using the 
  <A title="default collation" 
  href="REC-xpath20-20070123.htm#dt-def-collation">default 
  collation</A> also compare <CODE>xs:anyURI</CODE> values using the <A 
  title="default collation" 
  href="REC-xpath20-20070123.htm#dt-def-collation">default 
  collation</A>. This ensures that orderings that include strings, 
  <CODE>xs:anyURI</CODE> values, or any combination of the two types are 
  consistent and well-defined.</P></DIV></LI></OL>
<P>Note that <A title="type promotion" 
href="REC-xpath20-20070123.htm#dt-type-promotion">type 
promotion</A> is different from <A title="subtype substitution" 
href="REC-xpath20-20070123.htm#dt-subtype-substitution">subtype 
substitution</A>. For example:</P>
<UL>
  <LI>
  <P>A function that expects a parameter <CODE>$p</CODE> of type 
  <CODE>xs:float</CODE> can be invoked with a value of type 
  <CODE>xs:decimal</CODE>. This is an example of <A title="type promotion" 
  href="REC-xpath20-20070123.htm#dt-type-promotion">type 
  promotion</A>. The value is actually converted to the expected type. Within 
  the body of the function, <CODE>$p instance of xs:decimal</CODE> returns 
  <CODE>false</CODE>.</P>
  <LI>
  <P>A function that expects a parameter <CODE>$p</CODE> of type 
  <CODE>xs:decimal</CODE> can be invoked with a value of type 
  <CODE>xs:integer</CODE>. This is an example of <A title="subtype substitution" 
  href="REC-xpath20-20070123.htm#dt-subtype-substitution">subtype 
  substitution</A>. The value retains its original type. Within the body of the 
  function, <CODE>$p instance of xs:integer</CODE> returns 
  <CODE>true</CODE>.</P></LI></UL></DIV>
<DIV class=div2>
<H3><A id=mapping name=mapping></A>B.2 Operator Mapping</H3>
<P>The operator mapping tables in this section list the combinations of types 
for which the various operators of XPath are defined. [<A 
id=dt-operator-function title="operator function" 
name=dt-operator-function>Definition</A>: For each operator and valid 
combination of operand types, the operator mapping tables specify a result type 
and an <B>operator function</B> that implements the semantics of the operator 
for the given types.] The definitions of the operator functions are given in <A 
href="REC-xpath20-20070123.htm#FunctionsAndOperators">[XQuery 
1.0 and XPath 2.0 Functions and Operators]</A>. The result of an operator may be 
the raising of an error by its operator function, as defined in <A 
href="REC-xpath20-20070123.htm#FunctionsAndOperators">[XQuery 
1.0 and XPath 2.0 Functions and Operators]</A>. In some cases, the operator 
function does not implement the full semantics of a given operator. For the 
definition of each operator (including its behavior for empty sequences or 
sequences of length greater than one), see the descriptive material in the main 
part of this document.</P>
<P>The <CODE>and</CODE> and <CODE>or</CODE> operators are defined directly in 
the main body of this document, and do not occur in the operator mapping 
tables.</P>
<P>If an operator in the operator mapping tables expects an operand of type 
<EM>ET</EM>, that operator can be applied to an operand of type <EM>AT</EM> if 
type <EM>AT</EM> can be converted to type <EM>ET</EM> by a combination of <A 
title="type promotion" 
href="REC-xpath20-20070123.htm#dt-type-promotion">type 
promotion</A> and <A title="subtype substitution" 
href="REC-xpath20-20070123.htm#dt-subtype-substitution">subtype 
substitution</A>. For example, a table entry indicates that the <CODE>gt</CODE> 
operator may be applied to two <CODE>xs:date</CODE> operands, returning 
<CODE>xs:boolean</CODE>. Therefore, the <CODE>gt</CODE> operator may also be 
applied to two (possibly different) subtypes of <CODE>xs:date</CODE>, also 
returning <CODE>xs:boolean</CODE>.</P>
<P>[<A id=dt-numeric title=numeric name=dt-numeric>Definition</A>: When 
referring to a type, the term <B>numeric</B> denotes the types 
<CODE>xs:integer</CODE>, <CODE>xs:decimal</CODE>, <CODE>xs:float</CODE>, and 
<CODE>xs:double</CODE>.] An operator whose operands and result are designated as 
<A title=numeric 
href="REC-xpath20-20070123.htm#dt-numeric">numeric</A> 
might be thought of as representing four operators, one for each of the numeric 
types. For example, the numeric <CODE>+</CODE> operator might be thought of as 
representing the following four operators:</P>
<TABLE width="80%" summary=Operators border=1>
  <TBODY>
  <TR>
    <TD align=middle>Operator</TD>
    <TD align=middle>First operand type</TD>
    <TD align=middle>Second operand type</TD>
    <TD align=middle>Result type</TD></TR>
  <TR>
    <TD align=middle><CODE>+</CODE></TD>
    <TD align=middle><CODE>xs:integer</CODE></TD>
    <TD align=middle><CODE>xs:integer</CODE></TD>
    <TD align=middle><CODE>xs:integer</CODE></TD></TR>
  <TR>
    <TD align=middle><CODE>+</CODE></TD>
    <TD align=middle><CODE>xs:decimal</CODE></TD>
    <TD align=middle><CODE>xs:decimal</CODE></TD>
    <TD align=middle><CODE>xs:decimal</CODE></TD></TR>
  <TR>
    <TD align=middle><CODE>+</CODE></TD>
    <TD align=middle><CODE>xs:float</CODE></TD>
    <TD align=middle><CODE>xs:float</CODE></TD>
    <TD align=middle><CODE>xs:float</CODE></TD></TR>
  <TR>
    <TD align=middle><CODE>+</CODE></TD>
    <TD align=middle><CODE>xs:double</CODE></TD>
    <TD align=middle><CODE>xs:double</CODE></TD>
    <TD align=middle><CODE>xs:double</CODE></TD></TR></TBODY></TABLE>
<P>A numeric operator may be validly applied to an operand of type <EM>AT</EM> 
if type <EM>AT</EM> can be converted to any of the four numeric types by a 
combination of <A title="type promotion" 
href="REC-xpath20-20070123.htm#dt-type-promotion">type 
promotion</A> and <A title="subtype substitution" 
href="REC-xpath20-20070123.htm#dt-subtype-substitution">subtype 
substitution</A>. If the result type of an operator is listed as numeric, it 
means "the first type in the ordered list <CODE>(xs:integer, xs:decimal, 
xs:float, xs:double)</CODE> into which all operands can be converted by <A 
title="subtype substitution" 
href="REC-xpath20-20070123.htm#dt-subtype-substitution">subtype 
substitution</A> and <A title="type promotion" 
href="REC-xpath20-20070123.htm#dt-type-promotion">type 
promotion</A>." As an example, suppose that the type <CODE>hatsize</CODE> is 
derived from <CODE>xs:integer</CODE> and the type <CODE>shoesize</CODE> is 
derived from <CODE>xs:float</CODE>. Then if the <CODE>+</CODE> operator is 
invoked with operands of type <CODE>hatsize</CODE> and <CODE>shoesize</CODE>, it 
returns a result of type <CODE>xs:float</CODE>. Similarly, if <CODE>+</CODE> is 
invoked with two operands of type <CODE>hatsize</CODE> it returns a result of 
type <CODE>xs:integer</CODE>.</P>
<P>[<A id=dt-gregorian title=Gregorian name=dt-gregorian>Definition</A>: In the 
operator mapping tables, the term <B>Gregorian</B> refers to the types 
<CODE>xs:gYearMonth</CODE>, <CODE>xs:gYear</CODE>, <CODE>xs:gMonthDay</CODE>, 
<CODE>xs:gDay</CODE>, and <CODE>xs:gMonth</CODE>.] For binary operators that 
accept two Gregorian-type operands, both operands must have the same type (for 
example, if one operand is of type <CODE>xs:gDay</CODE>, the other operand must 
be of type <CODE>xs:gDay</CODE>.)</P>
<DIV class=small>
<TABLE class=small summary="Binary operators" border=1>
  <CAPTION>Binary Operators</CAPTION>
  <TBODY>
  <TR>
    <TH>Operator</TH>
    <TH>Type(A)</TH>
    <TH>Type(B)</TH>
    <TH>Function</TH>
    <TH>Result type</TH></TR>
  <TR>
    <TD>A + B</TD>
    <TD>numeric</TD>
    <TD>numeric</TD>
    <TD>op:numeric-add(A, B)</TD>
    <TD>numeric</TD></TR>
  <TR>
    <TD>A + B</TD>
    <TD>xs:date</TD>
    <TD>xs:yearMonthDuration</TD>
    <TD>op:add-yearMonthDuration-to-date(A, B)</TD>
    <TD>xs:date</TD></TR>
  <TR>
    <TD>A + B</TD>
    <TD>xs:yearMonthDuration</TD>
    <TD>xs:date</TD>
    <TD>op:add-yearMonthDuration-to-date(B, A)</TD>
    <TD>xs:date</TD></TR>
  <TR>
    <TD>A + B</TD>
    <TD>xs:date</TD>
    <TD>xs:dayTimeDuration</TD>
    <TD>op:add-dayTimeDuration-to-date(A, B)</TD>
    <TD>xs:date</TD></TR>
  <TR>
    <TD>A + B</TD>
    <TD>xs:dayTimeDuration</TD>
    <TD>xs:date</TD>
    <TD>op:add-dayTimeDuration-to-date(B, A)</TD>
    <TD>xs:date</TD></TR>
  <TR>
    <TD>A + B</TD>
    <TD>xs:time</TD>
    <TD>xs:dayTimeDuration</TD>
    <TD>op:add-dayTimeDuration-to-time(A, B)</TD>
    <TD>xs:time</TD></TR>
  <TR>
    <TD>A + B</TD>
    <TD>xs:dayTimeDuration</TD>
    <TD>xs:time</TD>
    <TD>op:add-dayTimeDuration-to-time(B, A)</TD>
    <TD>xs:time</TD></TR>
  <TR>
    <TD>A + B</TD>
    <TD>xs:dateTime</TD>
    <TD>xs:yearMonthDuration</TD>
    <TD>op:add-yearMonthDuration-to-dateTime(A, B)</TD>
    <TD>xs:dateTime</TD></TR>
  <TR>
    <TD>A + B</TD>
    <TD>xs:yearMonthDuration</TD>
    <TD>xs:dateTime</TD>
    <TD>op:add-yearMonthDuration-to-dateTime(B, A)</TD>
    <TD>xs:dateTime</TD></TR>
  <TR>
    <TD>A + B</TD>
    <TD>xs:dateTime</TD>
    <TD>xs:dayTimeDuration</TD>
    <TD>op:add-dayTimeDuration-to-dateTime(A, B)</TD>
    <TD>xs:dateTime</TD></TR>
  <TR>
    <TD>A + B</TD>
    <TD>xs:dayTimeDuration</TD>
    <TD>xs:dateTime</TD>
    <TD>op:add-dayTimeDuration-to-dateTime(B, A)</TD>
    <TD>xs:dateTime</TD></TR>
  <TR>
    <TD>A + B</TD>
    <TD>xs:yearMonthDuration</TD>
    <TD>xs:yearMonthDuration</TD>
    <TD>op:add-yearMonthDurations(A, B)</TD>
    <TD>xs:yearMonthDuration</TD></TR>
  <TR>
    <TD>A + B</TD>
    <TD>xs:dayTimeDuration</TD>
    <TD>xs:dayTimeDuration</TD>
    <TD>op:add-dayTimeDurations(A, B)</TD>
    <TD>xs:dayTimeDuration</TD></TR>
  <TR>
    <TD>A - B</TD>
    <TD>numeric</TD>
    <TD>numeric</TD>
    <TD>op:numeric-subtract(A, B)</TD>
    <TD>numeric</TD></TR>
  <TR>
    <TD>A - B</TD>
    <TD>xs:date</TD>
    <TD>xs:date</TD>
    <TD>op:subtract-dates(A, B)</TD>
    <TD>xs:dayTimeDuration</TD></TR>
  <TR>
    <TD>A - B</TD>
    <TD>xs:date</TD>
    <TD>xs:yearMonthDuration</TD>
    <TD>op:subtract-yearMonthDuration-from-date(A, B)</TD>
    <TD>xs:date</TD></TR>
  <TR>
    <TD>A - B</TD>
    <TD>xs:date</TD>
    <TD>xs:dayTimeDuration</TD>
    <TD>op:subtract-dayTimeDuration-from-date(A, B)</TD>
    <TD>xs:date</TD></TR>
  <TR>
    <TD>A - B</TD>
    <TD>xs:time</TD>
    <TD>xs:time</TD>
    <TD>op:subtract-times(A, B)</TD>
    <TD>xs:dayTimeDuration</TD></TR>
  <TR>
    <TD>A - B</TD>
    <TD>xs:time</TD>
    <TD>xs:dayTimeDuration</TD>
    <TD>op:subtract-dayTimeDuration-from-time(A, B)</TD>
    <TD>xs:time</TD></TR>
  <TR>
    <TD>A - B</TD>
    <TD>xs:dateTime</TD>
    <TD>xs:dateTime</TD>
    <TD>op:subtract-dateTimes(A, B)</TD>
    <TD>xs:dayTimeDuration</TD></TR>
  <TR>
    <TD>A - B</TD>
    <TD>xs:dateTime</TD>
    <TD>xs:yearMonthDuration</TD>
    <TD>op:subtract-yearMonthDuration-from-dateTime(A, B)</TD>
    <TD>xs:dateTime</TD></TR>
  <TR>
    <TD>A - B</TD>
    <TD>xs:dateTime</TD>
    <TD>xs:dayTimeDuration</TD>
    <TD>op:subtract-dayTimeDuration-from-dateTime(A, B)</TD>
    <TD>xs:dateTime</TD></TR>
  <TR>
    <TD>A - B</TD>
    <TD>xs:yearMonthDuration</TD>
    <TD>xs:yearMonthDuration</TD>
    <TD>op:subtract-yearMonthDurations(A, B)</TD>
    <TD>xs:yearMonthDuration</TD></TR>
  <TR>
    <TD>A - B</TD>
    <TD>xs:dayTimeDuration</TD>
    <TD>xs:dayTimeDuration</TD>
    <TD>op:subtract-dayTimeDurations(A, B)</TD>
    <TD>xs:dayTimeDuration</TD></TR>
  <TR>
    <TD>A * B</TD>
    <TD>numeric</TD>
    <TD>numeric</TD>
    <TD>op:numeric-multiply(A, B)</TD>
    <TD>numeric</TD></TR>
  <TR>
    <TD>A * B</TD>
    <TD>xs:yearMonthDuration</TD>
    <TD>numeric</TD>
    <TD>op:multiply-yearMonthDuration(A, B)</TD>
    <TD>xs:yearMonthDuration</TD></TR>
  <TR>
    <TD>A * B</TD>
    <TD>numeric</TD>
    <TD>xs:yearMonthDuration</TD>
    <TD>op:multiply-yearMonthDuration(B, A)</TD>
    <TD>xs:yearMonthDuration</TD></TR>
  <TR>
    <TD>A * B</TD>
    <TD>xs:dayTimeDuration</TD>
    <TD>numeric</TD>
    <TD>op:multiply-dayTimeDuration(A, B)</TD>
    <TD>xs:dayTimeDuration</TD></TR>
  <TR>
    <TD>A * B</TD>
    <TD>numeric</TD>
    <TD>xs:dayTimeDuration</TD>
    <TD>op:multiply-dayTimeDuration(B, A)</TD>
    <TD>xs:dayTimeDuration</TD></TR>
  <TR>
    <TD>A idiv B</TD>
    <TD>numeric</TD>
    <TD>numeric</TD>
    <TD>op:numeric-integer-divide(A, B)</TD>
    <TD>xs:integer</TD></TR>
  <TR>
    <TD>A div B</TD>
    <TD>numeric</TD>
    <TD>numeric</TD>
    <TD>op:numeric-divide(A, B)</TD>
    <TD>numeric; but xs:decimal if both operands are xs:integer</TD></TR>
  <TR>
    <TD>A div B</TD>
    <TD>xs:yearMonthDuration</TD>
    <TD>numeric</TD>
    <TD>op:divide-yearMonthDuration(A, B)</TD>
    <TD>xs:yearMonthDuration</TD></TR>
  <TR>
    <TD>A div B</TD>
    <TD>xs:dayTimeDuration</TD>
    <TD>numeric</TD>
    <TD>op:divide-dayTimeDuration(A, B)</TD>
    <TD>xs:dayTimeDuration</TD></TR>
  <TR>
    <TD>A div B</TD>
    <TD>xs:yearMonthDuration</TD>
    <TD>xs:yearMonthDuration</TD>
    <TD>op:divide-yearMonthDuration-by-yearMonthDuration (A, B)</TD>
    <TD>xs:decimal</TD></TR>
  <TR>
    <TD>A div B</TD>
    <TD>xs:dayTimeDuration</TD>
    <TD>xs:dayTimeDuration</TD>
    <TD>op:divide-dayTimeDuration-by-dayTimeDuration (A, B)</TD>
    <TD>xs:decimal</TD></TR>
  <TR>
    <TD>A mod B</TD>
    <TD>numeric</TD>
    <TD>numeric</TD>
    <TD>op:numeric-mod(A, B)</TD>
    <TD>numeric</TD></TR>
  <TR>
    <TD>A eq B</TD>
    <TD>numeric</TD>
    <TD>numeric</TD>
    <TD>op:numeric-equal(A, B)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A eq B</TD>
    <TD>xs:boolean</TD>
    <TD>xs:boolean</TD>
    <TD>op:boolean-equal(A, B)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A eq B</TD>
    <TD>xs:string</TD>
    <TD>xs:string</TD>
    <TD>op:numeric-equal(fn:compare(A, B), 0)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A eq B</TD>
    <TD>xs:date</TD>
    <TD>xs:date</TD>
    <TD>op:date-equal(A, B)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A eq B</TD>
    <TD>xs:time</TD>
    <TD>xs:time</TD>
    <TD>op:time-equal(A, B)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A eq B</TD>
    <TD>xs:dateTime</TD>
    <TD>xs:dateTime</TD>
    <TD>op:dateTime-equal(A, B)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A eq B</TD>
    <TD>xs:duration</TD>
    <TD>xs:duration</TD>
    <TD>op:duration-equal(A, B)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A eq B</TD>
    <TD>Gregorian</TD>
    <TD>Gregorian</TD>
    <TD>op:gYear-equal(A, B) etc.</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A eq B</TD>
    <TD>xs:hexBinary</TD>
    <TD>xs:hexBinary</TD>
    <TD>op:hex-binary-equal(A, B)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A eq B</TD>
    <TD>xs:base64Binary</TD>
    <TD>xs:base64Binary</TD>
    <TD>op:base64-binary-equal(A, B)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A eq B</TD>
    <TD>xs:anyURI</TD>
    <TD>xs:anyURI</TD>
    <TD>op:numeric-equal(fn:compare(A, B), 0)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A eq B</TD>
    <TD>xs:QName</TD>
    <TD>xs:QName</TD>
    <TD>op:QName-equal(A, B)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A eq B</TD>
    <TD>xs:NOTATION</TD>
    <TD>xs:NOTATION</TD>
    <TD>op:NOTATION-equal(A, B)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A ne B</TD>
    <TD>numeric</TD>
    <TD>numeric</TD>
    <TD>fn:not(op:numeric-equal(A, B))</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A ne B</TD>
    <TD>xs:boolean</TD>
    <TD>xs:boolean</TD>
    <TD>fn:not(op:boolean-equal(A, B))</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A ne B</TD>
    <TD>xs:string</TD>
    <TD>xs:string</TD>
    <TD>fn:not(op:numeric-equal(fn:compare(A, B), 0))</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A ne B</TD>
    <TD>xs:date</TD>
    <TD>xs:date</TD>
    <TD>fn:not(op:date-equal(A, B))</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A ne B</TD>
    <TD>xs:time</TD>
    <TD>xs:time</TD>
    <TD>fn:not(op:time-equal(A, B))</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A ne B</TD>
    <TD>xs:dateTime</TD>
    <TD>xs:dateTime</TD>
    <TD>fn:not(op:dateTime-equal(A, B))</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A ne B</TD>
    <TD>xs:duration</TD>
    <TD>xs:duration</TD>
    <TD>fn:not(op:duration-equal(A, B))</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A ne B</TD>
    <TD>Gregorian</TD>
    <TD>Gregorian</TD>
    <TD>fn:not(op:gYear-equal(A, B)) etc.</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A ne B</TD>
    <TD>xs:hexBinary</TD>
    <TD>xs:hexBinary</TD>
    <TD>fn:not(op:hex-binary-equal(A, B))</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A ne B</TD>
    <TD>xs:base64Binary</TD>
    <TD>xs:base64Binary</TD>
    <TD>fn:not(op:base64-binary-equal(A, B))</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A ne B</TD>
    <TD>xs:anyURI</TD>
    <TD>xs:anyURI</TD>
    <TD>fn:not(op:numeric-equal(fn:compare(A, B), 0))</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A ne B</TD>
    <TD>xs:QName</TD>
    <TD>xs:QName</TD>
    <TD>fn:not(op:QName-equal(A, B))</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A ne B</TD>
    <TD>xs:NOTATION</TD>
    <TD>xs:NOTATION</TD>
    <TD>fn:not(op:NOTATION-equal(A, B))</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A gt B</TD>
    <TD>numeric</TD>
    <TD>numeric</TD>
    <TD>op:numeric-greater-than(A, B)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A gt B</TD>
    <TD>xs:boolean</TD>
    <TD>xs:boolean</TD>
    <TD>op:boolean-greater-than(A, B)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A gt B</TD>
    <TD>xs:string</TD>
    <TD>xs:string</TD>
    <TD>op:numeric-greater-than(fn:compare(A, B), 0)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A gt B</TD>
    <TD>xs:date</TD>
    <TD>xs:date</TD>
    <TD>op:date-greater-than(A, B)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A gt B</TD>
    <TD>xs:time</TD>
    <TD>xs:time</TD>
    <TD>op:time-greater-than(A, B)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A gt B</TD>
    <TD>xs:dateTime</TD>
    <TD>xs:dateTime</TD>
    <TD>op:dateTime-greater-than(A, B)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A gt B</TD>
    <TD>xs:yearMonthDuration</TD>
    <TD>xs:yearMonthDuration</TD>
    <TD>op:yearMonthDuration-greater-than(A, B)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A gt B</TD>
    <TD>xs:dayTimeDuration</TD>
    <TD>xs:dayTimeDuration</TD>
    <TD>op:dayTimeDuration-greater-than(A, B)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A gt B</TD>
    <TD>xs:anyURI</TD>
    <TD>xs:anyURI</TD>
    <TD>op:numeric-greater-than(fn:compare(A, B), 0)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A lt B</TD>
    <TD>numeric</TD>
    <TD>numeric</TD>
    <TD>op:numeric-less-than(A, B)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A lt B</TD>
    <TD>xs:boolean</TD>
    <TD>xs:boolean</TD>
    <TD>op:boolean-less-than(A, B)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A lt B</TD>
    <TD>xs:string</TD>
    <TD>xs:string</TD>
    <TD>op:numeric-less-than(fn:compare(A, B), 0)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A lt B</TD>
    <TD>xs:date</TD>
    <TD>xs:date</TD>
    <TD>op:date-less-than(A, B)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A lt B</TD>
    <TD>xs:time</TD>
    <TD>xs:time</TD>
    <TD>op:time-less-than(A, B)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A lt B</TD>
    <TD>xs:dateTime</TD>
    <TD>xs:dateTime</TD>
    <TD>op:dateTime-less-than(A, B)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A lt B</TD>
    <TD>xs:yearMonthDuration</TD>
    <TD>xs:yearMonthDuration</TD>
    <TD>op:yearMonthDuration-less-than(A, B)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A lt B</TD>
    <TD>xs:dayTimeDuration</TD>
    <TD>xs:dayTimeDuration</TD>
    <TD>op:dayTimeDuration-less-than(A, B)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A lt B</TD>
    <TD>xs:anyURI</TD>
    <TD>xs:anyURI</TD>
    <TD>op:numeric-less-than(fn:compare(A, B), 0)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A ge B</TD>
    <TD>numeric</TD>
    <TD>numeric</TD>
    <TD>op:numeric-greater-than(A, B) or op:numeric-equal(A, B)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A ge B</TD>
    <TD>xs:boolean</TD>
    <TD>xs:boolean</TD>
    <TD>fn:not(op:boolean-less-than(A, B))</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A ge B</TD>
    <TD>xs:string</TD>
    <TD>xs:string</TD>
    <TD>op:numeric-greater-than(fn:compare(A, B), -1)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A ge B</TD>
    <TD>xs:date</TD>
    <TD>xs:date</TD>
    <TD>fn:not(op:date-less-than(A, B))</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A ge B</TD>
    <TD>xs:time</TD>
    <TD>xs:time</TD>
    <TD>fn:not(op:time-less-than(A, B))</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A ge B</TD>
    <TD>xs:dateTime</TD>
    <TD>xs:dateTime</TD>
    <TD>fn:not(op:dateTime-less-than(A, B))</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A ge B</TD>
    <TD>xs:yearMonthDuration</TD>
    <TD>xs:yearMonthDuration</TD>
    <TD>fn:not(op:yearMonthDuration-less-than(A, B))</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A ge B</TD>
    <TD>xs:dayTimeDuration</TD>
    <TD>xs:dayTimeDuration</TD>
    <TD>fn:not(op:dayTimeDuration-less-than(A, B))</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A ge B</TD>
    <TD>xs:anyURI</TD>
    <TD>xs:anyURI</TD>
    <TD>op:numeric-greater-than(fn:compare(A, B), -1)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A le B</TD>
    <TD>numeric</TD>
    <TD>numeric</TD>
    <TD>op:numeric-less-than(A, B) or op:numeric-equal(A, B)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A le B</TD>
    <TD>xs:boolean</TD>
    <TD>xs:boolean</TD>
    <TD>fn:not(op:boolean-greater-than(A, B))</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A le B</TD>
    <TD>xs:string</TD>
    <TD>xs:string</TD>
    <TD>op:numeric-less-than(fn:compare(A, B), 1)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A le B</TD>
    <TD>xs:date</TD>
    <TD>xs:date</TD>
    <TD>fn:not(op:date-greater-than(A, B))</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A le B</TD>
    <TD>xs:time</TD>
    <TD>xs:time</TD>
    <TD>fn:not(op:time-greater-than(A, B))</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A le B</TD>
    <TD>xs:dateTime</TD>
    <TD>xs:dateTime</TD>
    <TD>fn:not(op:dateTime-greater-than(A, B))</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A le B</TD>
    <TD>xs:yearMonthDuration</TD>
    <TD>xs:yearMonthDuration</TD>
    <TD>fn:not(op:yearMonthDuration-greater-than(A, B))</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A le B</TD>
    <TD>xs:dayTimeDuration</TD>
    <TD>xs:dayTimeDuration</TD>
    <TD>fn:not(op:dayTimeDuration-greater-than(A, B))</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A le B</TD>
    <TD>xs:anyURI</TD>
    <TD>xs:anyURI</TD>
    <TD>op:numeric-less-than(fn:compare(A, B), 1)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A is B</TD>
    <TD>node()</TD>
    <TD>node()</TD>
    <TD>op:is-same-node(A, B)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A &lt;&lt; B</TD>
    <TD>node()</TD>
    <TD>node()</TD>
    <TD>op:node-before(A, B)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A &gt;&gt; B</TD>
    <TD>node()</TD>
    <TD>node()</TD>
    <TD>op:node-after(A, B)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A union B</TD>
    <TD>node()*</TD>
    <TD>node()*</TD>
    <TD>op:union(A, B)</TD>
    <TD>node()*</TD></TR>
  <TR>
    <TD>A | B</TD>
    <TD>node()*</TD>
    <TD>node()*</TD>
    <TD>op:union(A, B)</TD>
    <TD>node()*</TD></TR>
  <TR>
    <TD>A intersect B</TD>
    <TD>node()*</TD>
    <TD>node()*</TD>
    <TD>op:intersect(A, B)</TD>
    <TD>node()*</TD></TR>
  <TR>
    <TD>A except B</TD>
    <TD>node()*</TD>
    <TD>node()*</TD>
    <TD>op:except(A, B)</TD>
    <TD>node()*</TD></TR>
  <TR>
    <TD>A to B</TD>
    <TD>xs:integer</TD>
    <TD>xs:integer</TD>
    <TD>op:to(A, B)</TD>
    <TD>xs:integer*</TD></TR>
  <TR>
    <TD>A , B</TD>
    <TD>item()*</TD>
    <TD>item()*</TD>
    <TD>op:concatenate(A, B)</TD>
    <TD>item()*</TD></TR></TBODY></TABLE></DIV>
<DIV class=small>
<TABLE class=small summary="Unary operators" border=1>
  <CAPTION>Unary Operators</CAPTION>
  <TBODY>
  <TR>
    <TH>Operator</TH>
    <TH>Operand type</TH>
    <TH>Function</TH>
    <TH>Result type</TH></TR>
  <TR>
    <TD>+ A</TD>
    <TD>numeric</TD>
    <TD>op:numeric-unary-plus(A)</TD>
    <TD>numeric</TD></TR>
  <TR>
    <TD>- A</TD>
    <TD>numeric</TD>
    <TD>op:numeric-unary-minus(A)</TD>
    <TD>numeric</TD></TR></TBODY></TABLE></DIV></DIV></DIV>
<DIV class=xpath>
<DIV class=div1>
<H2><A id=id-xp-context-components name=id-xp-context-components></A>C Context 
Components</H2>
<P>The tables in this section describe the scope (range of applicability) of the 
various components in the static context and dynamic context.</P>
<DIV class=div2>
<H3><A id=id-xp-static-context-components 
name=id-xp-static-context-components></A>C.1 Static Context Components</H3>
<P>The following table describes the components of the <B>static context</B>. 
For each component, "global" indicates that the value of the component applies 
throughout an XPath expression, whereas "lexical" indicates that the value of 
the component applies only within the subexpression in which it is defined.</P>
<DIV class=small>
<TABLE class=small width="60%" summary="Static Context" border=1>
  <CAPTION>Static Context Components</CAPTION>
  <TBODY>
  <TR>
    <TH>Component</TH>
    <TH>Scope</TH></TR>
  <TR>
    <TD>XPath 1.0 Compatibility Mode</TD>
    <TD>global</TD></TR>
  <TR>
    <TD>Statically known namespaces</TD>
    <TD>global</TD></TR>
  <TR>
    <TD>Default element/type namespace</TD>
    <TD>global</TD></TR>
  <TR>
    <TD>Default function namespace</TD>
    <TD>global</TD></TR>
  <TR>
    <TD>In-scope schema types</TD>
    <TD>global</TD></TR>
  <TR>
    <TD>In-scope element declarations</TD>
    <TD>global</TD></TR>
  <TR>
    <TD>In-scope attribute declarations</TD>
    <TD>global</TD></TR>
  <TR>
    <TD>In-scope variables</TD>
    <TD>lexical; for-expressions and quantified expressions can bind new 
      variables</TD></TR>
  <TR>
    <TD>Context item static type</TD>
    <TD>lexical</TD></TR>
  <TR>
    <TD>Function signatures</TD>
    <TD>global</TD></TR>
  <TR>
    <TD>Statically known collations</TD>
    <TD>global</TD></TR>
  <TR>
    <TD>Default collation</TD>
    <TD>global</TD></TR>
  <TR>
    <TD>Base URI</TD>
    <TD>global</TD></TR>
  <TR>
    <TD>Statically known documents</TD>
    <TD>global</TD></TR>
  <TR>
    <TD>Statically known collections</TD>
    <TD>global</TD></TR>
  <TR>
    <TD>Statically known default collection type</TD>
    <TD>global</TD></TR></TBODY></TABLE></DIV></DIV>
<DIV class=div2>
<H3><A id=id-xp-evaluation-context-components 
name=id-xp-evaluation-context-components></A>C.2 Dynamic Context Components</H3>
<P>The following table describes how values are assigned to the various 
components of the <B>dynamic context</B>. All these components are initialized 
by mechanisms defined by the host language. For each component, "global" 
indicates that the value of the component remains constant throughout evaluation 
of the XPath expression, whereas "dynamic" indicates that the value of the 
component can be modified by the evaluation of subexpressions.</P>
<DIV class=small>
<TABLE class=small width="60%" summary="Static Context" border=1>
  <CAPTION>Dynamic Context Components</CAPTION>
  <TBODY>
  <TR>
    <TH>Component</TH>
    <TH>Scope</TH></TR>
  <TR>
    <TD>Context item</TD>
    <TD>dynamic; changes during evaluation of path expressions and 
    predicates</TD></TR>
  <TR>
    <TD>Context position</TD>
    <TD>dynamic; changes during evaluation of path expressions and 
    predicates</TD></TR>
  <TR>
    <TD>Context size</TD>
    <TD>dynamic; changes during evaluation of path expressions and 
    predicates</TD></TR>
  <TR>
    <TD>Variable values</TD>
    <TD>dynamic; for-expressions and quantified expressions can bind new 
      variables</TD></TR>
  <TR>
    <TD>Current date and time</TD>
    <TD>global; must be initialized by implementation</TD></TR>
  <TR>
    <TD>Implicit timezone</TD>
    <TD>global; must be initialized by implementation</TD></TR>
  <TR>
    <TD>Available documents</TD>
    <TD>global; must be initialized by implementation</TD></TR>
  <TR>
    <TD>Available collections</TD>
    <TD>global; must be initialized by implementation</TD></TR>
  <TR>
    <TD>Default collection</TD>
    <TD>global; overwriteable by 
implementation</TD></TR></TBODY></TABLE></DIV></DIV></DIV></DIV>
<DIV class=div1>
<H2><A id=id-impl-defined-items name=id-impl-defined-items></A>D 
Implementation-Defined Items</H2>
<P>The following items in this specification are <A 
title="implementation defined" 
href="REC-xpath20-20070123.htm#dt-implementation-defined">implementation-defined</A>:</P>
<OL class=enumar>
  <LI>
  <P>The version of Unicode that is used to construct expressions.</P>
  <LI>
  <P>The <A title="statically known collations" 
  href="REC-xpath20-20070123.htm#dt-static-collations">statically-known 
  collations</A>.</P>
  <LI>
  <P>The <A title="implicit timezone" 
  href="REC-xpath20-20070123.htm#dt-timezone">implicit 
  timezone</A>.</P>
  <LI>
  <P>The circumstances in which <A title=warning 
  href="REC-xpath20-20070123.htm#dt-warning">warnings</A> 
  are raised, and the ways in which warnings are handled.</P>
  <LI>
  <P>The method by which errors are reported to the external processing 
  environment.</P>
  <LI>
  <P>Whether the implementation is based on the rules of <A 
  href="REC-xpath20-20070123.htm#XML">[XML 1.0]</A> and 
  <A href="REC-xpath20-20070123.htm#XMLNAMES">[XML 
  Names]</A> or the rules of <A 
  href="REC-xpath20-20070123.htm#XML1.1">[XML 1.1]</A> 
  and <A href="REC-xpath20-20070123.htm#XMLNAMES11">[XML 
  Names 1.1]</A>. One of these sets of rules must be applied consistently by all 
  aspects of the implementation.</P>
  <LI class=xpath>
  <P>Whether the implementation supports the namespace axis.</P>
  <LI class=xpath>
  <P>Any <A title="static typing extension" 
  href="REC-xpath20-20070123.htm#dt-xpath-static-typing-extension">static 
  typing extensions</A> supported by the implementation, if the <A 
  title="static typing feature" 
  href="REC-xpath20-20070123.htm#dt-xpath-static-typing-feature">Static 
  Typing Feature</A> is supported.</P></LI></OL>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>Additional <A title="implementation defined" 
href="REC-xpath20-20070123.htm#dt-implementation-defined">implementation-defined</A> 
items are listed in <A 
href="REC-xpath20-20070123.htm#datamodel">[XQuery/XPath 
Data Model (XDM)]</A> and <A 
href="REC-xpath20-20070123.htm#FunctionsAndOperators">[XQuery 
1.0 and XPath 2.0 Functions and Operators]</A>.</P></DIV></DIV>
<DIV class=div1>
<H2><A id=id-references name=id-references></A>E References</H2>
<DIV class=div2>
<H3><A id=id-normative-references name=id-normative-references></A>E.1 Normative 
References</H3>
<DL>
  <DT class=label><SPAN><A id=RFC2119 name=RFC2119></A>RFC 2119</SPAN> 
  <DD>
  <DIV>S. Bradner. <EM>Key Words for use in RFCs to Indicate Requirement 
  Levels.</EM> IETF RFC 2119. See <A 
  href="http://rfc.net/rfc2119.html">http://rfc.net/rfc2119.html</A>.</DIV>
  <DT class=label><SPAN><A id=RFC2396 name=RFC2396></A>RFC2396</SPAN> 
  <DD>
  <DIV>T. Berners-Lee, R. Fielding, and L. Masinter. <EM>Uniform Resource 
  Identifiers (URI): Generic Syntax</EM>. IETF RFC 2396. See <A 
  href="http://www.ietf.org/rfc/rfc2396.txt">http://www.ietf.org/rfc/rfc2396.txt</A>.</DIV>
  <DT class=label><SPAN><A id=RFC3986 name=RFC3986></A>RFC3986</SPAN> 
  <DD>
  <DIV>T. Berners-Lee, R. Fielding, and L. Masinter. <EM>Uniform Resource 
  Identifiers (URI): Generic Syntax</EM>. IETF RFC 3986. See <A 
  href="http://www.ietf.org/rfc/rfc3986.txt">http://www.ietf.org/rfc/rfc3986.txt</A>.</DIV>
  <DT class=label><SPAN><A id=RFC3987 name=RFC3987></A>RFC3987</SPAN> 
  <DD>
  <DIV>M. Duerst and M. Suignard. <EM>Internationalized Resource Identifiers 
  (IRIs)</EM>. IETF RFC 3987. See <A 
  href="http://www.ietf.org/rfc/rfc3987.txt">http://www.ietf.org/rfc/rfc3987.txt</A>.</DIV>
  <DT class=label><SPAN><A id=ISO10646 name=ISO10646></A>ISO/IEC 10646</SPAN> 
  <DD>
  <DIV>ISO (International Organization for Standardization). <EM>ISO/IEC 
  10646:2003. Information technology—Universal Multiple-Octet Coded Character 
  Set (UCS)</EM>, as, from time to time, amended, replaced by a new edition, or 
  expanded by the addition of new parts. [Geneva]: International Organization 
  for Standardization. (See <A 
  href="http://www.iso.org/">http://www.iso.org/</A> for the latest 
  version.)</DIV>
  <DT class=label><SPAN><A id=Unicode name=Unicode></A>Unicode</SPAN> 
  <DD>
  <DIV>The Unicode Consortium. <EM>The Unicode Standard</EM> Reading, Mass.: 
  Addison-Wesley, 2003, as updated from time to time by the publication of new 
  versions. See <A 
  href="http://www.unicode.org/unicode/standard/versions">http://www.unicode.org/unicode/standard/versions</A> 
  for the latest version and additional information on versions of the standard 
  and of the Unicode Character Database. The version of Unicode to be used is <A 
  title="implementation defined" 
  href="REC-xpath20-20070123.htm#dt-implementation-defined">implementation-defined</A>, 
  but implementations are recommended to use the latest Unicode version.</DIV>
  <DT class=label><SPAN><A id=XML name=XML></A>XML 1.0</SPAN> 
  <DD>
  <DIV>World Wide Web Consortium. <EM>Extensible Markup Language (XML) 1.0. 
  (Third Edition)</EM> W3C Recommendation. See <A 
  href="http://www.w3.org/TR/REC-xml">http://www.w3.org/TR/REC-xml</A></DIV>
  <DT class=label><SPAN><A id=XML1.1 name=XML1.1></A>XML 1.1</SPAN> 
  <DD>
  <DIV>World Wide Web Consortium. <EM>Extensible Markup Language (XML) 1.1.</EM> 
  W3C Recommendation. See <A 
  href="http://www.w3.org/TR/xml11/">http://www.w3.org/TR/xml11/</A></DIV>
  <DT class=label><SPAN><A id=XMLBASE name=XMLBASE></A>XML Base</SPAN> 
  <DD>
  <DIV>World Wide Web Consortium. <EM>XML Base.</EM> W3C Recommendation. See <A 
  href="http://www.w3.org/TR/xmlbase/">http://www.w3.org/TR/xmlbase/</A></DIV>
  <DT class=label><SPAN><A id=XMLNAMES name=XMLNAMES></A>XML Names</SPAN> 
  <DD>
  <DIV>World Wide Web Consortium. <EM>Namespaces in XML.</EM> W3C 
  Recommendation. See <A 
  href="http://www.w3.org/TR/REC-xml-names/">http://www.w3.org/TR/REC-xml-names/</A></DIV>
  <DT class=label><SPAN><A id=XMLNAMES11 name=XMLNAMES11></A>XML Names 
  1.1</SPAN> 
  <DD>
  <DIV>World Wide Web Consortium. <EM>Namespaces in XML 1.1.</EM> W3C 
  Recommendation. See <A 
  href="http://www.w3.org/TR/xml-names11/">http://www.w3.org/TR/xml-names11/</A></DIV>
  <DT class=label><SPAN><A id=XMLID name=XMLID></A>XML ID</SPAN> 
  <DD>
  <DIV>World Wide Web Consortium. <EM>xml:id Version 1.0.</EM> W3C 
  Recommendation. See <A 
  href="http://www.w3.org/TR/xml-id/">http://www.w3.org/TR/xml-id/</A></DIV>
  <DT class=label><SPAN><A id=XMLSchema name=XMLSchema></A>XML Schema</SPAN> 
  <DD>
  <DIV>World Wide Web Consortium. <EM>XML Schema, Parts 0, 1, and 2 (Second 
  Edition)</EM>. W3C Recommendation, 28 October 2004. See <A 
  href="http://www.w3.org/TR/xmlschema-0/">http://www.w3.org/TR/xmlschema-0/</A>, 
  <A 
  href="http://www.w3.org/TR/xmlschema-1/">http://www.w3.org/TR/xmlschema-1/</A>, 
  and <A 
  href="http://www.w3.org/TR/xmlschema-2/">http://www.w3.org/TR/xmlschema-2/</A>.</DIV>
  <DT class=label><SPAN><A id=datamodel name=datamodel></A>XQuery/XPath Data 
  Model (XDM)</SPAN> 
  <DD>
  <DIV>World Wide Web Consortium. <EM>XQuery 1.0 and XPath 2.0 Data Model 
  (XDM)</EM>. W3C Recommendation, 23 Jan. 2007. See <A 
  href="http://www.w3.org/TR/xpath-datamodel/">http://www.w3.org/TR/xpath-datamodel/</A>.</DIV>
  <DT class=label><SPAN><A id=XQueryFormalSemantics 
  name=XQueryFormalSemantics></A>XQuery 1.0 and XPath 2.0 Formal 
  Semantics</SPAN> 
  <DD>
  <DIV>World Wide Web Consortium. <EM>XQuery 1.0 and XPath 2.0 Formal 
  Semantics</EM>. W3C Recommendation, 23 Jan. 2007. See <A 
  href="http://www.w3.org/TR/xquery-semantics/">http://www.w3.org/TR/xquery-semantics/</A>.</DIV>
  <DT class=label><SPAN><A id=FunctionsAndOperators 
  name=FunctionsAndOperators></A>XQuery 1.0 and XPath 2.0 Functions and 
  Operators</SPAN> 
  <DD>
  <DIV>World Wide Web Consortium. <EM>XQuery 1.0 and XPath 2.0 Functions and 
  Operators</EM> W3C Recommendation, 23 Jan. 2007. See <A 
  href="http://www.w3.org/TR/xquery-operators/">http://www.w3.org/TR/xquery-operators/</A>.</DIV>
  <DT class=label><SPAN><A id=serialization name=serialization></A>XSLT 2.0 and 
  XQuery 1.0 Serialization</SPAN> 
  <DD>
  <DIV>World Wide Web Consortium. <EM>XSLT 2.0 and XQuery 1.0 
  Serialization</EM>. W3C Recommendation, 23 Jan. 2007. See <A 
  href="http://www.w3.org/TR/xslt-xquery-serialization/">http://www.w3.org/TR/xslt-xquery-serialization/</A>.</DIV></DD></DL></DIV>
<DIV class=div2>
<H3><A id=id-non-normative-references name=id-non-normative-references></A>E.2 
Non-normative References</H3>
<DL>
  <DT class=label><SPAN class=xpath><A id=XPath-Requirements 
  name=XPath-Requirements></A>XPath 2.0 Requirements</SPAN> 
  <DD>
  <DIV class=xpath>World Wide Web Consortium. <EM>XPath Requirements Version 
  2.0</EM>. W3C Working Draft 22 August 2003. See <A 
  href="http://www.w3.org/TR/xpath20req">http://www.w3.org/TR/xpath20req</A>.</DIV>
  <DT class=label><SPAN class=xpath><A id=xquery name=xquery></A>XQuery</SPAN> 
  <DD>
  <DIV class=xpath>World Wide Web Consortium. <EM>XQuery 1.0: An XML Query 
  Language</EM>. W3C Recommendation, 23 Jan. 2007. See <A 
  href="http://www.w3.org/TR/xquery/">http://www.w3.org/TR/xquery/</A>.</DIV>
  <DT class=label><SPAN><A id=XSLT name=XSLT></A>XSLT 2.0</SPAN> 
  <DD>
  <DIV>World Wide Web Consortium. <EM>XSL Transformations (XSLT) 2.0.</EM> W3C 
  Recommendation, 23 Jan. 2007. See <A 
  href="http://www.w3.org/TR/xslt20/">http://www.w3.org/TR/xslt20/</A></DIV>
  <DT class=label><SPAN><A id=DOM name=DOM></A>Document Object Model</SPAN> 
  <DD>
  <DIV>World Wide Web Consortium. <EM>Document Object Model (DOM) Level 3 Core 
  Specification.</EM> W3C Recommendation, April 7, 2004. See <A 
  href="http://www.w3.org/TR/DOM-Level-3-Core/">http://www.w3.org/TR/DOM-Level-3-Core/</A>.</DIV>
  <DT class=label><SPAN><A id=XINFO name=XINFO></A>XML Infoset</SPAN> 
  <DD>
  <DIV>World Wide Web Consortium. <EM>XML Information Set.</EM> W3C 
  Recommendation 24 October 2001. See <A 
  href="http://www.w3.org/TR/xml-infoset/">http://www.w3.org/TR/xml-infoset/</A></DIV>
  <DT class=label><SPAN><A id=XPath name=XPath></A>XPath 1.0</SPAN> 
  <DD>
  <DIV>World Wide Web Consortium. <EM>XML Path Language (XPath) Version 
  1.0</EM>. W3C Recommendation, Nov. 16, 1999. See <A 
  href="http://www.w3.org/TR/xpath.html">http://www.w3.org/TR/xpath.html</A></DIV>
  <DT class=label><SPAN><A id=XPTR name=XPTR></A>XPointer</SPAN> 
  <DD>
  <DIV>World Wide Web Consortium. <EM>XML Pointer Language (XPointer).</EM> W3C 
  Last Call Working Draft 8 January 2001. See <A 
  href="http://www.w3.org/TR/WD-xptr">http://www.w3.org/TR/WD-xptr</A></DIV></DD></DL></DIV>
<DIV class=div2>
<H3><A id=id-background-material name=id-background-material></A>E.3 Background 
Material</H3>
<DL>
  <DT class=label><SPAN><A id=CHARMOD name=CHARMOD></A>Character Model</SPAN> 
  <DD>
  <DIV>World Wide Web Consortium. <EM>Character Model for the World Wide 
  Web.</EM> W3C Working Draft. See <A 
  href="http://www.w3.org/TR/charmod/">http://www.w3.org/TR/charmod/</A>.</DIV>
  <DT class=label><SPAN><A id=XSLT1 name=XSLT1></A>XSLT 1.0</SPAN> 
  <DD>
  <DIV>World Wide Web Consortium. <EM>XSL Transformations (XSLT) 1.0.</EM> W3C 
  Recommendation. See <A 
  href="http://www.w3.org/TR/xslt">http://www.w3.org/TR/xslt</A></DIV></DD></DL></DIV></DIV>
<DIV class=xpath>
<DIV class=div1>
<H2><A id=id-xpath-conformance name=id-xpath-conformance></A>F Conformance</H2>
<P>XPath is intended primarily as a component that can be used by other 
specifications. Therefore, XPath relies on specifications that use it (such as 
<A href="REC-xpath20-20070123.htm#XPTR">[XPointer]</A> 
and <A href="REC-xpath20-20070123.htm#XSLT">[XSLT 
2.0]</A>) to specify conformance criteria for XPath in their respective 
environments. Specifications that set conformance criteria for their use of 
XPath must not change the syntactic or semantic definitions of XPath as given in 
this specification, except by subsetting and/or compatible extensions.</P>
<DIV class=div2>
<H3><A id=id-xpath-static-typing name=id-xpath-static-typing></A>F.1 Static 
Typing Feature</H3>
<P>[<A id=dt-xpath-static-typing-feature title="static typing feature" 
name=dt-xpath-static-typing-feature>Definition</A>: The <B>Static Typing 
Feature</B> is an optional feature of XPath that provides support for the static 
semantics defined in <A 
href="REC-xpath20-20070123.htm#XQueryFormalSemantics">[XQuery 
1.0 and XPath 2.0 Formal Semantics]</A>, and requires implementations to detect 
and report <A title="type error" 
href="REC-xpath20-20070123.htm#dt-type-error">type 
errors</A> during the <A title="static analysis phase" 
href="REC-xpath20-20070123.htm#dt-static-analysis">static 
analysis phase</A>.] Specifications that use XPath may specify conformance 
criteria for use of the Static Typing Feature.</P>
<P>If an implementation does not support the <A title="static typing feature" 
href="REC-xpath20-20070123.htm#dt-xpath-static-typing-feature">Static 
Typing Feature</A>, but can nevertheless determine during the static analysis 
phase that an expression will necessarily raise a type error if evaluated at run 
time, the implementation may raise that error during the static analysis phase. 
The choice of whether to raise such an error at analysis time is <A 
title="implementation dependent" 
href="REC-xpath20-20070123.htm#dt-implementation-dependent">implementation 
dependent</A>.</P>
<DIV class=div3>
<H4><A id=id-xpath-static-extensions name=id-xpath-static-extensions></A>F.1.1 
Static Typing Extensions</H4>
<P>In some cases, the static typing rules defined in <A 
href="REC-xpath20-20070123.htm#XQueryFormalSemantics">[XQuery 
1.0 and XPath 2.0 Formal Semantics]</A> are not very precise (see, for example, 
the type inference rules for the ancestor axes—parent, ancestor, and 
ancestor-or-self—and for the function <CODE>fn:root</CODE>). Some 
implementations may wish to support more precise static typing rules.</P>
<P>A conforming implementation that implements the <A 
title="static typing feature" 
href="REC-xpath20-20070123.htm#dt-xpath-static-typing-feature">Static 
Typing Feature</A> may also provide one or more <B>static typing extensions</B>. 
[<A id=dt-xpath-static-typing-extension title="static typing extension" 
name=dt-xpath-static-typing-extension>Definition</A>: A <B>static typing 
extension</B> is an <A title="implementation defined" 
href="REC-xpath20-20070123.htm#dt-implementation-defined">implementation-defined</A> 
type inference rule that infers a more precise static type than that inferred by 
the type inference rules in <A 
href="REC-xpath20-20070123.htm#XQueryFormalSemantics">[XQuery 
1.0 and XPath 2.0 Formal Semantics]</A>.] See <A 
href="http://www.w3.org/TR/xquery-semantics/#id-static-extensions">Section 6.1.1 
Static Typing Extensions</A><SUP><SMALL>FS</SMALL></SUP> for a formal definition 
of the constraints on static typing extensions.</P></DIV></DIV></DIV></DIV>
<DIV class=div1>
<H2><A id=id-errors name=id-errors></A>G Error Conditions</H2>
<DL>
  <DT><A id=ERRXPST0001 name=ERRXPST0001></A>err:XPST0001 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xpath20-20070123.htm#dt-static-error">static 
  error</A> if analysis of an expression relies on some component of the <A 
  title="static context" 
  href="REC-xpath20-20070123.htm#dt-static-context">static 
  context</A> that has not been assigned a value.</P>
  <DT><A id=ERRXPDY0002 name=ERRXPDY0002></A>err:XPDY0002 
  <DD>
  <P>It is a <A title="dynamic error" 
  href="REC-xpath20-20070123.htm#dt-dynamic-error">dynamic 
  error</A> if evaluation of an expression relies on some part of the <A 
  title="dynamic context" 
  href="REC-xpath20-20070123.htm#dt-dynamic-context">dynamic 
  context</A> that has not been assigned a value.</P>
  <DT><A id=ERRXPST0003 name=ERRXPST0003></A>err:XPST0003 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xpath20-20070123.htm#dt-static-error">static 
  error</A> if an expression is not a valid instance of the grammar defined in 
  <A href="REC-xpath20-20070123.htm#id-grammar"><B>A.1 
  EBNF</B></A>.</P>
  <DT><A id=ERRXPTY0004 name=ERRXPTY0004></A>err:XPTY0004 
  <DD>
  <P>It is a <A title="type error" 
  href="REC-xpath20-20070123.htm#dt-type-error">type 
  error</A> if, during the <A title="static analysis phase" 
  href="REC-xpath20-20070123.htm#dt-static-analysis">static 
  analysis phase</A>, an expression is found to have a <A title="static type" 
  href="REC-xpath20-20070123.htm#dt-static-type">static 
  type</A> that is not appropriate for the context in which the expression 
  occurs, or during the <A title="dynamic evaluation phase" 
  href="REC-xpath20-20070123.htm#dt-dynamic-evaluation">dynamic 
  evaluation phase</A>, the <A title="dynamic type" 
  href="REC-xpath20-20070123.htm#dt-dynamic-type">dynamic 
  type</A> of a value does not match a required type as specified by the 
  matching rules in <A 
  href="REC-xpath20-20070123.htm#id-sequencetype-matching"><B>2.5.4 
  SequenceType Matching</B></A>.</P>
  <DT><A id=ERRXPST0005 name=ERRXPST0005></A>err:XPST0005 
  <DD>
  <P>During the analysis phase, it is a <A title="static error" 
  href="REC-xpath20-20070123.htm#dt-static-error">static 
  error</A> if the <A title="static type" 
  href="REC-xpath20-20070123.htm#dt-static-type">static 
  type</A> assigned to an expression other than the expression <CODE>()</CODE> 
  or <CODE>data(())</CODE> is <CODE>empty-sequence()</CODE>.</P>
  <DT><A id=ERRXPTY0006 name=ERRXPTY0006></A>err:XPTY0006 
  <DD>
  <P>(Not currently used.)</P>
  <DT><A id=ERRXPTY0007 name=ERRXPTY0007></A>err:XPTY0007 
  <DD>
  <P>(Not currently used.)</P>
  <DT><A id=ERRXPST0008 name=ERRXPST0008></A>err:XPST0008 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xpath20-20070123.htm#dt-static-error">static 
  error</A> if an expression refers to an element name, attribute name, schema 
  type name, namespace prefix, or variable name that is not defined in the <A 
  title="static context" 
  href="REC-xpath20-20070123.htm#dt-static-context">static 
  context</A>, except for an ElementName in an <A 
  href="REC-xpath20-20070123.htm#doc-xpath-ElementTest">ElementTest</A> 
  or an AttributeName in an <A 
  href="REC-xpath20-20070123.htm#doc-xpath-AttributeTest">AttributeTest</A>.</P>
  <DT><A id=ERRXPST0010 name=ERRXPST0010></A>err:XPST0010 
  <DD>
  <P>An implementation must raise a <A title="static error" 
  href="REC-xpath20-20070123.htm#dt-static-error">static 
  error</A> if it encounters a reference to an axis that it does not 
support.</P>
  <DT><A id=ERRXPST0017 name=ERRXPST0017></A>err:XPST0017 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xpath20-20070123.htm#dt-static-error">static 
  error</A> if the expanded QName and number of arguments in a function call do 
  not match the name and arity of a <A title="function signature" 
  href="REC-xpath20-20070123.htm#dt-function-signature">function 
  signature</A> in the <A title="static context" 
  href="REC-xpath20-20070123.htm#dt-static-context">static 
  context</A>.</P>
  <DT><A id=ERRXPTY0018 name=ERRXPTY0018></A>err:XPTY0018 
  <DD>
  <P>It is a <A title="type error" 
  href="REC-xpath20-20070123.htm#dt-type-error">type 
  error</A> if the result of the last step in a path expression contains both 
  nodes and atomic values.</P>
  <DT><A id=ERRXPTY0019 name=ERRXPTY0019></A>err:XPTY0019 
  <DD>
  <P>It is a <A title="type error" 
  href="REC-xpath20-20070123.htm#dt-type-error">type 
  error</A> if the result of a step (other than the last step) in a path 
  expression contains an atomic value.</P>
  <DT><A id=ERRXPTY0020 name=ERRXPTY0020></A>err:XPTY0020 
  <DD>
  <P>It is a <A title="type error" 
  href="REC-xpath20-20070123.htm#dt-type-error">type 
  error</A> if, in an axis step, the context item is not a node.</P>
  <DT><A id=ERRXPDY0021 name=ERRXPDY0021></A>err:XPDY0021 
  <DD>
  <P>(Not currently used.)</P>
  <DT><A id=ERRXPDY0050 name=ERRXPDY0050></A>err:XPDY0050 
  <DD>
  <P>It is a <A title="dynamic error" 
  href="REC-xpath20-20070123.htm#dt-dynamic-error">dynamic 
  error</A> if the <A title="dynamic type" 
  href="REC-xpath20-20070123.htm#dt-dynamic-type">dynamic 
  type</A> of the operand of a <CODE>treat</CODE> expression does not match the 
  <A title="sequence type" 
  href="REC-xpath20-20070123.htm#dt-sequence-type">sequence 
  type</A> specified by the <CODE>treat</CODE> expression. This error might also 
  be raised by a path expression beginning with "<CODE>/</CODE>" or 
  "<CODE>//</CODE>" if the context node is not in a tree that is rooted at a 
  document node. This is because a leading "<CODE>/</CODE>" or "<CODE>//</CODE>" 
  in a path expression is an abbreviation for an initial step that includes the 
  clause <CODE>treat as document-node()</CODE>.</P>
  <DT><A id=ERRXPST0051 name=ERRXPST0051></A>err:XPST0051 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xpath20-20070123.htm#dt-static-error">static 
  error</A> if a QName that is used as an <A 
  href="REC-xpath20-20070123.htm#doc-xpath-AtomicType">AtomicType</A> 
  in a <A 
  href="REC-xpath20-20070123.htm#doc-xpath-SequenceType">SequenceType</A> 
  is not defined in the <A title="in-scope schema type" 
  href="REC-xpath20-20070123.htm#dt-is-types">in-scope 
  schema types</A> as an atomic type.</P>
  <DT><A id=ERRXPST0080 name=ERRXPST0080></A>err:XPST0080 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xpath20-20070123.htm#dt-static-error">static 
  error</A> if the target type of a <CODE>cast</CODE> or <CODE>castable</CODE> 
  expression is <CODE>xs:NOTATION</CODE> or <CODE>xs:anyAtomicType</CODE>.</P>
  <DT><A id=ERRXPST0081 name=ERRXPST0081></A>err:XPST0081 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xpath20-20070123.htm#dt-static-error">static 
  error</A> if a QName used in <SPAN class=xpath><SPAN class=xpath>an 
  expression</SPAN></SPAN> contains a namespace prefix that cannot be expanded 
  into a namespace URI by using the <A title="statically known namespaces" 
  href="REC-xpath20-20070123.htm#dt-static-namespaces">statically 
  known namespaces</A>.</P>
  <DT><A id=ERRXPST0083 name=ERRXPST0083></A>err:XPST0083 
  <DD>
  <P>(Not currently used.)</P></DD></DL></DIV>
<DIV class=div1>
<H2><A id=id-glossary name=id-glossary></A>H Glossary (Non-Normative)</H2>
<DL>
  <DT><A id=GLdt-atomic-value name=GLdt-atomic-value></A>atomic value 
  <DD>
  <P>An <B>atomic value</B> is a value in the value space of an <B>atomic 
  type</B>, as defined in <A 
  href="REC-xpath20-20070123.htm#XMLSchema">[XML 
  Schema]</A>.</P>
  <DT><A id=GLdt-atomization name=GLdt-atomization></A>atomization 
  <DD>
  <P><B>Atomization</B> of a sequence is defined as the result of invoking the 
  <CODE>fn:data</CODE> function on the sequence, as defined in <A 
  href="REC-xpath20-20070123.htm#FunctionsAndOperators">[XQuery 
  1.0 and XPath 2.0 Functions and Operators]</A>.</P>
  <DT><A id=GLdt-available-collections 
  name=GLdt-available-collections></A>available collections 
  <DD>
  <P><B>Available collections.</B> This is a mapping of strings onto sequences 
  of nodes. The string represents the absolute URI of a resource. The sequence 
  of nodes represents the result of the <CODE>fn:collection</CODE> function when 
  that URI is supplied as the argument.</P>
  <DT><A id=GLdt-available-docs name=GLdt-available-docs></A>available documents 

  <DD>
  <P><B>Available documents.</B> This is a mapping of strings onto document 
  nodes. The string represents the absolute URI of a resource. The document node 
  is the root of a tree that represents that resource using the <A 
  title="data model" 
  href="REC-xpath20-20070123.htm#dt-datamodel">data 
  model</A>. The document node is returned by the <CODE>fn:doc</CODE> function 
  when applied to that URI.</P>
  <DT><A id=GLdt-axis-step name=GLdt-axis-step></A>axis step 
  <DD>
  <P>An <B>axis step</B> returns a sequence of nodes that are reachable from the 
  context node via a specified axis. Such a step has two parts: an <B>axis</B>, 
  which defines the "direction of movement" for the step, and a <A 
  title="node test" 
  href="REC-xpath20-20070123.htm#dt-node-test">node 
  test</A>, which selects nodes based on their kind, name, and/or <A 
  title="type annotation" 
  href="REC-xpath20-20070123.htm#dt-type-annotation">type 
  annotation</A>.</P>
  <DT><A id=GLdt-base-uri name=GLdt-base-uri></A>base URI 
  <DD>
  <P><B>Base URI.</B> This is an absolute URI, used when necessary in the 
  resolution of relative URIs (for example, by the <CODE>fn:resolve-uri</CODE> 
  function.)</P>
  <DT><A id=GLdt-built-in-function name=GLdt-built-in-function></A>built-in 
  function 
  <DD>
  <P>The <B>built-in functions</B> supported by XPath are defined in <A 
  href="REC-xpath20-20070123.htm#FunctionsAndOperators">[XQuery 
  1.0 and XPath 2.0 Functions and Operators]</A>.</P>
  <DT><A id=GLdt-collation name=GLdt-collation></A>collation 
  <DD>
  <P>A <B>collation</B> is a specification of the manner in which strings and 
  URIs are compared and, by extension, ordered. For a more complete definition 
  of collation, see <A 
  href="REC-xpath20-20070123.htm#FunctionsAndOperators">[XQuery 
  1.0 and XPath 2.0 Functions and Operators]</A>.</P>
  <DT><A id=GLdt-comma-operator name=GLdt-comma-operator></A>comma operator 
  <DD>
  <P>One way to construct a sequence is by using the <B>comma operator</B>, 
  which evaluates each of its operands and concatenates the resulting sequences, 
  in order, into a single result sequence.</P>
  <DT><A id=GLdt-constructor-function 
  name=GLdt-constructor-function></A>constructor function 
  <DD>
  <P>The <B>constructor function</B> for a given type is used to convert 
  instances of other atomic types into the given type. The semantics of the 
  constructor function call <CODE>T($arg)</CODE> are defined to be equivalent to 
  the expression <CODE>(($arg) cast as T?)</CODE>.</P>
  <DT><A id=GLdt-context-item name=GLdt-context-item></A>context item 
  <DD>
  <P>The <B>context item</B> is the item currently being processed. An item is 
  either an atomic value or a node.</P>
  <DT><A id=GLdt-context-item-static-type 
  name=GLdt-context-item-static-type></A>context item static type 
  <DD>
  <P><B>Context item static type.</B> This component defines the <A 
  title="static type" 
  href="REC-xpath20-20070123.htm#dt-static-type">static 
  type</A> of the context item within the scope of a given expression.</P>
  <DT><A id=GLdt-context-node name=GLdt-context-node></A>context node 
  <DD>
  <P>When the context item is a node, it can also be referred to as the 
  <B>context node</B>.</P>
  <DT><A id=GLdt-context-position name=GLdt-context-position></A>context 
  position 
  <DD>
  <P>The <B>context position</B> is the position of the context item within the 
  sequence of items currently being processed.</P>
  <DT><A id=GLdt-context-size name=GLdt-context-size></A>context size 
  <DD>
  <P>The <B>context size</B> is the number of items in the sequence of items 
  currently being processed.</P>
  <DT><A id=GLdt-date-time name=GLdt-date-time></A>current dateTime 
  <DD>
  <P><B>Current dateTime.</B> This information represents an <A 
  title="implementation dependent" 
  href="REC-xpath20-20070123.htm#dt-implementation-dependent">implementation-dependent</A> 
  point in time during the processing of <SPAN class=xpath><SPAN class=xpath>an 
  expression</SPAN></SPAN>, and includes an explicit timezone. It can be 
  retrieved by the <CODE>fn:current-dateTime</CODE> function. If invoked 
  multiple times during the execution of <SPAN class=xpath><SPAN class=xpath>an 
  expression</SPAN></SPAN>, this function always returns the same result.</P>
  <DT><A id=GLdt-datamodel name=GLdt-datamodel></A>data model 
  <DD>
  <P>XPath operates on the abstract, logical structure of an XML document, 
  rather than its surface syntax. This logical structure, known as the <B>data 
  model</B>, is defined in <A 
  href="REC-xpath20-20070123.htm#datamodel">[XQuery/XPath 
  Data Model (XDM)]</A>.</P>
  <DT><A id=GLdt-data-model-schema name=GLdt-data-model-schema></A>data model 
  schema 
  <DD>
  <P>For a given node in an <A title="XDM instance" 
  href="REC-xpath20-20070123.htm#dt-data-model-instance">XDM 
  instance</A>, the <B>data model schema</B> is defined as the schema from which 
  the <A title="type annotation" 
  href="REC-xpath20-20070123.htm#dt-type-annotation">type 
  annotation</A> of that node was derived.</P>
  <DT><A id=GLdt-def-collation name=GLdt-def-collation></A>default collation 
  <DD>
  <P><B>Default collation.</B> This identifies one of the collations in <A 
  title="statically known collations" 
  href="REC-xpath20-20070123.htm#dt-static-collations">statically 
  known collations</A> as the collation to be used by functions and operators 
  for comparing and ordering values of type <CODE>xs:string</CODE> and 
  <CODE>xs:anyURI</CODE> (and types derived from them) when no explicit 
  collation is specified.</P>
  <DT><A id=GLdt-default-collection name=GLdt-default-collection></A>default 
  collection 
  <DD>
  <P><B>Default collection.</B> This is the sequence of nodes that would result 
  from calling the <CODE>fn:collection</CODE> function with no arguments.</P>
  <DT><A id=GLdt-def-elemtype-ns name=GLdt-def-elemtype-ns></A>default 
  element/type namespace 
  <DD>
  <P><B>Default element/type namespace.</B> This is a namespace URI or "none". 
  The namespace URI, if present, is used for any unprefixed QName appearing in a 
  position where an element or type name is expected.</P>
  <DT><A id=GLdt-def-fn-ns name=GLdt-def-fn-ns></A>default function namespace 
  <DD>
  <P><B>Default function namespace.</B> This is a namespace URI or "none". The 
  namespace URI, if present, is used for any unprefixed QName appearing in a 
  position where a function name is expected.</P>
  <DT><A id=GLdelimiting-token name=GLdelimiting-token></A>delimiting terminal 
  symbol 
  <DD>
  <P>The <B>delimiting terminal symbols</B> are: "-", (comma), (colon), "::", 
  "!=", "?", "/", "//", (dot), "..", <A 
  href="REC-xpath20-20070123.htm#prod-xpath-StringLiteral">StringLiteral</A>, 
  "(", ")", "[", "]", "@", "$", "*", "+", "&lt;", "&lt;&lt;", "&lt;=", "=", 
  "&gt;", "&gt;=", "&gt;&gt;", "|"</P>
  <DT><A id=GLdt-document-order name=GLdt-document-order></A>document order 
  <DD>
  <P>Informally, <B>document order</B> is the order in which nodes appear in the 
  XML serialization of a document.</P>
  <DT><A id=GLdt-dynamic-context name=GLdt-dynamic-context></A>dynamic context 
  <DD>
  <P>The <B>dynamic context</B> of an expression is defined as information that 
  is available at the time the expression is evaluated.</P>
  <DT><A id=GLdt-dynamic-error name=GLdt-dynamic-error></A>dynamic error 
  <DD>
  <P>A <B>dynamic error</B> is an error that must be detected during the dynamic 
  evaluation phase and may be detected during the static analysis phase. Numeric 
  overflow is an example of a dynamic error.</P>
  <DT><A id=GLdt-dynamic-evaluation name=GLdt-dynamic-evaluation></A>dynamic 
  evaluation phase 
  <DD>
  <P>The <B>dynamic evaluation phase</B> is the phase during which the value of 
  an expression is computed.</P>
  <DT><A id=GLdt-dynamic-type name=GLdt-dynamic-type></A>dynamic type 
  <DD>
  <P>A <B>dynamic type</B> is associated with each value as it is computed. The 
  dynamic type of a value may be more specific than the <A title="static type" 
  href="REC-xpath20-20070123.htm#dt-static-type">static 
  type</A> of the expression that computed it (for example, the static type of 
  an expression might be <CODE>xs:integer*</CODE>, denoting a sequence of zero 
  or more integers, but at evaluation time its value may have the dynamic type 
  <CODE>xs:integer</CODE>, denoting exactly one integer.)</P>
  <DT><A id=GLdt-ebv name=GLdt-ebv></A>effective boolean value 
  <DD>
  <P>The <B>effective boolean value</B> of a value is defined as the result of 
  applying the <CODE>fn:boolean</CODE> function to the value, as defined in <A 
  href="REC-xpath20-20070123.htm#FunctionsAndOperators">[XQuery 
  1.0 and XPath 2.0 Functions and Operators]</A>.</P>
  <DT><A id=GLdt-empty-sequence name=GLdt-empty-sequence></A>empty sequence 
  <DD>
  <P>A sequence containing zero items is called an <B>empty sequence</B>.</P>
  <DT><A id=GLdt-error-value name=GLdt-error-value></A>error value 
  <DD>
  <P>In addition to its identifying QName, a dynamic error may also carry a 
  descriptive string and one or more additional values called <B>error 
  values</B>.</P>
  <DT><A id=GLdt-expanded-qname name=GLdt-expanded-qname></A>expanded QName 
  <DD>
  <P>An <B>expanded QName</B> consists of an optional namespace URI and a local 
  name. An expanded QName also retains its original namespace prefix (if any), 
  to facilitate casting the expanded QName into a string.</P>
  <DT><A id=GLdt-expression-context name=GLdt-expression-context></A>expression 
  context 
  <DD>
  <P>The <B>expression context</B> for a given expression consists of all the 
  information that can affect the result of the expression.</P>
  <DT><A id=GLdt-filter-expression name=GLdt-filter-expression></A>filter 
  expression 
  <DD>
  <P>A <B>filter expression</B> consists simply of a <B>primary expression</B> 
  followed by zero or more <A title=predicate 
  href="REC-xpath20-20070123.htm#dt-predicate">predicates</A>. 
  The result of the filter expression consists of the items returned by the 
  primary expression, filtered by applying each predicate in turn, working from 
  left to right.</P>
  <DT><A id=GLdt-focus name=GLdt-focus></A>focus 
  <DD>
  <P>The first three components of the <A title="dynamic context" 
  href="REC-xpath20-20070123.htm#dt-dynamic-context">dynamic 
  context</A> (context item, context position, and context size) are called the 
  <B>focus</B> of the expression.</P>
  <DT><A id=GLdt-function-implementation 
  name=GLdt-function-implementation></A>function implementation 
  <DD>
  <P><B>Function implementations</B>. Each function in <A 
  title="function signature" 
  href="REC-xpath20-20070123.htm#dt-function-signature">function 
  signatures</A> has a function implementation that enables the function to map 
  instances of its parameter types into an instance of its result type.</P>
  <DT><A id=GLdt-function-signature name=GLdt-function-signature></A>function 
  signature 
  <DD>
  <P><B>Function signatures.</B> This component defines the set of functions 
  that are available to be called from within an expression. Each function is 
  uniquely identified by its <A title="expanded QName" 
  href="REC-xpath20-20070123.htm#dt-expanded-qname">expanded 
  QName</A> and its arity (number of parameters).</P>
  <DT><A id=GLdt-gregorian name=GLdt-gregorian></A>Gregorian 
  <DD>
  <P>In the operator mapping tables, the term <B>Gregorian</B> refers to the 
  types <CODE>xs:gYearMonth</CODE>, <CODE>xs:gYear</CODE>, 
  <CODE>xs:gMonthDay</CODE>, <CODE>xs:gDay</CODE>, and 
  <CODE>xs:gMonth</CODE>.</P>
  <DT><A id=GLIgnorableWhitespace name=GLIgnorableWhitespace></A>ignorable 
  whitespace 
  <DD>
  <P><B>Ignorable whitespace</B> consists of any <A title=whitespace 
  href="REC-xpath20-20070123.htm#Whitespace">whitespace</A> 
  characters that may occur between <A title=terminal 
  href="REC-xpath20-20070123.htm#terminal">terminals</A>, 
  unless these characters occur in the context of a production marked with a <A 
  href="REC-xpath20-20070123.htm#ExplicitWhitespaceHandling">ws:explicit</A> 
  annotation, in which case they can occur only where explicitly specified (see 
  <A 
  href="REC-xpath20-20070123.htm#ExplicitWhitespaceHandling"><B>A.2.4.2 
  Explicit Whitespace Handling</B></A>).</P>
  <DT><A id=GLdt-implementation-defined 
  name=GLdt-implementation-defined></A>implementation defined 
  <DD>
  <P><B>Implementation-defined</B> indicates an aspect that may differ between 
  implementations, but must be specified by the implementor for each particular 
  implementation.</P>
  <DT><A id=GLdt-implementation-dependent 
  name=GLdt-implementation-dependent></A>implementation dependent 
  <DD>
  <P><B>Implementation-dependent</B> indicates an aspect that may differ between 
  implementations, is not specified by this or any W3C specification, and is not 
  required to be specified by the implementor for any particular 
  implementation.</P>
  <DT><A id=GLdt-timezone name=GLdt-timezone></A>implicit timezone 
  <DD>
  <P><B>Implicit timezone.</B> This is the timezone to be used when a date, 
  time, or dateTime value that does not have a timezone is used in a comparison 
  or arithmetic operation. The implicit timezone is an <A 
  title="implementation defined" 
  href="REC-xpath20-20070123.htm#dt-implementation-defined">implementation-defined</A> 
  value of type <CODE>xs:dayTimeDuration</CODE>. See <A 
  href="REC-xpath20-20070123.htm#XMLSchema">[XML 
  Schema]</A> for the range of legal values of a timezone.</P>
  <DT><A id=GLdt-is-attrs name=GLdt-is-attrs></A>in-scope attribute declarations 

  <DD>
  <P><B>In-scope attribute declarations.</B> Each attribute declaration is 
  identified either by an <A title="expanded QName" 
  href="REC-xpath20-20070123.htm#dt-expanded-qname">expanded 
  QName</A> (for a top-level attribute declaration) or by an <A 
  title="implementation dependent" 
  href="REC-xpath20-20070123.htm#dt-implementation-dependent">implementation-dependent</A> 
  attribute identifier (for a local attribute declaration).</P>
  <DT><A id=GLdt-is-elems name=GLdt-is-elems></A>in-scope element declarations 
  <DD>
  <P><B>In-scope element declarations.</B> Each element declaration is 
  identified either by an <A title="expanded QName" 
  href="REC-xpath20-20070123.htm#dt-expanded-qname">expanded 
  QName</A> (for a top-level element declaration) or by an <A 
  title="implementation dependent" 
  href="REC-xpath20-20070123.htm#dt-implementation-dependent">implementation-dependent</A> 
  element identifier (for a local element declaration).</P>
  <DT><A id=GLdt-in-scope-namespaces name=GLdt-in-scope-namespaces></A>in-scope 
  namespaces 
  <DD>
  <P>The <B>in-scope namespaces</B> property of an element node is a set of 
  <B>namespace bindings</B>, each of which associates a namespace prefix with a 
  URI, thus defining the set of namespace prefixes that are available for 
  interpreting QNames within the scope of the element. For a given element, one 
  namespace binding may have an empty prefix; the URI of this namespace binding 
  is the default namespace within the scope of the element.</P>
  <DT><A id=GLdt-issd name=GLdt-issd></A>in-scope schema definitions 
  <DD>
  <P><B>In-scope schema definitions.</B> This is a generic term for all the 
  element declarations, attribute declarations, and schema type definitions that 
  are in scope during processing of an expression.</P>
  <DT><A id=GLdt-is-types name=GLdt-is-types></A>in-scope schema type 
  <DD>
  <P><B>In-scope schema types.</B> Each schema type definition is identified 
  either by an <A title="expanded QName" 
  href="REC-xpath20-20070123.htm#dt-expanded-qname">expanded 
  QName</A> (for a <B>named type</B>) or by an <A 
  title="implementation dependent" 
  href="REC-xpath20-20070123.htm#dt-implementation-dependent">implementation-dependent</A> 
  type identifier (for an <B>anonymous type</B>). The in-scope schema types 
  include the predefined schema types described in <A 
  href="REC-xpath20-20070123.htm#id-predefined-types"><B>2.5.1 
  Predefined Schema Types</B></A>.</P>
  <DT><A id=GLdt-in-scope-variables name=GLdt-in-scope-variables></A>in-scope 
  variables 
  <DD>
  <P><B>In-scope variables.</B> This is a set of (expanded QName, type) pairs. 
  It defines the set of variables that are available for reference within an 
  expression. The <A title="expanded QName" 
  href="REC-xpath20-20070123.htm#dt-expanded-qname">expanded 
  QName</A> is the name of the variable, and the type is the <A 
  title="static type" 
  href="REC-xpath20-20070123.htm#dt-static-type">static 
  type</A> of the variable.</P>
  <DT><A id=GLdt-item name=GLdt-item></A>item 
  <DD>
  <P>An <B>item</B> is either an <A title="atomic value" 
  href="REC-xpath20-20070123.htm#dt-atomic-value">atomic 
  value</A> or a <A title=node 
  href="REC-xpath20-20070123.htm#dt-node">node</A>.</P>
  <DT><A id=GLdt-kind-test name=GLdt-kind-test></A>kind test 
  <DD>
  <P>An alternative form of a node test called a <B>kind test</B> can select 
  nodes based on their kind, name, and <A title="type annotation" 
  href="REC-xpath20-20070123.htm#dt-type-annotation">type 
  annotation</A>.</P>
  <DT><A id=GLdt-literal name=GLdt-literal></A>literal 
  <DD>
  <P>A <B>literal</B> is a direct syntactic representation of an atomic 
  value.</P>
  <DT><A id=GLdt-name-test name=GLdt-name-test></A>name test 
  <DD>
  <P>A node test that consists only of a QName or a Wildcard is called a <B>name 
  test</B>.</P>
  <DT><A id=GLdt-node name=GLdt-node></A>node 
  <DD>
  <P>A <B>node</B> is an instance of one of the <B>node kinds</B> defined in <A 
  href="REC-xpath20-20070123.htm#datamodel">[XQuery/XPath 
  Data Model (XDM)]</A>.</P>
  <DT><A id=GLdt-node-test name=GLdt-node-test></A>node test 
  <DD>
  <P>A <B>node test</B> is a condition that must be true for each node selected 
  by a <A title=step 
  href="REC-xpath20-20070123.htm#dt-step">step</A>.</P>
  <DT><A id=GLnon-delimiting-token 
  name=GLnon-delimiting-token></A>non-delimiting terminal symbol 
  <DD>
  <P>The <B>non-delimiting terminal symbols</B> are: <A 
  href="REC-xpath20-20070123.htm#prod-xpath-IntegerLiteral">IntegerLiteral</A>, 
  <A 
  href="REC-xpath20-20070123.htm#prod-xpath-NCName">NCName</A>, 
  <A 
  href="REC-xpath20-20070123.htm#prod-xpath-QName">QName</A>, 
  <A 
  href="REC-xpath20-20070123.htm#prod-xpath-DecimalLiteral">DecimalLiteral</A>, 
  <A 
  href="REC-xpath20-20070123.htm#prod-xpath-DoubleLiteral">DoubleLiteral</A>, 
  "ancestor", "ancestor-or-self", "and", "as", "attribute", "cast", "castable", 
  "child", "comment", "descendant", "descendant-or-self", "div", 
  "document-node", "element", "else", "empty-sequence", "eq", "every", "except", 
  "external", "following", "following-sibling", "for", "ge", "gt", "idiv", "if", 
  "in", "instance", "intersect", "is", "item", "le", "lt", "mod", "namespace", 
  "ne", "node", "of", "or", "parent", "preceding", "preceding-sibling", 
  "processing-instruction", "return", "satisfies", "schema-attribute", 
  "schema-element", "self", "some", "text", "then", "to", "treat", "union"</P>
  <DT><A id=GLdt-numeric name=GLdt-numeric></A>numeric 
  <DD>
  <P>When referring to a type, the term <B>numeric</B> denotes the types 
  <CODE>xs:integer</CODE>, <CODE>xs:decimal</CODE>, <CODE>xs:float</CODE>, and 
  <CODE>xs:double</CODE>.</P>
  <DT><A id=GLdt-numeric-predicate name=GLdt-numeric-predicate></A>numeric 
  predicate 
  <DD>
  <P>A predicate whose predicate expression returns a numeric type is called a 
  <B>numeric predicate</B>.</P>
  <DT><A id=GLdt-operator-function name=GLdt-operator-function></A>operator 
  function 
  <DD>
  <P>For each operator and valid combination of operand types, the operator 
  mapping tables specify a result type and an <B>operator function</B> that 
  implements the semantics of the operator for the given types.</P>
  <DT><A id=GLdt-path-expression name=GLdt-path-expression></A>path expression 
  <DD>
  <P>A <B>path expression</B> can be used to locate nodes within trees. A path 
  expression consists of a series of one or more <A title=step 
  href="REC-xpath20-20070123.htm#dt-step">steps</A>, 
  separated by "<CODE>/</CODE>" or "<CODE>//</CODE>", and optionally beginning 
  with "<CODE>/</CODE>" or "<CODE>//</CODE>".</P>
  <DT><A id=GLdt-predicate name=GLdt-predicate></A>predicate 
  <DD>
  <P>A <B>predicate</B> consists of an expression, called a <B>predicate 
  expression</B>, enclosed in square brackets. A predicate serves to filter a 
  sequence, retaining some items and discarding others.</P>
  <DT><A id=GLdt-primary-expression name=GLdt-primary-expression></A>primary 
  expression 
  <DD>
  <P><B>Primary expressions</B> are the basic primitives of the language. They 
  include literals, variable references, context item expressions, and function 
  calls. A primary expression may also be created by enclosing any expression in 
  parentheses, which is sometimes helpful in controlling the precedence of 
  operators.</P>
  <DT><A id=GLdt-principal-node-kind name=GLdt-principal-node-kind></A>principal 
  node kind 
  <DD>
  <P>Every axis has a <B>principal node kind</B>. If an axis can contain 
  elements, then the principal node kind is element; otherwise, it is the kind 
  of nodes that the axis can contain.</P>
  <DT><A id=GLdt-qname name=GLdt-qname></A>QName 
  <DD>
  <P>Lexically, a <B>QName</B> consists of an optional namespace prefix and a 
  local name. If the namespace prefix is present, it is separated from the local 
  name by a colon.</P>
  <DT><A id=GLdt-reverse-document-order 
  name=GLdt-reverse-document-order></A>reverse document order 
  <DD>
  <P>The node ordering that is the reverse of document order is called 
  <B>reverse document order</B>.</P>
  <DT><A id=GLdt-schema-type name=GLdt-schema-type></A>schema type 
  <DD>
  <P>A <B>schema type</B> is a type that is (or could be) defined using the 
  facilities of <A 
  href="REC-xpath20-20070123.htm#XMLSchema">[XML 
  Schema]</A> (including the built-in types of <A 
  href="REC-xpath20-20070123.htm#XMLSchema">[XML 
  Schema]</A>).</P>
  <DT><A id=GLdt-sequence name=GLdt-sequence></A>sequence 
  <DD>
  <P>A <B>sequence</B> is an ordered collection of zero or more <A title=item 
  href="REC-xpath20-20070123.htm#dt-item">items</A>.</P>
  <DT><A id=GLdt-sequence-type name=GLdt-sequence-type></A>sequence type 
  <DD>
  <P>A <B>sequence type</B> is a type that can be expressed using the <A 
  href="REC-xpath20-20070123.htm#doc-xpath-SequenceType">SequenceType</A> 
  syntax. Sequence types are used whenever it is necessary to refer to a type in 
  an XPath expression. The term <B>sequence type</B> suggests that this syntax 
  is used to describe the type of an XPath value, which is always a 
sequence.</P>
  <DT><A id=GLdt-sequencetype-matching 
  name=GLdt-sequencetype-matching></A>SequenceType matching 
  <DD>
  <P>During evaluation of an expression, it is sometimes necessary to determine 
  whether a value with a known <A title="dynamic type" 
  href="REC-xpath20-20070123.htm#dt-dynamic-type">dynamic 
  type</A> "matches" an expected <A title="sequence type" 
  href="REC-xpath20-20070123.htm#dt-sequence-type">sequence 
  type</A>. This process is known as <B>SequenceType matching</B>.</P>
  <DT><A id=GLdt-serialization name=GLdt-serialization></A>serialization 
  <DD>
  <P><B>Serialization</B> is the process of converting an <A 
  title="XDM instance" 
  href="REC-xpath20-20070123.htm#dt-data-model-instance">XDM 
  instance</A> into a sequence of octets (step DM4 in Figure 1.)</P>
  <DT><A id=GLdt-singleton name=GLdt-singleton></A>singleton 
  <DD>
  <P>A sequence containing exactly one item is called a <B>singleton</B>.</P>
  <DT><A id=GLstable name=GLstable></A>stable 
  <DD>
  <P>Document order is <B>stable</B>, which means that the relative order of two 
  nodes will not change during the processing of a given <SPAN class=xpath><SPAN 
  class=xpath>expression</SPAN></SPAN>, even if this order is <A 
  title="implementation dependent" 
  href="REC-xpath20-20070123.htm#dt-implementation-dependent">implementation-dependent</A>.</P>
  <DT><A id=GLdt-static-collations name=GLdt-static-collations></A>statically 
  known collations 
  <DD>
  <P><B>Statically known collations.</B> This is an <A 
  title="implementation defined" 
  href="REC-xpath20-20070123.htm#dt-implementation-defined">implementation-defined</A> 
  set of (URI, collation) pairs. It defines the names of the collations that are 
  available for use in processing expressions.</P>
  <DT><A id=GLdt-known-collections name=GLdt-known-collections></A>statically 
  known collections 
  <DD>
  <P><B>Statically known collections.</B> This is a mapping from strings onto 
  types. The string represents the absolute URI of a resource that is 
  potentially available using the <CODE>fn:collection</CODE> function. The type 
  is the type of the sequence of nodes that would result from calling the 
  <CODE>fn:collection</CODE> function with this URI as its argument.</P>
  <DT><A id=GLdt-known-default-collection 
  name=GLdt-known-default-collection></A>statically known default collection 
  type 
  <DD>
  <P><B>Statically known default collection type.</B> This is the type of the 
  sequence of nodes that would result from calling the 
  <CODE>fn:collection</CODE> function with no arguments.</P>
  <DT><A id=GLdt-known-docs name=GLdt-known-docs></A>statically known documents 
  <DD>
  <P><B>Statically known documents.</B> This is a mapping from strings onto 
  types. The string represents the absolute URI of a resource that is 
  potentially available using the <CODE>fn:doc</CODE> function. The type is the 
  <A title="static type" 
  href="REC-xpath20-20070123.htm#dt-static-type">static 
  type</A> of a call to <CODE>fn:doc</CODE> with the given URI as its literal 
  argument.</P>
  <DT><A id=GLdt-static-namespaces name=GLdt-static-namespaces></A>statically 
  known namespaces 
  <DD>
  <P><B>Statically known namespaces.</B> This is a set of (prefix, URI) pairs 
  that define all the namespaces that are known during static processing of a 
  given expression.</P>
  <DT><A id=GLdt-static-analysis name=GLdt-static-analysis></A>static analysis 
  phase 
  <DD>
  <P>The <B>static analysis phase</B> depends on the expression itself and on 
  the <A title="static context" 
  href="REC-xpath20-20070123.htm#dt-static-context">static 
  context</A>. The <B>static analysis phase</B> does not depend on input data 
  (other than schemas).</P>
  <DT><A id=GLdt-static-context name=GLdt-static-context></A>static context 
  <DD>
  <P>The <B>static context</B> of an expression is the information that is 
  available during static analysis of the expression, prior to its 
  evaluation.</P>
  <DT><A id=GLdt-static-error name=GLdt-static-error></A>static error 
  <DD>
  <P>A <B>static error</B> is an error that must be detected during the static 
  analysis phase. A syntax error is an example of a <A title="static error" 
  href="REC-xpath20-20070123.htm#dt-static-error">static 
  error</A>.</P>
  <DT><A id=GLdt-static-type name=GLdt-static-type></A>static type 
  <DD>
  <P>The <B>static type</B> of an expression is a type such that, when the 
  expression is evaluated, the resulting value will always conform to the static 
  type.</P>
  <DT><A id=GLdt-xpath-static-typing-extension 
  name=GLdt-xpath-static-typing-extension></A>static typing extension 
  <DD>
  <P>A <B>static typing extension</B> is an <A title="implementation defined" 
  href="REC-xpath20-20070123.htm#dt-implementation-defined">implementation-defined</A> 
  type inference rule that infers a more precise static type than that inferred 
  by the type inference rules in <A 
  href="REC-xpath20-20070123.htm#XQueryFormalSemantics">[XQuery 
  1.0 and XPath 2.0 Formal Semantics]</A>.</P>
  <DT><A id=GLdt-xpath-static-typing-feature 
  name=GLdt-xpath-static-typing-feature></A>static typing feature 
  <DD>
  <P>The <B>Static Typing Feature</B> is an optional feature of XPath that 
  provides support for the static semantics defined in <A 
  href="REC-xpath20-20070123.htm#XQueryFormalSemantics">[XQuery 
  1.0 and XPath 2.0 Formal Semantics]</A>, and requires implementations to 
  detect and report <A title="type error" 
  href="REC-xpath20-20070123.htm#dt-type-error">type 
  errors</A> during the <A title="static analysis phase" 
  href="REC-xpath20-20070123.htm#dt-static-analysis">static 
  analysis phase</A>.</P>
  <DT><A id=GLdt-step name=GLdt-step></A>step 
  <DD>
  <P>A <B>step</B> is a part of a <A title="path expression" 
  href="REC-xpath20-20070123.htm#dt-path-expression">path 
  expression</A> that generates a sequence of items and then filters the 
  sequence by zero or more <A title=predicate 
  href="REC-xpath20-20070123.htm#dt-predicate">predicates</A>. 
  The value of the step consists of those items that satisfy the predicates, 
  working from left to right. A step may be either an <A title="axis step" 
  href="REC-xpath20-20070123.htm#dt-axis-step">axis 
  step</A> or a <A title="filter expression" 
  href="REC-xpath20-20070123.htm#dt-filter-expression">filter 
  expression</A>.</P>
  <DT><A id=GLdt-string-value name=GLdt-string-value></A>string value 
  <DD>
  <P>The <B>string value</B> of a node is a string and can be extracted by 
  applying the <CODE>fn:string</CODE> function to the node.</P>
  <DT><A id=GLdt-substitution-group 
  name=GLdt-substitution-group></A>substitution group 
  <DD>
  <P><B>Substitution groups</B> are defined in <A 
  href="REC-xpath20-20070123.htm#XMLSchema">[XML 
  Schema]</A> Part 1, Section 2.2.2.2. Informally, the substitution group headed 
  by a given element (called the <B>head element</B>) consists of the set of 
  elements that can be substituted for the head element without affecting the 
  outcome of schema validation.</P>
  <DT><A id=GLdt-subtype-substitution name=GLdt-subtype-substitution></A>subtype 
  substitution 
  <DD>
  <P>The use of a value whose <A title="dynamic type" 
  href="REC-xpath20-20070123.htm#dt-dynamic-type">dynamic 
  type</A> is derived from an expected type is known as <B>subtype 
  substitution</B>.</P>
  <DT><A id=GLsymbol name=GLsymbol></A>symbol 
  <DD>
  <P>Each rule in the grammar defines one <B>symbol</B>, using the following 
  format:</P>
  <DIV class=exampleInner><PRE>symbol ::= expression
</PRE></DIV>
  <DT><A id=GLsymbolseparators name=GLsymbolseparators></A>symbol separators 
  <DD>
  <P><A title=whitespace 
  href="REC-xpath20-20070123.htm#Whitespace">Whitespace</A> 
  and <A 
  href="REC-xpath20-20070123.htm#doc-xpath-Comment">Comments</A> 
  function as <B>symbol separators</B>. For the most part, they are not 
  mentioned in the grammar, and may occur between any two terminal symbols 
  mentioned in the grammar, except where that is forbidden by the <A 
  href="REC-xpath20-20070123.htm#ws-explicit">/* ws: 
  explicit */</A> annotation in the EBNF, or by the <A 
  href="REC-xpath20-20070123.htm#parse-note-xml-version">/* 
  xgs: xml-version */</A> annotation.</P>
  <DT><A id=GLterminal name=GLterminal></A>terminal 
  <DD>
  <P>A <B>terminal</B> is a symbol or string or pattern that can appear in the 
  right-hand side of a rule, but never appears on the left hand side in the main 
  grammar, although it may appear on the left-hand side of a rule in the grammar 
  for terminals.</P>
  <DT><A id=GLdt-type-annotation name=GLdt-type-annotation></A>type annotation 
  <DD>
  <P>Each element node and attribute node in an <A title="XDM instance" 
  href="REC-xpath20-20070123.htm#dt-data-model-instance">XDM 
  instance</A> has a <B>type annotation</B> (referred to in <A 
  href="REC-xpath20-20070123.htm#datamodel">[XQuery/XPath 
  Data Model (XDM)]</A> as its <CODE>type-name</CODE> property.) The type 
  annotation of a node is a <A title="schema type" 
  href="REC-xpath20-20070123.htm#dt-schema-type">schema 
  type</A> that describes the relationship between the <A title="string value" 
  href="REC-xpath20-20070123.htm#dt-string-value">string 
  value</A> of the node and its <A title="typed value" 
  href="REC-xpath20-20070123.htm#dt-typed-value">typed 
  value</A>.</P>
  <DT><A id=GLdt-typed-value name=GLdt-typed-value></A>typed value 
  <DD>
  <P>The <B>typed value</B> of a node is a sequence of atomic values and can be 
  extracted by applying the <CODE>fn:data</CODE> function to the node.</P>
  <DT><A id=GLdt-type-error name=GLdt-type-error></A>type error 
  <DD>
  <P>A <B>type error</B> may be raised during the static analysis phase or the 
  dynamic evaluation phase. During the static analysis phase, a <A 
  title="type error" 
  href="REC-xpath20-20070123.htm#dt-type-error">type 
  error</A> occurs when the <A title="static type" 
  href="REC-xpath20-20070123.htm#dt-static-type">static 
  type</A> of an expression does not match the expected type of the context in 
  which the expression occurs. During the dynamic evaluation phase, a <A 
  title="type error" 
  href="REC-xpath20-20070123.htm#dt-type-error">type 
  error</A> occurs when the <A title="dynamic type" 
  href="REC-xpath20-20070123.htm#dt-dynamic-type">dynamic 
  type</A> of a value does not match the expected type of the context in which 
  the value occurs.</P>
  <DT><A id=GLdt-type-promotion name=GLdt-type-promotion></A>type promotion 
  <DD>
  <P>Under certain circumstances, an atomic value can be promoted from one type 
  to another. <B>Type promotion</B> is used in evaluating function calls (see <A 
  href="REC-xpath20-20070123.htm#id-function-calls"><B>3.1.5 
  Function Calls</B></A>) and operators that accept numeric or string operands 
  (see <A href="REC-xpath20-20070123.htm#mapping"><B>B.2 
  Operator Mapping</B></A>).</P>
  <DT><A id=GLdt-URI name=GLdt-URI></A>URI 
  <DD>
  <P>Within this specification, the term <B>URI</B> refers to a Universal 
  Resource Identifier as defined in <A 
  href="REC-xpath20-20070123.htm#RFC3986">[RFC3986]</A> 
  and extended in <A 
  href="REC-xpath20-20070123.htm#RFC3987">[RFC3987]</A> 
  with the new name <B>IRI</B>.</P>
  <DT><A id=GLdt-value name=GLdt-value></A>value 
  <DD>
  <P>In the <A title="data model" 
  href="REC-xpath20-20070123.htm#dt-datamodel">data 
  model</A>, a <B>value</B> is always a <A title=sequence 
  href="REC-xpath20-20070123.htm#dt-sequence">sequence</A>.</P>
  <DT><A id=GLdt-variable-reference name=GLdt-variable-reference></A>variable 
  reference 
  <DD>
  <P>A <B>variable reference</B> is a QName preceded by a $-sign.</P>
  <DT><A id=GLdt-variable-values name=GLdt-variable-values></A>variable values 
  <DD>
  <P><B>Variable values</B>. This is a set of (expanded QName, value) pairs. It 
  contains the same <A title="expanded QName" 
  href="REC-xpath20-20070123.htm#dt-expanded-qname">expanded 
  QNames</A> as the <A title="in-scope variables" 
  href="REC-xpath20-20070123.htm#dt-in-scope-variables">in-scope 
  variables</A> in the <A title="static context" 
  href="REC-xpath20-20070123.htm#dt-static-context">static 
  context</A> for the expression. The expanded QName is the name of the variable 
  and the value is the dynamic value of the variable, which includes its <A 
  title="dynamic type" 
  href="REC-xpath20-20070123.htm#dt-dynamic-type">dynamic 
  type</A>.</P>
  <DT><A id=GLdt-warning name=GLdt-warning></A>warning 
  <DD>
  <P>In addition to <A title="static error" 
  href="REC-xpath20-20070123.htm#dt-static-error">static 
  errors</A>, <A title="dynamic error" 
  href="REC-xpath20-20070123.htm#dt-dynamic-error">dynamic 
  errors</A>, and <A title="type error" 
  href="REC-xpath20-20070123.htm#dt-type-error">type 
  errors</A>, an XPath implementation may raise <B>warnings</B>, either during 
  the <A title="static analysis phase" 
  href="REC-xpath20-20070123.htm#dt-static-analysis">static 
  analysis phase</A> or the <A title="dynamic evaluation phase" 
  href="REC-xpath20-20070123.htm#dt-dynamic-evaluation">dynamic 
  evaluation phase</A>. The circumstances in which warnings are raised, and the 
  ways in which warnings are handled, are <A title="implementation defined" 
  href="REC-xpath20-20070123.htm#dt-implementation-defined">implementation-defined</A>.</P>
  <DT><A id=GLWhitespace name=GLWhitespace></A>whitespace 
  <DD>
  <P>A <B>whitespace</B> character is any of the characters defined by <A 
  href="http://www.w3.org/TR/REC-xml#NT-S">[http://www.w3.org/TR/REC-xml#NT-S]</A>.</P>
  <DT><A id=GLdt-data-model-instance name=GLdt-data-model-instance></A>XDM 
  instance 
  <DD>
  <P>The term <B>XDM instance</B> is used, synonymously with the term 
  <B>value</B>, to denote an unconstrained sequence of <A title=node 
  href="REC-xpath20-20070123.htm#dt-node">nodes</A> 
  and/or <A title="atomic value" 
  href="REC-xpath20-20070123.htm#dt-atomic-value">atomic 
  values</A> in the <A title="data model" 
  href="REC-xpath20-20070123.htm#dt-datamodel">data 
  model</A>.</P>
  <DT><A id=GLdt-xpath-compat-mode name=GLdt-xpath-compat-mode></A>XPath 1.0 
  compatibility mode 
  <DD>
  <P><B>XPath 1.0 compatibility mode.</B> <SPAN class=xpath><SPAN 
  class=xpath>This value is <CODE>true</CODE> if rules for backward 
  compatibility with XPath Version 1.0 are in effect; otherwise it is 
  <CODE>false</CODE>.</SPAN></SPAN></P>
  <DT><A id=GLdt-anyAtomicType name=GLdt-anyAtomicType></A>xs:anyAtomicType 
  <DD>
  <P><CODE>xs:anyAtomicType</CODE> is an atomic type that includes all atomic 
  values (and no values that are not atomic). Its base type is 
  <CODE>xs:anySimpleType</CODE> from which all simple types, including atomic, 
  list, and union types, are derived. All primitive atomic types, such as 
  <CODE>xs:integer</CODE>, <CODE>xs:string</CODE>, and 
  <CODE>xs:untypedAtomic</CODE>, have <CODE>xs:anyAtomicType</CODE> as their 
  base type.</P>
  <DT><A id=GLdt-dayTimeDuration 
  name=GLdt-dayTimeDuration></A>xs:dayTimeDuration 
  <DD>
  <P><CODE>xs:dayTimeDuration</CODE> is derived by restriction from 
  <CODE>xs:duration</CODE>. The lexical representation of 
  <CODE>xs:dayTimeDuration</CODE> is restricted to contain only day, hour, 
  minute, and second components.</P>
  <DT><A id=GLdt-untyped name=GLdt-untyped></A>xs:untyped 
  <DD>
  <P><CODE>xs:untyped</CODE> is used as the <A title="type annotation" 
  href="REC-xpath20-20070123.htm#dt-type-annotation">type 
  annotation</A> of an element node that has not been validated, or has been 
  validated in <CODE>skip</CODE> mode.</P>
  <DT><A id=GLdt-untypedAtomic name=GLdt-untypedAtomic></A>xs:untypedAtomic 
  <DD>
  <P><CODE>xs:untypedAtomic</CODE> is an atomic type that is used to denote 
  untyped atomic data, such as text that has not been assigned a more specific 
  type.</P>
  <DT><A id=GLdt-yearMonthDuration 
  name=GLdt-yearMonthDuration></A>xs:yearMonthDuration 
  <DD>
  <P><CODE>xs:yearMonthDuration</CODE> is derived by restriction from 
  <CODE>xs:duration</CODE>. The lexical representation of 
  <CODE>xs:yearMonthDuration</CODE> is restricted to contain only year and month 
  components.</P></DD></DL></DIV>
<DIV class=xpath>
<DIV class=div1>
<H2><A id=id-backwards-compatibility name=id-backwards-compatibility></A>I 
Backwards Compatibility with XPath 1.0 (Non-Normative)</H2>
<P>This appendix provides a summary of the areas of incompatibility between 
XPath 2.0 and <A 
href="REC-xpath20-20070123.htm#XPath">[XPath 
1.0]</A>.</P>
<P>Three separate cases are considered:</P>
<OL class=enumar>
  <LI>
  <P>Incompatibilities that exist when source documents have no schema, and when 
  running with XPath 1.0 compatibility mode set to true. This specification has 
  been designed to reduce the number of incompatibilities in this situation to 
  an absolute minumum, but some differences remain and are listed 
  individually.</P>
  <LI>
  <P>Incompatibilities that arise when XPath 1.0 compatibility mode is set to 
  false. In this case, the number of expressions where compatibility is lost is 
  rather greater.</P>
  <LI>
  <P>Incompatibilities that arise when the source document is processed using a 
  schema (whether or not XPath 1.0 compatibility mode is set to true). 
  Processing the document with a schema changes the way that the values of nodes 
  are interpreted, and this can cause an XPath expression to return different 
  results.</P></LI></OL>
<DIV class=div2>
<H3><A id=id-incompat-in-true-mode name=id-incompat-in-true-mode></A>I.1 
Incompatibilities when Compatibility Mode is true</H3>
<P>The list below contains all known areas, within the scope of this 
specification, where an XPath 2.0 processor running with compatibility mode set 
to true will produce different results from an XPath 1.0 processor evaluating 
the same expression, assuming that the expression was valid in XPath 1.0, and 
that the nodes in the source document have no type annotations other than 
<CODE>xs:untyped</CODE> and <CODE>xs:untypedAtomic</CODE>.</P>
<P>Incompatibilities in the behavior of individual functions are not listed 
here, but are included in an appendix of <A 
href="REC-xpath20-20070123.htm#FunctionsAndOperators">[XQuery 
1.0 and XPath 2.0 Functions and Operators]</A>.</P>
<P>Since both XPath 1.0 and XPath 2.0 leave some aspects of the specification 
implementation-defined, there may be incompatiblities in the behavior of a 
particular implementation that are outside the scope of this specification. 
Equally, some aspects of the behavior of XPath are defined by the host 
language.</P>
<OL class=enumar>
  <LI>
  <P>Consecutive comparison operators such as <CODE>A &lt; B &lt; C</CODE> were 
  supported in XPath 1.0, but are not permitted by the XPath 2.0 grammar. In 
  most cases such comparisons in XPath 1.0 did not have the intuitive meaning, 
  so it is unlikely that they have been widely used in practice. If such a 
  construct is found, an XPath 2.0 processor will report a syntax error, and the 
  construct can be rewritten as <CODE>(A &lt; B) &lt; C</CODE></P>
  <LI>
  <P>When converting strings to numbers (either explicitly when using the 
  <CODE>number</CODE> function, or implicitly say on a function call), certain 
  strings that converted to the special value <CODE>NaN</CODE> under XPath 1.0 
  will convert to values other than <CODE>NaN</CODE> under XPath 2.0. These 
  include any number written with a leading <CODE>+</CODE> sign, any number in 
  exponential floating point notation (for example <CODE>1.0e+9</CODE>), and the 
  strings <CODE>INF</CODE> and <CODE>-INF</CODE>.</P>
  <LI>
  <P>XPath 2.0 does not allow a token starting with a letter to follow 
  immediately after a numeric literal, without intervening whitespace. For 
  example, <CODE>10div 3</CODE> was permitted in XPath 1.0, but in XPath 2.0 
  must be written as <CODE>10 div 3</CODE>.</P>
  <LI>
  <P>The namespace axis is deprecated in XPath 2.0. Implementations may support 
  the namespace axis for backward compatibility with XPath 1.0, but they are not 
  required to do so. (XSLT 2.0 requires that if XPath backwards compatibility 
  mode is supported, then the namespace axis must also be supported; but other 
  host languages may define the conformance rules 
differently.)</P></LI></OL></DIV>
<DIV class=div2>
<H3><A id=id-incompat-in-false-mode name=id-incompat-in-false-mode></A>I.2 
Incompatibilities when Compatibility Mode is false</H3>
<P>Even when the setting of the XPath 1.0 compatibility mode is false, many 
XPath expressions will still produce the same results under XPath 2.0 as under 
XPath 1.0. The exceptions are described in this section.</P>
<P>In all cases it is assumed that the expression in question was valid under 
XPath 1.0, that XPath 1.0 compatibility mode is false, and that all elements and 
attributes are annotated with the types <CODE>xs:untyped</CODE> and 
<CODE>xs:untypedAtomic</CODE> respectively.</P>
<P>In the description below, the terms <EM>node-set</EM> and <EM>number</EM> are 
used with their XPath 1.0 meanings, that is, to describe expressions which 
according to the rules of XPath 1.0 would have generated a node-set or a number 
respectively.</P>
<OL class=enumar>
  <LI>
  <P>When a node-set containing more than one node is supplied as an argument to 
  a function or operator that expects a single node or value, the XPath 1.0 rule 
  was that all nodes after the first were discarded. Under XPath 2.0, a type 
  error occurs if there is more than one node. The XPath 1.0 behavior can always 
  be restored by using the predicate <CODE>[1]</CODE> to explicitly select the 
  first node in the node-set.</P>
  <LI>
  <P>In XPath 1.0, the <CODE>&lt;</CODE> and <CODE>&gt;</CODE> operators, when 
  applied to two strings, attempted to convert both the strings to numbers and 
  then made a numeric comparison between the results. In XPath 2.0, these 
  operators perform a string comparison using the default collating sequence. 
  (If either value is numeric, however, the results are compatible with XPath 
  1.0)</P>
  <LI>
  <P>When an empty node-set is supplied as an argument to a function or operator 
  that expects a number, the value is no longer converted implicitly to NaN. The 
  XPath 1.0 behavior can always be restored by using the <CODE>number</CODE> 
  function to perform an explicit conversion.</P>
  <LI>
  <P>More generally, the supplied arguments to a function or operator are no 
  longer implicitly converted to the required type, except in the case where the 
  supplied argument is of type <CODE>xs:untypedAtomic</CODE> (which will 
  commonly be the case when a node in a schemaless document is supplied as the 
  argument). For example, the function call <CODE>substring-before(10 div 3, 
  ".")</CODE> raises a type error under XPath 2.0, because the arguments to the 
  <CODE>substring-before</CODE> function must be strings rather than numbers. 
  The XPath 1.0 behavior can be restored by performing an explicit conversion to 
  the required type using a constructor function or cast.</P>
  <LI>
  <P>The rules for comparing a node-set to a boolean have changed. In XPath 1.0, 
  an expression such as <CODE>$node-set = true()</CODE> was evaluated by 
  converting the node-set to a boolean and then performing a boolean comparison: 
  so this expression would return <CODE>true</CODE> if <CODE>$node-set</CODE> 
  was non-empty. In XPath 2.0, this expression is handled in the same way as 
  other comparisons between a sequence and a singleton: it is <CODE>true</CODE> 
  if <CODE>$node-set</CODE> contains at least one node whose value, after 
  atomization and conversion to a boolean using the casting rules, is 
  <CODE>true</CODE>.</P>
  <P>This means that if <CODE>$node-set</CODE> is empty, the result under XPath 
  2.0 will be <CODE>false</CODE> regardless of the value of the boolean operand, 
  and regardless of which operator is used. If <CODE>$node-set</CODE> is 
  non-empty, then in most cases the comparison with a boolean is likely to fail, 
  giving a dynamic error. But if a node has the value "0", "1", "true", or 
  "false", evaluation of the expression may succeed.</P>
  <LI>
  <P>Comparisons of a number to a boolean, a number to a string, or a string to 
  a boolean are not allowed in XPath 2.0: they result in a type error. In XPath 
  1.0 such comparisons were allowed, and were handled by converting one of the 
  operands to the type of the other. So for example in XPath 1.0 <CODE>4 = 
  true()</CODE> was true; <CODE>4 = "+4"</CODE> was false (because the string 
  <CODE>+4</CODE> converts to <CODE>NaN</CODE>), and <CODE>false = 
  "false"</CODE> was false (because the string <CODE>"false"</CODE> converts to 
  the boolean <CODE>true</CODE>). In XPath 2.0 all these comparisons are type 
  errors.</P>
  <LI>
  <P>Additional numeric types have been introduced, with the effect that 
  arithmetic may now be done as an integer, decimal, or single- or 
  double-precision floating point calculation where previously it was always 
  performed as double-precision floating point. The result of the 
  <CODE>div</CODE> operator when dividing two integers is now a value of type 
  decimal rather than double. The expression <CODE>10 div 0</CODE> raises an 
  error rather than returning positive infinity.</P>
  <LI>
  <P>The rules for converting numbers to strings have changed. These may affect 
  the way numbers are displayed in the output of a stylesheet. For numbers whose 
  absolute value is in the range 1E-6 to 1E+6, the result should be the same, 
  but outside this range, scientific format is used for non-integral 
  <CODE>xs:float</CODE> and <CODE>xs:double</CODE> values.</P>
  <LI>
  <P>The rules for converting strings to numbers have changed. In addition to 
  the changes that apply when XPath 1.0 compatibility mode is true, when 
  compatibility mode is false the strings <CODE>Infinity</CODE> and 
  <CODE>-Infinity</CODE> are no longer recognized as representations of positive 
  and negative infinity. Note also that while the <CODE>number</CODE> function 
  continues to convert all unrecognized strings to <CODE>NaN</CODE>, operations 
  that cast a string to a number react to such strings with a dynamic error.</P>
  <LI>
  <P>Many operations in XPath 2.0 produce an empty sequence as their result when 
  one of the arguments or operands is an empty sequence. Where the operation 
  expects a string, an empty sequence is usually considered equivalent to a 
  zero-length string, which is compatible with the XPath 1.0 behavior. Where the 
  operation expects a number, however, the result is not the same. For example, 
  if <CODE>@width</CODE> returns an empty sequence, then in XPath 1.0 the result 
  of <CODE>@width+1</CODE> was <CODE>NaN</CODE>, while with XPath 2.0 it is 
  <CODE>()</CODE>. This has the effect that a filter expression such as 
  <CODE>item[@width+1 != 2]</CODE> will select items having no 
  <CODE>width</CODE> attribute under XPath 1.0, and will not select them under 
  XPath 2.0.</P>
  <LI>
  <P>The typed value of a comment node, processing instruction node, or 
  namespace node under XPath 2.0 is of type <CODE>xs:string</CODE>, not 
  <CODE>xs:untypedAtomic</CODE>. This means that no implicit conversions are 
  applied if the value is used in a context where a number is expected. If a 
  processing-instruction node is used as an operand of an arithmetic operator, 
  for example, XPath 1.0 would attempt to convert the string value of the node 
  to a number (and deliver <CODE>NaN</CODE> if unsuccessful), while XPath 2.0 
  will report a type error.</P>
  <LI>
  <P>In XPath 1.0, it was defined that with an expression of the form <CODE>A 
  and B</CODE>, B would not be evaluated if A was false. Similarly in the case 
  of <CODE>A or B</CODE>, B would not be evaluated if A was true. This is no 
  longer guaranteed with XPath 2.0: the implementation is free to evaluate the 
  two operands in either order or in parallel. This change has been made to give 
  more scope for optimization in situations where XPath expressions are 
  evaluated against large data collections supported by indexes. Implementations 
  may choose to retain backwards compatibility in this area, but they are not 
  obliged to do so.</P></LI></OL></DIV>
<DIV class=div2>
<H3><A id=id-incompat-when-using-schema 
name=id-incompat-when-using-schema></A>I.3 Incompatibilities when using a 
Schema</H3>
<P>An XPath expression applied to a document that has been processed against a 
schema will not always give the same results as the same expression applied to 
the same document in the absence of a schema. Since schema processing had no 
effect on the result of an XPath 1.0 expression, this may give rise to further 
incompatibilities. This section gives a few examples of the differences that can 
arise.</P>
<P>Suppose that the context node is an element node derived from the following 
markup: <CODE>&lt;background color="red green blue"/&gt;</CODE>. In XPath 1.0, 
the predicate <CODE>[@color="blue"]</CODE> would return <CODE>false</CODE>. In 
XPath 2.0, if the <CODE>color</CODE> attribute is defined in a schema to be of 
type <CODE>xs:NMTOKENS</CODE>, the same predicate will return 
<CODE>true</CODE>.</P>
<P>Similarly, consider the expression <CODE>@birth &lt; @death</CODE> applied to 
the element <CODE>&lt;person birth="1901-06-06" death="1991-05-09"/&gt;</CODE>. 
With XPath 1.0, this expression would return false, because both attributes are 
converted to numbers, which returns <CODE>NaN</CODE> in each case. With XPath 
2.0, in the presence of a schema that annotates these attributes as dates, the 
expression returns <CODE>true</CODE>.</P>
<P>Once schema validation is applied, elements and attributes cannot be used as 
operands and arguments of expressions that expect a different data type. For 
example, it is no longer possible to apply the <CODE>substring</CODE> function 
to a date to extract the year component, or to a number to extract the integer 
part. Similarly, if an attribute is annotated as a boolean then it is not 
possible to compare it with the strings <CODE>"true"</CODE> or 
<CODE>"false"</CODE>. All such operations lead to type errors. The remedy when 
such errors occur is to introduce an explicit conversion, or to do the 
computation in a different way. For example, <CODE>substring-after(@temperature, 
"-")</CODE> might be rewritten as <CODE>abs(@temperature)</CODE>.</P>
<P>In the case of an XPath 2.0 implementation that provides the static typing 
feature, many further type errors will be reported in respect of expressions 
that worked under XPath 1.0. For example, an expression such as 
<CODE>round(../@price)</CODE> might lead to a static type error because the 
processor cannot infer statically that <CODE>../@price</CODE> is guaranteed to 
be numeric.</P>
<P>Schema validation will in many cases perform whitespace normalization on the 
contents of elements (depending on their type). This will change the result of 
operations such as the <CODE>string-length</CODE> function.</P>
<P>Schema validation augments the data model by adding default values for 
omitted attributes and empty elements.</P></DIV></DIV></DIV>
<DIV class=div1>
<H2><A id=id-revisions-log name=id-revisions-log></A>J Revision Log 
(Non-Normative)</H2>
<DIV class=xpath>
<P class=xpath>No substantive changes have been made to this document since the 
Proposed Recommendation Draft of 21 November 
2006.</P></DIV></DIV></DIV></BODY></HTML>
