<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0047)http://www.w3.org/TR/2007/REC-xqueryx-20070123/ -->
<?xml version="1.0" encoding="utf-8"?><HTML lang=EN xml:lang="EN" 
xmlns="http://www.w3.org/1999/xhtml"><HEAD><TITLE>XML Syntax for XQuery 1.0 (XQueryX)</TITLE>
<META http-equiv=Content-Type content="text/html; charset=utf-8">
<META content="MSHTML 6.00.2900.3020" name=GENERATOR>
<STYLE type=text/css>CODE {
	FONT-FAMILY: monospace
}
DIV.constraint {
	MARGIN-LEFT: 2em
}
DIV.issue {
	MARGIN-LEFT: 2em
}
DIV.note {
	MARGIN-LEFT: 2em
}
DIV.notice {
	MARGIN-LEFT: 2em
}
DIV.issue P.title {
	MARGIN-LEFT: -2em
}
OL.enumar {
	LIST-STYLE-TYPE: decimal
}
OL.enumla {
	LIST-STYLE-TYPE: lower-alpha
}
OL.enumlr {
	LIST-STYLE-TYPE: lower-roman
}
OL.enumua {
	LIST-STYLE-TYPE: upper-alpha
}
OL.enumur {
	LIST-STYLE-TYPE: upper-roman
}
LI P {
	MARGIN-TOP: 0.3em; MARGIN-BOTTOM: 0.3em
}
SUP SMALL {
	COLOR: #8f8f8f; FONT-STYLE: italic
}
DIV.exampleInner PRE {
	MARGIN-TOP: 0em; MARGIN-BOTTOM: 0em; MARGIN-LEFT: 1em
}
DIV.exampleOuter {
	BORDER-RIGHT: gray 4px double; PADDING-RIGHT: 0em; BORDER-TOP: gray 4px double; PADDING-LEFT: 0em; PADDING-BOTTOM: 0em; MARGIN: 0em; BORDER-LEFT: gray 4px double; PADDING-TOP: 0em; BORDER-BOTTOM: gray 4px double
}
DIV.exampleInner {
	PADDING-RIGHT: 4px; BORDER-TOP: #d3d3d3 4px double; PADDING-LEFT: 4px; PADDING-BOTTOM: 4px; MARGIN: 0em; PADDING-TOP: 4px; BORDER-BOTTOM: #d3d3d3 4px double; BACKGROUND-COLOR: #d5dee3
}
DIV.exampleWrapper {
	MARGIN: 4px
}
DIV.exampleHeader {
	FONT-WEIGHT: bold; MARGIN: 4px
}
DIV.issue {
	MARGIN-BOTTOM: 20pt; BORDER-BOTTOM: black 1pt solid
}
TH.issue-toc-head {
	BORDER-BOTTOM: black 1pt solid
}
</STYLE>
<LINK href="REC-xqueryx-20070123_files/W3C-REC.css" type=text/css 
rel=stylesheet></HEAD>
<BODY>
<DIV class=head>
<P><A href="http://www.w3.org/"><IMG height=48 alt=W3C 
src="REC-xqueryx-20070123_files/w3c_home.png" width=72></A></P>
<H1><A id=title name=title></A>XML Syntax for XQuery 1.0 (XQueryX)</H1>
<H2><A id=w3c-doctype name=w3c-doctype></A>W3C Recommendation 23 January 
2007</H2>
<DL>
  <DT>This version: 
  <DD><A 
  href="http://www.w3.org/TR/2007/REC-xqueryx-20070123">http://www.w3.org/TR/2007/REC-xqueryx-20070123</A> 

  <DT>Latest version: 
  <DD><A href="http://www.w3.org/TR/xqueryx">http://www.w3.org/TR/xqueryx</A> 
  <DT>Previous version: 
  <DD><A 
  href="http://www.w3.org/TR/2006/PR-xqueryx-20061121">http://www.w3.org/TR/2006/PR-xqueryx-20061121</A> 

  <DT>Editors: 
  <DD>Jim Melton, Oracle <A 
  href="mailto:jim.melton@oracle.com">mailto:jim.melton@oracle.com</A> 
  <DD>Subramanian Muralidhar, Microsoft </DD></DL>
<P>Please refer to the <A 
href="http://www.w3.org/XML/2007/qt-errata/xqueryx-errata.html"><STRONG>errata</STRONG></A> 
for this document, which may include some normative corrections.</P>
<P>See also <A 
href="http://www.w3.org/2003/03/Translations/byTechnology?technology=xqueryx"><STRONG>translations</STRONG></A>.</P>
<P>This document is also available in these non-normative formats: <A 
href="http://www.w3.org/TR/2007/REC-xqueryx-20070123/xqueryx.xml">XML</A> 
and&nbsp;<A 
href="http://www.w3.org/TR/2007/REC-xqueryx-20070123/diff-from-20061121.html"> 
Revisions from PR draft</A>.</P>
<P class=copyright><A 
href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</A>&nbsp;©&nbsp;2007&nbsp;<A 
href="http://www.w3.org/"> <ACRONYM 
title="World Wide Web Consortium">W3C</ACRONYM></A><SUP>®</SUP> (<A 
href="http://www.csail.mit.edu/"><ACRONYM 
title="Massachusetts Institute of Technology">MIT</ACRONYM></A>, <A 
href="http://www.ercim.org/"><ACRONYM 
title="European Research Consortium for Informatics and Mathematics">ERCIM</ACRONYM></A>, 
<A href="http://www.keio.ac.jp/">Keio</A>), All Rights Reserved. W3C <A 
href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</A>, 
<A 
href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</A> 
and <A href="http://www.w3.org/Consortium/Legal/copyright-documents">document 
use</A> rules apply.</P></DIV>
<HR>

<DIV>
<H2><A id=abstract name=abstract></A>Abstract</H2>
<P>This document defines an XML Syntax for <A 
href="http://www.w3.org/TR/2007/REC-xqueryx-20070123/#xquery">[XQuery 1.0: An 
XML Query Language]</A>.</P></DIV>
<DIV>
<H2><A id=status name=status></A>Status of this Document</H2>
<P><EM>This section describes the status of this document at the time of its 
publication. Other documents may supersede this document. A list of current W3C 
publications and the latest revision of this technical report can be found in 
the <A href="http://www.w3.org/TR/">W3C technical reports index</A> at 
http://www.w3.org/TR/.</EM></P>
<P>This is one document in a set of eight documents that have progressed to 
Recommendation together (XQuery 1.0, XQueryX 1.0, XSLT 2.0, Data Model, 
Functions and Operators, Formal Semantics, Serialization, XPath 2.0).</P>
<P>This is a <A 
href="http://www.w3.org/2004/02/Process-20040205/tr.html#RecsW3C">Recommendation</A> 
of the W3C. It has been developed by the W3C <A 
href="http://www.w3.org/XML/Query">XML Query Working Group</A>, which is part of 
the <A href="http://www.w3.org/XML/Activity">XML Activity</A>.</P>
<P>This document has been reviewed by W3C Members, by software developers, and 
by other W3C groups and interested parties, and is endorsed by the Director as a 
W3C Recommendation. It is a stable document and may be used as reference 
material or cited from another document. W3C's role in making the Recommendation 
is to draw attention to the specification and to promote its widespread 
deployment. This enhances the functionality and interoperability of the Web.</P>
<P>This document incorporates minor changes made against the <A 
href="http://www.w3.org/2004/02/Process-20040205/tr.html#RecsPR">Proposed 
Recommendation</A> of 21 November 2006; please see the public disposition of 
comments for details. Changes to this document since the <A 
href="http://www.w3.org/2004/02/Process-20040205/tr.html#RecsPR">Proposed 
Recommendation</A> are detailed in the <A 
href="http://www.w3.org/TR/2007/REC-xqueryx-20070123/#changelog"><B>D Change 
log</B></A>.</P>
<P>Please report errors in this document using W3C's <A 
href="http://www.w3.org/Bugs/Public/">public Bugzilla system</A> (instructions 
can be found at <A 
href="http://www.w3.org/XML/2005/04/qt-bugzilla">http://www.w3.org/XML/2005/04/qt-bugzilla</A>). 
If access to that system is not feasible, you may send your comments to the W3C 
XSLT/XPath/XQuery public comments mailing list, <A 
href="mailto:public-qt-comments@w3.org">public-qt-comments@w3.org</A>. It will 
be very helpful if you include the string “[XQX]” in the subject line of your 
report, whether made in Bugzilla or in email. Each Bugzilla entry and email 
message should contain only one error report. Archives of the comments and 
responses are available at <A 
href="http://lists.w3.org/Archives/Public/public-qt-comments/">http://lists.w3.org/Archives/Public/public-qt-comments/</A>.</P>
<P>This document was produced by a group operating under the <A 
href="http://www.w3.org/Consortium/Patent-Policy-20040205/">5 February 2004 W3C 
Patent Policy</A>. W3C maintains a <A 
href="http://www.w3.org/2004/01/pp-impl/18797/status#disclosures">public list of 
any patent disclosures</A> made in connection with the deliverables of the 
group; that page also includes instructions for disclosing a patent. An 
individual who has actual knowledge of a patent which the individual believes 
contains <A 
href="http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">Essential 
Claim(s)</A> must disclose the information in accordance with <A 
href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">section 
6 of the W3C Patent Policy</A>.</P></DIV>
<DIV class=toc>
<H2><A id=contents name=contents></A>Table of Contents</H2>
<P class=toc>1 <A 
href="REC-xqueryx-20070123.htm#Introduction">Introduction</A><BR>2 
<A href="REC-xqueryx-20070123.htm#Mapping">Mapping the 
XQuery Syntax</A><BR>3 <A 
href="REC-xqueryx-20070123.htm#Examples">Examples from 
the XML Query Use Cases in XML Syntax</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;3.1 <A 
href="REC-xqueryx-20070123.htm#Example1">Example 
1</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.1.1 <A 
href="REC-xqueryx-20070123.htm#Example1-XQuery">XQuery 
solution in XQuery Use 
Cases:</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.1.2 <A 
href="REC-xqueryx-20070123.htm#Example1-XQueryX">A 
Solution in 
XQueryX:</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.1.3 <A 
href="REC-xqueryx-20070123.htm#Example1-Transformation">Transformation 
of XQueryX Solution into 
XQuery</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.1.4 <A 
href="REC-xqueryx-20070123.htm#Example1-Abstract">Corresponding 
Grammar Abstract Parse Tree</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;3.2 <A 
href="REC-xqueryx-20070123.htm#Example2">Example 
2</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.2.1 <A 
href="REC-xqueryx-20070123.htm#Example2-XQuery">XQuery 
solution in XQuery Use 
Cases:</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.2.2 <A 
href="REC-xqueryx-20070123.htm#Example2-XQueryX">A 
solution in 
XQueryX:</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.2.3 <A 
href="REC-xqueryx-20070123.htm#Example2-Transformation">Transformation 
of XQueryX Solution into XQuery</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;3.3 <A 
href="REC-xqueryx-20070123.htm#Example3">Example 
3</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.3.1 <A 
href="REC-xqueryx-20070123.htm#Example3-XQuery">XQuery 
solution in XQuery Use 
Cases:</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.3.2 <A 
href="REC-xqueryx-20070123.htm#Example3-XQueryX">A 
solution in 
XQueryX:</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.3.3 <A 
href="REC-xqueryx-20070123.htm#Example3-Transformation">Transformation 
of XQueryX Solution into XQuery</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;3.4 <A 
href="REC-xqueryx-20070123.htm#Example4">Example 
4</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.4.1 <A 
href="REC-xqueryx-20070123.htm#Example4-XQuery">XQuery 
solution in XQuery Use 
Cases:</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.4.2 <A 
href="REC-xqueryx-20070123.htm#Example4-XQueryX">A 
solution in 
XQueryX:</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.4.3 <A 
href="REC-xqueryx-20070123.htm#Example4-Transformation">Transformation 
of XQueryX Solution into XQuery</A><BR>4 <A 
href="REC-xqueryx-20070123.htm#Schema">An XML Schema for 
the XQuery XML Syntax</A><BR>5 <A 
href="REC-xqueryx-20070123.htm#xqx_conformance">Conformance</A><BR></P>
<H3><A id=appendices name=appendices></A>Appendices</H3>
<P class=toc>A <A 
href="REC-xqueryx-20070123.htm#biblio">References</A><BR>B 
<A 
href="REC-xqueryx-20070123.htm#Stylesheet">Transforming 
XQueryX to XQuery</A><BR>C <A 
href="REC-xqueryx-20070123.htm#xqueryx-id-mime-type">The 
application/xquery+xml Media Type</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;C.1 <A 
href="REC-xqueryx-20070123.htm#xqueryx-mime-introduction">Introduction</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;C.2 
<A 
href="REC-xqueryx-20070123.htm#xqueryx-mime-registration">Registration 
of MIME Media Type 
application/xquery+xml</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C.2.1 
<A 
href="REC-xqueryx-20070123.htm#xqueryx-mime-encoding">Encoding 
Considerations</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C.2.2 <A 
href="REC-xqueryx-20070123.htm#xqueryx-mime-security">Security 
Considerations</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C.2.3 <A 
href="REC-xqueryx-20070123.htm#xqueryx-mime-interoperability">Interoperability 
Considerations</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C.2.4 <A 
href="REC-xqueryx-20070123.htm#xqueryx-mime-pubspec">Published 
specification</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C.2.5 <A 
href="REC-xqueryx-20070123.htm#xqueryx-mime-applications">Applications 
That Use This Media 
Type</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C.2.6 <A 
href="REC-xqueryx-20070123.htm#xqueryx-mime-additional">Additional 
Information</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C.2.6.1 
<A 
href="REC-xqueryx-20070123.htm#xqueryx-mime-recognizing">Recognizing 
XQuery Files ("Magic 
Numbers")</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C.2.6.2 
<A 
href="REC-xqueryx-20070123.htm#xqueryx-mime-extensions">File 
Extensions</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C.2.6.3 
<A 
href="REC-xqueryx-20070123.htm#xqueryx-mime-macfiletype">Macintosh 
File Type Code(s)</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C.2.7 
<A 
href="REC-xqueryx-20070123.htm#xqueryx-mime-author">Person 
and Email Address to Contact For Further 
Information</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C.2.8 <A 
href="REC-xqueryx-20070123.htm#xqueryx-mime-intended-usage">Intended 
Usage</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C.2.9 <A 
href="REC-xqueryx-20070123.htm#xqueryx-mime-restrictions">Restrictions 
on usage</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C.2.10 <A 
href="REC-xqueryx-20070123.htm#xqueryx-mime-owner">Author/Change 
Controller</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C.2.11 <A 
href="REC-xqueryx-20070123.htm#xqueryx-mime-fragments">Fragment 
Identifiers</A><BR>D <A 
href="REC-xqueryx-20070123.htm#changelog">Change log</A> 
(Non-Normative)<BR></P></DIV>
<HR>

<DIV class=body>
<DIV class=div1>
<H2><A id=Introduction name=Introduction></A>1 Introduction</H2>
<P>The <A 
href="REC-xqueryx-20070123.htm#xquery-requirements">[XML 
Query 1.0 Requirements]</A> states that "The XML Query Language MAY have more 
than one syntax binding. One query language syntax MUST be convenient for humans 
to read and write. One query language syntax MUST be expressed in XML in a way 
that reflects the underlying structure of the query."</P>
<P>XQueryX is an XML representation of an XQuery. It was created by mapping the 
productions of the XQuery grammar into XML productions. The result is not 
particularly convenient for humans to read and write, but it is easy for 
programs to parse, and because XQueryX is represented in XML, standard XML tools 
can be used to create, interpret, or modify queries.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>Because the two syntaxes are merely different grammars that express the same 
query semantics, they share all aspects of an XQuery processing system except 
for the component that recognizes and translates the source representation of a 
query (that is, the parser). The aspects that are shared include both the static 
context and the dynamic context that are defined in <A 
href="REC-xqueryx-20070123.htm#xquery">[XQuery 1.0: An 
XML Query Language]</A>.</P></DIV>
<P>There are several environments in which XQueryX may be useful:</P>
<UL>
  <LI>
  <P><EM>Parser Reuse.</EM> In heterogeneous environments, a variety of systems 
  may be used to execute a query. One parser can generate XQueryX for all of 
  these systems.</P>
  <LI>
  <P><EM>Queries on Queries.</EM> Because XQueryX is represented in XML, queries 
  can be queried and can be transformed into new queries. For instance, a query 
  can be performed against a set of XQueryX queries to determine which queries 
  use FLWOR expressions to range over a set of invoices.</P>
  <LI>
  <P><EM>Generating Queries.</EM> In some XML-oriented programming environments, 
  it may be more convenient to build a query in its XQueryX representation than 
  in the corresponding XQuery representation, since ordinary XML tools can be 
  used.</P>
  <LI>
  <P><EM>Embedding Queries in XML.</EM> XQueryX can be embedded directly in an 
  XML document.</P></LI></UL>
<P>The most recent versions of the XQueryX XML Schema and the XQueryX XSLT 
stylesheet are available at <A 
href="http://www.w3.org/2005/XQueryX/xqueryx.xsd">http://www.w3.org/2005/XQueryX/xqueryx.xsd</A> 
and <A 
href="http://www.w3.org/2005/XQueryX/xqueryx.xsl">http://www.w3.org/2005/XQueryX/xqueryx.xsl</A>, 
respectively.</P></DIV>
<DIV class=div1>
<H2><A id=Mapping name=Mapping></A>2 Mapping the XQuery Syntax</H2>
<P>XQueryX is an XML representation of the abstract syntax found in Appendix A 
of <A href="REC-xqueryx-20070123.htm#xquery">[XQuery 1.0: 
An XML Query Language]</A>. The XQueryX syntax is defined by the XQueryX Schema, 
which is specified in <A 
href="REC-xqueryx-20070123.htm#Schema"><B>4 An XML Schema 
for the XQuery XML Syntax</B></A>. The XQueryX semantics are defined by a 
stylesheet that maps an instance of XQueryX to an instance of XQuery; see <A 
href="REC-xqueryx-20070123.htm#Stylesheet"><B>B 
Transforming XQueryX to XQuery</B></A>.</P>
<P>The main data structure in the XQueryX Schema is the set of types that 
describe expressions. We have chosen to model expressions using substitution 
groups, with an "expr" abstract base class and a number of intermediate abstract 
classes.</P>
<P>Consider the following productions from the abstract syntax:</P>
<DIV class=exampleInner><PRE>
FLWORExpr    ::=    (ForClause  | LetClause)+ WhereClause? OrderByClause? "return" ExprSingle 
ForClause    ::=    "for" "$" VarName TypeDeclaration? PositionalVar? "in" 
                    ExprSingle ("," "$" VarName TypeDeclaration? PositionalVar? 
                    "in" ExprSingle)* 
LetClause    ::=    "let" "$" VarName TypeDeclaration? ":=" ExprSingle
                    ("," "$" VarName TypeDeclaration? ":=" ExprSingle)*
WhereClause  ::=    "where" ExprSingle
</PRE></DIV>
<P>The following XQueryX Schema definitions reflect the structure of those 
productions from that abstract syntax:</P>
<DIV class=exampleInner><PRE>

  
&lt;!-- The base class --&gt;
  &lt;xsd:complexType name="expr"/&gt;
  &lt;xsd:element name="expr" type="expr" abstract="true"/&gt;
  
  &lt;!-- Simple wrapper class --&gt;
  &lt;xsd:complexType name="exprWrapper"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="expr"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;
  
  &lt;xsd:complexType name="flworExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:choice maxOccurs="unbounded"&gt;
            &lt;xsd:element ref="forClause"/&gt;
            &lt;xsd:element ref="letClause"/&gt;
          &lt;/xsd:choice&gt;
          &lt;xsd:element name="whereClause" minOccurs="0"/&gt;
          &lt;xsd:element name="orderByClause" minOccurs="0"/&gt;
          &lt;xsd:element name="returnClause"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="flworExpr" type="flworExpr" substitutionGroup="expr"/&gt;

  &lt;xsd:element name="forClause"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element ref="forClauseItem" maxOccurs="unbounded"/&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:element name="forClauseItem"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element ref="typedVariableBinding"/&gt;
        &lt;xsd:element ref="positionalVariableBinding" minOccurs="0"/&gt;
        &lt;xsd:element name="forExpr" type="exprWrapper"/&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:element name="letClause"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element ref="letClauseItem" maxOccurs="unbounded"/&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:element name="letClauseItem"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element ref="typedVariableBinding"/&gt;
        &lt;xsd:element name="letExpr" type="exprWrapper"/&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:element name="whereClause" type="exprWrapper"/&gt;

  &lt;xsd:element name="returnClause" type="exprWrapper"/&gt;
</PRE></DIV>
<P>Since XQuery uses the expression production liberally to allow expressions to 
be flexibly combined, XQueryX uses the exprWrapper type in embedded contexts to 
allow all expression types to occur.</P></DIV>
<DIV class=div1>
<H2><A id=Examples name=Examples></A>3 Examples from the XML Query Use Cases in 
XML Syntax</H2>
<P>Three of following examples are based on the data and queries in the XMP 
(Experiences and Exemplars) use case in <A 
href="REC-xqueryx-20070123.htm#xquery-use-cases">[XML 
Query Use Cases]</A>, while a fourth example is based on the data and queries in 
the NS (Queries Using Namespaces) use case. For each example, we show the 
English description of the query, the XQuery solution given in <A 
href="REC-xqueryx-20070123.htm#xquery-use-cases">[XML 
Query Use Cases]</A>, an XQueryX solution, and the XQuery that results from 
applying the XQueryX-to-XQuery transformation defined by the stylesheet in <A 
href="REC-xqueryx-20070123.htm#Stylesheet"><B>B 
Transforming XQueryX to XQuery</B></A> to the XQueryX solution. That produced 
XQuery is presented only as a sanity-check — the intent of the stylesheet is not 
to create the identical XQuery expression given in <A 
href="REC-xqueryx-20070123.htm#xquery-use-cases">[XML 
Query Use Cases]</A>, but to produce <EM>a</EM> valid XQuery expression with the 
same semantics. The semantics of the XQueryX solution are determined by the 
semantics of the XQuery expression that results from that transformation. The 
"correctness" of that transformation is determined by asking the following the 
question: Can some XQueryX processor QX process some XQueryX document D1 to 
produce results R1, after which the stylesheet is used to translate D1 into an 
XQuery expression E1 that, when processed by some XQuery processor Q, produces 
results R2 that are equivalent (under some meaningful definition of 
"equivalent") to results R1?</P>
<P>Comparison of the results of the XQueryX-to-XQuery transformation given in 
this document with the XQuery solutions in the <A 
href="REC-xqueryx-20070123.htm#xquery-use-cases">[XML 
Query Use Cases]</A> may be helpful in evaluating the correctness of the XQueryX 
solution in each example.</P>
<P>The XQuery Use Cases solution given for each example is provided only to 
assist readers of this document in understanding the XQueryX solution. There is 
no intent to imply that this document specifies a "compilation" or 
"transformation" of XQuery syntax into XQueryX syntax.</P>
<P>In the following examples, note that path expressions are expanded to show 
their structure. Also, note that the prefix syntax for binary operators like 
"and" makes the precedence explicit. In general, humans find it easier to read 
an XML representation that does not expand path expressions, but it is less 
convenient for programmatic representation and manipulation. XQueryX is designed 
as a language that is convenient for production and modification by software, 
and not as a convenient syntax for humans to read and write.</P>
<P>Finally, please note that white space, including new lines, have been added 
to some of the XQueryX documents and XQuery expressions for readability. That 
additional white space is not produced by the XQueryX-to-XQuery 
transformation.</P>
<DIV class=div2>
<H3><A id=Example1 name=Example1></A>3.1 Example 1</H3>
<P>Here is Q1 from the <A 
href="REC-xqueryx-20070123.htm#xquery-use-cases">[XML 
Query Use Cases]</A>, use case XMP (Experiences and Exemplars): "List books 
published by Addison-Wesley after 1991, including their year and title."</P>
<DIV class=div3>
<H4><A id=Example1-XQuery name=Example1-XQuery></A>3.1.1 XQuery solution in 
XQuery Use Cases:</H4>
<DIV class=exampleInner><PRE>&lt;bib&gt;
 {
  for $b in doc("http://bstore1.example.com/bib.xml")/bib/book
  where $b/publisher = "Addison-Wesley" and $b/@year &gt; 1991
  return
    &lt;book year="{ $b/@year }"&gt;
     { $b/title }
    &lt;/book&gt;
 }
&lt;/bib&gt;
</PRE></DIV></DIV>
<DIV class=div3>
<H4><A id=Example1-XQueryX name=Example1-XQueryX></A>3.1.2 A Solution in 
XQueryX:</H4>
<DIV class=exampleInner><PRE>&lt;?xml version="1.0"?&gt;
&lt;xqx:module xmlns:xqx="http://www.w3.org/2005/XQueryX"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://www.w3.org/2005/XQueryX
                                http://www.w3.org/2005/XQueryX/xqueryx.xsd"&gt;
  &lt;xqx:mainModule&gt;
    &lt;xqx:queryBody&gt;
      &lt;xqx:elementConstructor&gt;
        &lt;xqx:tagName&gt;bib&lt;/xqx:tagName&gt;
        &lt;xqx:elementContent&gt;
          &lt;xqx:flworExpr&gt;
            &lt;xqx:forClause&gt;
              &lt;xqx:forClauseItem&gt;
                &lt;xqx:typedVariableBinding&gt;
                  &lt;xqx:varName&gt;b&lt;/xqx:varName&gt;
                &lt;/xqx:typedVariableBinding&gt;
                &lt;xqx:forExpr&gt;
                  &lt;xqx:pathExpr&gt;
                    &lt;xqx:stepExpr&gt;
                      &lt;xqx:filterExpr&gt;
                        &lt;xqx:functionCallExpr&gt;
                          &lt;xqx:functionName&gt;doc&lt;/xqx:functionName&gt;
                          &lt;xqx:arguments&gt;
                            &lt;xqx:stringConstantExpr&gt;
                              &lt;xqx:value&gt;http://bstore1.example.com/bib.xml&lt;/xqx:value&gt;
                            &lt;/xqx:stringConstantExpr&gt;
                          &lt;/xqx:arguments&gt;
                        &lt;/xqx:functionCallExpr&gt;
                      &lt;/xqx:filterExpr&gt;
                    &lt;/xqx:stepExpr&gt;
                    &lt;xqx:stepExpr&gt;
                      &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                      &lt;xqx:nameTest&gt;bib&lt;/xqx:nameTest&gt;
                    &lt;/xqx:stepExpr&gt;
                    &lt;xqx:stepExpr&gt;
                      &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                      &lt;xqx:nameTest&gt;book&lt;/xqx:nameTest&gt;
                    &lt;/xqx:stepExpr&gt;
                  &lt;/xqx:pathExpr&gt;
                &lt;/xqx:forExpr&gt;
              &lt;/xqx:forClauseItem&gt;
            &lt;/xqx:forClause&gt;
            &lt;xqx:whereClause&gt;
              &lt;xqx:andOp&gt;
                &lt;xqx:firstOperand&gt;
                  &lt;xqx:equalOp&gt;
                    &lt;xqx:firstOperand&gt;
                      &lt;xqx:pathExpr&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:filterExpr&gt;
                            &lt;xqx:varRef&gt;
                              &lt;xqx:name&gt;b&lt;/xqx:name&gt;
                            &lt;/xqx:varRef&gt;
                          &lt;/xqx:filterExpr&gt;
                        &lt;/xqx:stepExpr&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                          &lt;xqx:nameTest&gt;publisher&lt;/xqx:nameTest&gt;
                        &lt;/xqx:stepExpr&gt;
                      &lt;/xqx:pathExpr&gt;
                    &lt;/xqx:firstOperand&gt;
                    &lt;xqx:secondOperand&gt;
                      &lt;xqx:stringConstantExpr&gt;
                        &lt;xqx:value&gt;Addison-Wesley&lt;/xqx:value&gt;
                      &lt;/xqx:stringConstantExpr&gt;
                    &lt;/xqx:secondOperand&gt;
                  &lt;/xqx:equalOp&gt;
                &lt;/xqx:firstOperand&gt;
                &lt;xqx:secondOperand&gt;
                  &lt;xqx:greaterThanOp&gt;
                    &lt;xqx:firstOperand&gt;
                      &lt;xqx:pathExpr&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:filterExpr&gt;
                            &lt;xqx:varRef&gt;
                              &lt;xqx:name&gt;b&lt;/xqx:name&gt;
                            &lt;/xqx:varRef&gt;
                          &lt;/xqx:filterExpr&gt;
                        &lt;/xqx:stepExpr&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:xpathAxis&gt;attribute&lt;/xqx:xpathAxis&gt;
                          &lt;xqx:nameTest&gt;year&lt;/xqx:nameTest&gt;
                        &lt;/xqx:stepExpr&gt;
                      &lt;/xqx:pathExpr&gt;
                    &lt;/xqx:firstOperand&gt;
                    &lt;xqx:secondOperand&gt;
                      &lt;xqx:integerConstantExpr&gt;
                        &lt;xqx:value&gt;1991&lt;/xqx:value&gt;
                      &lt;/xqx:integerConstantExpr&gt;
                    &lt;/xqx:secondOperand&gt;
                  &lt;/xqx:greaterThanOp&gt;
                &lt;/xqx:secondOperand&gt;
              &lt;/xqx:andOp&gt;
            &lt;/xqx:whereClause&gt;
            &lt;xqx:returnClause&gt;
              &lt;xqx:elementConstructor&gt;
                &lt;xqx:tagName&gt;book&lt;/xqx:tagName&gt;
                &lt;xqx:attributeList&gt;
                  &lt;xqx:attributeConstructor&gt;
                    &lt;xqx:attributeName&gt;year&lt;/xqx:attributeName&gt;
                    &lt;xqx:attributeValueExpr&gt;
                      &lt;xqx:pathExpr&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:filterExpr&gt;
                            &lt;xqx:varRef&gt;
                              &lt;xqx:name&gt;b&lt;/xqx:name&gt;
                            &lt;/xqx:varRef&gt;
                          &lt;/xqx:filterExpr&gt;
                        &lt;/xqx:stepExpr&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:xpathAxis&gt;attribute&lt;/xqx:xpathAxis&gt;
                          &lt;xqx:nameTest&gt;year&lt;/xqx:nameTest&gt;
                        &lt;/xqx:stepExpr&gt;
                      &lt;/xqx:pathExpr&gt;
                    &lt;/xqx:attributeValueExpr&gt;
                  &lt;/xqx:attributeConstructor&gt;
                &lt;/xqx:attributeList&gt;
                &lt;xqx:elementContent&gt;
                  &lt;xqx:pathExpr&gt;
                    &lt;xqx:stepExpr&gt;
                      &lt;xqx:filterExpr&gt;
                        &lt;xqx:varRef&gt;
                          &lt;xqx:name&gt;b&lt;/xqx:name&gt;
                        &lt;/xqx:varRef&gt;
                      &lt;/xqx:filterExpr&gt;
                    &lt;/xqx:stepExpr&gt;
                    &lt;xqx:stepExpr&gt;
                      &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                      &lt;xqx:nameTest&gt;title&lt;/xqx:nameTest&gt;
                    &lt;/xqx:stepExpr&gt;
                  &lt;/xqx:pathExpr&gt;
                &lt;/xqx:elementContent&gt;
              &lt;/xqx:elementConstructor&gt;
            &lt;/xqx:returnClause&gt;
          &lt;/xqx:flworExpr&gt;
        &lt;/xqx:elementContent&gt;
      &lt;/xqx:elementConstructor&gt;
    &lt;/xqx:queryBody&gt;
  &lt;/xqx:mainModule&gt;
&lt;/xqx:module&gt;
</PRE></DIV></DIV>
<DIV class=div3>
<H4><A id=Example1-Transformation name=Example1-Transformation></A>3.1.3 
Transformation of XQueryX Solution into XQuery</H4>
<P>Application of the stylesheet in <A 
href="REC-xqueryx-20070123.htm#Stylesheet"><B>B 
Transforming XQueryX to XQuery</B></A> to the XQueryX solution results in:</P>
<DIV class=exampleInner><PRE>  
&lt;bib&gt;{
 for $b in doc("http://bstore1.example.com/bib.xml")/child::bib/child::book
 where (($b/child::publisher = "Addison-Wesley") and ($b/attribute::year &gt; 1991))
 return &lt;book year="{$b/attribute::year}"&gt;{$b/child::title}&lt;/book&gt;
}&lt;/bib&gt;
</PRE></DIV></DIV>
<DIV class=div3>
<H4><A id=Example1-Abstract name=Example1-Abstract></A>3.1.4 Corresponding 
Grammar Abstract Parse Tree</H4>
<P>For comparison, here is the abstract parse tree corresponding to the XQuery 
for Example 1, as produced by the XQuery grammar applets found at <A 
href="http://www.w3.org/2005/qt-applets/xqueryApplet.html">http://www.w3.org/2005/qt-applets/xqueryApplet.html</A>.</P>
<DIV class=exampleInner><PRE>XPath2
  QueryList
    Module
      MainModule
        Prolog
        QueryBody
          Expr
            PathExpr
              Constructor
                DirectConstructor
                  DirElemConstructor &gt;
                    LessThanOpOrTagO &lt;
                    TagQName bib
                    DirAttributeList
                    StartTagClose &gt;
                    DirElemContent
                      ElementContentChar 
                    DirElemContent
                      ElementContentChar  
                    DirElemContent
                      CommonContent
                        EnclosedExpr
                          Lbrace {
                          Expr
                            FLWORExpr
                              ForClause
                                VarName
                                  QName b
                                PathExpr
                                  FunctionCall
                                    FunctionQName doc
                                    PathExpr
                                      StringLiteral "http://bstore1.example.com/bib.xml"
                                  StepExpr
                                    AbbrevForwardStep
                                      NodeTest
                                        NameTest
                                          QName bib
                                  StepExpr
                                    AbbrevForwardStep
                                      NodeTest
                                        NameTest
                                          QName book
                              WhereClause
                                AndExpr and
                                  ComparisonExpr =
                                    PathExpr
                                      VarName
                                        QName b
                                      StepExpr
                                        AbbrevForwardStep
                                          NodeTest
                                            NameTest
                                              QName publisher
                                    PathExpr
                                      StringLiteral "Addison-Wesley"
                                  ComparisonExpr &gt;
                                    PathExpr
                                      VarName
                                        QName b
                                      StepExpr
                                        AbbrevForwardStep @
                                          NodeTest
                                            NameTest
                                              QName year
                                    PathExpr
                                      IntegerLiteral 1991
                              PathExpr
                                Constructor
                                  DirectConstructor
                                    DirElemConstructor &gt;
                                      LessThanOpOrTagO &lt;
                                      TagQName book
                                      DirAttributeList
                                        S  
                                        TagQName year
                                        ValueIndicator =
                                        DirAttributeValue
                                          OpenQuot "
                                          QuotAttrValueContent
                                            CommonContent
                                              EnclosedExpr
                                                Lbrace {
                                                Expr
                                                  PathExpr
                                                    VarName
                                                      QName b
                                                    StepExpr
                                                      AbbrevForwardStep @
                                                        NodeTest
                                                          NameTest
                                                            QName year
                                                Rbrace }
                                          CloseQuot "
                                      StartTagClose &gt;
                                      DirElemContent
                                        ElementContentChar 
                                      DirElemContent
                                        ElementContentChar  
                                      DirElemContent
                                        ElementContentChar  
                                      DirElemContent
                                        ElementContentChar  
                                      DirElemContent
                                        ElementContentChar  
                                      DirElemContent
                                        ElementContentChar  
                                      DirElemContent
                                        CommonContent
                                          EnclosedExpr
                                            Lbrace {
                                            Expr
                                              PathExpr
                                                VarName
                                                  QName b
                                                StepExpr
                                                  AbbrevForwardStep
                                                    NodeTest
                                                      NameTest
                                                        QName title
                                            Rbrace }
                                      DirElemContent
                                        ElementContentChar 
                                      DirElemContent
                                        ElementContentChar  
                                      DirElemContent
                                        ElementContentChar  
                                      DirElemContent
                                        ElementContentChar  
                                      DirElemContent &lt;/
                                        ElementContentChar  
                          Rbrace }
                    DirElemContent &lt;/
                      ElementContentChar 
</PRE></DIV></DIV></DIV>
<DIV class=div2>
<H3><A id=Example2 name=Example2></A>3.2 Example 2</H3>
<P>Here is Q4 from the <A 
href="REC-xqueryx-20070123.htm#xquery-use-cases">[XML 
Query Use Cases]</A>, use case XMP (Experiences and Exemplars): "For each author 
in the bibliography, list the author's name and the titles of all books by that 
author, grouped inside a "result" element."</P>
<DIV class=div3>
<H4><A id=Example2-XQuery name=Example2-XQuery></A>3.2.1 XQuery solution in 
XQuery Use Cases:</H4>
<DIV class=exampleInner><PRE>&lt;results&gt;
  {
    let $a := doc("http://bstore1.example.com/bib/bib.xml")//author
    for $last in distinct-values($a/last),
        $first in distinct-values($a[last=$last]/first)
    order by $last, $first
    return
        &lt;result&gt;
            &lt;author&gt;
               &lt;last&gt;{ $last }&lt;/last&gt;
               &lt;first&gt;{ $first }&lt;/first&gt;
            &lt;/author&gt;
            {
                for $b in doc("http://bstore1.example.com/bib.xml")/bib/book
                where some $ba in $b/author 
                      satisfies ($ba/last = $last and $ba/first=$first)
                return $b/title
            }
        &lt;/result&gt;
  }
&lt;/results&gt; 
</PRE></DIV></DIV>
<DIV class=div3>
<H4><A id=Example2-XQueryX name=Example2-XQueryX></A>3.2.2 A solution in 
XQueryX:</H4>
<DIV class=exampleInner><PRE>&lt;?xml version="1.0"?&gt;
&lt;xqx:module xmlns:xqx="http://www.w3.org/2005/XQueryX"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://www.w3.org/2005/XQueryX
                          http://www.w3.org/2005/XQueryX/xqueryx.xsd"&gt;
  &lt;xqx:mainModule&gt;
    &lt;xqx:queryBody&gt;
      &lt;xqx:elementConstructor&gt;
        &lt;xqx:tagName&gt;results&lt;/xqx:tagName&gt;
        &lt;xqx:elementContent&gt;
          &lt;xqx:flworExpr&gt;
            &lt;xqx:letClause&gt;
              &lt;xqx:letClauseItem&gt;
                &lt;xqx:typedVariableBinding&gt;
                  &lt;xqx:varName&gt;a&lt;/xqx:varName&gt;
                &lt;/xqx:typedVariableBinding&gt;
                &lt;xqx:letExpr&gt;
                 &lt;xqx:pathExpr&gt;
                   &lt;xqx:stepExpr&gt;
                     &lt;xqx:filterExpr&gt;
                       &lt;xqx:functionCallExpr&gt;
                         &lt;xqx:functionName&gt;doc&lt;/xqx:functionName&gt;
                         &lt;xqx:arguments&gt;
                           &lt;xqx:stringConstantExpr&gt;
                             &lt;xqx:value&gt;http://bstore1.example.com/bib.xml&lt;/xqx:value&gt;
                           &lt;/xqx:stringConstantExpr&gt;
                         &lt;/xqx:arguments&gt;
                       &lt;/xqx:functionCallExpr&gt;
                     &lt;/xqx:filterExpr&gt;
                   &lt;/xqx:stepExpr&gt;
                   &lt;xqx:stepExpr&gt;
                     &lt;xqx:xpathAxis&gt;descendant-or-self&lt;/xqx:xpathAxis&gt;
                     &lt;xqx:anyKindTest/&gt;
                   &lt;/xqx:stepExpr&gt;
                   &lt;xqx:stepExpr&gt;
                     &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                     &lt;xqx:nameTest&gt;author&lt;/xqx:nameTest&gt;
                   &lt;/xqx:stepExpr&gt;
                 &lt;/xqx:pathExpr&gt;
                &lt;/xqx:letExpr&gt;
              &lt;/xqx:letClauseItem&gt;
            &lt;/xqx:letClause&gt;
            &lt;xqx:forClause&gt;
              &lt;xqx:forClauseItem&gt;
                &lt;xqx:typedVariableBinding&gt;
                  &lt;xqx:varName&gt;last&lt;/xqx:varName&gt;
                &lt;/xqx:typedVariableBinding&gt;
                &lt;xqx:forExpr&gt;
                  &lt;xqx:functionCallExpr&gt;
                    &lt;xqx:functionName&gt;distinct-values&lt;/xqx:functionName&gt;
                    &lt;xqx:arguments&gt;
                      &lt;xqx:pathExpr&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:filterExpr&gt;
                            &lt;xqx:varRef&gt;
                              &lt;xqx:name&gt;a&lt;/xqx:name&gt;
                            &lt;/xqx:varRef&gt;
                          &lt;/xqx:filterExpr&gt;
                        &lt;/xqx:stepExpr&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                          &lt;xqx:nameTest&gt;last&lt;/xqx:nameTest&gt;
                        &lt;/xqx:stepExpr&gt;
                      &lt;/xqx:pathExpr&gt;
                    &lt;/xqx:arguments&gt;
                  &lt;/xqx:functionCallExpr&gt;
                &lt;/xqx:forExpr&gt;
              &lt;/xqx:forClauseItem&gt;
              &lt;xqx:forClauseItem&gt;
                &lt;xqx:typedVariableBinding&gt;
                  &lt;xqx:varName&gt;first&lt;/xqx:varName&gt;
                &lt;/xqx:typedVariableBinding&gt;
                &lt;xqx:forExpr&gt;
                  &lt;xqx:functionCallExpr&gt;
                    &lt;xqx:functionName&gt;distinct-values&lt;/xqx:functionName&gt;
                    &lt;xqx:arguments&gt;
                      &lt;xqx:pathExpr&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:filterExpr&gt;
                            &lt;xqx:varRef&gt;
                              &lt;xqx:name&gt;a&lt;/xqx:name&gt;
                            &lt;/xqx:varRef&gt;
                          &lt;/xqx:filterExpr&gt;
                          &lt;xqx:predicates&gt;
                            &lt;xqx:equalOp&gt;
                              &lt;xqx:firstOperand&gt;
                                &lt;xqx:pathExpr&gt;
                                  &lt;xqx:stepExpr&gt;
                                    &lt;xqx:filterExpr&gt;
                                      &lt;xqx:contextItemExpr/&gt;
                                    &lt;/xqx:filterExpr&gt;
                                  &lt;/xqx:stepExpr&gt;
                                  &lt;xqx:stepExpr&gt;
                                    &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                                    &lt;xqx:nameTest&gt;last&lt;/xqx:nameTest&gt;
                                  &lt;/xqx:stepExpr&gt;
                                &lt;/xqx:pathExpr&gt;
                              &lt;/xqx:firstOperand&gt;
                              &lt;xqx:secondOperand&gt;
                                &lt;xqx:varRef&gt;
                                  &lt;xqx:name&gt;last&lt;/xqx:name&gt;
                                &lt;/xqx:varRef&gt;
                              &lt;/xqx:secondOperand&gt;
                            &lt;/xqx:equalOp&gt;
                          &lt;/xqx:predicates&gt;
                        &lt;/xqx:stepExpr&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                          &lt;xqx:nameTest&gt;first&lt;/xqx:nameTest&gt;
                        &lt;/xqx:stepExpr&gt;
                      &lt;/xqx:pathExpr&gt;
                    &lt;/xqx:arguments&gt;
                  &lt;/xqx:functionCallExpr&gt;
                &lt;/xqx:forExpr&gt;
              &lt;/xqx:forClauseItem&gt;
            &lt;/xqx:forClause&gt;
            &lt;xqx:orderByClause&gt;
              &lt;xqx:orderBySpec&gt;
                &lt;xqx:orderByExpr&gt;
                  &lt;xqx:varRef&gt;
                    &lt;xqx:name&gt;last&lt;/xqx:name&gt;
                  &lt;/xqx:varRef&gt;
                &lt;/xqx:orderByExpr&gt;
              &lt;/xqx:orderBySpec&gt;
              &lt;xqx:orderBySpec&gt;
                &lt;xqx:orderByExpr&gt;
                  &lt;xqx:varRef&gt;
                    &lt;xqx:name&gt;first&lt;/xqx:name&gt;
                  &lt;/xqx:varRef&gt;
                &lt;/xqx:orderByExpr&gt;
              &lt;/xqx:orderBySpec&gt;
            &lt;/xqx:orderByClause&gt;
            &lt;xqx:returnClause&gt;
              &lt;xqx:elementConstructor&gt;
                &lt;xqx:tagName&gt;result&lt;/xqx:tagName&gt;
                &lt;xqx:elementContent&gt;
                  &lt;xqx:elementConstructor&gt;
                    &lt;xqx:tagName&gt;author&lt;/xqx:tagName&gt;
                    &lt;xqx:elementContent&gt;
                      &lt;xqx:elementConstructor&gt;
                        &lt;xqx:tagName&gt;last&lt;/xqx:tagName&gt;
                        &lt;xqx:elementContent&gt;
                          &lt;xqx:varRef&gt;
                            &lt;xqx:name&gt;last&lt;/xqx:name&gt;
                          &lt;/xqx:varRef&gt;
                        &lt;/xqx:elementContent&gt;
                      &lt;/xqx:elementConstructor&gt;
                      &lt;xqx:elementConstructor&gt;
                        &lt;xqx:tagName&gt;first&lt;/xqx:tagName&gt;
                        &lt;xqx:elementContent&gt;
                          &lt;xqx:varRef&gt;
                            &lt;xqx:name&gt;first&lt;/xqx:name&gt;
                          &lt;/xqx:varRef&gt;
                        &lt;/xqx:elementContent&gt;
                      &lt;/xqx:elementConstructor&gt;
                    &lt;/xqx:elementContent&gt;
                  &lt;/xqx:elementConstructor&gt;
                    &lt;xqx:flworExpr&gt;
                      &lt;xqx:forClause&gt;
                        &lt;xqx:forClauseItem&gt;
                          &lt;xqx:typedVariableBinding&gt;
                            &lt;xqx:varName&gt;b&lt;/xqx:varName&gt;
                          &lt;/xqx:typedVariableBinding&gt;
                          &lt;xqx:forExpr&gt;
                            &lt;xqx:pathExpr&gt;
                              &lt;xqx:stepExpr&gt;
                                &lt;xqx:filterExpr&gt;
                                  &lt;xqx:functionCallExpr&gt;
                                    &lt;xqx:functionName&gt;doc&lt;/xqx:functionName&gt;
                                    &lt;xqx:arguments&gt;
                                      &lt;xqx:stringConstantExpr&gt;
                                        &lt;xqx:value&gt;http://bstore1.example.com/bib.xml&lt;/xqx:value&gt;
                                      &lt;/xqx:stringConstantExpr&gt;
                                    &lt;/xqx:arguments&gt;
                                  &lt;/xqx:functionCallExpr&gt;
                                &lt;/xqx:filterExpr&gt;
                              &lt;/xqx:stepExpr&gt;
                              &lt;xqx:stepExpr&gt;
                                &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                                &lt;xqx:nameTest&gt;bib&lt;/xqx:nameTest&gt;
                              &lt;/xqx:stepExpr&gt;
                              &lt;xqx:stepExpr&gt;
                                &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                                &lt;xqx:nameTest&gt;book&lt;/xqx:nameTest&gt;
                              &lt;/xqx:stepExpr&gt;
                            &lt;/xqx:pathExpr&gt;
                          &lt;/xqx:forExpr&gt;
                        &lt;/xqx:forClauseItem&gt;
                      &lt;/xqx:forClause&gt;
                      &lt;xqx:whereClause&gt;
                        &lt;xqx:quantifiedExpr&gt;
                          &lt;xqx:quantifier&gt;some&lt;/xqx:quantifier&gt;
                          &lt;xqx:quantifiedExprInClause&gt;
                            &lt;xqx:typedVariableBinding&gt;
                              &lt;xqx:varName&gt;ba&lt;/xqx:varName&gt;
                            &lt;/xqx:typedVariableBinding&gt;
                            &lt;xqx:sourceExpr&gt;
                              &lt;xqx:pathExpr&gt;
                                &lt;xqx:stepExpr&gt;
                                  &lt;xqx:filterExpr&gt;
                                    &lt;xqx:varRef&gt;
                                      &lt;xqx:name&gt;b&lt;/xqx:name&gt;
                                    &lt;/xqx:varRef&gt;
                                  &lt;/xqx:filterExpr&gt;
                                &lt;/xqx:stepExpr&gt;
                                &lt;xqx:stepExpr&gt;
                                  &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                                  &lt;xqx:nameTest&gt;author&lt;/xqx:nameTest&gt;
                                &lt;/xqx:stepExpr&gt;
                              &lt;/xqx:pathExpr&gt;
                            &lt;/xqx:sourceExpr&gt;
                          &lt;/xqx:quantifiedExprInClause&gt;
                          &lt;xqx:predicateExpr&gt;
                            &lt;xqx:andOp&gt;
                              &lt;xqx:firstOperand&gt;
                                &lt;xqx:equalOp&gt;
                                  &lt;xqx:firstOperand&gt;
                                    &lt;xqx:pathExpr&gt;
                                      &lt;xqx:stepExpr&gt;
                                        &lt;xqx:filterExpr&gt;
                                          &lt;xqx:varRef&gt;
                                            &lt;xqx:name&gt;ba&lt;/xqx:name&gt;
                                          &lt;/xqx:varRef&gt;
                                        &lt;/xqx:filterExpr&gt;
                                      &lt;/xqx:stepExpr&gt;
                                      &lt;xqx:stepExpr&gt;
                                        &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                                        &lt;xqx:nameTest&gt;last&lt;/xqx:nameTest&gt;
                                      &lt;/xqx:stepExpr&gt;
                                    &lt;/xqx:pathExpr&gt;
                                  &lt;/xqx:firstOperand&gt;
                                  &lt;xqx:secondOperand&gt;
                                    &lt;xqx:varRef&gt;
                                      &lt;xqx:name&gt;last&lt;/xqx:name&gt;
                                    &lt;/xqx:varRef&gt;
                                  &lt;/xqx:secondOperand&gt;
                                &lt;/xqx:equalOp&gt;
                              &lt;/xqx:firstOperand&gt;
                              &lt;xqx:secondOperand&gt;
                                &lt;xqx:equalOp&gt;
                                  &lt;xqx:firstOperand&gt;
                                    &lt;xqx:pathExpr&gt;
                                      &lt;xqx:stepExpr&gt;
                                        &lt;xqx:filterExpr&gt;
                                          &lt;xqx:varRef&gt;
                                            &lt;xqx:name&gt;ba&lt;/xqx:name&gt;
                                          &lt;/xqx:varRef&gt;
                                        &lt;/xqx:filterExpr&gt;
                                      &lt;/xqx:stepExpr&gt;
                                      &lt;xqx:stepExpr&gt;
                                        &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                                        &lt;xqx:nameTest&gt;first&lt;/xqx:nameTest&gt;
                                      &lt;/xqx:stepExpr&gt;
                                    &lt;/xqx:pathExpr&gt;
                                  &lt;/xqx:firstOperand&gt;
                                  &lt;xqx:secondOperand&gt;
                                    &lt;xqx:varRef&gt;
                                      &lt;xqx:name&gt;first&lt;/xqx:name&gt;
                                    &lt;/xqx:varRef&gt;
                                  &lt;/xqx:secondOperand&gt;
                                &lt;/xqx:equalOp&gt;
                              &lt;/xqx:secondOperand&gt;
                            &lt;/xqx:andOp&gt;
                          &lt;/xqx:predicateExpr&gt;
                        &lt;/xqx:quantifiedExpr&gt;
                      &lt;/xqx:whereClause&gt;
                      &lt;xqx:returnClause&gt;
                        &lt;xqx:pathExpr&gt;
                          &lt;xqx:stepExpr&gt;
                            &lt;xqx:filterExpr&gt;
                              &lt;xqx:varRef&gt;
                                &lt;xqx:name&gt;b&lt;/xqx:name&gt;
                              &lt;/xqx:varRef&gt;
                            &lt;/xqx:filterExpr&gt;
                          &lt;/xqx:stepExpr&gt;
                          &lt;xqx:stepExpr&gt;
                            &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                            &lt;xqx:nameTest&gt;title&lt;/xqx:nameTest&gt;
                          &lt;/xqx:stepExpr&gt;
                        &lt;/xqx:pathExpr&gt;
                      &lt;/xqx:returnClause&gt;
                    &lt;/xqx:flworExpr&gt;
                &lt;/xqx:elementContent&gt;
              &lt;/xqx:elementConstructor&gt;
            &lt;/xqx:returnClause&gt;
          &lt;/xqx:flworExpr&gt;
        &lt;/xqx:elementContent&gt;
      &lt;/xqx:elementConstructor&gt;
    &lt;/xqx:queryBody&gt;
  &lt;/xqx:mainModule&gt;
&lt;/xqx:module&gt;
</PRE></DIV></DIV>
<DIV class=div3>
<H4><A id=Example2-Transformation name=Example2-Transformation></A>3.2.3 
Transformation of XQueryX Solution into XQuery</H4>
<P>Application of the stylesheet in <A 
href="REC-xqueryx-20070123.htm#Stylesheet"><B>B 
Transforming XQueryX to XQuery</B></A> to the XQueryX solution results in:</P>
<DIV class=exampleInner><PRE>  
&lt;results&gt;{
 let $a:=doc("http://bstore1.example.com/bib.xml")/descendant-or-self::node()/child::author
 for $last in distinct-values($a/child::last), $first in distinct-values($a[(./child::last = $last)]/child::first)
 order by $last , $first 
 return &lt;result&gt;&lt;author&gt;&lt;last&gt;{$last}&lt;/last&gt;&lt;first&gt;{$first}&lt;/first&gt;&lt;/author&gt;{
 for $b in doc("http://bstore1.example.com/bib.xml")/child::bib/child::book
 where (some $ba in $b/child::author satisfies (($ba/child::last = $last) and ($ba/child::first = $first)))
 return $b/child::title
}&lt;/result&gt;
}&lt;/results&gt;
</PRE></DIV></DIV></DIV>
<DIV class=div2>
<H3><A id=Example3 name=Example3></A>3.3 Example 3</H3>
<P>Here is Q7 from the <A 
href="REC-xqueryx-20070123.htm#xquery-use-cases">[XML 
Query Use Cases]</A>, use case XMP (Experiences and Exemplars): "List the titles 
and years of all books published by Addison-Wesley after 1991, in alphabetic 
order."</P>
<DIV class=div3>
<H4><A id=Example3-XQuery name=Example3-XQuery></A>3.3.1 XQuery solution in 
XQuery Use Cases:</H4>
<DIV class=exampleInner><PRE>&lt;bib&gt;
  {
    for $b in doc("http://bstore1.example.com/bib.xml")//book
    where $b/publisher = "Addison-Wesley" and $b/@year &gt; 1991
    order by $b/title
    return
        &lt;book&gt;
            { $b/@year }
            { $b/title }
        &lt;/book&gt;
  }
&lt;/bib&gt; 
</PRE></DIV></DIV>
<DIV class=div3>
<H4><A id=Example3-XQueryX name=Example3-XQueryX></A>3.3.2 A solution in 
XQueryX:</H4>
<DIV class=exampleInner><PRE>&lt;?xml version="1.0"?&gt;
&lt;xqx:module xmlns:xqx="http://www.w3.org/2005/XQueryX"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://www.w3.org/2005/XQueryX
                                http://www.w3.org/2005/XQueryX/xqueryx.xsd"&gt;
  &lt;xqx:mainModule&gt;
    &lt;xqx:queryBody&gt;
      &lt;xqx:elementConstructor&gt;
        &lt;xqx:tagName&gt;bib&lt;/xqx:tagName&gt;
        &lt;xqx:elementContent&gt;
          &lt;xqx:flworExpr&gt;
            &lt;xqx:forClause&gt;
              &lt;xqx:forClauseItem&gt;
                &lt;xqx:typedVariableBinding&gt;
                  &lt;xqx:varName&gt;b&lt;/xqx:varName&gt;
                &lt;/xqx:typedVariableBinding&gt;
                &lt;xqx:forExpr&gt;
                  &lt;xqx:pathExpr&gt;
                    &lt;xqx:stepExpr&gt;
                      &lt;xqx:filterExpr&gt;
                        &lt;xqx:functionCallExpr&gt;
                          &lt;xqx:functionName&gt;doc&lt;/xqx:functionName&gt;
                          &lt;xqx:arguments&gt;
                            &lt;xqx:stringConstantExpr&gt;
                              &lt;xqx:value&gt;http://bstore1.example.com/bib.xml&lt;/xqx:value&gt;
                            &lt;/xqx:stringConstantExpr&gt;
                          &lt;/xqx:arguments&gt;
                        &lt;/xqx:functionCallExpr&gt;
                      &lt;/xqx:filterExpr&gt;
                    &lt;/xqx:stepExpr&gt;
                    &lt;xqx:stepExpr&gt;
                      &lt;xqx:xpathAxis&gt;descendant-or-self&lt;/xqx:xpathAxis&gt;
                      &lt;xqx:anyKindTest/&gt;
                    &lt;/xqx:stepExpr&gt;
                    &lt;xqx:stepExpr&gt;
                      &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                      &lt;xqx:nameTest&gt;book&lt;/xqx:nameTest&gt;
                    &lt;/xqx:stepExpr&gt;
                  &lt;/xqx:pathExpr&gt;
                &lt;/xqx:forExpr&gt;
              &lt;/xqx:forClauseItem&gt;
            &lt;/xqx:forClause&gt;
            &lt;xqx:whereClause&gt;
              &lt;xqx:andOp&gt;
                &lt;xqx:firstOperand&gt;
                  &lt;xqx:equalOp&gt;
                    &lt;xqx:firstOperand&gt;
                      &lt;xqx:pathExpr&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:filterExpr&gt;
                            &lt;xqx:varRef&gt;
                              &lt;xqx:name&gt;b&lt;/xqx:name&gt;
                            &lt;/xqx:varRef&gt;
                          &lt;/xqx:filterExpr&gt;
                        &lt;/xqx:stepExpr&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                          &lt;xqx:nameTest&gt;publisher&lt;/xqx:nameTest&gt;
                        &lt;/xqx:stepExpr&gt;
                      &lt;/xqx:pathExpr&gt;
                    &lt;/xqx:firstOperand&gt;
                    &lt;xqx:secondOperand&gt;
                      &lt;xqx:stringConstantExpr&gt;
                        &lt;xqx:value&gt;Addison-Wesley&lt;/xqx:value&gt;
                      &lt;/xqx:stringConstantExpr&gt;
                    &lt;/xqx:secondOperand&gt;
                  &lt;/xqx:equalOp&gt;
                &lt;/xqx:firstOperand&gt;
                &lt;xqx:secondOperand&gt;
                  &lt;xqx:greaterThanOp&gt;
                    &lt;xqx:firstOperand&gt;
                      &lt;xqx:pathExpr&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:filterExpr&gt;
                            &lt;xqx:varRef&gt;
                              &lt;xqx:name&gt;b&lt;/xqx:name&gt;
                            &lt;/xqx:varRef&gt;
                          &lt;/xqx:filterExpr&gt;
                        &lt;/xqx:stepExpr&gt;
                        &lt;xqx:stepExpr&gt;
                          &lt;xqx:xpathAxis&gt;attribute&lt;/xqx:xpathAxis&gt;
                          &lt;xqx:nameTest&gt;year&lt;/xqx:nameTest&gt;
                        &lt;/xqx:stepExpr&gt;
                      &lt;/xqx:pathExpr&gt;
                    &lt;/xqx:firstOperand&gt;
                    &lt;xqx:secondOperand&gt;
                      &lt;xqx:integerConstantExpr&gt;
                        &lt;xqx:value&gt;1991&lt;/xqx:value&gt;
                      &lt;/xqx:integerConstantExpr&gt;
                    &lt;/xqx:secondOperand&gt;
                  &lt;/xqx:greaterThanOp&gt;
                &lt;/xqx:secondOperand&gt;
              &lt;/xqx:andOp&gt;
            &lt;/xqx:whereClause&gt;
            &lt;xqx:orderByClause&gt;
              &lt;xqx:orderBySpec&gt;
                &lt;xqx:orderByExpr&gt;
                  &lt;xqx:pathExpr&gt;
                    &lt;xqx:stepExpr&gt;
                      &lt;xqx:filterExpr&gt;
                        &lt;xqx:varRef&gt;
                          &lt;xqx:name&gt;b&lt;/xqx:name&gt;
                        &lt;/xqx:varRef&gt;
                      &lt;/xqx:filterExpr&gt;
                    &lt;/xqx:stepExpr&gt;
                    &lt;xqx:stepExpr&gt;
                      &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                      &lt;xqx:nameTest&gt;title&lt;/xqx:nameTest&gt;
                    &lt;/xqx:stepExpr&gt;
                  &lt;/xqx:pathExpr&gt;
                &lt;/xqx:orderByExpr&gt;
              &lt;/xqx:orderBySpec&gt;
            &lt;/xqx:orderByClause&gt;
            &lt;xqx:returnClause&gt;
             &lt;xqx:elementConstructor&gt;
               &lt;xqx:tagName&gt;book&lt;/xqx:tagName&gt;
               &lt;xqx:elementContent&gt;
                 &lt;xqx:pathExpr&gt;
                   &lt;xqx:stepExpr&gt;
                     &lt;xqx:filterExpr&gt;
                       &lt;xqx:varRef&gt;
                         &lt;xqx:name&gt;b&lt;/xqx:name&gt;
                       &lt;/xqx:varRef&gt;
                     &lt;/xqx:filterExpr&gt;
                   &lt;/xqx:stepExpr&gt;
                   &lt;xqx:stepExpr&gt;
                     &lt;xqx:xpathAxis&gt;attribute&lt;/xqx:xpathAxis&gt;
                     &lt;xqx:nameTest&gt;year&lt;/xqx:nameTest&gt;
                   &lt;/xqx:stepExpr&gt;
                 &lt;/xqx:pathExpr&gt;
                 &lt;xqx:pathExpr&gt;
                   &lt;xqx:stepExpr&gt;
                     &lt;xqx:filterExpr&gt;
                       &lt;xqx:varRef&gt;
                         &lt;xqx:name&gt;b&lt;/xqx:name&gt;
                       &lt;/xqx:varRef&gt;
                     &lt;/xqx:filterExpr&gt;
                   &lt;/xqx:stepExpr&gt;
                   &lt;xqx:stepExpr&gt;
                     &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                     &lt;xqx:nameTest&gt;title&lt;/xqx:nameTest&gt;
                   &lt;/xqx:stepExpr&gt;
                 &lt;/xqx:pathExpr&gt;
               &lt;/xqx:elementContent&gt;
             &lt;/xqx:elementConstructor&gt;
            &lt;/xqx:returnClause&gt;
          &lt;/xqx:flworExpr&gt;
        &lt;/xqx:elementContent&gt;
      &lt;/xqx:elementConstructor&gt;
    &lt;/xqx:queryBody&gt;
  &lt;/xqx:mainModule&gt;
&lt;/xqx:module&gt;
</PRE></DIV></DIV>
<DIV class=div3>
<H4><A id=Example3-Transformation name=Example3-Transformation></A>3.3.3 
Transformation of XQueryX Solution into XQuery</H4>
<P>Application of the stylesheet in <A 
href="REC-xqueryx-20070123.htm#Stylesheet"><B>B 
Transforming XQueryX to XQuery</B></A> to the XQueryX solution results in:</P>
<DIV class=exampleInner><PRE>  
&lt;bib&gt;{
 for $b in doc("http://bstore1.example.com/bib.xml")/descendant-or-self::node()/child::book
 where (($b/child::publisher = "Addison-Wesley") and ($b/attribute::year &gt; 1991))
 order by $b/child::title 
 return &lt;book&gt;{$b/attribute::year}{$b/child::title}&lt;/book&gt;
}&lt;/bib&gt;
</PRE></DIV></DIV></DIV>
<DIV class=div2>
<H3><A id=Example4 name=Example4></A>3.4 Example 4</H3>
<P>Here is Q8 from the <A 
href="REC-xqueryx-20070123.htm#xquery-use-cases">[XML 
Query Use Cases]</A>, use case NS (Queries Using Namespaces): "Select all 
traders (either seller or high bidder) without negative comments."</P>
<DIV class=div3>
<H4><A id=Example4-XQuery name=Example4-XQuery></A>3.4.1 XQuery solution in 
XQuery Use Cases:</H4>
<DIV class=exampleInner><PRE>declare namespace ma = "http://www.example.com/AuctionWatch";
&lt;Q8 xmlns:ma="http://www.example.com/AuctionWatch"
    xmlns:eachbay="http://www.example.com/auctioneers#eachbay" 
    xmlns:xlink="http://www.w3.org/1999/xlink"&gt;
  {
    for $s in doc("auction.xml")//ma:Trading_Partners/(ma:Seller | ma:High_Bidder)
    where $s/*:NegativeComments = 0
    return $s
  }
&lt;/Q8&gt;
</PRE></DIV></DIV>
<DIV class=div3>
<H4><A id=Example4-XQueryX name=Example4-XQueryX></A>3.4.2 A solution in 
XQueryX:</H4>
<DIV class=exampleInner><PRE>&lt;?xml version="1.0"?&gt;
&lt;xqx:module xmlns:xqx="http://www.w3.org/2005/XQueryX"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://www.w3.org/2005/XQueryX
                          http://www.w3.org/2005/XQueryX/xqueryx.xsd"&gt;
  &lt;xqx:mainModule&gt;
    &lt;xqx:prolog&gt;
      &lt;xqx:namespaceDecl&gt;
        &lt;xqx:prefix&gt;ma&lt;/xqx:prefix&gt;
        &lt;xqx:uri&gt;http://www.example.com/AuctionWatch&lt;/xqx:uri&gt;
      &lt;/xqx:namespaceDecl&gt;
    &lt;/xqx:prolog&gt;
    &lt;xqx:queryBody&gt;
      &lt;xqx:elementConstructor&gt;
        &lt;xqx:tagName&gt;Q8&lt;/xqx:tagName&gt;
        &lt;xqx:attributeList&gt;
          &lt;xqx:namespaceDeclaration&gt;
            &lt;xqx:prefix&gt;ma&lt;/xqx:prefix&gt;
            &lt;xqx:uri&gt;http://www.example.com/AuctionWatch&lt;/xqx:uri&gt;
          &lt;/xqx:namespaceDeclaration&gt;
          &lt;xqx:namespaceDeclaration&gt;
            &lt;xqx:prefix&gt;eachbay&lt;/xqx:prefix&gt;
            &lt;xqx:uri&gt;http://www.example.com/auctioneers#eachbay&lt;/xqx:uri&gt;
          &lt;/xqx:namespaceDeclaration&gt;
          &lt;xqx:namespaceDeclaration&gt;
            &lt;xqx:prefix&gt;xlink&lt;/xqx:prefix&gt;
            &lt;xqx:uri&gt;http://www.w3.org/1999/xlink&lt;/xqx:uri&gt;
          &lt;/xqx:namespaceDeclaration&gt;
        &lt;/xqx:attributeList&gt;
        &lt;xqx:elementContent&gt;
          &lt;xqx:flworExpr&gt;
            &lt;xqx:forClause&gt;
              &lt;xqx:forClauseItem&gt;
                &lt;xqx:typedVariableBinding&gt;
                  &lt;xqx:varName&gt;s&lt;/xqx:varName&gt;
                &lt;/xqx:typedVariableBinding&gt;
                &lt;xqx:forExpr&gt;
                  &lt;xqx:pathExpr&gt;
                    &lt;xqx:stepExpr&gt;
                      &lt;xqx:filterExpr&gt;
                        &lt;xqx:functionCallExpr&gt;
                          &lt;xqx:functionName xqx:prefix="fn"&gt;doc&lt;/xqx:functionName&gt;
                          &lt;xqx:arguments&gt;
                            &lt;xqx:stringConstantExpr&gt;
                              &lt;xqx:value&gt;auction.xml&lt;/xqx:value&gt;
                            &lt;/xqx:stringConstantExpr&gt;
                          &lt;/xqx:arguments&gt;
                        &lt;/xqx:functionCallExpr&gt;
                      &lt;/xqx:filterExpr&gt;
                    &lt;/xqx:stepExpr&gt;
                    &lt;xqx:stepExpr&gt;
                      &lt;xqx:xpathAxis&gt;descendant-or-self&lt;/xqx:xpathAxis&gt;
                      &lt;xqx:anyKindTest/&gt;
                    &lt;/xqx:stepExpr&gt;
                    &lt;xqx:stepExpr&gt;
                      &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                      &lt;xqx:nameTest xqx:prefix="ma"&gt;Trading_Partners&lt;/xqx:nameTest&gt;
                    &lt;/xqx:stepExpr&gt;
                    &lt;xqx:stepExpr&gt;
                      &lt;xqx:filterExpr&gt;
                        &lt;xqx:parenthesizedExpr&gt;
                          &lt;xqx:unionOp&gt;
                            &lt;xqx:firstOperand&gt;
                              &lt;xqx:pathExpr&gt;
                                &lt;xqx:stepExpr&gt;
                                  &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                                  &lt;xqx:nameTest xqx:prefix="ma"&gt;Seller&lt;/xqx:nameTest&gt;
                                &lt;/xqx:stepExpr&gt;
                              &lt;/xqx:pathExpr&gt;
                            &lt;/xqx:firstOperand&gt;
                            &lt;xqx:secondOperand&gt;
                              &lt;xqx:pathExpr&gt;
                                &lt;xqx:stepExpr&gt;
                                  &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                                  &lt;xqx:nameTest xqx:prefix="ma"&gt;High_Bidder&lt;/xqx:nameTest&gt;
                                &lt;/xqx:stepExpr&gt;
                              &lt;/xqx:pathExpr&gt;
                            &lt;/xqx:secondOperand&gt;
                          &lt;/xqx:unionOp&gt;
                        &lt;/xqx:parenthesizedExpr&gt;
                      &lt;/xqx:filterExpr&gt;
                    &lt;/xqx:stepExpr&gt;
                  &lt;/xqx:pathExpr&gt;
                &lt;/xqx:forExpr&gt;
              &lt;/xqx:forClauseItem&gt;
            &lt;/xqx:forClause&gt;
            &lt;xqx:whereClause&gt;
              &lt;xqx:equalOp&gt;
                &lt;xqx:firstOperand&gt;
                  &lt;xqx:pathExpr&gt;
                    &lt;xqx:stepExpr&gt;
                      &lt;xqx:filterExpr&gt;
                        &lt;xqx:varRef&gt;
                          &lt;xqx:name&gt;s&lt;/xqx:name&gt;
                        &lt;/xqx:varRef&gt;
                      &lt;/xqx:filterExpr&gt;
                    &lt;/xqx:stepExpr&gt;
                    &lt;xqx:stepExpr&gt;
                      &lt;xqx:xpathAxis&gt;child&lt;/xqx:xpathAxis&gt;
                      &lt;xqx:Wildcard&gt;
                        &lt;xqx:star/&gt;
                        &lt;xqx:NCName&gt;NegativeComments&lt;/xqx:NCName&gt;
                      &lt;/xqx:Wildcard&gt;
                    &lt;/xqx:stepExpr&gt;
                  &lt;/xqx:pathExpr&gt;
                &lt;/xqx:firstOperand&gt;
                &lt;xqx:secondOperand&gt;
                  &lt;xqx:integerConstantExpr&gt;
                    &lt;xqx:value&gt;0&lt;/xqx:value&gt;
                  &lt;/xqx:integerConstantExpr&gt;
                &lt;/xqx:secondOperand&gt;
              &lt;/xqx:equalOp&gt;
            &lt;/xqx:whereClause&gt;
            &lt;xqx:returnClause&gt;
              &lt;xqx:varRef&gt;
                &lt;xqx:name&gt;s&lt;/xqx:name&gt;
              &lt;/xqx:varRef&gt;
            &lt;/xqx:returnClause&gt;
          &lt;/xqx:flworExpr&gt;
        &lt;/xqx:elementContent&gt;
      &lt;/xqx:elementConstructor&gt;
    &lt;/xqx:queryBody&gt;
  &lt;/xqx:mainModule&gt;
&lt;/xqx:module&gt;
</PRE></DIV></DIV>
<DIV class=div3>
<H4><A id=Example4-Transformation name=Example4-Transformation></A>3.4.3 
Transformation of XQueryX Solution into XQuery</H4>
<P>Application of the stylesheet in <A 
href="REC-xqueryx-20070123.htm#Stylesheet"><B>B 
Transforming XQueryX to XQuery</B></A> to the XQueryX solution results in:</P>
<DIV class=exampleInner><PRE>  
declare namespace ma="http://www.example.com/AuctionWatch";
&lt;Q8 xmlns:ma="http://www.example.com/AuctionWatch" xmlns:eachbay="http://www.example.com/auctioneers#eachbay" xmlns:xlink="http://www.w3.org/1999/xlink"&gt;{
 for $s in fn:doc("auction.xml")/descendant-or-self::node()/child::ma:Trading_Partners/((child::ma:Seller union child::ma:High_Bidder))
 where ($s/child::*:NegativeComments = 0)
 return $s
}&lt;/Q8&gt;
</PRE></DIV></DIV></DIV></DIV>
<DIV class=div1>
<H2><A id=Schema name=Schema></A>4 An XML Schema for the XQuery XML Syntax</H2>
<P>Here is the XML Schema against which XQueryX documents must be valid.</P>
<DIV class=exampleInner><PRE>&lt;?xml version="1.0"?&gt;
&lt;!--
  Changes from CR document:
  * revised the text describing the trivial embedding feature (bug #2611)
  * refined the content model for xqx:stepExpr and xqx:pathExpr (bug #2523)
  * fixed the handling of an empty xqx:Wildcard element (bug #3022)
  * removed the unnecessary &lt;xqx:parenthesizedExpr/&gt; element (#3333)
  * always generated braces associated with a computed PI constructor value (bug #3442)
  * escape/quote "&lt;" and whitespace chars other than #x20 (bugs #3446 and #3474)
  * support schemaImport and moduleImport with multiple &lt;xqx:targetLocation&gt;s (bug #3520)
  * restructure prolog details in preparation for future XQuery features
--&gt;
&lt;!--  Readers of this schema are reminded that the default value for both
      minOccurs and maxOccurs is "1". --&gt;
        &lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"
                    xmlns="http://www.w3.org/2005/XQueryX"
                    targetNamespace="http://www.w3.org/2005/XQueryX"
                    elementFormDefault="qualified" attributeFormDefault="qualified"&gt;


  &lt;!-- A few helper declarations --&gt;
  &lt;xsd:complexType name="emptyContent"/&gt;

  &lt;xsd:element name="NCName" type="xsd:NCName"/&gt;

  &lt;xsd:complexType name="QName"&gt;
    &lt;xsd:simpleContent&gt;
      &lt;xsd:extension base="xsd:NCName"&gt;
        &lt;xsd:attribute name="prefix" type="xsd:NCName" use="optional"/&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:simpleContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;!-- The base class --&gt;
  &lt;xsd:complexType name="expr"/&gt;

  &lt;xsd:element name="expr" type="expr" abstract="true"/&gt;

  &lt;!-- A list of expressions --&gt;
  &lt;xsd:complexType name="exprList"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="expr" minOccurs="0" maxOccurs="unbounded"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:complexType name="exprWrapperOptional"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="expr" minOccurs="0"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;!-- Simple wrapper class --&gt;
  &lt;xsd:complexType name="exprWrapper"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="expr"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;!-- constant expressions. We have 4 different subclasses for this --&gt;
  &lt;xsd:complexType name="constantExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="value" type="xsd:anyType"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="constantExpr" type="constantExpr" abstract="true" substitutionGroup="expr"/&gt;

  &lt;xsd:complexType name="integerConstantExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:restriction base="constantExpr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="value" type="xsd:integer"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:restriction&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="integerConstantExpr" type="integerConstantExpr" substitutionGroup="constantExpr"/&gt;

  &lt;xsd:complexType name="decimalConstantExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:restriction base="constantExpr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="value" type="xsd:decimal"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:restriction&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="decimalConstantExpr" type="decimalConstantExpr" substitutionGroup="constantExpr"/&gt;

  &lt;xsd:complexType name="doubleConstantExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:restriction base="constantExpr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="value" type="xsd:double"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:restriction&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="doubleConstantExpr" type="doubleConstantExpr" substitutionGroup="constantExpr"/&gt;

  &lt;xsd:complexType name="stringConstantExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:restriction base="constantExpr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="value" type="xsd:string"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:restriction&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="stringConstantExpr" type="stringConstantExpr" substitutionGroup="constantExpr"/&gt;

  &lt;!-- Variables --&gt;
  &lt;xsd:complexType name="varRef"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="name" type="QName"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="varRef" type="varRef" substitutionGroup="expr"/&gt;

  &lt;!-- root and context-item expressions --&gt;
  &lt;!-- rootExpr deleted per Bugzilla Bug #2523 --&gt;
  &lt;xsd:complexType name="contextItemExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"/&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="contextItemExpr" type="contextItemExpr" substitutionGroup="expr"/&gt;

  &lt;!-- Pragmas and extension expressions --&gt;
  &lt;xsd:element name="pragma"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element name="pragmaName" type="QName"/&gt;
        &lt;xsd:element name="pragmaContents" type="xsd:string"/&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:complexType name="extensionExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element ref="pragma" maxOccurs="unbounded"/&gt;
          &lt;xsd:element name="argExpr" type="exprWrapper" minOccurs="0"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="extensionExpr" type="extensionExpr" substitutionGroup="expr"/&gt;

  &lt;xsd:complexType name="functionCallExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="functionName" type="QName"/&gt;
          &lt;xsd:element name="arguments" type="exprList" minOccurs="0"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="functionCallExpr" type="functionCallExpr" substitutionGroup="expr"/&gt;

  &lt;!-- Constructor functions --&gt;
  &lt;xsd:complexType name="constructorFunctionExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="typeName" type="QName"/&gt;
          &lt;xsd:element name="argExpr" type="exprWrapper"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="constructorFunctionExpr" type="constructorFunctionExpr" substitutionGroup="expr"/&gt;

  &lt;xsd:complexType name="sequenceExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element ref="expr" minOccurs="0" maxOccurs="unbounded"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="sequenceExpr" type="sequenceExpr" substitutionGroup="expr"/&gt;

  &lt;xsd:complexType name="rangeSequenceExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="startExpr" type="exprWrapper"/&gt;
          &lt;xsd:element name="endExpr" type="exprWrapper"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="rangeSequenceExpr" type="rangeSequenceExpr" substitutionGroup="expr"/&gt;

  &lt;!-- Builtin operator expressions --&gt;
  &lt;xsd:complexType name="operatorExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"/&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:complexType name="unaryOperatorExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="operatorExpr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="operand" type="exprWrapper"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:complexType name="binaryOperatorExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="operatorExpr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="firstOperand" type="exprWrapper"/&gt;
          &lt;xsd:element name="secondOperand" type="exprWrapper"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="operatorExpr" type="operatorExpr" abstract="true" substitutionGroup="expr"/&gt;

  &lt;xsd:element name="arithmeticOp" type="operatorExpr" abstract="true" substitutionGroup="operatorExpr"/&gt;

  &lt;xsd:element name="addOp" type="binaryOperatorExpr" substitutionGroup="arithmeticOp"/&gt;

  &lt;xsd:element name="subtractOp" type="binaryOperatorExpr" substitutionGroup="arithmeticOp"/&gt;

  &lt;xsd:element name="multiplyOp" type="binaryOperatorExpr" substitutionGroup="arithmeticOp"/&gt;

  &lt;xsd:element name="divOp" type="binaryOperatorExpr" substitutionGroup="arithmeticOp"/&gt;

  &lt;xsd:element name="idivOp" type="binaryOperatorExpr" substitutionGroup="arithmeticOp"/&gt;

  &lt;xsd:element name="modOp" type="binaryOperatorExpr" substitutionGroup="arithmeticOp"/&gt;

  &lt;xsd:element name="unaryMinusOp" type="unaryOperatorExpr" substitutionGroup="arithmeticOp"/&gt;

  &lt;xsd:element name="unaryPlusOp" type="unaryOperatorExpr" substitutionGroup="arithmeticOp"/&gt;

  &lt;xsd:element name="comparisonOp" type="binaryOperatorExpr" abstract="true"
               substitutionGroup="operatorExpr"/&gt;

  &lt;xsd:element name="valueComparisonOp" type="binaryOperatorExpr" abstract="true"
               substitutionGroup="operatorExpr"/&gt;

  &lt;xsd:element name="eqOp" type="binaryOperatorExpr" substitutionGroup="valueComparisonOp"/&gt;

  &lt;xsd:element name="neOp" type="binaryOperatorExpr" substitutionGroup="valueComparisonOp"/&gt;

  &lt;xsd:element name="gtOp" type="binaryOperatorExpr" substitutionGroup="valueComparisonOp"/&gt;

  &lt;xsd:element name="geOp" type="binaryOperatorExpr" substitutionGroup="valueComparisonOp"/&gt;

  &lt;xsd:element name="ltOp" type="binaryOperatorExpr" substitutionGroup="valueComparisonOp"/&gt;

  &lt;xsd:element name="leOp" type="binaryOperatorExpr" substitutionGroup="valueComparisonOp"/&gt;

  &lt;xsd:element name="generalComparisonOp" type="binaryOperatorExpr" abstract="true"
               substitutionGroup="operatorExpr"/&gt;

  &lt;xsd:element name="equalOp" type="binaryOperatorExpr" substitutionGroup="generalComparisonOp"/&gt;

  &lt;xsd:element name="notEqualOp" type="binaryOperatorExpr" substitutionGroup="generalComparisonOp"/&gt;

  &lt;xsd:element name="lessThanOp" type="binaryOperatorExpr" substitutionGroup="generalComparisonOp"/&gt;

  &lt;xsd:element name="lessThanOrEqualOp" type="binaryOperatorExpr"
               substitutionGroup="generalComparisonOp"/&gt;

  &lt;xsd:element name="greaterThanOp" type="binaryOperatorExpr" substitutionGroup="generalComparisonOp"/&gt;

  &lt;xsd:element name="greaterThanOrEqualOp" type="binaryOperatorExpr"
               substitutionGroup="generalComparisonOp"/&gt;

  &lt;xsd:element name="nodeComparisonOp" type="binaryOperatorExpr" abstract="true"
               substitutionGroup="operatorExpr"/&gt;

  &lt;xsd:element name="isOp" type="binaryOperatorExpr" substitutionGroup="nodeComparisonOp"/&gt;

  &lt;xsd:element name="orderComparisonOp" type="binaryOperatorExpr" abstract="true"
               substitutionGroup="operatorExpr"/&gt;

  &lt;xsd:element name="nodeBeforeOp" type="binaryOperatorExpr" substitutionGroup="orderComparisonOp"/&gt;

  &lt;xsd:element name="nodeAfterOp" type="binaryOperatorExpr" substitutionGroup="orderComparisonOp"/&gt;

  &lt;xsd:element name="logicalOp" type="binaryOperatorExpr" abstract="true"
               substitutionGroup="operatorExpr"/&gt;

  &lt;xsd:element name="andOp" type="binaryOperatorExpr" substitutionGroup="logicalOp"/&gt;

  &lt;xsd:element name="orOp" type="binaryOperatorExpr" substitutionGroup="logicalOp"/&gt;

  &lt;xsd:element name="setOp" type="binaryOperatorExpr" abstract="true" substitutionGroup="operatorExpr"/&gt;

  &lt;xsd:element name="unionOp" type="binaryOperatorExpr" substitutionGroup="setOp"/&gt;

  &lt;xsd:element name="intersectOp" type="binaryOperatorExpr" substitutionGroup="setOp"/&gt;

  &lt;xsd:element name="exceptOp" type="binaryOperatorExpr" substitutionGroup="setOp"/&gt;

  &lt;!-- Basic typenames --&gt;
  &lt;xsd:element name="atomicType" type="QName" substitutionGroup="itemType"/&gt;

  &lt;!-- Used in castable expression --&gt;
  &lt;xsd:element name="singleType"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element ref="atomicType"/&gt;
        &lt;xsd:element name="optional" type="emptyContent" minOccurs="0"/&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:element name="itemType" abstract="true"/&gt;

  &lt;xsd:complexType name="emptyItemTypeContent"/&gt;

  &lt;xsd:element name="anyItemType" type="emptyItemTypeContent" substitutionGroup="itemType"/&gt;

  &lt;xsd:simpleType name="occurrenceIndicator"&gt;
    &lt;xsd:restriction base="xsd:string"&gt;
      &lt;xsd:enumeration value="?"/&gt;
      &lt;xsd:enumeration value="*"/&gt;
      &lt;xsd:enumeration value="+"/&gt;
    &lt;/xsd:restriction&gt;
  &lt;/xsd:simpleType&gt;

  &lt;xsd:complexType name="sequenceType"&gt;
    &lt;xsd:choice&gt;
      &lt;xsd:element name="voidSequenceType" type="emptyContent"/&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element ref="itemType"/&gt;
        &lt;xsd:element name="occurrenceIndicator" type="occurrenceIndicator" minOccurs="0"/&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:choice&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="sequenceType" type="sequenceType"/&gt;

  &lt;xsd:element name="typeDeclaration" type="sequenceType"/&gt;

  &lt;!-- Represents a "typed" variable (for clause, let clause etc) --&gt;
  &lt;xsd:element name="typedVariableBinding"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element name="varName" type="QName"/&gt;
        &lt;xsd:element ref="typeDeclaration" minOccurs="0"/&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;!-- Represents an untyped variable for the "at" clause in a for clause --&gt;
  &lt;xsd:element name="positionalVariableBinding" type="QName"/&gt;
&lt;!--               substitutionGroup="FLWORVariableBindings"/&gt; --&gt;

  &lt;xsd:element name="variableBinding" type="QName"/&gt;

  &lt;!-- Represents all variable bindings in a for or let clause except typed and positional variable bindings --&gt;
  &lt;xsd:element name="forLetClauseItemExtensions" abstract="true"/&gt;

  &lt;xsd:complexType name="forClauseItem"&gt;
    &lt;xsd:sequence&gt;
          &lt;xsd:element ref="typedVariableBinding"/&gt;
          &lt;xsd:element ref="positionalVariableBinding" minOccurs="0" maxOccurs="1"/&gt;
      &lt;xsd:element ref="forLetClauseItemExtensions" minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;xsd:element name="forExpr" type="exprWrapper"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="forClauseItem" type="forClauseItem"/&gt;

  &lt;xsd:element name="forClause"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element ref="forClauseItem" minOccurs="1" maxOccurs="unbounded"/&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;


  &lt;xsd:element name="letClauseItem"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:choice&gt;
                  &lt;xsd:sequence&gt;
            &lt;xsd:element ref="typedVariableBinding"/&gt;
                        &lt;xsd:element ref="forLetClauseItemExtensions" minOccurs="0" maxOccurs="unbounded"/&gt;
                  &lt;/xsd:sequence&gt;
          &lt;xsd:element ref="forLetClauseItemExtensions" minOccurs="0" maxOccurs="unbounded"/&gt;
                &lt;/xsd:choice&gt;
        &lt;xsd:element name="letExpr" type="exprWrapper"/&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:element name="letClause"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element ref="letClauseItem" maxOccurs="unbounded"/&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:element name="whereClause" type="exprWrapper"/&gt;

  &lt;xsd:element name="returnClause" type="exprWrapper"/&gt;

  &lt;xsd:simpleType name="emptyOrderingMode"&gt;
    &lt;xsd:restriction base="xsd:string"&gt;
      &lt;xsd:enumeration value="empty greatest"/&gt;
      &lt;xsd:enumeration value="empty least"/&gt;
    &lt;/xsd:restriction&gt;
  &lt;/xsd:simpleType&gt;

  &lt;xsd:simpleType name="orderingKind"&gt;
    &lt;xsd:restriction base="xsd:string"&gt;
      &lt;xsd:enumeration value="ascending"/&gt;
      &lt;xsd:enumeration value="descending"/&gt;
    &lt;/xsd:restriction&gt;
  &lt;/xsd:simpleType&gt;

  &lt;xsd:element name="orderModifier"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element name="orderingKind" type="orderingKind" minOccurs="0"/&gt;
        &lt;xsd:element name="emptyOrderingMode" type="emptyOrderingMode" minOccurs="0"/&gt;
        &lt;xsd:element name="collation" type="xsd:string" minOccurs="0"/&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:element name="orderBySpec"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element name="orderByExpr" type="exprWrapper"/&gt;
        &lt;xsd:element ref="orderModifier" minOccurs="0"/&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:element name="orderByClause"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element name="stable" type="emptyContent" minOccurs="0"/&gt;
        &lt;xsd:element ref="orderBySpec" maxOccurs="unbounded"/&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;!-- This is the flwor expression --&gt;
  &lt;xsd:complexType name="flworExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:choice maxOccurs="unbounded"&gt;
            &lt;xsd:element ref="forClause"/&gt;
            &lt;xsd:element ref="letClause"/&gt;
          &lt;/xsd:choice&gt;
          &lt;xsd:element ref="whereClause" minOccurs="0"/&gt;
          &lt;xsd:element ref="orderByClause" minOccurs="0"/&gt;
          &lt;xsd:element ref="returnClause"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="flworExpr" type="flworExpr" substitutionGroup="expr"/&gt;

  &lt;!-- conditional expressions --&gt;
  &lt;xsd:complexType name="ifThenElseExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="ifClause" type="exprWrapper"/&gt;
          &lt;xsd:element name="thenClause" type="exprWrapper"/&gt;
          &lt;xsd:element name="elseClause" type="exprWrapper"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="ifThenElseExpr" type="ifThenElseExpr" substitutionGroup="expr"/&gt;

  &lt;!-- The following clauses describe quantified expressions --&gt;
  &lt;xsd:simpleType name="quantifier"&gt;
    &lt;xsd:restriction base="xsd:NMTOKEN"&gt;
      &lt;xsd:enumeration value="some"/&gt;
      &lt;xsd:enumeration value="every"/&gt;
    &lt;/xsd:restriction&gt;
  &lt;/xsd:simpleType&gt;

  &lt;xsd:element name="quantifiedExprInClause"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element ref="typedVariableBinding"/&gt;
        &lt;xsd:element name="sourceExpr" type="exprWrapper"/&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:complexType name="quantifiedExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="quantifier" type="quantifier"/&gt;
          &lt;xsd:element ref="quantifiedExprInClause" maxOccurs="unbounded"/&gt;
          &lt;xsd:element name="predicateExpr" type="exprWrapper"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="quantifiedExpr" type="quantifiedExpr" substitutionGroup="expr"/&gt;

  &lt;!-- handle the typeswitch construct --&gt;
  &lt;!-- Note: no substitutionGroup as we cannot use this anywhere --&gt;
  &lt;xsd:element name="typeswitchExprCaseClause"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:complexContent&gt;
        &lt;xsd:extension base="expr"&gt;
          &lt;xsd:sequence&gt;
            &lt;xsd:element ref="variableBinding" minOccurs="0"/&gt;
            &lt;xsd:element ref="sequenceType"/&gt;
            &lt;xsd:element name="resultExpr" type="exprWrapper"/&gt;
          &lt;/xsd:sequence&gt;
        &lt;/xsd:extension&gt;
      &lt;/xsd:complexContent&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;!-- Note: no substitutionGroup as we cannot use this anywhere --&gt;
  &lt;xsd:element name="typeswitchExprDefaultClause"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:complexContent&gt;
        &lt;xsd:extension base="expr"&gt;
          &lt;xsd:sequence&gt;
            &lt;xsd:element ref="variableBinding" minOccurs="0"/&gt;
            &lt;xsd:element name="resultExpr" type="exprWrapper"/&gt;
          &lt;/xsd:sequence&gt;
        &lt;/xsd:extension&gt;
      &lt;/xsd:complexContent&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:complexType name="typeswitchExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="argExpr" type="exprWrapper"/&gt;
          &lt;xsd:element ref="typeswitchExprCaseClause" maxOccurs="unbounded"/&gt;
          &lt;xsd:element ref="typeswitchExprDefaultClause"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="typeswitchExpr" type="typeswitchExpr" substitutionGroup="expr"/&gt;

  &lt;!-- instance-of expressions --&gt;
  &lt;xsd:complexType name="instanceOfExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="argExpr" type="exprWrapper"/&gt;
          &lt;xsd:element ref="sequenceType"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="instanceOfExpr" type="instanceOfExpr" substitutionGroup="expr"/&gt;

  &lt;!-- treat-as expressions --&gt;
  &lt;xsd:complexType name="treatExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="argExpr" type="exprWrapper"/&gt;
          &lt;xsd:element ref="sequenceType"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="treatExpr" type="treatExpr" substitutionGroup="expr"/&gt;

  &lt;!-- castable and cast expressions --&gt;
  &lt;xsd:complexType name="castableExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="argExpr" type="exprWrapper"/&gt;
          &lt;xsd:element ref="singleType"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="castableExpr" type="castableExpr" substitutionGroup="expr"/&gt;

  &lt;xsd:complexType name="castExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="argExpr" type="exprWrapper"/&gt;
          &lt;xsd:element ref="singleType"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="castExpr" type="castExpr" substitutionGroup="expr"/&gt;

  &lt;!-- Validate expressions --&gt;
  &lt;xsd:simpleType name="validationMode"&gt;
    &lt;xsd:restriction base="xsd:NMTOKEN"&gt;
      &lt;xsd:enumeration value="lax"/&gt;
      &lt;xsd:enumeration value="strict"/&gt;
    &lt;/xsd:restriction&gt;
  &lt;/xsd:simpleType&gt;

  &lt;xsd:complexType name="validateExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="validationMode" type="validationMode" minOccurs="0"/&gt;
          &lt;xsd:element name="argExpr" type="exprWrapper"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="validateExpr" type="validateExpr" substitutionGroup="expr"/&gt;

  &lt;!-- Direct constructors. Only elementConstructor for now --&gt;
  &lt;!-- Note the absence of constructors corresponding to
       the directCommentConstructor and the directPIConstructor
       productions in the XQuery grammar. This is because they are
       trivially identical to the computed variants
    --&gt;

  &lt;!-- attributeConstructor is no longer a subclass of expr --&gt;
  &lt;xsd:complexType name="attributeConstructor"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="attributeName" type="QName"/&gt;
      &lt;xsd:choice&gt;
        &lt;xsd:element name="attributeValueExpr" type="exprList"/&gt;
        &lt;xsd:element name="attributeValue" type="xsd:string"/&gt;
      &lt;/xsd:choice&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:complexType name="namespaceDeclaration"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="prefix" type="xsd:NCName" minOccurs="0"/&gt;
      &lt;xsd:element name="uri" type="xsd:string"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="attributeList"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:choice maxOccurs="unbounded"&gt;
          &lt;xsd:element name="attributeConstructor" type="attributeConstructor"/&gt;
          &lt;xsd:element name="namespaceDeclaration" type="namespaceDeclaration"/&gt;
        &lt;/xsd:choice&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:element name="elementContent" type="exprList"/&gt;

  &lt;xsd:complexType name="elementConstructor"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="tagName" type="QName"/&gt;
          &lt;xsd:element ref="attributeList" minOccurs="0"/&gt;
          &lt;xsd:element ref="elementContent" minOccurs="0"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="elementConstructor" type="elementConstructor" substitutionGroup="expr"/&gt;

  &lt;!-- computed constructors --&gt;
  &lt;xsd:complexType name="computedElementConstructor"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:choice&gt;
            &lt;xsd:element name="tagName" type="QName"/&gt;
            &lt;xsd:element name="tagNameExpr" type="exprWrapper"/&gt;
          &lt;/xsd:choice&gt;
          &lt;xsd:element name="contentExpr" type="exprWrapper" minOccurs="0"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="computedElementConstructor" type="computedElementConstructor"
               substitutionGroup="expr"/&gt;

  &lt;xsd:complexType name="computedAttributeConstructor"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:choice&gt;
            &lt;xsd:element name="tagName" type="QName"/&gt;
            &lt;xsd:element name="tagNameExpr" type="exprWrapper"/&gt;
          &lt;/xsd:choice&gt;
          &lt;xsd:element name="valueExpr" type="exprWrapper" minOccurs="0"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="computedAttributeConstructor" type="computedAttributeConstructor"
               substitutionGroup="expr"/&gt;

  &lt;xsd:complexType name="computedDocumentConstructor"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="argExpr" type="exprWrapper"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="computedDocumentConstructor" type="computedDocumentConstructor"
               substitutionGroup="expr"/&gt;

  &lt;xsd:complexType name="computedTextConstructor"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="argExpr" type="exprWrapper" minOccurs="0"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="computedTextConstructor" type="computedTextConstructor" substitutionGroup="expr"/&gt;

  &lt;xsd:complexType name="computedCommentConstructor"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="argExpr" type="exprWrapper"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="computedCommentConstructor" type="computedCommentConstructor"
               substitutionGroup="expr"/&gt;

  &lt;xsd:complexType name="computedPIConstructor"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:choice&gt;
            &lt;xsd:element name="piTarget" type="xsd:NCName"/&gt;
            &lt;xsd:element name="piTargetExpr" type="exprWrapper"/&gt;
          &lt;/xsd:choice&gt;
          &lt;xsd:element name="piValueExpr" type="exprWrapper" minOccurs="0"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="computedPIConstructor" type="computedPIConstructor" substitutionGroup="expr"/&gt;

  &lt;!-- ordered and unordered expressions --&gt;
  &lt;xsd:complexType name="unorderedExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="argExpr" type="exprWrapper"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="unorderedExpr" type="unorderedExpr" substitutionGroup="expr"/&gt;

  &lt;xsd:complexType name="orderedExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:sequence&gt;
          &lt;xsd:element name="argExpr" type="exprWrapper"/&gt;
        &lt;/xsd:sequence&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="orderedExpr" type="orderedExpr" substitutionGroup="expr"/&gt;

  &lt;xsd:complexType name="simpleWildcard"&gt;
    &lt;xsd:choice&gt;
      &lt;xsd:element name="QName" type="QName"/&gt;
      &lt;xsd:element name="star" type="emptyContent"/&gt;
    &lt;/xsd:choice&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="Wildcard"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:all&gt;
        &lt;xsd:element name="star" type="emptyContent" minOccurs="0"/&gt;
        &lt;xsd:element ref="NCName" minOccurs="0"/&gt;
      &lt;/xsd:all&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:element name="schemaAttributeTest" type="QName" substitutionGroup="kindTest"/&gt;

  &lt;xsd:element name="attributeTest" substitutionGroup="kindTest"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:complexContent&gt;
        &lt;xsd:extension base="emptyItemTypeContent"&gt;
          &lt;xsd:sequence minOccurs="0"&gt;
            &lt;xsd:element name="attributeName" type="simpleWildcard"/&gt;
            &lt;xsd:element name="typeName" type="QName" minOccurs="0"/&gt;
          &lt;/xsd:sequence&gt;
        &lt;/xsd:extension&gt;
      &lt;/xsd:complexContent&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:element name="anyElementTest" abstract="true" substitutionGroup="kindTest"/&gt;

  &lt;xsd:element name="schemaElementTest" type="QName" substitutionGroup="anyElementTest"/&gt;

  &lt;xsd:element name="elementTest" substitutionGroup="anyElementTest"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:complexContent&gt;
        &lt;xsd:extension base="emptyItemTypeContent"&gt;
          &lt;xsd:sequence minOccurs="0"&gt;
            &lt;xsd:element name="elementName" type="simpleWildcard"/&gt;
            &lt;xsd:sequence minOccurs="0"&gt;
              &lt;xsd:element name="typeName" type="QName"/&gt;
              &lt;xsd:element name="nillable" type="emptyContent" minOccurs="0"/&gt;
            &lt;/xsd:sequence&gt;
          &lt;/xsd:sequence&gt;
        &lt;/xsd:extension&gt;
      &lt;/xsd:complexContent&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:element name="documentTest" substitutionGroup="kindTest"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:complexContent&gt;
        &lt;xsd:extension base="emptyItemTypeContent"&gt;
          &lt;xsd:sequence&gt;
             &lt;xsd:element ref="anyElementTest" minOccurs="0"/&gt;
          &lt;/xsd:sequence&gt;
        &lt;/xsd:extension&gt;
      &lt;/xsd:complexContent&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:element name="piTest" substitutionGroup="kindTest"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:complexContent&gt;
        &lt;xsd:extension base="emptyItemTypeContent"&gt;
          &lt;xsd:sequence&gt;
            &lt;xsd:element name="piTarget" type="xsd:NCName" minOccurs="0"/&gt;
          &lt;/xsd:sequence&gt;
        &lt;/xsd:extension&gt;
      &lt;/xsd:complexContent&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;


  &lt;xsd:element name="nameTest" type="QName"/&gt;

  &lt;xsd:element name="kindTest" substitutionGroup="itemType"/&gt;

  &lt;xsd:element name="textTest" type="emptyItemTypeContent" substitutionGroup="kindTest"/&gt;

  &lt;xsd:element name="commentTest" type="emptyItemTypeContent" substitutionGroup="kindTest"/&gt;

  &lt;xsd:element name="anyKindTest" type="emptyItemTypeContent" substitutionGroup="kindTest"/&gt;


  &lt;xsd:element name="xpathAxis"&gt;
    &lt;xsd:simpleType&gt;
      &lt;xsd:restriction base="xsd:NMTOKEN"&gt;
        &lt;xsd:enumeration value="child"/&gt;
        &lt;xsd:enumeration value="attribute"/&gt;
        &lt;xsd:enumeration value="self"/&gt;
        &lt;xsd:enumeration value="parent"/&gt;
        &lt;xsd:enumeration value="descendant-or-self"/&gt;
        &lt;xsd:enumeration value="descendant"/&gt;
        &lt;xsd:enumeration value="following"/&gt;
        &lt;xsd:enumeration value="following-sibling"/&gt;
        &lt;xsd:enumeration value="ancestor"/&gt;
        &lt;xsd:enumeration value="ancestor-or-self"/&gt;
        &lt;xsd:enumeration value="preceding"/&gt;
        &lt;xsd:enumeration value="preceding-sibling"/&gt;
      &lt;/xsd:restriction&gt;
    &lt;/xsd:simpleType&gt;
  &lt;/xsd:element&gt;


&lt;!-- xqx:parenthesizedExpr deemed not useful; removed.
  &lt;xsd:element name="parenthesizedExpr" type="exprWrapperOptional"/&gt;
--&gt;

  &lt;xsd:group name="filterExpr"&gt;
    &lt;xsd:choice&gt;
      &lt;xsd:element ref="constantExpr"/&gt;
      &lt;xsd:element ref="varRef"/&gt;
      &lt;xsd:element ref="contextItemExpr"/&gt;
      &lt;xsd:element ref="functionCallExpr"/&gt;
&lt;!-- xqx:parenthesizedExpr deemed not useful; replaced with xqx:sequenceExpr. --&gt;
      &lt;xsd:element ref="sequenceExpr"/&gt;
      &lt;xsd:element ref="elementConstructor"/&gt;
      &lt;xsd:element ref="computedElementConstructor"/&gt;
      &lt;xsd:element ref="computedAttributeConstructor"/&gt;
      &lt;xsd:element ref="computedDocumentConstructor"/&gt;
      &lt;xsd:element ref="computedTextConstructor"/&gt;
      &lt;xsd:element ref="computedCommentConstructor"/&gt;
      &lt;xsd:element ref="computedPIConstructor"/&gt;
      &lt;xsd:element ref="orderedExpr"/&gt;
      &lt;xsd:element ref="unorderedExpr"/&gt;
    &lt;/xsd:choice&gt;
  &lt;/xsd:group&gt;

  &lt;!-- removed nameTest and Wildcard outer choices per Bugzilla Bug #2523 --&gt;
  &lt;xsd:element name="stepExpr"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:choice&gt;
          &lt;xsd:sequence&gt;
            &lt;xsd:element ref="xpathAxis"/&gt;
            &lt;xsd:choice&gt;
              &lt;xsd:element ref="kindTest"/&gt;
              &lt;xsd:element ref="nameTest"/&gt;
              &lt;xsd:element ref="Wildcard"/&gt;
                     &lt;/xsd:choice&gt;
          &lt;/xsd:sequence&gt;
          &lt;xsd:element name="filterExpr"&gt;
            &lt;xsd:complexType&gt;
              &lt;xsd:sequence&gt;
                &lt;xsd:group ref="filterExpr"/&gt;
              &lt;/xsd:sequence&gt;
            &lt;/xsd:complexType&gt;
          &lt;/xsd:element&gt;
        &lt;/xsd:choice&gt;
        &lt;xsd:element name="predicates" type="exprList" minOccurs="0"/&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;!-- rewrote pathExpr definition per Bugzilla Bug #2523 --&gt;
  &lt;xsd:complexType name="pathExpr"&gt;
    &lt;xsd:complexContent&gt;
      &lt;xsd:extension base="expr"&gt;
        &lt;xsd:choice&gt;
          &lt;xsd:sequence&gt;
            &lt;xsd:element name="rootExpr" type="emptyContent"/&gt;
            &lt;xsd:element ref="stepExpr" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;/xsd:sequence&gt;
          &lt;xsd:element ref="stepExpr" maxOccurs="unbounded"/&gt;
        &lt;/xsd:choice&gt;
      &lt;/xsd:extension&gt;
    &lt;/xsd:complexContent&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="pathExpr" type="pathExpr" substitutionGroup="expr"/&gt;

  &lt;!-- The following constructs deal with the query prolog --&gt;
  &lt;xsd:element name="module"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element ref="versionDecl" minOccurs="0"/&gt;
        &lt;xsd:choice&gt;
          &lt;xsd:element ref="mainModule"/&gt;
          &lt;xsd:element ref="libraryModule"/&gt;
        &lt;/xsd:choice&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:element name="mainModule"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element ref="prolog" minOccurs="0"/&gt;
        &lt;xsd:element name="queryBody" type="exprWrapper"/&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:element name="libraryModule"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element ref="moduleDecl"/&gt;
        &lt;xsd:element ref="prolog" minOccurs="0"/&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:element name="versionDecl"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element name="version" type="xsd:string"/&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:element name="prolog"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
            &lt;xsd:element ref="prologPartOneItem" minOccurs="0" maxOccurs="unbounded"/&gt;
            &lt;xsd:element ref="prologPartTwoItem" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;/xsd:sequence&gt;
        &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:element name="prologPartOneItem" abstract="true"/&gt;

  &lt;xsd:element name="prologPartTwoItem" abstract="true"/&gt;

  &lt;xsd:element name="defaultCollationDecl" type="xsd:string"
               substitutionGroup="prologPartOneItem"/&gt;

  &lt;xsd:element name="baseUriDecl" type="xsd:string"
               substitutionGroup="prologPartOneItem"/&gt;

  &lt;xsd:element name="constructionDecl" substitutionGroup="prologPartOneItem"&gt;
    &lt;xsd:simpleType&gt;
      &lt;xsd:restriction base="xsd:NMTOKEN"&gt;
        &lt;xsd:enumeration value="strip"/&gt;
        &lt;xsd:enumeration value="preserve"/&gt;
      &lt;/xsd:restriction&gt;
    &lt;/xsd:simpleType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:element name="orderingModeDecl" substitutionGroup="prologPartOneItem"&gt;
    &lt;xsd:simpleType&gt;
      &lt;xsd:restriction base="xsd:NMTOKEN"&gt;
        &lt;xsd:enumeration value="ordered"/&gt;
        &lt;xsd:enumeration value="unordered"/&gt;
      &lt;/xsd:restriction&gt;
    &lt;/xsd:simpleType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:element name="emptyOrderingDecl" type="emptyOrderingMode"
               substitutionGroup="prologPartOneItem"/&gt;

  &lt;xsd:element name="copyNamespacesDecl" substitutionGroup="prologPartOneItem"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element name="preserveMode"&gt;
          &lt;xsd:simpleType&gt;
            &lt;xsd:restriction base="xsd:NMTOKEN"&gt;
              &lt;xsd:enumeration value="preserve"/&gt;
              &lt;xsd:enumeration value="no-preserve"/&gt;
            &lt;/xsd:restriction&gt;
          &lt;/xsd:simpleType&gt;
        &lt;/xsd:element&gt;
        &lt;xsd:element name="inheritMode"&gt;
          &lt;xsd:simpleType&gt;
            &lt;xsd:restriction base="xsd:NMTOKEN"&gt;
              &lt;xsd:enumeration value="inherit"/&gt;
              &lt;xsd:enumeration value="no-inherit"/&gt;
            &lt;/xsd:restriction&gt;
          &lt;/xsd:simpleType&gt;
        &lt;/xsd:element&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:simpleType name="defaultNamespaceCategory"&gt;
    &lt;xsd:restriction base="xsd:NMTOKEN"&gt;
      &lt;xsd:enumeration value="function"/&gt;
      &lt;xsd:enumeration value="element"/&gt;
    &lt;/xsd:restriction&gt;
  &lt;/xsd:simpleType&gt;

  &lt;xsd:element name="defaultNamespaceDecl" substitutionGroup="prologPartOneItem"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element name="defaultNamespaceCategory" type="defaultNamespaceCategory"/&gt;
        &lt;xsd:element name="uri" type="xsd:string"/&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:complexType name="namespaceDeclType"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element name="prefix" type="xsd:NCName"/&gt;
      &lt;xsd:element name="uri" type="xsd:string"/&gt;
    &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;

  &lt;xsd:element name="namespaceDecl" type="namespaceDeclType"
               substitutionGroup="prologPartOneItem"/&gt;

  &lt;xsd:element name="moduleDecl" type="namespaceDeclType"/&gt;

  &lt;xsd:element name="schemaImport" substitutionGroup="prologPartOneItem"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:choice minOccurs="0"&gt;
          &lt;xsd:element name="namespacePrefix" type="xsd:NCName"/&gt;
          &lt;xsd:element name="defaultElementNamespace" type="emptyContent"/&gt;
        &lt;/xsd:choice&gt;
        &lt;xsd:element name="targetNamespace" type="xsd:string"/&gt;
        &lt;xsd:element name="targetLocation" type="xsd:string" minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:element name="moduleImport" substitutionGroup="prologPartOneItem"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element name="namespacePrefix" type="xsd:NCName" minOccurs="0"/&gt;
        &lt;xsd:element name="targetNamespace" type="xsd:string"/&gt;
        &lt;xsd:element name="targetLocation" type="xsd:string" minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:element name="varDecl" substitutionGroup="prologPartTwoItem"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element name="varName" type="QName"/&gt;
        &lt;xsd:element ref="typeDeclaration" minOccurs="0"/&gt;
        &lt;xsd:choice&gt;
          &lt;xsd:element name="varValue" type="exprWrapper"/&gt;
          &lt;xsd:element name="external" type="emptyContent"/&gt;
        &lt;/xsd:choice&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:element name="optionDecl" substitutionGroup="prologPartTwoItem"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element name="optionName" type="QName"/&gt;
        &lt;xsd:element name="optionContents" type="xsd:string"/&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:element name="functionDecl" substitutionGroup="prologPartTwoItem"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element name="functionName" type="QName"/&gt;
        &lt;xsd:element ref="paramList"/&gt;
        &lt;xsd:element ref="typeDeclaration" minOccurs="0"/&gt;
        &lt;xsd:choice&gt;
          &lt;xsd:element name="functionBody" type="exprWrapper"/&gt;
          &lt;xsd:element name="externalDefinition" type="emptyContent"/&gt;
        &lt;/xsd:choice&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;


  &lt;xsd:element name="param"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element name="varName" type="QName"/&gt;
        &lt;xsd:element ref="typeDeclaration" minOccurs="0"/&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;xsd:element name="paramList"&gt;
    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element ref="param" minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;
  &lt;/xsd:element&gt;

  &lt;!-- The element below handles the trivial XQuery embedding --&gt;
  &lt;xsd:element name="xquery" type="xsd:string"/&gt;

&lt;/xsd:schema&gt;
</PRE></DIV></DIV>
<DIV class=div1>
<H2><A id=xqx_conformance name=xqx_conformance></A>5 Conformance</H2>
<P>This section defines the conformance criteria for an XQueryX processor (see 
Figure 1, "Processing Model Overview", in <A 
href="REC-xqueryx-20070123.htm#xquery">[XQuery 1.0: An 
XML Query Language]</A>, <A 
href="http://www.w3.org/TR/xquery#id-processing-model">Section 2.2 Processing 
Model</A><SUP><SMALL>XQ</SMALL></SUP>.</P>
<P>In this section, the following terms are used to indicate the requirement 
levels defined in <A 
href="REC-xqueryx-20070123.htm#RFC2119">[RFC 2119]</A>. 
[Definition: MUST means that the item is an absolute requirement of the 
specification.] [Definition: SHOULD means that there may exist valid reasons in 
particular circumstances to ignore a particular item, but the full implications 
must be understood and carefully weighed before choosing a different course.] 
[Definition: MAY means that an item is truly optional.]</P>
<P>An XQueryX processor that claims to conform to this specification MUST 
implement the XQueryX syntax as defined in <A 
href="REC-xqueryx-20070123.htm#Schema"><B>4 An XML Schema 
for the XQuery XML Syntax</B></A> of this specification and include a claim of 
Minimal Conformance as defined in <A 
href="REC-xqueryx-20070123.htm#xquery">[XQuery 1.0: An 
XML Query Language]</A>, <A 
href="http://www.w3.org/TR/xquery#id-minimal-conformance">Section 5.1 Minimal 
Conformance</A><SUP><SMALL>XQ</SMALL></SUP>. In addition to a claim of Minimal 
Conformance, it MAY claim conformance to one or more optional features defined 
in <A href="REC-xqueryx-20070123.htm#xquery">[XQuery 1.0: 
An XML Query Language]</A>, <A 
href="http://www.w3.org/TR/xquery#id-conform-optional-features">Section 5.2 
Optional Features</A><SUP><SMALL>XQ</SMALL></SUP>.</P></DIV></DIV>
<DIV class=back>
<DIV class=div1>
<H2><A id=biblio name=biblio></A>A References</H2>
<DL>
  <DT class=label><SPAN><A id=xquery-requirements 
  name=xquery-requirements></A>XML Query 1.0 Requirements</SPAN> 
  <DD>
  <DIV><A href="http://www.w3.org/TR/xquery-requirements/"><CITE>XML Query 
  (XQuery) Requirements</CITE></A>, Don Chamberlin, Peter Fankhauser, Massimo 
  Marchiori, and Jonathan Robie, Editors. World Wide Web Consortium, 
  3&nbsp;Jun&nbsp;2005. This version is 
  http://www.w3.org/TR/2005/WD-xquery-requirements-20050603/. The <A 
  href="http://www.w3.org/TR/xquery-requirements">latest version</A> is 
  available at http://www.w3.org/TR/xquery-requirements/.</DIV>
  <DT class=label><SPAN><A id=xquery name=xquery></A>XQuery 1.0: An XML Query 
  Language</SPAN> 
  <DD>
  <DIV><A href="http://www.w3.org/TR/xquery/"><CITE>XQuery 1.0: An XML Query 
  Language</CITE></A>, Don Chamberlin , Anders Berglund, Scott Boag, <EM>et. 
  al.</EM>, Editors. World Wide Web Consortium, 23 Jan 2007. This version is 
  REC-xquery-20070123.htm. The <A 
  href="http://www.w3.org/TR/xquery/">latest version</A> is available at 
  http://www.w3.org/TR/xquery/.</DIV>
  <DT class=label><SPAN><A id=xquery-use-cases name=xquery-use-cases></A>XML 
  Query Use Cases</SPAN> 
  <DD>
  <DIV><A href="http://www.w3.org/TR/xquery-use-cases/"><CITE>XML Query Use 
  Cases</CITE></A>, Jonathan Robie, Don Chamberlin, Peter Fankhauser, <EM>et. 
  al.</EM>, Editors. World Wide Web Consortium, 8 Jun 2006. This version is 
  http://www.w3.org/TR/2006/WD-xquery-use-cases-20060608/. The <A 
  href="http://www.w3.org/TR/xquery-use-cases/">latest version</A> is available 
  at http://www.w3.org/TR/xquery-use-cases/.</DIV>
  <DT class=label><SPAN><A id=xquery-semantics name=xquery-semantics></A>XQuery 
  1.0 Formal Semantics</SPAN> 
  <DD>
  <DIV><A href="http://www.w3.org/TR/xquery-semantics/"><CITE>XQuery 1.0 and 
  XPath 2.0 Formal Semantics</CITE></A>, Jérôme Siméon, Denise Draper, Peter 
  Frankhauser, <EM>et. al.</EM>, Editors. World Wide Web Consortium, 23 Jan 
  2007. This version is 
  REC-xquery-semantics-20070123.htm. The <A 
  href="http://www.w3.org/TR/xquery-semantics/">latest version</A> is available 
  at http://www.w3.org/TR/xquery-semantics/.</DIV>
  <DT class=label><SPAN><A id=RFC2119 name=RFC2119></A>RFC 2119</SPAN> 
  <DD>
  <DIV>S. Bradner. <EM>Key Words for use in RFCs to Indicate Requirement 
  Levels.</EM> IETF RFC 2119. See <A 
  href="http://www.ietf.org/rfc/rfc2119.txt">http://www.ietf.org/rfc/rfc2119.txt</A>.</DIV>
  <DT class=label><SPAN><A id=RFC3023 name=RFC3023></A>RFC 3023</SPAN> 
  <DD>
  <DIV>M. Murata, S. St. Laurent, and D. Kohn. <EM>XML Media Types</EM> IETF RFC 
  3023 or its successors. See <A 
  href="http://www.ietf.org/rfc/rfc3023.txt">http://www.ietf.org/rfc/rfc3023.txt</A>.</DIV></DD></DL></DIV>
<DIV class=div1>
<H2><A id=Stylesheet name=Stylesheet></A>B Transforming XQueryX to XQuery</H2>
<P>The following stylesheet converts from XQueryX syntax to XML Query syntax. 
Note the intent of the stylesheet is to produce <EM>a</EM> valid XQuery with the 
same semantics (see <A 
href="REC-xqueryx-20070123.htm#xquery-semantics">[XQuery 
1.0 Formal Semantics]</A>) as the input XQueryX.</P>
<DIV class=exampleInner><PRE>&lt;?xml version="1.0"?&gt;
&lt;xsl:stylesheet version="1.0"
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:xqx="http://www.w3.org/2005/XQueryX"&gt;

&lt;!-- Note that this stylesheet frequently invokes templates for
     specified elements, even when there are no templates in the
     stylesheet whose match="" attribute identifies those elements.
     In such case, the default template's element matching template
     is invoked, which merely invokes xsl:apply-templates --&gt;

  &lt;xsl:output method="text"/&gt;
  &lt;xsl:strip-space elements="*"/&gt;
  &lt;xsl:preserve-space elements="xqx:value xqx:attributeValue xqx:pragmaContents
                                xqx:optionContents xqx:xquery"/&gt;

  &lt;xsl:variable name="DOT" select="'.'"/&gt;
  &lt;xsl:variable name="SPACE" select="' '"/&gt;
  &lt;xsl:variable name="SLASH" select="'/'"/&gt;
  &lt;xsl:variable name="SLASH_SLASH" select="'//'"/&gt;
  &lt;xsl:variable name="LESSTHAN" select="'&amp;lt;'"/&gt;
  &lt;xsl:variable name="GREATERTHAN" select="'&amp;gt;'"/&gt;
  &lt;xsl:variable name="LPAREN" select="'('"/&gt;
  &lt;xsl:variable name="RPAREN" select="')'"/&gt;
  &lt;xsl:variable name="NEWLINE"&gt;&lt;xsl:text&gt;
&lt;/xsl:text&gt;&lt;/xsl:variable&gt;
  &lt;xsl:variable name="COMMA" select="','"/&gt;
  &lt;xsl:variable name="COMMA_SPACE" select="', '"/&gt;
  &lt;xsl:variable name="COMMA_NEWLINE"&gt;&lt;xsl:text&gt;,
&lt;/xsl:text&gt;&lt;/xsl:variable&gt;
  &lt;xsl:variable name="QUOTE"&gt;&lt;xsl:text&gt;'&lt;/xsl:text&gt;&lt;/xsl:variable&gt;
  &lt;xsl:variable name="DOUBLEQUOTE"&gt;&lt;xsl:text&gt;"&lt;/xsl:text&gt;&lt;/xsl:variable&gt;
  &lt;xsl:variable name="TO" select="' to '"/&gt;
  &lt;xsl:variable name="LBRACE" select="'{'"/&gt;
  &lt;xsl:variable name="RBRACE" select="'}'"/&gt;
  &lt;xsl:variable name="LBRACKET" select="'['"/&gt;
  &lt;xsl:variable name="RBRACKET" select="']'"/&gt;
  &lt;xsl:variable name="DOLLAR" select="'$'"/&gt;
  &lt;xsl:variable name="MINUS" select="'-'"/&gt;
  &lt;xsl:variable name="PLUS" select="'+'"/&gt;
  &lt;xsl:variable name="EQUAL" select="'='"/&gt;
  &lt;xsl:variable name="COLON" select="':'"/&gt;
  &lt;xsl:variable name="DOUBLE_COLON" select="'::'"/&gt;
  &lt;xsl:variable name="SEMICOLON" select="';'"/&gt;
  &lt;xsl:variable name="AT" select="'@'"/&gt;
  &lt;xsl:variable name="STAR" select="'*'"/&gt;
  &lt;xsl:variable name="QUESTIONMARK" select="'?'"/&gt;
  &lt;xsl:variable name="ASSIGN" select="':='"/&gt;
  &lt;xsl:variable name="SEPARATOR" select="';'"/&gt;
  &lt;xsl:variable name="PRAGMA_BEGIN" select="'(# '"/&gt;
  &lt;xsl:variable name="PRAGMA_END" select="' #)'"/&gt;


  &lt;xsl:template name="delimitedList"&gt;
    &lt;xsl:param name="delimiter" /&gt;
    &lt;xsl:param name="leftEncloser"/&gt;
    &lt;xsl:param name="rightEncloser" /&gt;
    &lt;xsl:param name="selector"/&gt;

    &lt;xsl:value-of select="$leftEncloser"/&gt;
    &lt;xsl:for-each select="*"&gt;
      &lt;xsl:apply-templates select="."/&gt;
      &lt;xsl:if test="not (position()=last())"&gt;        
        &lt;xsl:value-of select="$delimiter"/&gt;
      &lt;/xsl:if&gt;       
    &lt;/xsl:for-each&gt;
    &lt;xsl:value-of select="$rightEncloser"/&gt;
  &lt;/xsl:template&gt;   


  &lt;xsl:template name="parenthesizedList"&gt;
    &lt;xsl:param name="delimiter" select="$COMMA_SPACE"/&gt;
    &lt;xsl:call-template name="delimitedList"&gt;
      &lt;xsl:with-param name="delimiter" select="$delimiter" /&gt;
      &lt;xsl:with-param name="leftEncloser" select="$LPAREN"/&gt;
      &lt;xsl:with-param name="rightEncloser" select="$RPAREN"/&gt;
    &lt;/xsl:call-template&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template name="commaSeparatedList"&gt;
    &lt;xsl:call-template name="delimitedList"&gt;
      &lt;xsl:with-param name="delimiter"&gt;
        &lt;xsl:value-of select="$COMMA_SPACE"/&gt;
      &lt;/xsl:with-param&gt;
    &lt;/xsl:call-template&gt;
  &lt;/xsl:template&gt;


  &lt;!-- To resolve Bugzilla bug #3446, we now escape CR (#xD), NEL (#x85),
       and LINE SEPARATOR (#x2028) characters in text nodes and attribute values.
         Note that this template is invoked for a number of other purposes (e.g.,
       xqx:collation, xqx:namespaceDeclaration) where the presence of such
       characters would be invalid and thus are highly unlikely to appear. 
       If they do, then this template will happily escape them, deferring the
       error until the resulting XQuery expression is processed. --&gt;
  &lt;xsl:template name="quote"&gt;
    &lt;xsl:param name="item"/&gt;
    &lt;xsl:value-of select="$DOUBLEQUOTE"/&gt;
    &lt;xsl:call-template name="globalReplace"&gt;
      &lt;xsl:with-param name="stringToBeFixed"&gt;
        &lt;xsl:call-template name="globalReplace"&gt;
          &lt;xsl:with-param name="stringToBeFixed"&gt;
            &lt;xsl:call-template name="globalReplace"&gt;
              &lt;xsl:with-param name="stringToBeFixed"&gt;
                &lt;xsl:call-template name="globalReplace"&gt;
                  &lt;xsl:with-param name="stringToBeFixed"&gt;
                    &lt;xsl:call-template name="globalReplace"&gt;
                      &lt;xsl:with-param name="stringToBeFixed"&gt;
                        &lt;xsl:call-template name="globalReplace"&gt;
                          &lt;xsl:with-param name="stringToBeFixed"&gt;
                            &lt;xsl:value-of select="$item"/&gt;
                          &lt;/xsl:with-param&gt;
                          &lt;xsl:with-param name="toBeReplaced"&gt;&amp;amp;&lt;/xsl:with-param&gt;
                          &lt;xsl:with-param name="replacement"&gt;&amp;amp;amp;&lt;/xsl:with-param&gt;
                        &lt;/xsl:call-template&gt;
                                      &lt;/xsl:with-param&gt;
                      &lt;xsl:with-param name="toBeReplaced"&gt;&amp;lt;&lt;/xsl:with-param&gt;
                      &lt;xsl:with-param name="replacement"&gt;&amp;amp;lt;&lt;/xsl:with-param&gt;
                    &lt;/xsl:call-template&gt;
                  &lt;/xsl:with-param&gt;
                  &lt;xsl:with-param name="toBeReplaced" select="'&amp;#x85;'"/&gt;
                  &lt;xsl:with-param name="replacement"&gt;&amp;amp;#x85;&lt;/xsl:with-param&gt;
                &lt;/xsl:call-template&gt;
              &lt;/xsl:with-param&gt;
              &lt;xsl:with-param name="toBeReplaced" select="'&amp;#xD;'"/&gt;
              &lt;xsl:with-param name="replacement"&gt;&amp;amp;#xD;&lt;/xsl:with-param&gt;
            &lt;/xsl:call-template&gt;
          &lt;/xsl:with-param&gt;
          &lt;xsl:with-param name="toBeReplaced" select="'&amp;#x2028;'"/&gt;
          &lt;xsl:with-param name="replacement"&gt;&amp;amp;#x2028;&lt;/xsl:with-param&gt;
        &lt;/xsl:call-template&gt;
      &lt;/xsl:with-param&gt;
      &lt;xsl:with-param name="toBeReplaced"&gt;&lt;xsl:text&gt;"&lt;/xsl:text&gt;&lt;/xsl:with-param&gt;
      &lt;xsl:with-param name="replacement"&gt;&lt;xsl:text&gt;""&lt;/xsl:text&gt;&lt;/xsl:with-param&gt;
    &lt;/xsl:call-template&gt;
    &lt;xsl:value-of select="$DOUBLEQUOTE"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template name="globalReplace"&gt;
    &lt;xsl:param name="stringToBeFixed"/&gt;
    &lt;xsl:param name="toBeReplaced"/&gt;
    &lt;xsl:param name="replacement"/&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="contains($stringToBeFixed, $toBeReplaced)"&gt;
        &lt;xsl:value-of select="concat(substring-before($stringToBeFixed, $toBeReplaced), $replacement)"/&gt;
        &lt;xsl:call-template name="globalReplace"&gt;
          &lt;xsl:with-param name="stringToBeFixed" select="substring-after($stringToBeFixed, $toBeReplaced)"/&gt;
          &lt;xsl:with-param name="toBeReplaced" select="$toBeReplaced"/&gt;
          &lt;xsl:with-param name="replacement" select="$replacement"/&gt;
        &lt;/xsl:call-template&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:value-of select="$stringToBeFixed"/&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:QName | xqx:pragmaName | xqx:typeName | xqx:varName |
                       xqx:functionName | xqx:optionName |
                       xqx:atomicType | xqx:tagName"&gt;
    &lt;xsl:if test="@xqx:prefix"&gt;
      &lt;xsl:value-of select="@xqx:prefix"/&gt;
      &lt;xsl:value-of select="$COLON"/&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:attributeName"&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="@xqx:prefix='xmlns'"&gt;
        &lt;xsl:message terminate="yes"&gt;Incorrect XQueryX: Attribute names are not permitted to have prefix 'xmlns'; use xqx:namespaceDeclaration to declare namespaces&lt;/xsl:message&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:when test="@xqx:prefix"&gt;
        &lt;xsl:value-of select="@xqx:prefix"/&gt;
        &lt;xsl:value-of select="$COLON"/&gt;
        &lt;xsl:value-of select="."/&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:when test=". = 'xmlns'"&gt;
        &lt;xsl:message terminate="yes"&gt;Incorrect XQueryX: Attribute names are not permitted to be 'xmlns'; use xqx:namespaceDeclaration to declare namespaces&lt;/xsl:message&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:value-of select="."/&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:NCName"&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:rootExpr"&gt;
    &lt;xsl:value-of select="$SLASH"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:contextItemExpr"&gt;
    &lt;xsl:value-of select="$DOT"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:stringConstantExpr"&gt;
    &lt;xsl:call-template name="quote"&gt;
      &lt;xsl:with-param name="item" select="xqx:value"/&gt;
    &lt;/xsl:call-template&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:integerConstantExpr
      | xqx:decimalConstantExpr
      | xqx:doubleConstantExpr"&gt;
    &lt;xsl:value-of select="xqx:value"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:varRef"&gt;
    &lt;xsl:value-of select="$DOLLAR"/&gt;
    &lt;xsl:if test="xqx:name/@xqx:prefix"&gt;
      &lt;xsl:value-of select="xqx:name/@xqx:prefix"/&gt;
      &lt;xsl:value-of select="$COLON"/&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:value-of select="xqx:name"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:pragma"&gt;
    &lt;xsl:value-of select="$PRAGMA_BEGIN"/&gt;
    &lt;xsl:apply-templates select="xqx:pragmaName"/&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:value-of select="xqx:pragmaContents"/&gt;
    &lt;xsl:value-of select="$PRAGMA_END"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:extensionExpr"&gt;
    &lt;xsl:apply-templates select="xqx:pragma"/&gt;
    &lt;xsl:value-of select="$LBRACE"/&gt;
    &lt;xsl:apply-templates select="xqx:argExpr"/&gt;
    &lt;xsl:value-of select="$RBRACE"/&gt;
  &lt;/xsl:template&gt;

&lt;!-- Response to Bugzilla bug #2528 --&gt;
   &lt;xsl:template match="xqx:functionCallExpr"&gt;
     &lt;xsl:choose&gt;
       &lt;xsl:when test="xqx:functionName/@xqx:prefix"&gt;
         &lt;xsl:value-of select="xqx:functionName/@xqx:prefix"/&gt;
         &lt;xsl:value-of select="$COLON"/&gt;
       &lt;/xsl:when&gt;
       &lt;xsl:otherwise&gt;
         &lt;xsl:if test="xqx:functionName = 'node' or
                       xqx:functionName = 'document-node' or
                       xqx:functionName = 'element' or
                       xqx:functionName = 'attribute' or
                       xqx:functionName = 'schema-element' or
                       xqx:functionName = 'schema-attribute' or
                       xqx:functionName = 'processing-instruction' or
                       xqx:functionName = 'comment' or
                       xqx:functionName = 'text' or
                       xqx:functionName = 'item' or
                       xqx:functionName = 'if' or
                       xqx:functionName = 'typeswitch' or
                       xqx:functionName = 'empty-sequence'"&gt;
           &lt;xsl:variable name="message"&gt;&lt;xsl:text&gt;Incorrect XQueryX: function calls must not use unqualified "reserved" name "&lt;/xsl:text&gt;&lt;xsl:value-of select="xqx:functionName"/&gt;&lt;xsl:text&gt;"&lt;/xsl:text&gt;&lt;/xsl:variable&gt;
           &lt;xsl:message terminate="yes"&gt;&lt;xsl:value-of select="$message"/&gt;&lt;/xsl:message&gt;
         &lt;/xsl:if&gt;
       &lt;/xsl:otherwise&gt;
     &lt;/xsl:choose&gt;
     &lt;xsl:value-of select="xqx:functionName"/&gt;
     &lt;xsl:choose&gt;
       &lt;xsl:when test="xqx:arguments"&gt;
         &lt;xsl:for-each select="xqx:arguments"&gt;
           &lt;xsl:call-template name="parenthesizedList"/&gt;
         &lt;/xsl:for-each&gt;
       &lt;/xsl:when&gt;
       &lt;xsl:otherwise&gt;
         &lt;xsl:value-of select="$LPAREN"/&gt;
         &lt;xsl:value-of select="$RPAREN"/&gt;
       &lt;/xsl:otherwise&gt;
     &lt;/xsl:choose&gt;
   &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:constructorFunctionExpr"&gt;
    &lt;xsl:apply-templates select="xqx:typeName"/&gt;
    &lt;xsl:for-each select="xqx:argExpr"&gt;
      &lt;xsl:call-template name="parenthesizedList"/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:unaryMinusOp | xqx:unaryPlusOp"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
     &lt;xsl:choose&gt;
       &lt;xsl:when test="self::xqx:unaryPlusOp"&gt;&lt;xsl:value-of select="$PLUS"/&gt;&lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:unaryMinusOp"&gt;&lt;xsl:value-of select="$MINUS"/&gt;&lt;/xsl:when&gt;
     &lt;/xsl:choose&gt;
    &lt;xsl:apply-templates select="xqx:operand"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:addOp | xqx:subtractOp | xqx:multiplyOp
                     | xqx:divOp | xqx:idivOp | xqx:modOp"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
     &lt;xsl:apply-templates select="xqx:firstOperand"/&gt;
     &lt;xsl:choose&gt;
       &lt;xsl:when test="self::xqx:addOp"&gt;&lt;xsl:value-of select="$PLUS"/&gt;&lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:subtractOp"&gt;&lt;xsl:text&gt; &lt;/xsl:text&gt;&lt;xsl:value-of select="$MINUS"/&gt;&lt;xsl:text&gt; &lt;/xsl:text&gt;&lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:multiplyOp"&gt;&lt;xsl:value-of select="$STAR"/&gt;&lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:divOp"&gt;&lt;xsl:text&gt; div &lt;/xsl:text&gt;&lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:idivOp"&gt;&lt;xsl:text&gt; idiv &lt;/xsl:text&gt;&lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:modOp"&gt;&lt;xsl:text&gt; mod &lt;/xsl:text&gt;&lt;/xsl:when&gt;
     &lt;/xsl:choose&gt;
    &lt;xsl:apply-templates select="xqx:secondOperand"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:eqOp | xqx:neOp | xqx:ltOp
                     | xqx:gtOp | xqx:leOp | xqx:geOp"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
     &lt;xsl:apply-templates select="xqx:firstOperand"/&gt;
     &lt;xsl:choose&gt;
       &lt;xsl:when test="self::xqx:eqOp"&gt;&lt;xsl:text&gt; eq &lt;/xsl:text&gt;&lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:neOp"&gt;&lt;xsl:text&gt; ne &lt;/xsl:text&gt;&lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:ltOp"&gt;&lt;xsl:text&gt; lt &lt;/xsl:text&gt;&lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:gtOp"&gt;&lt;xsl:text&gt; gt &lt;/xsl:text&gt;&lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:leOp"&gt;&lt;xsl:text&gt; le &lt;/xsl:text&gt;&lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:geOp"&gt;&lt;xsl:text&gt; ge &lt;/xsl:text&gt;&lt;/xsl:when&gt;
     &lt;/xsl:choose&gt;
    &lt;xsl:apply-templates select="xqx:secondOperand"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:equalOp | xqx:notEqualOp | xqx:lessThanOp
                     | xqx:greaterThanOp | xqx:lessThanOrEqualOp | xqx:greaterThanOrEqualOp"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
     &lt;xsl:apply-templates select="xqx:firstOperand"/&gt;
     &lt;xsl:choose&gt;
       &lt;xsl:when test="self::xqx:equalOp"&gt;
         &lt;xsl:text&gt; &lt;/xsl:text&gt;&lt;xsl:value-of select="$EQUAL"/&gt;&lt;xsl:text&gt; &lt;/xsl:text&gt;
       &lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:notEqualOp"&gt;
         &lt;xsl:text&gt; !&lt;/xsl:text&gt;&lt;xsl:value-of select="$EQUAL"/&gt;&lt;xsl:text&gt; &lt;/xsl:text&gt;
       &lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:lessThanOp"&gt;
         &lt;xsl:text&gt; &lt;/xsl:text&gt;&lt;xsl:value-of select="$LESSTHAN"/&gt;&lt;xsl:text&gt; &lt;/xsl:text&gt;
       &lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:greaterThanOp"&gt;
         &lt;xsl:text&gt; &lt;/xsl:text&gt;&lt;xsl:value-of select="$GREATERTHAN"/&gt;&lt;xsl:text&gt; &lt;/xsl:text&gt;
       &lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:lessThanOrEqualOp"&gt;
         &lt;xsl:text&gt; &lt;/xsl:text&gt;&lt;xsl:value-of select="$LESSTHAN"/&gt;
         &lt;xsl:value-of select="$EQUAL"/&gt;&lt;xsl:text&gt; &lt;/xsl:text&gt;
       &lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:greaterThanOrEqualOp"&gt;
         &lt;xsl:text&gt; &lt;/xsl:text&gt;&lt;xsl:value-of select="$GREATERTHAN"/&gt;
         &lt;xsl:value-of select="$EQUAL"/&gt;&lt;xsl:text&gt; &lt;/xsl:text&gt;
       &lt;/xsl:when&gt;
     &lt;/xsl:choose&gt;
    &lt;xsl:apply-templates select="xqx:secondOperand"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:isOp | xqx:nodeBeforeOp | xqx:nodeAfterOp"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
     &lt;xsl:apply-templates select="xqx:firstOperand"/&gt;
     &lt;xsl:choose&gt;
       &lt;xsl:when test="self::xqx:isOp"&gt;&lt;xsl:text&gt; is &lt;/xsl:text&gt;&lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:nodeBeforeOp"&gt;&lt;xsl:text&gt; &lt;/xsl:text&gt;
         &lt;xsl:value-of select="$LESSTHAN"/&gt;&lt;xsl:value-of select="$LESSTHAN"/&gt;
         &lt;xsl:text&gt; &lt;/xsl:text&gt;&lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:nodeAfterOp"&gt;&lt;xsl:text&gt; &lt;/xsl:text&gt;
         &lt;xsl:value-of select="$GREATERTHAN"/&gt;&lt;xsl:value-of select="$GREATERTHAN"/&gt;
         &lt;xsl:text&gt; &lt;/xsl:text&gt;&lt;/xsl:when&gt;
     &lt;/xsl:choose&gt;
    &lt;xsl:apply-templates select="xqx:secondOperand"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:andOp | xqx:orOp"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
     &lt;xsl:apply-templates select="xqx:firstOperand"/&gt;
     &lt;xsl:choose&gt;
       &lt;xsl:when test="self::xqx:andOp"&gt;&lt;xsl:text&gt; and &lt;/xsl:text&gt;&lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:orOp"&gt;&lt;xsl:text&gt; or &lt;/xsl:text&gt;&lt;/xsl:when&gt;
     &lt;/xsl:choose&gt;
    &lt;xsl:apply-templates select="xqx:secondOperand"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:unionOp | xqx:intersectOp | xqx:exceptOp"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
     &lt;xsl:apply-templates select="xqx:firstOperand"/&gt;
     &lt;xsl:choose&gt;
       &lt;xsl:when test="self::xqx:unionOp"&gt;&lt;xsl:text&gt; union &lt;/xsl:text&gt;&lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:intersectOp"&gt;&lt;xsl:text&gt; intersect &lt;/xsl:text&gt;&lt;/xsl:when&gt;
       &lt;xsl:when test="self::xqx:exceptOp"&gt;&lt;xsl:text&gt; except &lt;/xsl:text&gt;&lt;/xsl:when&gt;
     &lt;/xsl:choose&gt;
    &lt;xsl:apply-templates select="xqx:secondOperand"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:sequenceExpr"&gt;
    &lt;xsl:for-each select="."&gt;
      &lt;xsl:call-template name="parenthesizedList"&gt;
        &lt;xsl:with-param name="delimiter" select="$COMMA_NEWLINE"/&gt;
      &lt;/xsl:call-template&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:rangeSequenceExpr"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:apply-templates select="xqx:startExpr"/&gt;
    &lt;xsl:value-of select="$TO"/&gt;
    &lt;xsl:apply-templates select="xqx:endExpr"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:forClause"&gt;
    &lt;xsl:text&gt; for &lt;/xsl:text&gt;
    &lt;xsl:call-template name="commaSeparatedList"/&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="xqx:forClauseItem"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="xqx:forExpr"&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
    &lt;xsl:text&gt;    in &lt;/xsl:text&gt;
        &lt;xsl:apply-templates/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:letClause"&gt;
    &lt;xsl:text&gt; let &lt;/xsl:text&gt;
    &lt;xsl:call-template name="commaSeparatedList"/&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="xqx:letClauseItem"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="xqx:letExpr"&gt;
    &lt;xsl:value-of select="$ASSIGN"/&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:returnClause"&gt;
    &lt;xsl:text&gt; return &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="*"/&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:whereClause"&gt;
    &lt;xsl:text&gt; where &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="*"/&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:collation"&gt;
    &lt;xsl:text&gt; collation &lt;/xsl:text&gt;
    &lt;xsl:call-template name="quote"&gt;
      &lt;xsl:with-param name="item"&gt;
        &lt;xsl:value-of select="."/&gt;
      &lt;/xsl:with-param&gt;
    &lt;/xsl:call-template&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:emptyOrderingMode"&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:orderingKind"&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:orderModifier"&gt;
    &lt;xsl:apply-templates select="*"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:orderBySpec"&gt;
    &lt;xsl:apply-templates select="xqx:orderByExpr"/&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:apply-templates select="xqx:orderModifier"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:orderByClause"&gt;
    &lt;xsl:if test="xqx:stable"&gt;
      &lt;xsl:text&gt; stable&lt;/xsl:text&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:text&gt; order by &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:orderBySpec[1]"/&gt;
    &lt;xsl:for-each select="xqx:orderBySpec[position() &gt; 1]"&gt;
      &lt;xsl:value-of select="$COMMA_SPACE"/&gt;
      &lt;xsl:apply-templates select="."/&gt;
    &lt;/xsl:for-each&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
  &lt;/xsl:template&gt;


&lt;!-- Surrounding FLWOR expressions with parentheses completes the set --&gt;
  &lt;xsl:template match="xqx:flworExpr"&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:apply-templates select="*"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:ifThenElseExpr"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:text&gt; if &lt;/xsl:text&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:apply-templates select="xqx:ifClause"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
    &lt;xsl:text&gt; then &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:thenClause"/&gt;
    &lt;xsl:text&gt; else &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:elseClause"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:positionalVariableBinding"&gt;
    &lt;xsl:text&gt; at &lt;/xsl:text&gt;
    &lt;xsl:value-of select="$DOLLAR"/&gt;
    &lt;xsl:if test="@xqx:prefix"&gt;
      &lt;xsl:value-of select="@xqx:prefix"/&gt;
      &lt;xsl:value-of select="$COLON"/&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:variableBinding"&gt;
    &lt;xsl:value-of select="$DOLLAR"/&gt;
    &lt;xsl:if test="@xqx:prefix"&gt;
      &lt;xsl:value-of select="@xqx:prefix"/&gt;
      &lt;xsl:value-of select="$COLON"/&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:value-of select="."/&gt;
    &lt;xsl:if test="parent::xqx:typeswitchExprCaseClause"&gt;
      &lt;xsl:text&gt; as &lt;/xsl:text&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:typedVariableBinding" name="typedVariableBinding"&gt;
    &lt;xsl:value-of select="$DOLLAR"/&gt;
    &lt;xsl:apply-templates select="xqx:varName"/&gt;
    &lt;xsl:apply-templates select="xqx:typeDeclaration"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:quantifiedExprInClause"&gt;
    &lt;xsl:apply-templates select="xqx:typedVariableBinding"/&gt;
    &lt;xsl:text&gt; in &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:sourceExpr"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:quantifiedExpr"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:value-of select="xqx:quantifier"/&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:apply-templates select="xqx:quantifiedExprInClause[1]"/&gt;
    &lt;xsl:for-each select="xqx:quantifiedExprInClause[position() &gt; 1]"&gt;
      &lt;xsl:value-of select="$COMMA_SPACE"/&gt;
      &lt;xsl:apply-templates select="."/&gt;
    &lt;/xsl:for-each&gt;
    &lt;xsl:text&gt; satisfies &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:predicateExpr"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:instanceOfExpr"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:apply-templates select="xqx:argExpr"/&gt;
    &lt;xsl:text&gt; instance of &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:sequenceType"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:castExpr"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:apply-templates select="xqx:argExpr"/&gt;
    &lt;xsl:text&gt; cast as &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:singleType"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:castableExpr"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:apply-templates select="xqx:argExpr"/&gt;
    &lt;xsl:text&gt; castable as &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:singleType"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:treatExpr"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:apply-templates select="xqx:argExpr"/&gt;
    &lt;xsl:text&gt; treat as &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:sequenceType"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:typeswitchExprCaseClause"&gt;
    &lt;xsl:text&gt; case &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:variableBinding"/&gt;
    &lt;xsl:apply-templates select="xqx:sequenceType"/&gt;
    &lt;xsl:text&gt; return &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:resultExpr"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:typeswitchExprDefaultClause"&gt;
    &lt;xsl:text&gt; default &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:variableBinding"/&gt;
    &lt;xsl:text&gt; return &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:resultExpr"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:typeswitchExpr"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:text&gt;typeswitch&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:apply-templates select="xqx:argExpr"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
    &lt;xsl:apply-templates select="xqx:typeswitchExprCaseClause"/&gt;
    &lt;xsl:apply-templates select="xqx:typeswitchExprDefaultClause"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:validateExpr"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:text&gt; validate &lt;/xsl:text&gt;
    &lt;xsl:value-of select="xqx:validationMode"/&gt;
    &lt;xsl:value-of select="$LBRACE"/&gt;
    &lt;xsl:apply-templates select="xqx:argExpr"/&gt;
    &lt;xsl:value-of select="$RBRACE"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:xpathAxis"&gt;
    &lt;xsl:value-of select="."/&gt;
    &lt;xsl:value-of select="$DOUBLE_COLON"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:predicates"&gt;
    &lt;xsl:for-each select="*"&gt;
      &lt;xsl:value-of select="$LBRACKET"/&gt;
      &lt;xsl:apply-templates select="."/&gt;
      &lt;xsl:value-of select="$RBRACKET"/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:star"&gt;
    &lt;xsl:value-of select="$STAR"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:Wildcard[*]"&gt;
    &lt;xsl:apply-templates select="*[1]"/&gt;
    &lt;xsl:if test="*[2]"&gt;
      &lt;xsl:value-of select="$COLON"/&gt;
      &lt;xsl:apply-templates select="*[2]"/&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:Wildcard[not(*)]"&gt;
    &lt;xsl:value-of select="$STAR"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template name="simpleWildcard" match="xqx:simpleWildcard"&gt;
    &lt;xsl:apply-templates select="xqx:star"/&gt;
    &lt;xsl:apply-templates select="xqx:QName"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:textTest"&gt;
    &lt;xsl:text&gt;text()&lt;/xsl:text&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:commentTest"&gt;
    &lt;xsl:text&gt;comment()&lt;/xsl:text&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:anyKindTest"&gt;
    &lt;xsl:text&gt;node()&lt;/xsl:text&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:piTest"&gt;
    &lt;xsl:text&gt;processing-instruction&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:value-of select="*"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:documentTest"&gt;
    &lt;xsl:text&gt;document-node&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:apply-templates select="*"/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:nameTest"&gt;
    &lt;xsl:if test="@xqx:prefix"&gt;
      &lt;xsl:value-of select="@xqx:prefix"/&gt;
      &lt;xsl:value-of select="$COLON"/&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:attributeTest"&gt;
    &lt;xsl:text&gt;attribute&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:for-each select="xqx:attributeName"&gt;
      &lt;xsl:call-template name="simpleWildcard"/&gt;
    &lt;/xsl:for-each&gt;
    &lt;xsl:if test="xqx:typeName"&gt;
      &lt;xsl:value-of select="$COMMA"/&gt;
      &lt;xsl:apply-templates select="xqx:typeName"/&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:elementTest"&gt;
    &lt;xsl:text&gt;element&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:for-each select="xqx:elementName"&gt;
      &lt;xsl:call-template name="simpleWildcard"/&gt;
    &lt;/xsl:for-each&gt;
    &lt;xsl:if test="xqx:typeName"&gt;
      &lt;xsl:value-of select="$COMMA"/&gt;
      &lt;xsl:apply-templates select="xqx:typeName"/&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="xqx:nillable"&gt;
      &lt;xsl:value-of select="$QUESTIONMARK"/&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:schemaElementTest"&gt;
    &lt;xsl:text&gt;schema-element&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:if test="@xqx:prefix"&gt;
      &lt;xsl:value-of select="@xqx:prefix"/&gt;
      &lt;xsl:value-of select="$COLON"/&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:value-of select="."/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:schemaAttributeTest"&gt;
    &lt;xsl:text&gt;schema-attribute&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;
    &lt;xsl:if test="@xqx:prefix"&gt;
      &lt;xsl:value-of select="@xqx:prefix"/&gt;
      &lt;xsl:value-of select="$COLON"/&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:value-of select="."/&gt;
    &lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;!-- rewrote test expression per Bugzilla Bug #2523 --&gt;
  &lt;xsl:template match="xqx:stepExpr"&gt;
    &lt;xsl:if test="preceding-sibling::xqx:stepExpr"&gt;
      &lt;xsl:value-of select="$SLASH"/&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:apply-templates select="*"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:parenthesizedExpr"&gt;
    &lt;xsl:value-of select="$LPAREN"/&gt;&lt;xsl:apply-templates/&gt;&lt;xsl:value-of select="$RPAREN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:filterExpr"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:template&gt;


  &lt;!-- rewrote pathExpr template per Bugzilla Bug #2523 --&gt;
  &lt;xsl:template match="xqx:pathExpr"&gt;
    &lt;xsl:apply-templates select="xqx:rootExpr | xqx:stepExpr"/&gt;
  &lt;/xsl:template&gt;


  &lt;!-- To resolve Bugzilla bug #3446, we now escape NL (#xA) and TAB (#x9)
       characters in attribute values --&gt;
  &lt;xsl:template match="xqx:attributeConstructor"&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:apply-templates select="xqx:attributeName"/&gt;
    &lt;xsl:value-of select="$EQUAL"/&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="xqx:attributeValue"&gt;
        &lt;xsl:call-template name="globalReplace"&gt;
          &lt;xsl:with-param name="stringToBeFixed"&gt;
            &lt;xsl:call-template name="globalReplace"&gt;
              &lt;xsl:with-param name="stringToBeFixed"&gt;
                &lt;xsl:call-template name="quote"&gt;
                  &lt;xsl:with-param name="item"&gt;
                    &lt;xsl:call-template name="globalReplace"&gt;
                      &lt;xsl:with-param name="stringToBeFixed"&gt;
                        &lt;xsl:call-template name="globalReplace"&gt;
                          &lt;xsl:with-param name="stringToBeFixed"&gt;
                            &lt;xsl:value-of select="xqx:attributeValue"/&gt;
                          &lt;/xsl:with-param&gt;
                          &lt;xsl:with-param name="toBeReplaced"&gt;&lt;xsl:text&gt;{&lt;/xsl:text&gt;&lt;/xsl:with-param&gt;
                          &lt;xsl:with-param name="replacement"&gt;&lt;xsl:text&gt;{{&lt;/xsl:text&gt;&lt;/xsl:with-param&gt;
                        &lt;/xsl:call-template&gt;
                      &lt;/xsl:with-param&gt;
                      &lt;xsl:with-param name="toBeReplaced"&gt;&lt;xsl:text&gt;}&lt;/xsl:text&gt;&lt;/xsl:with-param&gt;
                      &lt;xsl:with-param name="replacement"&gt;&lt;xsl:text&gt;}}&lt;/xsl:text&gt;&lt;/xsl:with-param&gt;
                    &lt;/xsl:call-template&gt;
                  &lt;/xsl:with-param&gt;
                &lt;/xsl:call-template&gt;
              &lt;/xsl:with-param&gt;
              &lt;xsl:with-param name="toBeReplaced" select="'&amp;#xA;'"/&gt;
              &lt;xsl:with-param name="replacement"&gt;&amp;amp;#xA;&lt;/xsl:with-param&gt;
            &lt;/xsl:call-template&gt;
          &lt;/xsl:with-param&gt;
          &lt;xsl:with-param name="toBeReplaced" select="'&amp;#x9;'"/&gt;
          &lt;xsl:with-param name="replacement"&gt;&amp;amp;#x9;&lt;/xsl:with-param&gt;
        &lt;/xsl:call-template&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:value-of select="$DOUBLEQUOTE"/&gt;
        &lt;xsl:for-each select="./xqx:attributeValueExpr/xqx:*"&gt;
          &lt;xsl:value-of select="$LBRACE"/&gt;
            &lt;xsl:apply-templates select="."/&gt;
          &lt;xsl:value-of select="$RBRACE"/&gt;
        &lt;/xsl:for-each&gt;
        &lt;xsl:value-of select="$DOUBLEQUOTE"/&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:namespaceDeclaration"&gt;
    &lt;xsl:text&gt; xmlns&lt;/xsl:text&gt;
    &lt;xsl:if test="xqx:prefix"&gt;
      &lt;xsl:text&gt;:&lt;/xsl:text&gt;
      &lt;xsl:value-of select="xqx:prefix"/&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:value-of select="$EQUAL"/&gt;
    &lt;xsl:call-template name="quote"&gt;
      &lt;xsl:with-param name="item" select="xqx:uri"/&gt;
    &lt;/xsl:call-template&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="xqx:attributeList"&gt;
    &lt;xsl:apply-templates select="*"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:elementContent"&gt;
    &lt;xsl:for-each select="*"&gt;
      &lt;xsl:if test="not(self::xqx:elementConstructor)"&gt;
         &lt;xsl:value-of select="$LBRACE"/&gt;
      &lt;/xsl:if&gt;
      &lt;xsl:apply-templates select="."/&gt;
      &lt;xsl:if test="not(self::xqx:elementConstructor)"&gt;
         &lt;xsl:value-of select="$RBRACE"/&gt;
      &lt;/xsl:if&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:elementConstructor"&gt;
    &lt;xsl:value-of select="$LESSTHAN"/&gt;
    &lt;xsl:apply-templates select="xqx:tagName"/&gt;
    &lt;xsl:apply-templates select="xqx:attributeList"/&gt;
    &lt;xsl:value-of select="$GREATERTHAN"/&gt;
    &lt;xsl:apply-templates select="xqx:elementContent"/&gt;
    &lt;xsl:value-of select="$LESSTHAN"/&gt;
    &lt;xsl:value-of select="$SLASH"/&gt;
    &lt;xsl:apply-templates select="xqx:tagName"/&gt;
    &lt;xsl:value-of select="$GREATERTHAN"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:tagNameExpr"&gt;
    &lt;xsl:value-of select="$LBRACE"/&gt;
    &lt;xsl:apply-templates select="*"/&gt;
    &lt;xsl:value-of select="$RBRACE"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:computedElementConstructor"&gt;
    &lt;xsl:text&gt; element &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:tagName"/&gt;
    &lt;xsl:apply-templates select="xqx:tagNameExpr"/&gt;
    &lt;xsl:value-of select="$LBRACE"/&gt;
    &lt;xsl:apply-templates select="xqx:contentExpr"/&gt;     
    &lt;xsl:value-of select="$RBRACE"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:computedAttributeConstructor"&gt;
    &lt;xsl:text&gt; attribute &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:tagName"/&gt;
    &lt;xsl:apply-templates select="xqx:tagNameExpr"/&gt;
    &lt;xsl:value-of select="$LBRACE"/&gt;
    &lt;xsl:apply-templates select="xqx:valueExpr"/&gt;     
    &lt;xsl:value-of select="$RBRACE"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:computedDocumentConstructor"&gt;
    &lt;xsl:text&gt; document {&lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="*"/&gt;
    &lt;xsl:text&gt; }&lt;/xsl:text&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:computedTextConstructor"&gt;
    &lt;xsl:text&gt; text&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$LBRACE"/&gt;
    &lt;xsl:apply-templates select="*"/&gt;
    &lt;xsl:value-of select="$RBRACE"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:computedCommentConstructor"&gt;
    &lt;xsl:text&gt; comment&lt;/xsl:text&gt;
    &lt;xsl:value-of select="$LBRACE"/&gt;
    &lt;xsl:apply-templates select="*"/&gt;
    &lt;xsl:value-of select="$RBRACE"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:piTargetExpr"&gt;
    &lt;xsl:value-of select="$LBRACE"/&gt;
    &lt;xsl:apply-templates select="*"/&gt;
    &lt;xsl:value-of select="$RBRACE"/&gt;
  &lt;/xsl:template&gt;


&lt;!-- Move value braces into computedPIConstructor template from this template, Bugzilla bug #3442 --&gt;
  &lt;xsl:template match="xqx:piValueExpr"&gt;
    &lt;xsl:apply-templates select="*"/&gt;
  &lt;/xsl:template&gt;


&lt;!-- Move value braces into this template from piValueExpr template, Bugzilla bug #3442 --&gt;
  &lt;xsl:template match="xqx:computedPIConstructor"&gt;
    &lt;xsl:text&gt; processing-instruction &lt;/xsl:text&gt;
    &lt;xsl:value-of select="xqx:piTarget"/&gt;
    &lt;xsl:apply-templates select="xqx:piTargetExpr"/&gt;
    &lt;xsl:value-of select="$LBRACE"/&gt;
    &lt;xsl:apply-templates select="xqx:piValueExpr"/&gt;
    &lt;xsl:value-of select="$RBRACE"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:unorderedExpr"&gt;
    &lt;xsl:text&gt; unordered&lt;/xsl:text&gt;
        &lt;xsl:value-of select="$LBRACE"/&gt;
    &lt;xsl:text&gt; &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="*"/&gt;
    &lt;xsl:text&gt; &lt;/xsl:text&gt;
    &lt;xsl:value-of select="$RBRACE"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:orderedExpr"&gt;
    &lt;xsl:text&gt; ordered&lt;/xsl:text&gt;
        &lt;xsl:value-of select="$LBRACE"/&gt;
    &lt;xsl:text&gt; &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="*"/&gt;
    &lt;xsl:text&gt; &lt;/xsl:text&gt;
    &lt;xsl:value-of select="$RBRACE"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:versionDecl"&gt;
    &lt;xsl:text&gt; xquery version &lt;/xsl:text&gt;
    &lt;xsl:call-template name="quote"&gt;
      &lt;xsl:with-param name="item" select="xqx:version"/&gt;
    &lt;/xsl:call-template&gt;
    &lt;xsl:value-of select="$SEPARATOR"/&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:namespaceDecl"&gt;
    &lt;xsl:text&gt;declare namespace &lt;/xsl:text&gt;
    &lt;xsl:value-of select="xqx:prefix"/&gt;
    &lt;xsl:value-of select="$EQUAL"/&gt;
    &lt;xsl:call-template name="quote"&gt;
      &lt;xsl:with-param name="item" select="xqx:uri"/&gt;
    &lt;/xsl:call-template&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:defaultNamespaceDecl"&gt;
    &lt;xsl:text&gt;declare default &lt;/xsl:text&gt;
    &lt;xsl:value-of select="xqx:defaultNamespaceCategory"/&gt;
    &lt;xsl:text&gt; namespace &lt;/xsl:text&gt;
    &lt;xsl:call-template name="quote"&gt;
      &lt;xsl:with-param name="item" select="xqx:uri"/&gt;
    &lt;/xsl:call-template&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:defaultCollationDecl"&gt;
    &lt;xsl:text&gt;declare default collation &lt;/xsl:text&gt;
    &lt;xsl:call-template name="quote"&gt;
      &lt;xsl:with-param name="item" select="."/&gt;
    &lt;/xsl:call-template&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:baseUriDecl"&gt;
    &lt;xsl:text&gt;declare base-uri &lt;/xsl:text&gt;
    &lt;xsl:call-template name="quote"&gt;
      &lt;xsl:with-param name="item" select="."/&gt;
    &lt;/xsl:call-template&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="xqx:constructionDecl"&gt;
    &lt;xsl:text&gt;declare construction &lt;/xsl:text&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:orderingModeDecl"&gt;
    &lt;xsl:text&gt;declare ordering &lt;/xsl:text&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:emptyOrderingDecl"&gt;
    &lt;xsl:text&gt;declare default order &lt;/xsl:text&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:copyNamespacesDecl"&gt;
    &lt;xsl:text&gt;declare copy-namespaces &lt;/xsl:text&gt;
    &lt;xsl:value-of select="xqx:preserveMode"/&gt;
    &lt;xsl:value-of select="$COMMA"/&gt;
    &lt;xsl:value-of select="xqx:inheritMode"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:optionDecl"&gt;
    &lt;xsl:text&gt;declare option &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:optionName"/&gt;
    &lt;xsl:value-of select="$SPACE"/&gt;
    &lt;xsl:call-template name="quote"&gt;
      &lt;xsl:with-param name="item" select="xqx:optionContents"/&gt;
    &lt;/xsl:call-template&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:voidSequenceType"&gt;
    &lt;xsl:text&gt;empty-sequence()&lt;/xsl:text&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:occurrenceIndicator"&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:anyItemType"&gt;
    &lt;xsl:text&gt;item()&lt;/xsl:text&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:sequenceType"&gt;
    &lt;xsl:apply-templates select="*"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:singleType"&gt;
    &lt;xsl:apply-templates select="xqx:atomicType"/&gt;
    &lt;xsl:if test="xqx:optional"&gt;
      &lt;xsl:text&gt;?&lt;/xsl:text&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:typeDeclaration"&gt;
    &lt;xsl:text&gt; as &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="*"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:varDecl"&gt;
    &lt;xsl:text&gt;declare variable &lt;/xsl:text&gt;
    &lt;xsl:value-of select="$DOLLAR"/&gt;
    &lt;xsl:apply-templates select="xqx:varName"/&gt;
    &lt;xsl:apply-templates select="xqx:typeDeclaration"/&gt;
    &lt;xsl:if test="xqx:external"&gt;
      &lt;xsl:text&gt; external &lt;/xsl:text&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="xqx:varValue"&gt;
      &lt;xsl:value-of select="$ASSIGN"/&gt;
      &lt;xsl:apply-templates select="xqx:varValue"/&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;


&lt;!-- Part of fix for Bugzilla bug #3520 --&gt;
  &lt;xsl:template match="xqx:targetLocation"&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="position()=1"&gt; at &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;,&amp;#xD;  &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
    &lt;xsl:call-template name="quote"&gt;
      &lt;xsl:with-param name="item" select="."/&gt;
    &lt;/xsl:call-template&gt;
  &lt;/xsl:template&gt;


&lt;!-- Modified to fix Bugzilla bug #3520 --&gt;
  &lt;xsl:template match="xqx:schemaImport"&gt;
    &lt;xsl:text&gt; import schema &lt;/xsl:text&gt;
    &lt;xsl:if test="xqx:defaultElementNamespace"&gt;
      &lt;xsl:text&gt; default element namespace &lt;/xsl:text&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:if test="xqx:namespacePrefix"&gt;
      &lt;xsl:text&gt; namespace &lt;/xsl:text&gt;
      &lt;xsl:value-of select="xqx:namespacePrefix"/&gt;
      &lt;xsl:value-of select="$EQUAL"/&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:call-template name="quote"&gt;
      &lt;xsl:with-param name="item" select="xqx:targetNamespace"/&gt;
    &lt;/xsl:call-template&gt;
    &lt;xsl:apply-templates select="xqx:targetLocation"/&gt;
  &lt;/xsl:template&gt;


&lt;!-- Modified to fix Bugzilla bug #3520 --&gt;
  &lt;xsl:template match="xqx:moduleImport"&gt;
    &lt;xsl:text&gt; import module &lt;/xsl:text&gt;
    &lt;xsl:if test="xqx:namespacePrefix"&gt;
      &lt;xsl:text&gt; namespace &lt;/xsl:text&gt;
      &lt;xsl:value-of select="xqx:namespacePrefix"/&gt;
      &lt;xsl:value-of select="$EQUAL"/&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:call-template name="quote"&gt;
      &lt;xsl:with-param name="item" select="xqx:targetNamespace"/&gt;
    &lt;/xsl:call-template&gt;
    &lt;xsl:apply-templates select="xqx:targetLocation"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:param"&gt;
    &lt;xsl:value-of select="$DOLLAR"/&gt;
    &lt;xsl:apply-templates select="xqx:varName"/&gt;
    &lt;xsl:apply-templates select="xqx:typeDeclaration"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:paramList"&gt;
    &lt;xsl:call-template name="parenthesizedList"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:functionBody"&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
    &lt;xsl:value-of select="$LBRACE"/&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
    &lt;xsl:apply-templates/&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
    &lt;xsl:value-of select="$RBRACE"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:functionDecl"&gt;
    &lt;xsl:text&gt;declare function &lt;/xsl:text&gt;
    &lt;xsl:apply-templates select="xqx:functionName"/&gt;
    &lt;xsl:apply-templates select="xqx:paramList"/&gt;
    &lt;xsl:apply-templates select="xqx:typeDeclaration"/&gt;
    &lt;xsl:apply-templates select="xqx:functionBody"/&gt;
    &lt;xsl:if test="xqx:externalDefinition"&gt;
      &lt;xsl:text&gt; external &lt;/xsl:text&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:queryBody"&gt;
    &lt;xsl:apply-templates select="*"/&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="xqx:moduleDecl"&gt;
    &lt;xsl:text&gt; module namespace &lt;/xsl:text&gt;
    &lt;xsl:value-of select="xqx:prefix"/&gt;
    &lt;xsl:value-of select="$EQUAL"/&gt;
    &lt;xsl:call-template name="quote"&gt;
      &lt;xsl:with-param name="item" select="xqx:uri" /&gt;
    &lt;/xsl:call-template&gt;
    &lt;xsl:value-of select="$SEPARATOR"/&gt;
    &lt;xsl:value-of select="$NEWLINE"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:prolog"&gt;
    &lt;xsl:for-each select="*"&gt;
      &lt;xsl:apply-templates select="."/&gt;
      &lt;xsl:value-of select="$SEPARATOR"/&gt;
      &lt;xsl:value-of select="$NEWLINE"/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:libraryModule"&gt;
    &lt;xsl:apply-templates select="xqx:moduleDecl"/&gt;
    &lt;xsl:apply-templates select="xqx:prolog"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:mainModule"&gt;
    &lt;xsl:apply-templates select="xqx:prolog"/&gt;
    &lt;xsl:apply-templates select="xqx:queryBody"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="xqx:module" priority="2"&gt;
    &lt;xsl:apply-templates select="*"/&gt;
  &lt;/xsl:template&gt;


  &lt;xsl:template match="/xqx:*"&gt;
   &lt;xsl:message terminate="yes"&gt;Incorrect XQueryX: The only top-level element permitted is xqx:module&lt;/xsl:message&gt;
  &lt;/xsl:template&gt;


&lt;/xsl:stylesheet&gt; 
</PRE></DIV></DIV>
<DIV class=div1>
<H2><A id=xqueryx-id-mime-type name=xqueryx-id-mime-type></A>C The 
<CODE>application/xquery+xml</CODE> Media Type</H2>
<P>This Appendix specifies the media type for XQueryX Version 1.0. XQueryX is 
the XML syntax of a language, XQuery, for querying over data from XML data 
sources, as specified in <A 
href="REC-xqueryx-20070123.htm#xquery">[XQuery 1.0: An 
XML Query Language]</A>.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>Specification of media types is described in <A 
href="REC-xqueryx-20070123.htm#RFC3023">[RFC 
3023]</A>.</P></DIV>
<DIV class=div2>
<H3><A id=xqueryx-mime-introduction name=xqueryx-mime-introduction></A>C.1 
Introduction</H3>
<P>This document, together with its normative references, defines the XML syntax 
for the XML Query language XQuery Version 1.0. This Appendix specifies the 
<CODE>application/xquery+xml</CODE> media type, which is intended to be used for 
transmitting queries expressed in the XQueryX syntax.</P>
<P>This media type is being submitted to the IESG for review, approval, and 
registration with IANA.</P>
<P>This document was prepared by members of the W3C XML Query Working Group. 
Please send comments to public-qt-comments@w3.org, a public mailing list with 
archives at <A 
href="http://lists.w3.org/Archives/Public/public-qt-comments">http://lists.w3.org/Archives/Public/public-qt-comments</A>.</P></DIV>
<DIV class=div2>
<H3><A id=xqueryx-mime-registration name=xqueryx-mime-registration></A>C.2 
Registration of MIME Media Type <CODE>application/xquery+xml</CODE></H3>
<P>MIME media type name: <CODE>application</CODE></P>
<P>MIME subtype name: <CODE>xquery+xml</CODE></P>
<P>Required parameters: none</P>
<P>Optional parameters: <CODE>charset</CODE></P>
<P>This parameter has identical semantics to the <CODE>charset</CODE> parameter 
of the <CODE>application/xml</CODE> media type as specified in [RFC 3023].</P>
<DIV class=div3>
<H4><A id=xqueryx-mime-encoding name=xqueryx-mime-encoding></A>C.2.1 Encoding 
Considerations</H4>
<P>By virtue of XSLT content being XML, it has the same considerations when sent 
as "<CODE>application/xquery+xml</CODE>" as does XML. See [RFC 3023], section 
3.2.</P></DIV>
<DIV class=div3>
<H4><A id=xqueryx-mime-security name=xqueryx-mime-security></A>C.2.2 Security 
Considerations</H4>
<P>Queries written in XQuery may cause arbitrary URIs or IRIs to be 
dereferenced. Therefore, the security issues of [RFC3987] Section 8 should be 
considered. In addition, the contents of resources identified by 
<CODE>file:</CODE> URIs can in some cases be accessed, processed and returned as 
results. XQuery expressions can invoke any of the functions defined in XQuery 
1.0 and XPath 2.0 Functions and Operators, including <CODE>file-exists()</CODE>; 
a <CODE>doc()</CODE> function also allows local filesystem probes as well as 
access to any URI-defined resource accessible from the system evaluating the 
XQuery expression.</P>
<P>XQuery is a full declarative programming language, and supports user-defined 
functions, external function libraries (modules) referenced by URI, and 
system-specific "native" functions.</P>
<P>Arbitrary recursion is possible, as is arbitrarily large memory usage, and 
implementations may place limits on CPU and memory usage, as well as restricting 
access to system-defined functions.</P>
<P>The XML Query Working group is working on a facility to allow XQuery 
expressions to be used to create and update persistent data. Untrusted queries 
should not be given write access to data.</P>
<P>Furthermore, because the XQuery language permits extensions, it is possible 
that application/xquery may describe content that has security implications 
beyond those described here.</P></DIV>
<DIV class=div3>
<H4><A id=xqueryx-mime-interoperability 
name=xqueryx-mime-interoperability></A>C.2.3 Interoperability 
Considerations</H4>
<P>See <A href="http://www.w3.org/TR/xquery#id-xquery-conformance">Section 5 
Conformance</A><SUP><SMALL>XQ</SMALL></SUP>.</P></DIV>
<DIV class=div3>
<H4><A id=xqueryx-mime-pubspec name=xqueryx-mime-pubspec></A>C.2.4 Published 
specification</H4>
<P>This media type registration is for XQueryX documents as described by the 
XQueryX 1.0 specification, which is located at <A 
href="http://www.w3.org/TR/xqueryx/">http://www.w3.org/TR/xqueryx/</A>. It is 
also appropriate to use this media type with later versions of the XQueryX 
language.</P></DIV>
<DIV class=div3>
<H4><A id=xqueryx-mime-applications name=xqueryx-mime-applications></A>C.2.5 
Applications That Use This Media Type</H4>
<P>The public <A href="http://www.w3.org/XML/Query">XQuery Web page</A> lists 
more than two dozen implementations of the XQuery language, both proprietary and 
open source. Some of these are known to support XQueryX.</P>
<P>This new media type is being registered to allow for deployment of XQueryX on 
the World Wide Web.</P>
<P>There is no experimental, vendor specific, or personal tree predecessor to 
"application/xquery+xml", reflecting the fact that no applications currently 
recognize it. This new type is being registered in order to allow for the 
expected deployment of XQueryX 1.0 on the World Wide Web, as a first class XML 
application.</P></DIV>
<DIV class=div3>
<H4><A id=xqueryx-mime-additional name=xqueryx-mime-additional></A>C.2.6 
Additional Information</H4>
<DIV class=div4>
<H5><A id=xqueryx-mime-recognizing name=xqueryx-mime-recognizing></A>C.2.6.1 
Recognizing XQuery Files ("Magic Numbers")</H5>
<P>Although no byte sequences can be counted on to consistently identify 
XQueryX, XQueryX documents will have the sequence 
"http://www.w3.org/2005/XQueryX" to identify the XQueryX namespace. This 
sequence will normally be found in a namespace attribute of the first element in 
the document.</P></DIV>
<DIV class=div4>
<H5><A id=xqueryx-mime-extensions name=xqueryx-mime-extensions></A>C.2.6.2 File 
Extensions</H5>
<P>The most common file extension in use for XQueryX is 
<CODE>.xqx</CODE>.</P></DIV>
<DIV class=div4>
<H5><A id=xqueryx-mime-macfiletype name=xqueryx-mime-macfiletype></A>C.2.6.3 
Macintosh File Type Code(s)</H5>
<P>The appropriate Macintosh file type code is 
<CODE>TEXT</CODE>.</P></DIV></DIV>
<DIV class=div3>
<H4><A id=xqueryx-mime-author name=xqueryx-mime-author></A>C.2.7 Person and 
Email Address to Contact For Further Information</H4>
<P>Jim Melton, Oracle Corp., <A 
href="mailto:jim.melton@oracle.com">jim.melton@oracle.com</A></P></DIV>
<DIV class=div3>
<H4><A id=xqueryx-mime-intended-usage name=xqueryx-mime-intended-usage></A>C.2.8 
Intended Usage</H4>
<P>COMMON</P></DIV>
<DIV class=div3>
<H4><A id=xqueryx-mime-restrictions name=xqueryx-mime-restrictions></A>C.2.9 
Restrictions on usage</H4>
<P>The intended usage of this media type is for interchange of XQueryX 
expressions.</P></DIV>
<DIV class=div3>
<H4><A id=xqueryx-mime-owner name=xqueryx-mime-owner></A>C.2.10 Author/Change 
Controller</H4>
<P>XQuery was produced by, and is maintained by, the World Wide Web Consortium's 
XML Query Working Group. The W3C has change control over this 
specification.</P></DIV>
<DIV class=div3>
<H4><A id=xqueryx-mime-fragments name=xqueryx-mime-fragments></A>C.2.11 Fragment 
Identifiers</H4>
<P>For documents labeled as "<CODE>application/xquery+xml</CODE>", the fragment 
identifier notation is exactly that for "<CODE>application/xml</CODE>", as 
specified in [RFC 3023].</P></DIV></DIV></DIV>
<DIV class=div1>
<H2><A id=changelog name=changelog></A>D Change log (Non-Normative)</H2>
<P>This appendix lists the changes that have been made to this specification 
since the publication of the Proposed Recommendation Draft on 21 November 
2006.</P>
<UL>
  <LI>
  <P>The MIME appendix was updated to normalize the text regarding security 
  considerations and to create a reference to the XQueryX spec that will be 
  visible when the MIME type is registered with IETF.</P>
  <LI>
  <P>A few very minor typographical errors were corrected and one or two 
  sentences were reworded to be consistent with other sentences having similar 
  purposes.</P></LI></UL></DIV></DIV></BODY></HTML>
