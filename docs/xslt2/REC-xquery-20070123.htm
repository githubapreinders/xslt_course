<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0046)http://www.w3.org/TR/2007/REC-xquery-20070123/ -->
<?xml version="1.0" encoding="utf-8"?><HTML lang=EN xml:lang="EN" 
xmlns="http://www.w3.org/1999/xhtml"><HEAD><TITLE>XQuery 1.0: An XML Query Language</TITLE>
<META http-equiv=Content-Type content="text/html; charset=utf-8">
<META content="MSHTML 6.00.2900.3020" name=GENERATOR>
<STYLE type=text/css>CODE {
	FONT-FAMILY: monospace
}
DIV.constraint {
	MARGIN-LEFT: 2em
}
DIV.issue {
	MARGIN-LEFT: 2em
}
DIV.note {
	MARGIN-LEFT: 2em
}
DIV.notice {
	MARGIN-LEFT: 2em
}
DIV.issue P.title {
	MARGIN-LEFT: -2em
}
OL.enumar {
	LIST-STYLE-TYPE: decimal
}
OL.enumla {
	LIST-STYLE-TYPE: lower-alpha
}
OL.enumlr {
	LIST-STYLE-TYPE: lower-roman
}
OL.enumua {
	LIST-STYLE-TYPE: upper-alpha
}
OL.enumur {
	LIST-STYLE-TYPE: upper-roman
}
LI P {
	MARGIN-TOP: 0.3em; MARGIN-BOTTOM: 0.3em
}
SUP SMALL {
	COLOR: #8f8f8f; FONT-STYLE: italic
}
DIV.exampleInner PRE {
	MARGIN-TOP: 0em; MARGIN-BOTTOM: 0em; MARGIN-LEFT: 1em
}
DIV.exampleOuter {
	BORDER-RIGHT: gray 4px double; PADDING-RIGHT: 0em; BORDER-TOP: gray 4px double; PADDING-LEFT: 0em; PADDING-BOTTOM: 0em; MARGIN: 0em; BORDER-LEFT: gray 4px double; PADDING-TOP: 0em; BORDER-BOTTOM: gray 4px double
}
DIV.exampleInner {
	PADDING-RIGHT: 4px; BORDER-TOP: #d3d3d3 4px double; PADDING-LEFT: 4px; PADDING-BOTTOM: 4px; MARGIN: 0em; PADDING-TOP: 4px; BORDER-BOTTOM: #d3d3d3 4px double; BACKGROUND-COLOR: #d5dee3
}
DIV.exampleWrapper {
	MARGIN: 4px
}
DIV.exampleHeader {
	FONT-WEIGHT: bold; MARGIN: 4px
}
DIV.issue {
	MARGIN-BOTTOM: 20pt; BORDER-BOTTOM: black 1pt solid
}
TH.issue-toc-head {
	BORDER-BOTTOM: black 1pt solid
}
TABLE.small {
	FONT-SIZE: x-small
}
</STYLE>
<LINK href="REC-xquery-20070123_files/W3C-REC.css" type=text/css 
rel=stylesheet></HEAD>
<BODY>
<DIV class=head>
<P><A href="http://www.w3.org/"><IMG height=48 alt=W3C 
src="REC-xquery-20070123_files/w3c_home.png" width=72></A></P>
<H1><A id=title name=title></A>XQuery 1.0: An XML Query Language</H1>
<H2><A id=w3c-doctype name=w3c-doctype></A>W3C Recommendation 23 January 
2007</H2>
<DL>
  <DT>This version: 
  <DD><SPAN class=xquery><A 
  href="http://www.w3.org/TR/2007/REC-xquery-20070123/">http://www.w3.org/TR/2007/REC-xquery-20070123/</A></SPAN> 

  <DT>Latest version: 
  <DD><SPAN class=xquery><A 
  href="http://www.w3.org/TR/xquery/">http://www.w3.org/TR/xquery/</A></SPAN> 
  <DT>Previous version: 
  <DD><SPAN class=xquery><A 
  href="http://www.w3.org/TR/2006/PR-xquery-20061121/">http://www.w3.org/TR/2006/PR-xquery-20061121/</A></SPAN> 

  <DT>Editors: 
  <DD>Scott Boag (XSL WG), IBM Research <A 
  href="mailto:scott_boag@us.ibm.com">mailto:scott_boag@us.ibm.com</A> 
  <DD>Don Chamberlin (XML Query WG), IBM Almaden Research Center, via <A 
  href="http://www.almaden.ibm.com/cs/people/chamberlin/">http://www.almaden.ibm.com/cs/people/chamberlin/</A> 

  <DD>Mary F. Fernández (XML Query WG), AT&amp;T Labs <A 
  href="mailto:mff@research.att.com">mailto:mff@research.att.com</A> 
  <DD class=xquery>Daniela Florescu (XML Query WG), Oracle <A 
  href="mailto:dana.florescu@oracle.com">mailto:dana.florescu@oracle.com</A> 
  <DD>Jonathan Robie (XML Query WG), <SPAN><A 
  href="http://www.xquery.com/">DataDirect Technologies</A></SPAN>, via <A 
  href="http://www.ibiblio.org/jwrobie/">http://www.ibiblio.org/jwrobie/</A> 
  <DD>Jérôme Siméon (XML Query WG), IBM T.J. Watson Research Center <A 
  href="mailto:simeon@us.ibm.com">mailto:simeon@us.ibm.com</A> </DD></DL>
<P>Please refer to the <A 
href="http://www.w3.org/XML/2007/qt-errata/xquery-errata.html"><STRONG>errata</STRONG></A> 
for this document, which may include some normative corrections.</P>
<P>See also <A 
href="http://www.w3.org/2003/03/Translations/byTechnology?technology=xquery"><STRONG>translations</STRONG></A>.</P>
<P>This document is also available in these non-normative formats: <SPAN 
class=xquery><A 
href="http://www.w3.org/TR/2007/REC-xquery-20070123/xquery.xml">XML</A></SPAN> 
and&nbsp;<SPAN class=xquery><A 
href="http://www.w3.org/TR/2007/REC-xquery-20070123/diff-from-20061121.html"> 
Recent revisions</A></SPAN>.</P>
<P class=copyright><A 
href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</A>&nbsp;©&nbsp;2007&nbsp;<A 
href="http://www.w3.org/"> <ACRONYM 
title="World Wide Web Consortium">W3C</ACRONYM></A><SUP>®</SUP> (<A 
href="http://www.csail.mit.edu/"><ACRONYM 
title="Massachusetts Institute of Technology">MIT</ACRONYM></A>, <A 
href="http://www.ercim.org/"><ACRONYM 
title="European Research Consortium for Informatics and Mathematics">ERCIM</ACRONYM></A>, 
<A href="http://www.keio.ac.jp/">Keio</A>), All Rights Reserved. W3C <A 
href="http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</A>, 
<A 
href="http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</A> 
and <A href="http://www.w3.org/Consortium/Legal/copyright-documents">document 
use</A> rules apply.</P></DIV>
<HR>

<DIV>
<H2><A id=abstract name=abstract></A>Abstract</H2>
<DIV class=xquery>
<P class=xquery>XML is a versatile markup language, capable of labeling the 
information content of diverse data sources including structured and 
semi-structured documents, relational databases, and object repositories. A 
query language that uses the structure of XML intelligently can express queries 
across all these kinds of data, whether physically stored in XML or viewed as 
XML via middleware. This specification describes a query language called XQuery, 
which is designed to be broadly applicable across many types of XML data 
sources.</P></DIV></DIV>
<DIV>
<H2><A id=status name=status></A>Status of this Document</H2>
<P><EM>This section describes the status of this document at the time of its 
publication. Other documents may supersede this document. A list of current W3C 
publications and the latest revision of this technical report can be found in 
the <A href="http://www.w3.org/TR/">W3C technical reports index</A> at 
http://www.w3.org/TR/.</EM></P>
<P>This is one document in a set of eight documents that have progressed to 
Recommendation together (XQuery 1.0, XQueryX 1.0, XSLT 2.0, Data Model, 
Functions and Operators, Formal Semantics, Serialization, XPath 2.0).</P>
<P>This is a <A 
href="http://www.w3.org/2004/02/Process-20040205/tr.html#RecsW3C">Recommendation</A> 
of the W3C. It <SPAN class=xquery><SPAN class=xquery>has been developed by the 
W3C <A href="http://www.w3.org/XML/Query">XML Query Working Group</A>, which is 
part of the <A href="http://www.w3.org/XML/Activity">XML 
Activity</A>.</SPAN></SPAN></P>
<P>This document has been reviewed by W3C Members, by software developers, and 
by other W3C groups and interested parties, and is endorsed by the Director as a 
W3C Recommendation. It is a stable document and may be used as reference 
material or cited from another document. W3C's role in making the Recommendation 
is to draw attention to the specification and to promote its widespread 
deployment. This enhances the functionality and interoperability of the Web.</P>
<P><SPAN class=xquery><SPAN class=xquery>This document incorporates minor 
changes made against the <A 
href="http://www.w3.org/2004/02/Process-20040205/tr.html#RecsPR">Proposed 
Recommendation</A> of 21 November 2006; please see the public disposition of 
comments for details. Changes to this document since the <A 
href="http://www.w3.org/2004/02/Process-20040205/tr.html#RecsPR">Proposed 
Recommendation</A> are detailed in the <A 
href="http://www.w3.org/TR/2007/REC-xquery-20070123/#id-revisions-log"><B>J 
Revision Log</B></A>.</SPAN></SPAN></P>
<P>Please report errors in this document using W3C's <A 
href="http://www.w3.org/Bugs/Public/">public Bugzilla system</A> (instructions 
can be found at <A 
href="http://www.w3.org/XML/2005/04/qt-bugzilla">http://www.w3.org/XML/2005/04/qt-bugzilla</A>). 
If access to that system is not feasible, you may send your comments to the W3C 
XSLT/XPath/XQuery public comments mailing list, <A 
href="mailto:public-qt-comments@w3.org">public-qt-comments@w3.org</A>. It will 
be very helpful if you include the string “[<SPAN class=xquery><SPAN 
class=xquery>XQuery</SPAN></SPAN>]” in the subject line of your report, whether 
made in Bugzilla or in email. Each Bugzilla entry and email message should 
contain only one error report. Archives of the comments and responses are 
available at <A 
href="http://lists.w3.org/Archives/Public/public-qt-comments/">http://lists.w3.org/Archives/Public/public-qt-comments/</A>.</P>
<P>This document was produced by <SPAN class=xquery><SPAN class=xquery>a 
group</SPAN></SPAN> operating under the <A 
href="http://www.w3.org/Consortium/Patent-Policy-20040205/">5 February 2004 W3C 
Patent Policy</A>. W3C maintains a <A 
href="http://www.w3.org/2004/01/pp-impl/18797/status#disclosures">public list of 
any patent disclosures</A> made in connection with the deliverables of the <SPAN 
class=xquery><SPAN class=xquery>group; that page also includes</SPAN></SPAN> 
instructions for disclosing a patent. An individual who has actual knowledge of 
a patent which the individual believes contains <A 
href="http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">Essential 
Claim(s)</A> must disclose the information in accordance with <A 
href="http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">section 
6 of the W3C Patent Policy</A>.</P></DIV>
<DIV class=toc>
<H2><A id=contents name=contents></A>Table of Contents</H2>
<P class=toc>1 <A 
href="REC-xquery-20070123.htm#id-introduction">Introduction</A><BR>2 
<A 
href="REC-xquery-20070123.htm#id-basics">Basics</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;2.1 
<A href="REC-xquery-20070123.htm#context">Expression 
Context</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.1.1 <A 
href="REC-xquery-20070123.htm#static_context">Static 
Context</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.1.2 <A 
href="REC-xquery-20070123.htm#eval_context">Dynamic 
Context</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;2.2 <A 
href="REC-xquery-20070123.htm#id-processing-model">Processing 
Model</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.2.1 <A 
href="REC-xquery-20070123.htm#id-data-model-generation">Data 
Model Generation</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.2.2 <A 
href="REC-xquery-20070123.htm#id-schema-import-processing">Schema 
Import Processing</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.2.3 
<A 
href="REC-xquery-20070123.htm#id-expression-processing">Expression 
Processing</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.2.3.1 
<A 
href="REC-xquery-20070123.htm#id-static-analysis">Static 
Analysis 
Phase</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.2.3.2 
<A 
href="REC-xquery-20070123.htm#id-dynamic-evaluation">Dynamic 
Evaluation Phase</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.2.4 <A 
href="REC-xquery-20070123.htm#id-serialization">Serialization</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.2.5 
<A 
href="REC-xquery-20070123.htm#id-consistency-constraints">Consistency 
Constraints</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;2.3 <A 
href="REC-xquery-20070123.htm#errors">Error 
Handling</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.3.1 <A 
href="REC-xquery-20070123.htm#id-kinds-of-errors">Kinds 
of Errors</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.3.2 <A 
href="REC-xquery-20070123.htm#id-identifying-errors">Identifying 
and Reporting 
Errors</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.3.3 <A 
href="REC-xquery-20070123.htm#id-handling-dynamic">Handling 
Dynamic Errors</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.3.4 <A 
href="REC-xquery-20070123.htm#id-errors-and-opt">Errors 
and Optimization</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;2.4 <A 
href="REC-xquery-20070123.htm#id-important-concepts">Concepts</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.4.1 
<A 
href="REC-xquery-20070123.htm#id-document-order">Document 
Order</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.4.2 <A 
href="REC-xquery-20070123.htm#id-atomization">Atomization</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.4.3 
<A href="REC-xquery-20070123.htm#id-ebv">Effective 
Boolean Value</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.4.4 <A 
href="REC-xquery-20070123.htm#id-input-sources">Input 
Sources</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.4.5 <A 
href="REC-xquery-20070123.htm#id-uri-literals">URI 
Literals</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;2.5 <A 
href="REC-xquery-20070123.htm#id-types">Types</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.5.1 
<A 
href="REC-xquery-20070123.htm#id-predefined-types">Predefined 
Schema Types</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.5.2 <A 
href="REC-xquery-20070123.htm#id-typed-value">Typed Value 
and String Value</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.5.3 <A 
href="REC-xquery-20070123.htm#id-sequencetype-syntax">SequenceType 
Syntax</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.5.4 <A 
href="REC-xquery-20070123.htm#id-sequencetype-matching">SequenceType 
Matching</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.5.4.1 
<A 
href="REC-xquery-20070123.htm#id-matching-value">Matching 
a SequenceType and a 
Value</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.5.4.2 
<A 
href="REC-xquery-20070123.htm#id-matching-item">Matching 
an ItemType and an 
Item</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.5.4.3 
<A href="REC-xquery-20070123.htm#id-element-test">Element 
Test</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.5.4.4 
<A 
href="REC-xquery-20070123.htm#id-schema-element-test">Schema 
Element 
Test</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.5.4.5 
<A 
href="REC-xquery-20070123.htm#id-attribute-test">Attribute 
Test</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.5.4.6 
<A 
href="REC-xquery-20070123.htm#id-schema-attribute-test">Schema 
Attribute Test</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;2.6 <A 
href="REC-xquery-20070123.htm#comments">Comments</A><BR>3 
<A 
href="REC-xquery-20070123.htm#id-expressions">Expressions</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;3.1 
<A 
href="REC-xquery-20070123.htm#id-primary-expressions">Primary 
Expressions</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.1.1 <A 
href="REC-xquery-20070123.htm#id-literals">Literals</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.1.2 
<A href="REC-xquery-20070123.htm#id-variables">Variable 
References</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.1.3 <A 
href="REC-xquery-20070123.htm#id-paren-expressions">Parenthesized 
Expressions</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.1.4 <A 
href="REC-xquery-20070123.htm#id-context-item-expression">Context 
Item Expression</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.1.5 <A 
href="REC-xquery-20070123.htm#id-function-calls">Function 
Calls</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;3.2 <A 
href="REC-xquery-20070123.htm#id-path-expressions">Path 
Expressions</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.2.1 <A 
href="REC-xquery-20070123.htm#id-steps">Steps</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.2.1.1 
<A 
href="REC-xquery-20070123.htm#axes">Axes</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.2.1.2 
<A href="REC-xquery-20070123.htm#node-tests">Node 
Tests</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.2.2 <A 
href="REC-xquery-20070123.htm#id-predicates">Predicates</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.2.3 
<A href="REC-xquery-20070123.htm#unabbrev">Unabbreviated 
Syntax</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.2.4 <A 
href="REC-xquery-20070123.htm#abbrev">Abbreviated 
Syntax</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;3.3 <A 
href="REC-xquery-20070123.htm#id-sequence-expressions">Sequence 
Expressions</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.3.1 <A 
href="REC-xquery-20070123.htm#construct_seq">Constructing 
Sequences</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.3.2 <A 
href="REC-xquery-20070123.htm#id-filter-expr">Filter 
Expressions</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.3.3 <A 
href="REC-xquery-20070123.htm#combining_seq">Combining 
Node Sequences</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;3.4 <A 
href="REC-xquery-20070123.htm#id-arithmetic">Arithmetic 
Expressions</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;3.5 <A 
href="REC-xquery-20070123.htm#id-comparisons">Comparison 
Expressions</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.5.1 <A 
href="REC-xquery-20070123.htm#id-value-comparisons">Value 
Comparisons</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.5.2 <A 
href="REC-xquery-20070123.htm#id-general-comparisons">General 
Comparisons</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.5.3 <A 
href="REC-xquery-20070123.htm#id-node-comparisons">Node 
Comparisons</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;3.6 <A 
href="REC-xquery-20070123.htm#id-logical-expressions">Logical 
Expressions</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;3.7 <A 
href="REC-xquery-20070123.htm#id-constructors">Constructors</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.7.1 
<A 
href="REC-xquery-20070123.htm#id-element-constructor">Direct 
Element 
Constructors</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.7.1.1 
<A 
href="REC-xquery-20070123.htm#id-attributes">Attributes</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.7.1.2 
<A href="REC-xquery-20070123.htm#id-namespaces">Namespace 
Declaration 
Attributes</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.7.1.3 
<A 
href="REC-xquery-20070123.htm#id-content">Content</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.7.1.4 
<A href="REC-xquery-20070123.htm#id-whitespace">Boundary 
Whitespace</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.7.2 <A 
href="REC-xquery-20070123.htm#id-otherConstructors">Other 
Direct Constructors</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.7.3 
<A 
href="REC-xquery-20070123.htm#id-computedConstructors">Computed 
Constructors</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.7.3.1 
<A 
href="REC-xquery-20070123.htm#id-computedElements">Computed 
Element 
Constructors</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.7.3.2 
<A 
href="REC-xquery-20070123.htm#id-computedAttributes">Computed 
Attribute 
Constructors</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.7.3.3 
<A 
href="REC-xquery-20070123.htm#id-documentConstructors">Document 
Node 
Constructors</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.7.3.4 
<A 
href="REC-xquery-20070123.htm#id-textConstructors">Text 
Node 
Constructors</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.7.3.5 
<A 
href="REC-xquery-20070123.htm#id-computed-pis">Computed 
Processing Instruction 
Constructors</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.7.3.6 
<A 
href="REC-xquery-20070123.htm#id-computed-comments">Computed 
Comment 
Constructors</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.7.4 <A 
href="REC-xquery-20070123.htm#id-ns-nodes-on-elements">In-scope 
Namespaces of a Constructed Element</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;3.8 <A 
href="REC-xquery-20070123.htm#id-flwor-expressions">FLWOR 
Expressions</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.8.1 <A 
href="REC-xquery-20070123.htm#id-for-let">For and Let 
Clauses</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.8.2 <A 
href="REC-xquery-20070123.htm#id-where">Where 
Clause</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.8.3 <A 
href="REC-xquery-20070123.htm#id-orderby-return">Order By 
and Return Clauses</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.8.4 
<A 
href="REC-xquery-20070123.htm#id-flwor-example">Example</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;3.9 
<A 
href="REC-xquery-20070123.htm#id-unordered-expressions">Ordered 
and Unordered Expressions</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;3.10 <A 
href="REC-xquery-20070123.htm#id-conditionals">Conditional 
Expressions</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;3.11 <A 
href="REC-xquery-20070123.htm#id-quantified-expressions">Quantified 
Expressions</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;3.12 <A 
href="REC-xquery-20070123.htm#id-expressions-on-datatypes">Expressions 
on SequenceTypes</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.12.1 
<A href="REC-xquery-20070123.htm#id-instance-of">Instance 
Of</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.12.2 <A 
href="REC-xquery-20070123.htm#id-typeswitch">Typeswitch</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.12.3 
<A 
href="REC-xquery-20070123.htm#id-cast">Cast</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.12.4 
<A 
href="REC-xquery-20070123.htm#id-castable">Castable</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.12.5 
<A 
href="REC-xquery-20070123.htm#id-constructor-functions">Constructor 
Functions</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.12.6 <A 
href="REC-xquery-20070123.htm#id-treat">Treat</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;3.13 
<A href="REC-xquery-20070123.htm#id-validate">Validate 
Expressions</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;3.14 <A 
href="REC-xquery-20070123.htm#id-extension-expressions">Extension 
Expressions</A><BR>4 <A 
href="REC-xquery-20070123.htm#id-query-prolog">Modules 
and Prologs</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;4.1 <A 
href="REC-xquery-20070123.htm#id-version-declaration">Version 
Declaration</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;4.2 <A 
href="REC-xquery-20070123.htm#id-module-declaration">Module 
Declaration</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;4.3 <A 
href="REC-xquery-20070123.htm#id-boundary-space-decls">Boundary-space 
Declaration</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;4.4 <A 
href="REC-xquery-20070123.htm#id-default-collation-declaration">Default 
Collation Declaration</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;4.5 <A 
href="REC-xquery-20070123.htm#id-base-uri-decl">Base URI 
Declaration</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;4.6 <A 
href="REC-xquery-20070123.htm#id-construction-declaration">Construction 
Declaration</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;4.7 <A 
href="REC-xquery-20070123.htm#id-default-ordering-decl">Ordering 
Mode Declaration</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;4.8 <A 
href="REC-xquery-20070123.htm#id-empty-order-decl">Empty 
Order Declaration</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;4.9 <A 
href="REC-xquery-20070123.htm#id-copy-namespaces-decl">Copy-Namespaces 
Declaration</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;4.10 <A 
href="REC-xquery-20070123.htm#id-schema-import">Schema 
Import</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;4.11 <A 
href="REC-xquery-20070123.htm#id-module-import">Module 
Import</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;4.12 <A 
href="REC-xquery-20070123.htm#id-namespace-declaration">Namespace 
Declaration</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;4.13 <A 
href="REC-xquery-20070123.htm#id-default-namespace">Default 
Namespace Declaration</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;4.14 <A 
href="REC-xquery-20070123.htm#id-variable-declarations">Variable 
Declaration</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;4.15 <A 
href="REC-xquery-20070123.htm#FunctionDeclns">Function 
Declaration</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;4.16 <A 
href="REC-xquery-20070123.htm#id-option-declaration">Option 
Declaration</A><BR>5 <A 
href="REC-xquery-20070123.htm#id-xquery-conformance">Conformance</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;5.1 
<A 
href="REC-xquery-20070123.htm#id-minimal-conformance">Minimal 
Conformance</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;5.2 <A 
href="REC-xquery-20070123.htm#id-conform-optional-features">Optional 
Features</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.2.1 <A 
href="REC-xquery-20070123.htm#id-schema-import-feature">Schema 
Import Feature</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.2.2 <A 
href="REC-xquery-20070123.htm#id-schema-validation-feature">Schema 
Validation Feature</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.2.3 
<A 
href="REC-xquery-20070123.htm#id-static-typing-feature">Static 
Typing 
Feature</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.2.3.1 
<A 
href="REC-xquery-20070123.htm#id-static-extensions">Static 
Typing Extensions</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.2.4 
<A 
href="REC-xquery-20070123.htm#id-full-axis-feature">Full 
Axis Feature</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.2.5 <A 
href="REC-xquery-20070123.htm#id-module-feature">Module 
Feature</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.2.6 <A 
href="REC-xquery-20070123.htm#id-serialization-feature">Serialization 
Feature</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;5.3 <A 
href="REC-xquery-20070123.htm#id-data-model-conformance">Data 
Model Conformance</A><BR></P>
<H3><A id=appendices name=appendices></A>Appendices</H3>
<P class=toc>A <A 
href="REC-xquery-20070123.htm#nt-bnf">XQuery 
Grammar</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;A.1 <A 
href="REC-xquery-20070123.htm#id-grammar">EBNF</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.1.1 
<A 
href="REC-xquery-20070123.htm#EBNFNotation">Notation</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.1.2 
<A 
href="REC-xquery-20070123.htm#extra-grammatical-constraints">Extra-grammatical 
Constraints</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.1.3 <A 
href="REC-xquery-20070123.htm#notes-on-parsing">Grammar 
Notes</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;A.2 <A 
href="REC-xquery-20070123.htm#lexical-structure">Lexical 
structure</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.2.1 <A 
href="REC-xquery-20070123.htm#terminal-symbols">Terminal 
Symbols</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.2.2 <A 
href="REC-xquery-20070123.htm#id-terminal-delimitation">Terminal 
Delimitation</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.2.3 <A 
href="REC-xquery-20070123.htm#id-eol-handling">End-of-Line 
Handling</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.2.3.1 
<A 
href="REC-xquery-20070123.htm#id-xml10-eol-handling">XML 
1.0 End-of-Line 
Handling</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.2.3.2 
<A 
href="REC-xquery-20070123.htm#id-xml11-eol-handling">XML 
1.1 End-of-Line 
Handling</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.2.4 <A 
href="REC-xquery-20070123.htm#whitespace-rules">Whitespace 
Rules</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.2.4.1 
<A 
href="REC-xquery-20070123.htm#DefaultWhitespaceHandling">Default 
Whitespace 
Handling</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A.2.4.2 
<A 
href="REC-xquery-20070123.htm#ExplicitWhitespaceHandling">Explicit 
Whitespace Handling</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;A.3 <A 
href="REC-xquery-20070123.htm#id-reserved-fn-names">Reserved 
Function Names</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;A.4 <A 
href="REC-xquery-20070123.htm#id-precedence-order">Precedence 
Order</A><BR>B <A 
href="REC-xquery-20070123.htm#id-type-promotion-and-operator-mapping">Type 
Promotion and Operator Mapping</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;B.1 <A 
href="REC-xquery-20070123.htm#promotion">Type 
Promotion</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;B.2 <A 
href="REC-xquery-20070123.htm#mapping">Operator 
Mapping</A><BR>C <A 
href="REC-xquery-20070123.htm#id-xq-context-components">Context 
Components</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;C.1 <A 
href="REC-xquery-20070123.htm#id-xq-static-context-components">Static 
Context Components</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;C.2 <A 
href="REC-xquery-20070123.htm#id-xq-evaluation-context-components">Dynamic 
Context Components</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;C.3 <A 
href="REC-xquery-20070123.htm#id-xq-serialization-parameters">Serialization 
Parameters</A><BR>D <A 
href="REC-xquery-20070123.htm#id-impl-defined-items">Implementation-Defined 
Items</A><BR>E <A 
href="REC-xquery-20070123.htm#id-references">References</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;E.1 
<A 
href="REC-xquery-20070123.htm#id-normative-references">Normative 
References</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;E.2 <A 
href="REC-xquery-20070123.htm#id-non-normative-references">Non-normative 
References</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;E.3 <A 
href="REC-xquery-20070123.htm#id-background-material">Background 
Material</A><BR>F <A 
href="REC-xquery-20070123.htm#id-errors">Error 
Conditions</A><BR>G <A 
href="REC-xquery-20070123.htm#id-mime-type">The 
application/xquery Media Type</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;G.1 <A 
href="REC-xquery-20070123.htm#id-mime-type-intro">Introduction</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;G.2 
<A 
href="REC-xquery-20070123.htm#id-registration-of-mime-type">Registration 
of MIME Media Type 
application/xquery</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;G.2.1 
<A 
href="REC-xquery-20070123.htm#id-interoperability-considerations">Interoperability 
Considerations</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;G.2.2 <A 
href="REC-xquery-20070123.htm#id-applications-of-media-type">Applications 
Using this Media 
Type</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;G.2.3 <A 
href="REC-xquery-20070123.htm#id-file-extensions">File 
Extensions</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;G.2.4 <A 
href="REC-xquery-20070123.htm#id-intended-usage">Intended 
Usage</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;G.2.5 <A 
href="REC-xquery-20070123.htm#id-author-change-controller">Author/Change 
Controller</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;G.3 <A 
href="REC-xquery-20070123.htm#xquery-mime-encoding">Encoding 
Considerations</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;G.4 <A 
href="REC-xquery-20070123.htm#xquery-mime-recognizing">Recognizing 
XQuery Files</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;G.5 <A 
href="REC-xquery-20070123.htm#id-charset-default-rules">Charset 
Default Rules</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;G.6 <A 
href="REC-xquery-20070123.htm#id-security-considerations">Security 
Considerations</A><BR>H <A 
href="REC-xquery-20070123.htm#id-glossary">Glossary</A> 
(Non-Normative)<BR>I <A 
href="REC-xquery-20070123.htm#id-example-applications">Example 
Applications</A> (Non-Normative)<BR>&nbsp;&nbsp;&nbsp;&nbsp;I.1 <A 
href="REC-xquery-20070123.htm#id-joins">Joins</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;I.2 
<A 
href="REC-xquery-20070123.htm#id-grouping">Grouping</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;I.3 
<A 
href="REC-xquery-20070123.htm#id-queries-on-sequence">Queries 
on Sequence</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;I.4 <A 
href="REC-xquery-20070123.htm#id-recursive-transformations">Recursive 
Transformations</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;I.5 <A 
href="REC-xquery-20070123.htm#id-select-distinct">Selecting 
Distinct Combinations</A><BR>J <A 
href="REC-xquery-20070123.htm#id-revisions-log">Revision 
Log</A> (Non-Normative)<BR></P></DIV>
<HR>

<DIV class=body>
<DIV class=div1>
<H2><A id=id-introduction name=id-introduction></A>1 Introduction</H2>
<DIV class=xquery>
<P class=xquery>As increasing amounts of information are stored, exchanged, and 
presented using XML, the ability to intelligently query XML data sources becomes 
increasingly important. One of the great strengths of XML is its flexibility in 
representing many different kinds of information from diverse sources. To 
exploit this flexibility, an XML query language must provide features for 
retrieving and interpreting information from these diverse sources.</P></DIV>
<DIV class=xquery>
<P class=xquery>XQuery is designed to meet the requirements identified by the 
W3C XML Query Working Group <A 
href="REC-xquery-20070123.htm#Requirements">[XML Query 
1.0 Requirements]</A> and the use cases in <A 
href="REC-xquery-20070123.htm#UseCases">[XML Query Use 
Cases]</A>. It is designed to be a language in which queries are concise and 
easily understood. It is also flexible enough to query a broad spectrum of XML 
information sources, including both databases and documents. The Query Working 
Group has identified a requirement for both a non-XML query syntax and an 
XML-based query syntax. XQuery is designed to meet the first of these 
requirements. XQuery is derived from an XML query language called Quilt <A 
href="REC-xquery-20070123.htm#Quilt">[Quilt]</A>, which 
in turn borrowed features from several other languages, including XPath 1.0 <A 
href="REC-xquery-20070123.htm#XPath">[XPath 1.0]</A>, XQL 
<A href="REC-xquery-20070123.htm#XQL">[XQL]</A>, XML-QL 
<A href="REC-xquery-20070123.htm#XML-QL">[XML-QL]</A>, 
SQL <A href="REC-xquery-20070123.htm#SQL">[SQL]</A>, and 
OQL <A 
href="REC-xquery-20070123.htm#ODMG">[ODMG]</A>.</P></DIV>
<P>[<A id=dt-datamodel title="data model" name=dt-datamodel>Definition</A>: 
XQuery operates on the abstract, logical structure of an XML document, rather 
than its surface syntax. This logical structure, known as the <B>data model</B>, 
is defined in <A 
href="REC-xquery-20070123.htm#datamodel">[XQuery/XPath 
Data Model (XDM)]</A>.]</P>
<P>XQuery Version 1.0 is an extension of XPath Version 2.0. Any expression that 
is syntactically valid and executes successfully in both XPath 2.0 and XQuery 
1.0 will return the same result in both languages. Since these languages are so 
closely related, their grammars and language descriptions are generated from a 
common source to ensure consistency, and the editors of these specifications 
work together closely.</P>
<P>XQuery also depends on and is closely related to the following 
specifications:</P>
<UL>
  <LI>
  <P><A 
  href="REC-xquery-20070123.htm#datamodel">[XQuery/XPath 
  Data Model (XDM)]</A> defines the data model that underlies all XQuery 
  expressions.</P>
  <LI>
  <P><A 
  href="REC-xquery-20070123.htm#XQueryFormalSemantics">[XQuery 
  1.0 and XPath 2.0 Formal Semantics]</A> defines the static semantics of XQuery 
  and also contains a formal but non-normative description of the dynamic 
  semantics that may be useful for implementors and others who require a formal 
  definition.</P>
  <LI>
  <P>The type system of XQuery is based on <A 
  href="REC-xquery-20070123.htm#XMLSchema">[XML 
  Schema]</A>.</P>
  <LI>
  <P>The built-in function library and the operators supported by XQuery are 
  defined in <A 
  href="REC-xquery-20070123.htm#FunctionsAndOperators">[XQuery 
  1.0 and XPath 2.0 Functions and Operators]</A>.</P>
  <LI class=xquery>
  <P>One requirement in <A 
  href="REC-xquery-20070123.htm#Requirements">[XML Query 
  1.0 Requirements]</A> is that an XML query language have both a human-readable 
  syntax and an XML-based syntax. The XML-based syntax for XQuery is described 
  in <A href="REC-xquery-20070123.htm#XQueryX">[XQueryX 
  1.0]</A>.</P></LI></UL>
<P>This document specifies a grammar for XQuery, using the same basic EBNF 
notation used in <A 
href="REC-xquery-20070123.htm#XML">[XML 1.0]</A>. Unless 
otherwise noted (see <A 
href="REC-xquery-20070123.htm#lexical-structure"><B>A.2 
Lexical structure</B></A>), whitespace is not significant in <SPAN 
class=xquery><SPAN class=xquery>queries</SPAN></SPAN>. Grammar productions are 
introduced together with the features that they describe, and a complete grammar 
is also presented in the appendix [<A 
href="REC-xquery-20070123.htm#nt-bnf"><B>A XQuery 
Grammar</B></A>]. The appendix is the normative version.</P>
<P>In the grammar productions in this document, named symbols are underlined and 
literal text is enclosed in double quotes. For example, the following production 
describes the syntax of a function call:</P>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=fakeid_doc-xquery-FunctionCall 
      name=fakeid_doc-xquery-FunctionCall></A>[93]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>FunctionCall</CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-QName">QName</A> 
      "(" (<A 
      href="REC-xquery-20070123.htm#doc-xquery-ExprSingle">ExprSingle</A> 
      ("," <A 
      href="REC-xquery-20070123.htm#doc-xquery-ExprSingle">ExprSingle</A>)*)? 
      ")"</CODE></TD></TR></TBODY></TABLE>
<P>The production should be read as follows: A function call consists of a QName 
followed by an open-parenthesis. The open-parenthesis is followed by an optional 
argument list. The argument list (if present) consists of one or more 
expressions, separated by commas. The optional argument list is followed by a 
close-parenthesis.</P>
<P>Certain aspects of language processing are described in this specification as 
<B>implementation-defined</B> or <B>implementation-dependent</B>.</P>
<UL>
  <LI>
  <P>[<A id=dt-implementation-defined title="implementation defined" 
  name=dt-implementation-defined>Definition</A>: <B>Implementation-defined</B> 
  indicates an aspect that may differ between implementations, but must be 
  specified by the implementor for each particular implementation.]</P>
  <LI>
  <P>[<A id=dt-implementation-dependent title="implementation dependent" 
  name=dt-implementation-dependent>Definition</A>: 
  <B>Implementation-dependent</B> indicates an aspect that may differ between 
  implementations, is not specified by this or any W3C specification, and is not 
  required to be specified by the implementor for any particular 
  implementation.]</P></LI></UL>
<P>This document normatively defines the dynamic semantics of XQuery. The static 
semantics of XQuery are normatively defined in <A 
href="REC-xquery-20070123.htm#XQueryFormalSemantics">[XQuery 
1.0 and XPath 2.0 Formal Semantics]</A>. In this document, examples and material 
labeled as "Note" are provided for explanatory purposes and are not 
normative.</P></DIV>
<DIV class=div1>
<H2><A id=id-basics name=id-basics></A>2 Basics</H2>
<P>The basic building block of XQuery is the <B>expression</B>, which is a 
string of <A 
href="REC-xquery-20070123.htm#Unicode">[Unicode]</A> 
characters (the version of Unicode to be used is <A 
title="implementation defined" 
href="REC-xquery-20070123.htm#dt-implementation-defined">implementation-defined</A>.) 
The language provides several kinds of expressions which may be constructed from 
keywords, symbols, and operands. In general, the operands of an expression are 
other expressions. XQuery allows expressions to be nested with full generality. 
<SPAN class=xquery><SPAN class=xquery>(However, unlike a pure functional 
language, it does not allow variable substitution if the variable declaration 
contains construction of new nodes.)</SPAN></SPAN></P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>This specification contains no assumptions or requirements regarding the 
character set encoding of strings of <A 
href="REC-xquery-20070123.htm#Unicode">[Unicode]</A> 
characters.</P></DIV>
<P>Like XML, XQuery is a case-sensitive language. Keywords in XQuery use 
lower-case characters and are not reserved—that is, names in XQuery expressions 
are allowed to be the same as language keywords, except for certain unprefixed 
function-names listed in <A 
href="REC-xquery-20070123.htm#id-reserved-fn-names"><B>A.3 
Reserved Function Names</B></A>.</P>
<P>[<A id=dt-value title=value name=dt-value>Definition</A>: In the <A 
title="data model" 
href="REC-xquery-20070123.htm#dt-datamodel">data 
model</A>, a <B>value</B> is always a <A title=sequence 
href="REC-xquery-20070123.htm#dt-sequence">sequence</A>.] 
[<A id=dt-sequence title=sequence name=dt-sequence>Definition</A>: A 
<B>sequence</B> is an ordered collection of zero or more <A title=item 
href="REC-xquery-20070123.htm#dt-item">items</A>.] [<A 
id=dt-item title=item name=dt-item>Definition</A>: An <B>item</B> is either an 
<A title="atomic value" 
href="REC-xquery-20070123.htm#dt-atomic-value">atomic 
value</A> or a <A title=node 
href="REC-xquery-20070123.htm#dt-node">node</A>.] [<A 
id=dt-atomic-value title="atomic value" name=dt-atomic-value>Definition</A>: An 
<B>atomic value</B> is a value in the value space of an <B>atomic type</B>, as 
defined in <A 
href="REC-xquery-20070123.htm#XMLSchema">[XML 
Schema]</A>.] [<A id=dt-node title=node name=dt-node>Definition</A>: A 
<B>node</B> is an instance of one of the <B>node kinds</B> defined in <A 
href="REC-xquery-20070123.htm#datamodel">[XQuery/XPath 
Data Model (XDM)]</A>.] Each node has a unique <B>node identity</B>, a <B>typed 
value</B>, and a <B>string value</B>. In addition, some nodes have a 
<B>name</B>. The <B>typed value</B> of a node is a sequence of zero or more 
atomic values. The <B>string value</B> of a node is a value of type 
<CODE>xs:string</CODE>. The <B>name</B> of a node is a value of type 
<CODE>xs:QName</CODE>.</P>
<P>[<A id=dt-singleton title=singleton name=dt-singleton>Definition</A>: A 
sequence containing exactly one item is called a <B>singleton</B>.] An item is 
identical to a singleton sequence containing that item. Sequences are never 
nested—for example, combining the values 1, (2, 3), and ( ) into a single 
sequence results in the sequence (1, 2, 3). [<A id=dt-empty-sequence 
title="empty sequence" name=dt-empty-sequence>Definition</A>: A sequence 
containing zero items is called an <B>empty sequence</B>.]</P>
<P>[<A id=dt-data-model-instance title="XDM instance" 
name=dt-data-model-instance>Definition</A>: The term <B>XDM instance</B> is 
used, synonymously with the term <B>value</B>, to denote an unconstrained 
sequence of <A title=node 
href="REC-xquery-20070123.htm#dt-node">nodes</A> and/or 
<A title="atomic value" 
href="REC-xquery-20070123.htm#dt-atomic-value">atomic 
values</A> in the <A title="data model" 
href="REC-xquery-20070123.htm#dt-datamodel">data 
model</A>.]</P>
<P>Names in XQuery are called <B>QNames</B>, and conform to the syntax in <A 
href="REC-xquery-20070123.htm#XMLNAMES">[XML Names]</A>. 
[<A id=dt-qname title=QName name=dt-qname>Definition</A>: Lexically, a 
<B>QName</B> consists of an optional namespace prefix and a local name. If the 
namespace prefix is present, it is separated from the local name by a colon.] A 
lexical QName can be converted into an <B>expanded QName</B> by resolving its 
namespace prefix to a namespace URI, using the <A 
title="statically known namespaces" 
href="REC-xquery-20070123.htm#dt-static-namespaces">statically 
known namespaces</A> [<A title=err:XPST0081 
href="REC-xquery-20070123.htm#ERRXPST0081">err:XPST0081</A>]. 
[<A id=dt-expanded-qname title="expanded QName" 
name=dt-expanded-qname>Definition</A>: An <B>expanded QName</B> consists of an 
optional namespace URI and a local name. An expanded QName also retains its 
original namespace prefix (if any), to facilitate casting the expanded QName 
into a string.] The namespace URI value is whitespace normalized according to 
the rules for the <CODE>xs:anyURI</CODE> type in <A 
href="REC-xquery-20070123.htm#XMLSchema">[XML 
Schema]</A>. Two expanded QNames are equal if their namespace URIs are equal and 
their local names are equal (even if their namespace prefixes are not equal). 
Namespace URIs and local names are compared on a codepoint basis, without 
further normalization.</P>
<DIV class=xquery>
<P class=xquery>Certain namespace prefixes are predeclared by XQuery and bound 
to fixed namespace URIs. These namespace prefixes are as follows:</P></DIV>
<UL>
  <LI class=xquery>
  <P><CODE>xml = http://www.w3.org/XML/1998/namespace</CODE></P>
  <LI>
  <P><CODE>xs = http://www.w3.org/2001/XMLSchema</CODE></P>
  <LI class=xquery>
  <P><CODE>xsi = http://www.w3.org/2001/XMLSchema-instance</CODE></P>
  <LI>
  <P><CODE>fn = http://www.w3.org/2005/xpath-functions</CODE></P>
  <LI class=xquery>
  <P><CODE>local = http://www.w3.org/2005/xquery-local-functions</CODE> (see <A 
  href="REC-xquery-20070123.htm#FunctionDeclns"><B>4.15 
  Function Declaration</B></A>.)</P></LI></UL>
<DIV class=xquery>
<P class=xquery>In addition to the prefixes in the above list, this document 
uses the prefix <CODE>err</CODE> to represent the namespace URI 
<CODE>http://www.w3.org/2005/xqt-errors</CODE> (see <A 
href="REC-xquery-20070123.htm#id-identifying-errors"><B>2.3.2 
Identifying and Reporting Errors</B></A>). This namespace prefix is not 
predeclared and its use in this document is not normative.</P></DIV>
<P>Element nodes have a property called <B>in-scope namespaces</B>. [<A 
id=dt-in-scope-namespaces title="in-scope namespaces" 
name=dt-in-scope-namespaces>Definition</A>: The <B>in-scope namespaces</B> 
property of an element node is a set of <B>namespace bindings</B>, each of which 
associates a namespace prefix with a URI, thus defining the set of namespace 
prefixes that are available for interpreting QNames within the scope of the 
element. For a given element, one namespace binding may have an empty prefix; 
the URI of this namespace binding is the default namespace within the scope of 
the element.]</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>In <A href="REC-xquery-20070123.htm#XPath">[XPath 
1.0]</A>, the in-scope namespaces of an element node are represented by a 
collection of <B>namespace nodes</B> arranged on a <B>namespace axis</B>, which 
is optional and deprecated in <A 
href="REC-xquery-20070123.htm#XPath20">[XPath 2.0]</A>. 
XQuery does not support the namespace axis and does not represent namespace 
bindings in the form of nodes. However, where other specifications such as <A 
href="REC-xquery-20070123.htm#serialization">[XSLT 2.0 
and XQuery 1.0 Serialization]</A> refer to namespace nodes, these nodes may be 
synthesized from the in-scope namespaces of an element node by interpreting each 
namespace binding as a namespace node.</P></DIV>
<P>[<A id=dt-URI title=URI name=dt-URI>Definition</A>: Within this 
specification, the term <B>URI</B> refers to a Universal Resource Identifier as 
defined in <A 
href="REC-xquery-20070123.htm#RFC3986">[RFC3986]</A> and 
extended in <A 
href="REC-xquery-20070123.htm#RFC3987">[RFC3987]</A> with 
the new name <B>IRI</B>.] The term URI has been retained in preference to IRI to 
avoid introducing new names for concepts such as "Base URI" that are defined or 
referenced across the whole family of XML specifications.</P>
<DIV class=div2>
<H3><A id=context name=context></A>2.1 Expression Context</H3>
<P>[<A id=dt-expression-context title="expression context" 
name=dt-expression-context>Definition</A>: The <B>expression context</B> for a 
given expression consists of all the information that can affect the result of 
the expression.] This information is organized into two categories called the <A 
title="static context" 
href="REC-xquery-20070123.htm#dt-static-context">static 
context</A> and the <A title="dynamic context" 
href="REC-xquery-20070123.htm#dt-dynamic-context">dynamic 
context</A>.</P>
<DIV class=div3>
<H4><A id=static_context name=static_context></A>2.1.1 Static Context</H4>
<P>[<A id=dt-static-context title="static context" 
name=dt-static-context>Definition</A>: The <B>static context</B> of an 
expression is the information that is available during static analysis of the 
expression, prior to its evaluation.] This information can be used to decide 
whether the expression contains a <A title="static error" 
href="REC-xquery-20070123.htm#dt-static-error">static 
error</A>. If analysis of an expression relies on some component of the <A 
title="static context" 
href="REC-xquery-20070123.htm#dt-static-context">static 
context</A> that has not been assigned a value, a <A title="static error" 
href="REC-xquery-20070123.htm#dt-static-error">static 
error</A> is raised [<A title=err:XPST0001 
href="REC-xquery-20070123.htm#ERRXPST0001">err:XPST0001</A>].</P>
<P>The individual components of the <A title="static context" 
href="REC-xquery-20070123.htm#dt-static-context">static 
context</A> are summarized below. <SPAN class=xquery><SPAN class=xquery>Rules 
governing the scope and initialization of these components can be found in <A 
href="REC-xquery-20070123.htm#id-xq-static-context-components"><B>C.1 
Static Context Components</B></A>.</SPAN></SPAN></P>
<UL>
  <LI>
  <P>[<A id=dt-xpath-compat-mode title="XPath 1.0 compatibility mode" 
  name=dt-xpath-compat-mode>Definition</A>: <B>XPath 1.0 compatibility mode.</B> 
  <SPAN class=xquery><SPAN class=xquery>This component must be set by all host 
  languages that include XPath 2.0 as a subset, indicating whether rules for 
  compatibility with XPath 1.0 are in effect. XQuery sets the value of this 
  component to <CODE>false</CODE>.</SPAN></SPAN> ]</P>
  <LI>
  <P>[<A id=dt-static-namespaces title="statically known namespaces" 
  name=dt-static-namespaces>Definition</A>: <B>Statically known namespaces.</B> 
  This is a set of (prefix, URI) pairs that define all the namespaces that are 
  known during static processing of a given expression.] The URI value is 
  whitespace normalized according to the rules for the <CODE>xs:anyURI</CODE> 
  type in <A 
  href="REC-xquery-20070123.htm#XMLSchema">[XML 
  Schema]</A>. Note the difference between <A title="in-scope namespaces" 
  href="REC-xquery-20070123.htm#dt-in-scope-namespaces">in-scope 
  namespaces</A>, which is a dynamic property of an element node, and <A 
  title="statically known namespaces" 
  href="REC-xquery-20070123.htm#dt-static-namespaces">statically 
  known namespaces</A>, which is a static property of an expression.</P>
  <DIV class=xquery>
  <P class=xquery>Some namespaces are predefined; additional namespaces can be 
  added to the statically known namespaces by <A title="namespace declaration" 
  href="REC-xquery-20070123.htm#dt-namespace-declaration">namespace 
  declarations</A> in a <A title=Prolog 
  href="REC-xquery-20070123.htm#dt-prolog">Prolog</A> and 
  by <A title="namespace declaration attribute" 
  href="REC-xquery-20070123.htm#dt-namespace-decl-attr">namespace 
  declaration attributes</A> in <A title="direct element constructor" 
  href="REC-xquery-20070123.htm#dt-direct-elem-const">direct 
  element constructors</A>.</P></DIV>
  <LI>
  <P>[<A id=dt-def-elemtype-ns title="default element/type namespace" 
  name=dt-def-elemtype-ns>Definition</A>: <B>Default element/type namespace.</B> 
  This is a namespace URI or "none". The namespace URI, if present, is used for 
  any unprefixed QName appearing in a position where an element or type name is 
  expected.] The URI value is whitespace normalized according to the rules for 
  the <CODE>xs:anyURI</CODE> type in <A 
  href="REC-xquery-20070123.htm#XMLSchema">[XML 
  Schema]</A>.</P>
  <LI>
  <P>[<A id=dt-def-fn-ns title="default function namespace" 
  name=dt-def-fn-ns>Definition</A>: <B>Default function namespace.</B> This is a 
  namespace URI or "none". The namespace URI, if present, is used for any 
  unprefixed QName appearing in a position where a function name is expected.] 
  The URI value is whitespace normalized according to the rules for the 
  <CODE>xs:anyURI</CODE> type in <A 
  href="REC-xquery-20070123.htm#XMLSchema">[XML 
  Schema]</A>.</P>
  <LI>
  <P>[<A id=dt-issd title="in-scope schema definitions" 
  name=dt-issd>Definition</A>: <B>In-scope schema definitions.</B> This is a 
  generic term for all the element declarations, attribute declarations, and 
  schema type definitions that are in scope during processing of an expression.] 
  It includes the following three parts:</P>
  <UL>
    <LI>
    <P>[<A id=dt-is-types title="in-scope schema type" 
    name=dt-is-types>Definition</A>: <B>In-scope schema types.</B> Each schema 
    type definition is identified either by an <A title="expanded QName" 
    href="REC-xquery-20070123.htm#dt-expanded-qname">expanded 
    QName</A> (for a <B>named type</B>) or by an <A 
    title="implementation dependent" 
    href="REC-xquery-20070123.htm#dt-implementation-dependent">implementation-dependent</A> 
    type identifier (for an <B>anonymous type</B>). The in-scope schema types 
    include the predefined schema types described in <A 
    href="REC-xquery-20070123.htm#id-predefined-types"><B>2.5.1 
    Predefined Schema Types</B></A>. <SPAN class=xquery><SPAN class=xquery>If 
    the <A title="schema import feature" 
    href="REC-xquery-20070123.htm#dt-schema-import-feature">Schema 
    Import Feature</A> is supported, in-scope schema types also include all type 
    definitions found in imported schemas.</SPAN></SPAN> ]</P>
    <LI>
    <P>[<A id=dt-is-elems title="in-scope element declarations" 
    name=dt-is-elems>Definition</A>: <B>In-scope element declarations.</B> Each 
    element declaration is identified either by an <A title="expanded QName" 
    href="REC-xquery-20070123.htm#dt-expanded-qname">expanded 
    QName</A> (for a top-level element declaration) or by an <A 
    title="implementation dependent" 
    href="REC-xquery-20070123.htm#dt-implementation-dependent">implementation-dependent</A> 
    element identifier (for a local element declaration). <SPAN 
    class=xquery><SPAN class=xquery>If the <A title="schema import feature" 
    href="REC-xquery-20070123.htm#dt-schema-import-feature">Schema 
    Import Feature</A> is supported, in-scope element declarations include all 
    element declarations found in imported schemas.</SPAN></SPAN> ] An element 
    declaration includes information about the element's <A 
    title="substitution group" 
    href="REC-xquery-20070123.htm#dt-substitution-group">substitution 
    group</A> affiliation.</P>
    <P>[<A id=dt-substitution-group title="substitution group" 
    name=dt-substitution-group>Definition</A>: <B>Substitution groups</B> are 
    defined in <A 
    href="REC-xquery-20070123.htm#XMLSchema">[XML 
    Schema]</A> Part 1, Section 2.2.2.2. Informally, the substitution group 
    headed by a given element (called the <B>head element</B>) consists of the 
    set of elements that can be substituted for the head element without 
    affecting the outcome of schema validation.]</P>
    <LI>
    <P>[<A id=dt-is-attrs title="in-scope attribute declarations" 
    name=dt-is-attrs>Definition</A>: <B>In-scope attribute declarations.</B> 
    Each attribute declaration is identified either by an <A 
    title="expanded QName" 
    href="REC-xquery-20070123.htm#dt-expanded-qname">expanded 
    QName</A> (for a top-level attribute declaration) or by an <A 
    title="implementation dependent" 
    href="REC-xquery-20070123.htm#dt-implementation-dependent">implementation-dependent</A> 
    attribute identifier (for a local attribute declaration). <SPAN 
    class=xquery><SPAN class=xquery>If the <A title="schema import feature" 
    href="REC-xquery-20070123.htm#dt-schema-import-feature">Schema 
    Import Feature</A> is supported, in-scope attribute declarations include all 
    attribute declarations found in imported schemas.</SPAN></SPAN>]</P></LI></UL>
  <LI>
  <P>[<A id=dt-in-scope-variables title="in-scope variables" 
  name=dt-in-scope-variables>Definition</A>: <B>In-scope variables.</B> This is 
  a set of (expanded QName, type) pairs. It defines the set of variables that 
  are available for reference within an expression. The <A 
  title="expanded QName" 
  href="REC-xquery-20070123.htm#dt-expanded-qname">expanded 
  QName</A> is the name of the variable, and the type is the <A 
  title="static type" 
  href="REC-xquery-20070123.htm#dt-static-type">static 
  type</A> of the variable.]</P>
  <P><SPAN class=xquery><SPAN class=xquery>Variable declarations in a <A 
  title=Prolog 
  href="REC-xquery-20070123.htm#dt-prolog">Prolog</A> are 
  added to <A title="in-scope variables" 
  href="REC-xquery-20070123.htm#dt-in-scope-variables">in-scope 
  variables</A>.</SPAN></SPAN> An expression that binds a variable (such as a 
  <SPAN class=xquery><SPAN class=xquery><CODE>let</CODE>,</SPAN></SPAN> 
  <CODE>for</CODE>, <CODE>some</CODE>, or <CODE>every</CODE> expression) extends 
  the <A title="in-scope variables" 
  href="REC-xquery-20070123.htm#dt-in-scope-variables">in-scope 
  variables</A> of its subexpressions with the new bound variable and its type. 
  <SPAN class=xquery><SPAN class=xquery>Within a <B>function declaration</B>, 
  the <A title="in-scope variables" 
  href="REC-xquery-20070123.htm#dt-in-scope-variables">in-scope 
  variables</A> are extended by the names and types of the <B>function 
  parameters</B>.</SPAN></SPAN></P>
  <DIV class=xquery>
  <P class=xquery>The static type of a variable may be either declared in a 
  query or (if the <A title="static typing feature" 
  href="REC-xquery-20070123.htm#dt-static-typing-feature">Static 
  Typing Feature</A> is enabled) inferred by static type inference rules as 
  described in <A 
  href="REC-xquery-20070123.htm#XQueryFormalSemantics">[XQuery 
  1.0 and XPath 2.0 Formal Semantics]</A>.</P></DIV>
  <LI>
  <P>[<A id=dt-context-item-static-type title="context item static type" 
  name=dt-context-item-static-type>Definition</A>: <B>Context item static 
  type.</B> This component defines the <A title="static type" 
  href="REC-xquery-20070123.htm#dt-static-type">static 
  type</A> of the context item within the scope of a given expression.]</P>
  <LI>
  <P>[<A id=dt-function-signature title="function signature" 
  name=dt-function-signature>Definition</A>: <B>Function signatures.</B> This 
  component defines the set of functions that are available to be called from 
  within an expression. Each function is uniquely identified by its <A 
  title="expanded QName" 
  href="REC-xquery-20070123.htm#dt-expanded-qname">expanded 
  QName</A> and its arity (number of parameters).] In addition to the name and 
  arity, each function signature specifies the <A title="static type" 
  href="REC-xquery-20070123.htm#dt-static-type">static 
  types</A> of the function parameters and result.</P>
  <P>The <A title="function signature" 
  href="REC-xquery-20070123.htm#dt-function-signature">function 
  signatures</A> include the signatures of <A title="constructor function" 
  href="REC-xquery-20070123.htm#dt-constructor-function">constructor 
  functions</A>, which are discussed in <A 
  href="REC-xquery-20070123.htm#id-constructor-functions"><B>3.12.5 
  Constructor Functions</B></A>.</P>
  <LI>
  <P>[<A id=dt-static-collations title="statically known collations" 
  name=dt-static-collations>Definition</A>: <B>Statically known collations.</B> 
  This is an <A title="implementation defined" 
  href="REC-xquery-20070123.htm#dt-implementation-defined">implementation-defined</A> 
  set of (URI, collation) pairs. It defines the names of the collations that are 
  available for use in processing <SPAN class=xquery><SPAN class=xquery>queries 
  and</SPAN></SPAN> expressions.] [<A id=dt-collation title=collation 
  name=dt-collation>Definition</A>: A <B>collation</B> is a specification of the 
  manner in which strings and URIs are compared and, by extension, ordered. For 
  a more complete definition of collation, see <A 
  href="REC-xquery-20070123.htm#FunctionsAndOperators">[XQuery 
  1.0 and XPath 2.0 Functions and Operators]</A>.]</P>
  <LI>
  <P>[<A id=dt-def-collation title="default collation" 
  name=dt-def-collation>Definition</A>: <B>Default collation.</B> This 
  identifies one of the collations in <A title="statically known collations" 
  href="REC-xquery-20070123.htm#dt-static-collations">statically 
  known collations</A> as the collation to be used by functions and operators 
  for comparing and ordering values of type <CODE>xs:string</CODE> and 
  <CODE>xs:anyURI</CODE> (and types derived from them) when no explicit 
  collation is specified.]</P>
  <LI class=xquery>
  <P>[<A id=dt-construction-mode title="construction mode" 
  name=dt-construction-mode>Definition</A>: <B>Construction mode.</B> The 
  construction mode governs the behavior of element and document node 
  constructors. If construction mode is <CODE>preserve</CODE>, the type of a 
  constructed element node is <CODE>xs:anyType</CODE>, and all attribute and 
  element nodes copied during node construction retain their original types. If 
  construction mode is <CODE>strip</CODE>, the type of a constructed element 
  node is <CODE>xs:untyped</CODE>; all element nodes copied during node 
  construction receive the type <CODE>xs:untyped</CODE>, and all attribute nodes 
  copied during node construction receive the type 
  <CODE>xs:untypedAtomic</CODE>.]</P>
  <LI class=xquery>
  <P>[<A id=dt-ordering-mode title="ordering mode" 
  name=dt-ordering-mode>Definition</A>: <B>Ordering mode.</B> Ordering mode, 
  which has the value <CODE>ordered</CODE> or <CODE>unordered</CODE>, affects 
  the ordering of the result sequence returned by certain <A 
  title="path expression" 
  href="REC-xquery-20070123.htm#dt-path-expression">path 
  expressions</A>, <CODE>union</CODE>, <CODE>intersect</CODE>, and 
  <CODE>except</CODE> expressions, and FLWOR expressions that have no 
  <CODE>order by</CODE> clause.] Details are provided in the descriptions of 
  these expressions.</P>
  <LI class=xquery>
  <P>[<A id=dt-default-empty-order title="default order for empty sequences" 
  name=dt-default-empty-order>Definition</A>: <B>Default order for empty 
  sequences.</B> This component controls the processing of empty sequences and 
  <CODE>NaN</CODE> values as ordering keys in an <CODE>order by</CODE> clause in 
  a FLWOR expression, as described in <A 
  href="REC-xquery-20070123.htm#id-orderby-return"><B>3.8.3 
  Order By and Return Clauses</B></A>.] Its value may be <CODE>greatest</CODE> 
  or <CODE>least</CODE>.</P>
  <LI class=xquery>
  <P>[<A id=dt-boundary-space-policy title="boundary-space policy" 
  name=dt-boundary-space-policy>Definition</A>: <B>Boundary-space policy.</B> 
  This component controls the processing of <A title="boundary whitespace" 
  href="REC-xquery-20070123.htm#dt-boundary-whitespace">boundary 
  whitespace</A> by <A title="direct element constructor" 
  href="REC-xquery-20070123.htm#dt-direct-elem-const">direct 
  element constructors</A>, as described in <A 
  href="REC-xquery-20070123.htm#id-whitespace"><B>3.7.1.4 
  Boundary Whitespace</B></A>.] Its value may be <CODE>preserve</CODE> or 
  <CODE>strip</CODE>.</P>
  <LI class=xquery>
  <P>[<A id=dt-copy-namespaces-mode title="copy-namespaces mode" 
  name=dt-copy-namespaces-mode>Definition</A>: <B>Copy-namespaces mode.</B> This 
  component controls the namespace bindings that are assigned when an existing 
  element node is copied by an element constructor, as described in <A 
  href="REC-xquery-20070123.htm#id-element-constructor"><B>3.7.1 
  Direct Element Constructors</B></A>. Its value consists of two parts: 
  <CODE>preserve</CODE> or <CODE>no-preserve</CODE>, and <CODE>inherit</CODE> or 
  <CODE>no-inherit</CODE>.]</P>
  <LI>
  <P>[<A id=dt-base-uri title="base URI" name=dt-base-uri>Definition</A>: 
  <B>Base URI.</B> This is an absolute URI, used when necessary in the 
  resolution of relative URIs (for example, by the <CODE>fn:resolve-uri</CODE> 
  function.)] The URI value is whitespace normalized according to the rules for 
  the <CODE>xs:anyURI</CODE> type in <A 
  href="REC-xquery-20070123.htm#XMLSchema">[XML 
  Schema]</A>.</P>
  <LI>
  <P>[<A id=dt-known-docs title="statically known documents" 
  name=dt-known-docs>Definition</A>: <B>Statically known documents.</B> This is 
  a mapping from strings onto types. The string represents the absolute URI of a 
  resource that is potentially available using the <CODE>fn:doc</CODE> function. 
  The type is the <A title="static type" 
  href="REC-xquery-20070123.htm#dt-static-type">static 
  type</A> of a call to <CODE>fn:doc</CODE> with the given URI as its literal 
  argument. ] If the argument to <CODE>fn:doc</CODE> is a string literal that is 
  not present in <B>statically known documents</B>, then the <A 
  title="static type" 
  href="REC-xquery-20070123.htm#dt-static-type">static 
  type</A> of <CODE>fn:doc</CODE> is <CODE>document-node()?</CODE>.</P>
  <DIV class=note>
  <P class=prefix><B>Note:</B></P>
  <P>The purpose of the <B>statically known documents</B> is to provide static 
  type information, not to determine which documents are available. A URI need 
  not be found in the <B>statically known documents</B> to be accessed using 
  <CODE>fn:doc</CODE>.</P></DIV>
  <LI>
  <P>[<A id=dt-known-collections title="statically known collections" 
  name=dt-known-collections>Definition</A>: <B>Statically known collections.</B> 
  This is a mapping from strings onto types. The string represents the absolute 
  URI of a resource that is potentially available using the 
  <CODE>fn:collection</CODE> function. The type is the type of the sequence of 
  nodes that would result from calling the <CODE>fn:collection</CODE> function 
  with this URI as its argument.] If the argument to <CODE>fn:collection</CODE> 
  is a string literal that is not present in <B>statically known 
  collections</B>, then the <A title="static type" 
  href="REC-xquery-20070123.htm#dt-static-type">static 
  type</A> of <CODE>fn:collection</CODE> is <CODE>node()*</CODE>.</P>
  <DIV class=note>
  <P class=prefix><B>Note:</B></P>
  <P>The purpose of the <B>statically known collections</B> is to provide static 
  type information, not to determine which collections are available. A URI need 
  not be found in the <B>statically known collections</B> to be accessed using 
  <CODE>fn:collection</CODE>.</P></DIV>
  <LI>
  <P>[<A id=dt-known-default-collection 
  title="statically known default collection type" 
  name=dt-known-default-collection>Definition</A>: <B>Statically known default 
  collection type.</B> This is the type of the sequence of nodes that would 
  result from calling the <CODE>fn:collection</CODE> function with no 
  arguments.] Unless initialized to some other value by an implementation, the 
  value of <B>statically known default collection type</B> is 
  <CODE>node()*</CODE>.</P></LI></UL></DIV>
<DIV class=div3>
<H4><A id=eval_context name=eval_context></A>2.1.2 Dynamic Context</H4>
<P>[<A id=dt-dynamic-context title="dynamic context" 
name=dt-dynamic-context>Definition</A>: The <B>dynamic context</B> of an 
expression is defined as information that is available at the time the 
expression is evaluated.] If evaluation of an expression relies on some part of 
the <A title="dynamic context" 
href="REC-xquery-20070123.htm#dt-dynamic-context">dynamic 
context</A> that has not been assigned a value, a <A title="dynamic error" 
href="REC-xquery-20070123.htm#dt-dynamic-error">dynamic 
error</A> is raised [<A title=err:XPDY0002 
href="REC-xquery-20070123.htm#ERRXPDY0002">err:XPDY0002</A>].</P>
<P>The individual components of the <A title="dynamic context" 
href="REC-xquery-20070123.htm#dt-dynamic-context">dynamic 
context</A> are summarized below. Further rules governing the semantics of these 
components can be found in <A 
href="REC-xquery-20070123.htm#id-xq-evaluation-context-components"><B>C.2 
Dynamic Context Components</B></A>.</P>
<P>The <A title="dynamic context" 
href="REC-xquery-20070123.htm#dt-dynamic-context">dynamic 
context</A> consists of all the components of the <A title="static context" 
href="REC-xquery-20070123.htm#dt-static-context">static 
context</A>, and the additional components listed below.</P>
<P>[<A id=dt-focus title=focus name=dt-focus>Definition</A>: The first three 
components of the <A title="dynamic context" 
href="REC-xquery-20070123.htm#dt-dynamic-context">dynamic 
context</A> (context item, context position, and context size) are called the 
<B>focus</B> of the expression. ] The focus enables the processor to keep track 
of which items are being processed by the expression.</P>
<P>Certain language constructs, notably the <A title="path expression" 
href="REC-xquery-20070123.htm#dt-path-expression">path 
expression</A> <CODE>E1/E2</CODE> and the <A title=predicate 
href="REC-xquery-20070123.htm#dt-predicate">predicate</A> 
<CODE>E1[E2]</CODE>, create a new focus for the evaluation of a sub-expression. 
In these constructs, <CODE>E2</CODE> is evaluated once for each item in the 
sequence that results from evaluating <CODE>E1</CODE>. Each time <CODE>E2</CODE> 
is evaluated, it is evaluated with a different focus. The focus for evaluating 
<CODE>E2</CODE> is referred to below as the <B>inner focus</B>, while the focus 
for evaluating <CODE>E1</CODE> is referred to as the <B>outer focus</B>. The 
inner focus exists only while <CODE>E2</CODE> is being evaluated. When this 
evaluation is complete, evaluation of the containing expression continues with 
its original focus unchanged.</P>
<UL>
  <LI>
  <P>[<A id=dt-context-item title="context item" 
  name=dt-context-item>Definition</A>: The <B>context item</B> is the item 
  currently being processed. An item is either an atomic value or a node.][<A 
  id=dt-context-node title="context node" name=dt-context-node>Definition</A>: 
  When the context item is a node, it can also be referred to as the <B>context 
  node</B>.] The context item is returned by an expression consisting of a 
  single dot (<CODE>.</CODE>). When an expression <CODE>E1/E2</CODE> or 
  <CODE>E1[E2]</CODE> is evaluated, each item in the sequence obtained by 
  evaluating <CODE>E1</CODE> becomes the context item in the inner focus for an 
  evaluation of <CODE>E2</CODE>.</P>
  <LI>
  <P>[<A id=dt-context-position title="context position" 
  name=dt-context-position>Definition</A>: The <B>context position</B> is the 
  position of the context item within the sequence of items currently being 
  processed.] It changes whenever the context item changes. When the focus is 
  defined, the value of the context position is an integer greater than zero. 
  The context position is returned by the expression <CODE>fn:position()</CODE>. 
  When an expression <CODE>E1/E2</CODE> or <CODE>E1[E2]</CODE> is evaluated, the 
  context position in the inner focus for an evaluation of <CODE>E2</CODE> is 
  the position of the context item in the sequence obtained by evaluating 
  <CODE>E1</CODE>. The position of the first item in a sequence is always 1 
  (one). The context position is always less than or equal to the context 
  size.</P>
  <LI>
  <P>[<A id=dt-context-size title="context size" 
  name=dt-context-size>Definition</A>: The <B>context size</B> is the number of 
  items in the sequence of items currently being processed.] Its value is always 
  an integer greater than zero. The context size is returned by the expression 
  <CODE>fn:last()</CODE>. When an expression <CODE>E1/E2</CODE> or 
  <CODE>E1[E2]</CODE> is evaluated, the context size in the inner focus for an 
  evaluation of <CODE>E2</CODE> is the number of items in the sequence obtained 
  by evaluating <CODE>E1</CODE>.</P>
  <LI>
  <P>[<A id=dt-variable-values title="variable values" 
  name=dt-variable-values>Definition</A>: <B>Variable values</B>. This is a set 
  of (expanded QName, value) pairs. It contains the same <A 
  title="expanded QName" 
  href="REC-xquery-20070123.htm#dt-expanded-qname">expanded 
  QNames</A> as the <A title="in-scope variables" 
  href="REC-xquery-20070123.htm#dt-in-scope-variables">in-scope 
  variables</A> in the <A title="static context" 
  href="REC-xquery-20070123.htm#dt-static-context">static 
  context</A> for the expression. The expanded QName is the name of the variable 
  and the value is the dynamic value of the variable, which includes its <A 
  title="dynamic type" 
  href="REC-xquery-20070123.htm#dt-dynamic-type">dynamic 
  type</A>.]</P>
  <LI>
  <P>[<A id=dt-function-implementation title="function implementation" 
  name=dt-function-implementation>Definition</A>: <B>Function 
  implementations</B>. Each function in <A title="function signature" 
  href="REC-xquery-20070123.htm#dt-function-signature">function 
  signatures</A> has a function implementation that enables the function to map 
  instances of its parameter types into an instance of its result type. <SPAN 
  class=xquery><SPAN class=xquery>For a <A title="user-defined function" 
  href="REC-xquery-20070123.htm#dt-udf">user-defined 
  function</A>, the function implementation is an XQuery expression. For a <A 
  title="built-in function" 
  href="REC-xquery-20070123.htm#dt-built-in-function">built-in 
  function</A> or <A title="external function" 
  href="REC-xquery-20070123.htm#dt-external-function">external 
  function</A>, the function implementation is <A 
  title="implementation dependent" 
  href="REC-xquery-20070123.htm#dt-implementation-dependent">implementation-dependent</A>.</SPAN></SPAN>]</P>
  <LI>
  <P>[<A id=dt-date-time title="current dateTime" 
  name=dt-date-time>Definition</A>: <B>Current dateTime.</B> This information 
  represents an <A title="implementation dependent" 
  href="REC-xquery-20070123.htm#dt-implementation-dependent">implementation-dependent</A> 
  point in time during the processing of <SPAN class=xquery><SPAN class=xquery>a 
  query</SPAN></SPAN>, and includes an explicit timezone. It can be retrieved by 
  the <CODE>fn:current-dateTime</CODE> function. If invoked multiple times 
  during the execution of <SPAN class=xquery><SPAN class=xquery>a 
  query</SPAN></SPAN>, this function always returns the same result.]</P>
  <LI>
  <P>[<A id=dt-timezone title="implicit timezone" 
  name=dt-timezone>Definition</A>: <B>Implicit timezone.</B> This is the 
  timezone to be used when a date, time, or dateTime value that does not have a 
  timezone is used in a comparison or arithmetic operation. The implicit 
  timezone is an <A title="implementation defined" 
  href="REC-xquery-20070123.htm#dt-implementation-defined">implementation-defined</A> 
  value of type <CODE>xs:dayTimeDuration</CODE>. See <A 
  href="REC-xquery-20070123.htm#XMLSchema">[XML 
  Schema]</A> for the range of legal values of a timezone.]</P>
  <LI>
  <P>[<A id=dt-available-docs title="available documents" 
  name=dt-available-docs>Definition</A>: <B>Available documents.</B> This is a 
  mapping of strings onto document nodes. The string represents the absolute URI 
  of a resource. The document node is the root of a tree that represents that 
  resource using the <A title="data model" 
  href="REC-xquery-20070123.htm#dt-datamodel">data 
  model</A>. The document node is returned by the <CODE>fn:doc</CODE> function 
  when applied to that URI.] The set of available documents is not limited to 
  the set of <A title="statically known documents" 
  href="REC-xquery-20070123.htm#dt-known-docs">statically 
  known documents</A>, and it may be empty.</P>
  <P>If there are one or more URIs in <A title="available documents" 
  href="REC-xquery-20070123.htm#dt-available-docs">available 
  documents</A> that map to a document node <CODE>D</CODE>, then the 
  document-uri property of <CODE>D</CODE> must either be absent, or must be one 
  of these URIs.</P>
  <DIV class=note>
  <P class=prefix><B>Note:</B></P>
  <P>This means that given a document node <CODE>$N</CODE>, the result of 
  <CODE>fn:doc(fn:document-uri($N)) is $N</CODE> will always be True, unless 
  <CODE>fn:document-uri($N)</CODE> is an empty sequence.</P></DIV>
  <LI>
  <P>[<A id=dt-available-collections title="available collections" 
  name=dt-available-collections>Definition</A>: <B>Available collections.</B> 
  This is a mapping of strings onto sequences of nodes. The string represents 
  the absolute URI of a resource. The sequence of nodes represents the result of 
  the <CODE>fn:collection</CODE> function when that URI is supplied as the 
  argument. ] The set of available collections is not limited to the set of <A 
  title="statically known collections" 
  href="REC-xquery-20070123.htm#dt-known-collections">statically 
  known collections</A>, and it may be empty.</P>
  <P>For every document node <CODE>D</CODE> that is in the target of a mapping 
  in <A title="available collections" 
  href="REC-xquery-20070123.htm#dt-available-collections">available 
  collections</A>, or that is the root of a tree containing such a node, the 
  document-uri property of <CODE>D</CODE> must either be absent, or must be a 
  URI <CODE>U</CODE> such that <A title="available documents" 
  href="REC-xquery-20070123.htm#dt-available-docs">available 
  documents</A> contains a mapping from <CODE>U</CODE> to <CODE>D</CODE>."</P>
  <DIV class=note>
  <P class=prefix><B>Note:</B></P>
  <P>This means that for any document node <CODE>$N</CODE> retrieved using the 
  <CODE>fn:collection</CODE> function, either directly or by navigating to the 
  root of a node that was returned, the result of 
  <CODE>fn:doc(fn:document-uri($N)) is $N</CODE> will always be True, unless 
  <CODE>fn:document-uri($N)</CODE> is an empty sequence. This implies a 
  requirement for the <CODE>fn:doc</CODE> and <CODE>fn:collection</CODE> 
  functions to be consistent in their effect. If the implementation uses 
  catalogs or user-supplied URI resolvers to dereference URIs supplied to the 
  <CODE>fn:doc</CODE> function, the implementation of the 
  <CODE>fn:collection</CODE> function must take these mechanisms into account. 
  For example, an implementation might achieve this by mapping the collection 
  URI to a set of document URIs, which are then resolved using the same catalog 
  or URI resolver that is used by the <CODE>fn:doc</CODE> function.</P></DIV>
  <LI>
  <P>[<A id=dt-default-collection title="default collection" 
  name=dt-default-collection>Definition</A>: <B>Default collection.</B> This is 
  the sequence of nodes that would result from calling the 
  <CODE>fn:collection</CODE> function with no arguments.] The value of 
  <B>default collection</B> may be initialized by the 
implementation.</P></LI></UL></DIV></DIV>
<DIV class=div2>
<H3><A id=id-processing-model name=id-processing-model></A>2.2 Processing 
Model</H3>
<P>XQuery is defined in terms of the <A title="data model" 
href="REC-xquery-20070123.htm#dt-datamodel">data 
model</A> and the <A title="expression context" 
href="REC-xquery-20070123.htm#dt-expression-context">expression 
context</A>.</P><IMG alt="Processing Model Overview" 
src="REC-xquery-20070123_files/ProcMod-XQuery.gif"> 
<P>Figure 1: Processing Model Overview</P>
<P>Figure 1 provides a schematic overview of the processing steps that are 
discussed in detail below. Some of these steps are completely outside the domain 
of XQuery; in Figure 1, these are depicted outside the line that represents the 
boundaries of the language, an area labeled <B>external processing</B>. The 
external processing domain includes generation of an <A title="XDM instance" 
href="REC-xquery-20070123.htm#dt-data-model-instance">XDM 
instance</A> that represents the data to be queried (see <A 
href="REC-xquery-20070123.htm#id-data-model-generation"><B>2.2.1 
Data Model Generation</B></A>), schema import processing (see <A 
href="REC-xquery-20070123.htm#id-schema-import-processing"><B>2.2.2 
Schema Import Processing</B></A>) and serialization (see <A 
href="REC-xquery-20070123.htm#id-serialization"><B>2.2.4 
Serialization</B></A>). The area inside the boundaries of the language is known 
as the <SPAN class=xquery><SPAN class=xquery><B>query processing 
domain</B></SPAN></SPAN>, which includes the static analysis and dynamic 
evaluation phases (see <A 
href="REC-xquery-20070123.htm#id-expression-processing"><B>2.2.3 
Expression Processing</B></A>). Consistency constraints on the <SPAN 
class=xquery><SPAN class=xquery>query</SPAN></SPAN> processing domain are 
defined in <A 
href="REC-xquery-20070123.htm#id-consistency-constraints"><B>2.2.5 
Consistency Constraints</B></A>.</P>
<DIV class=div3>
<H4><A id=id-data-model-generation name=id-data-model-generation></A>2.2.1 Data 
Model Generation</H4>
<P>Before <SPAN class=xquery><SPAN class=xquery>a query</SPAN></SPAN> can be 
processed, its input data must be represented as an <A title="XDM instance" 
href="REC-xquery-20070123.htm#dt-data-model-instance">XDM 
instance</A>. This process occurs outside the domain of XQuery, which is why 
Figure 1 represents it in the external processing domain. Here are some steps by 
which an XML document might be converted to an <A title="XDM instance" 
href="REC-xquery-20070123.htm#dt-data-model-instance">XDM 
instance</A>:</P>
<OL class=enumar>
  <LI>
  <P>A document may be parsed using an XML parser that generates an <B>XML 
  Information Set</B> (see <A 
  href="REC-xquery-20070123.htm#XINFO">[XML 
  Infoset]</A>). The parsed document may then be validated against one or more 
  schemas. This process, which is described in <A 
  href="REC-xquery-20070123.htm#XMLSchema">[XML 
  Schema]</A>, results in an abstract information structure called the 
  <B>Post-Schema Validation Infoset</B> (PSVI). If a document has no associated 
  schema, its Information Set is preserved. (See DM1 in Fig. 1.)</P>
  <LI>
  <P>The Information Set or PSVI may be transformed into an <A 
  title="XDM instance" 
  href="REC-xquery-20070123.htm#dt-data-model-instance">XDM 
  instance</A> by a process described in <A 
  href="REC-xquery-20070123.htm#datamodel">[XQuery/XPath 
  Data Model (XDM)]</A>. (See DM2 in Fig. 1.)</P></LI></OL>
<P>The above steps provide an example of how an <A title="XDM instance" 
href="REC-xquery-20070123.htm#dt-data-model-instance">XDM 
instance</A> might be constructed. An XDM instance might also be synthesized 
directly from a relational database, or constructed in some other way (see DM3 
in Fig. 1.) XQuery is defined in terms of the <A title="data model" 
href="REC-xquery-20070123.htm#dt-datamodel">data 
model</A>, but it does not place any constraints on how XDM instances are 
constructed.</P>
<P>[<A id=dt-type-annotation title="type annotation" 
name=dt-type-annotation>Definition</A>: Each element node and attribute node in 
an <A title="XDM instance" 
href="REC-xquery-20070123.htm#dt-data-model-instance">XDM 
instance</A> has a <B>type annotation</B> (referred to in <A 
href="REC-xquery-20070123.htm#datamodel">[XQuery/XPath 
Data Model (XDM)]</A> as its <CODE>type-name</CODE> property.) The type 
annotation of a node is a <A title="schema type" 
href="REC-xquery-20070123.htm#dt-schema-type">schema 
type</A> that describes the relationship between the <A title="string value" 
href="REC-xquery-20070123.htm#dt-string-value">string 
value</A> of the node and its <A title="typed value" 
href="REC-xquery-20070123.htm#dt-typed-value">typed 
value</A>.] If the <A title="XDM instance" 
href="REC-xquery-20070123.htm#dt-data-model-instance">XDM 
instance</A> was derived from a validated XML document as described in <A 
href="http://www.w3.org/TR/xpath-datamodel/#const-psvi">Section 3.3 Construction 
from a PSVI</A><SUP><SMALL>DM</SMALL></SUP>, the type annotations of the element 
and attribute nodes are derived from schema validation. XQuery does not provide 
a way to directly access the type annotation of an element or attribute 
node.</P>
<P>The value of an attribute is represented directly within the attribute node. 
An attribute node whose type is unknown (such as might occur in a schemaless 
document) is given the <A title="type annotation" 
href="REC-xquery-20070123.htm#dt-type-annotation">type 
annotation</A> <CODE>xs:untypedAtomic</CODE>.</P>
<P>The value of an element is represented by the children of the element node, 
which may include text nodes and other element nodes. The <A 
title="type annotation" 
href="REC-xquery-20070123.htm#dt-type-annotation">type 
annotation</A> of an element node indicates how the values in its child text 
nodes are to be interpreted. An element that has not been validated (such as 
might occur in a schemaless document) is annotated with the schema type 
<CODE>xs:untyped</CODE>. An element that has been validated and found to be 
partially valid is annotated with the schema type <CODE>xs:anyType</CODE>. If an 
element node is annotated as <CODE>xs:untyped</CODE>, all its descendant element 
nodes are also annotated as <CODE>xs:untyped</CODE>. However, if an element node 
is annotated as <CODE>xs:anyType</CODE>, some of its descendant element nodes 
may have a more specific <A title="type annotation" 
href="REC-xquery-20070123.htm#dt-type-annotation">type 
annotation</A>.</P></DIV>
<DIV class=div3>
<H4><A id=id-schema-import-processing name=id-schema-import-processing></A>2.2.2 
Schema Import Processing</H4>
<DIV class=xquery>
<P class=xquery>The <A title="in-scope schema definitions" 
href="REC-xquery-20070123.htm#dt-issd">in-scope schema 
definitions</A> in the <A title="static context" 
href="REC-xquery-20070123.htm#dt-static-context">static 
context</A> may be extracted from actual XML schemas as described in <A 
href="REC-xquery-20070123.htm#XQueryFormalSemantics">[XQuery 
1.0 and XPath 2.0 Formal Semantics]</A> (see step SI1 in Figure 1) or may be 
generated by some other mechanism (see step SI2 in Figure 1). In either case, 
the result must satisfy the consistency constraints defined in <A 
href="REC-xquery-20070123.htm#id-consistency-constraints"><B>2.2.5 
Consistency Constraints</B></A>.</P></DIV></DIV>
<DIV class=div3>
<H4><A id=id-expression-processing name=id-expression-processing></A>2.2.3 
Expression Processing</H4>
<P>XQuery defines two phases of processing called the <A 
title="static analysis phase" 
href="REC-xquery-20070123.htm#dt-static-analysis">static 
analysis phase</A> and the <A title="dynamic evaluation phase" 
href="REC-xquery-20070123.htm#dt-dynamic-evaluation">dynamic 
evaluation phase</A> (see Fig. 1). During the static analysis phase, <A 
title="static error" 
href="REC-xquery-20070123.htm#dt-static-error">static 
errors</A>, <A title="dynamic error" 
href="REC-xquery-20070123.htm#dt-dynamic-error">dynamic 
errors</A>, or <A title="type error" 
href="REC-xquery-20070123.htm#dt-type-error">type 
errors</A> may be raised. During the dynamic evaluation phase, only <A 
title="dynamic error" 
href="REC-xquery-20070123.htm#dt-dynamic-error">dynamic 
errors</A> or <A title="type error" 
href="REC-xquery-20070123.htm#dt-type-error">type 
errors</A> may be raised. These kinds of errors are defined in <A 
href="REC-xquery-20070123.htm#id-kinds-of-errors"><B>2.3.1 
Kinds of Errors</B></A>.</P>
<P>Within each phase, an implementation is free to use any strategy or algorithm 
whose result conforms to the specifications in this document.</P>
<DIV class=div4>
<H5><A id=id-static-analysis name=id-static-analysis></A>2.2.3.1 Static Analysis 
Phase</H5>
<P>[<A id=dt-static-analysis title="static analysis phase" 
name=dt-static-analysis>Definition</A>: The <B>static analysis phase</B> depends 
on the expression itself and on the <A title="static context" 
href="REC-xquery-20070123.htm#dt-static-context">static 
context</A>. The <B>static analysis phase</B> does not depend on input data 
(other than schemas).]</P>
<P>During the static analysis phase, the <SPAN class=xquery><SPAN 
class=xquery>query</SPAN></SPAN> is parsed into an internal representation 
called the <B>operation tree</B> (step SQ1 in Figure 1). A parse error is raised 
as a <A title="static error" 
href="REC-xquery-20070123.htm#dt-static-error">static 
error</A> [<A title=err:XPST0003 
href="REC-xquery-20070123.htm#ERRXPST0003">err:XPST0003</A>]. 
The <A title="static context" 
href="REC-xquery-20070123.htm#dt-static-context">static 
context</A> is initialized by the implementation (step SQ2). <SPAN 
class=xquery><SPAN class=xquery>The <A title="static context" 
href="REC-xquery-20070123.htm#dt-static-context">static 
context</A> is then changed and augmented based on information in the 
<B>prolog</B> (step SQ3). If the <A title="schema import feature" 
href="REC-xquery-20070123.htm#dt-schema-import-feature">Schema 
Import Feature</A> is supported, the <A title="in-scope schema definitions" 
href="REC-xquery-20070123.htm#dt-issd">in-scope schema 
definitions</A> are populated with information from imported schemas. If the <A 
title="module feature" 
href="REC-xquery-20070123.htm#dt-module-feature">Module 
Feature</A> is supported, the static context is extended with function 
declarations and variable declarations from imported modules.</SPAN></SPAN> The 
<A title="static context" 
href="REC-xquery-20070123.htm#dt-static-context">static 
context</A> is used to resolve schema type names, function names, namespace 
prefixes, and variable names (step SQ4). If a name of one of these kinds in the 
<B>operation tree</B> is not found in the <A title="static context" 
href="REC-xquery-20070123.htm#dt-static-context">static 
context</A>, a <A title="static error" 
href="REC-xquery-20070123.htm#dt-static-error">static 
error</A> ([<A title=err:XPST0008 
href="REC-xquery-20070123.htm#ERRXPST0008">err:XPST0008</A>] 
or [<A title=err:XPST0017 
href="REC-xquery-20070123.htm#ERRXPST0017">err:XPST0017</A>]) 
is raised (however, see exceptions to this rule in <A 
href="REC-xquery-20070123.htm#id-element-test"><B>2.5.4.3 
Element Test</B></A> and <A 
href="REC-xquery-20070123.htm#id-attribute-test"><B>2.5.4.5 
Attribute Test</B></A>.)</P>
<P>The <B>operation tree</B> is then <B>normalized</B> by making explicit the 
implicit operations such as <A title=atomization 
href="REC-xquery-20070123.htm#dt-atomization">atomization</A> 
and extraction of <A title="effective boolean value" 
href="REC-xquery-20070123.htm#dt-ebv">Effective Boolean 
Values</A> (step SQ5). The normalization process is described in <A 
href="REC-xquery-20070123.htm#XQueryFormalSemantics">[XQuery 
1.0 and XPath 2.0 Formal Semantics]</A>.</P>
<P>Each expression is then assigned a <A title="static type" 
href="REC-xquery-20070123.htm#dt-static-type">static 
type</A> (step SQ6). [<A id=dt-static-type title="static type" 
name=dt-static-type>Definition</A>: The <B>static type</B> of an expression is a 
type such that, when the expression is evaluated, the resulting value will 
always conform to the static type.] If the <A title="static typing feature" 
href="REC-xquery-20070123.htm#dt-static-typing-feature">Static 
Typing Feature</A> is supported, the <A title="static type" 
href="REC-xquery-20070123.htm#dt-static-type">static 
types</A> of various expressions are inferred according to the rules described 
in <A 
href="REC-xquery-20070123.htm#XQueryFormalSemantics">[XQuery 
1.0 and XPath 2.0 Formal Semantics]</A>. If the <A title="static typing feature" 
href="REC-xquery-20070123.htm#dt-static-typing-feature">Static 
Typing Feature</A> is not supported, the static types that are assigned are <A 
title="implementation dependent" 
href="REC-xquery-20070123.htm#dt-implementation-dependent">implementation-dependent</A>.</P>
<P>During the <A title="static analysis phase" 
href="REC-xquery-20070123.htm#dt-static-analysis">static 
analysis phase</A>, if the <A title="static typing feature" 
href="REC-xquery-20070123.htm#dt-static-typing-feature">Static 
Typing Feature</A> is in effect and an operand of an expression is found to have 
a <A title="static type" 
href="REC-xquery-20070123.htm#dt-static-type">static 
type</A> that is not appropriate for that operand, a <A title="type error" 
href="REC-xquery-20070123.htm#dt-type-error">type 
error</A> is raised [<A title=err:XPTY0004 
href="REC-xquery-20070123.htm#ERRXPTY0004">err:XPTY0004</A>]. 
If static type checking raises no errors and assigns a <A title="static type" 
href="REC-xquery-20070123.htm#dt-static-type">static 
type</A> T to an expression, then execution of the expression on valid input 
data is guaranteed either to produce a value of type T or to raise a <A 
title="dynamic error" 
href="REC-xquery-20070123.htm#dt-dynamic-error">dynamic 
error</A>.</P>
<P>The purpose of the <A title="static typing feature" 
href="REC-xquery-20070123.htm#dt-static-typing-feature">Static 
Typing Feature</A> is to provide early detection of <A title="type error" 
href="REC-xquery-20070123.htm#dt-type-error">type 
errors</A> and to infer type information that may be useful in optimizing the 
evaluation of an expression.</P></DIV>
<DIV class=div4>
<H5><A id=id-dynamic-evaluation name=id-dynamic-evaluation></A>2.2.3.2 Dynamic 
Evaluation Phase</H5>
<P>[<A id=dt-dynamic-evaluation title="dynamic evaluation phase" 
name=dt-dynamic-evaluation>Definition</A>: The <B>dynamic evaluation phase</B> 
is the phase during which the value of an expression is computed.] It occurs 
after completion of the <A title="static analysis phase" 
href="REC-xquery-20070123.htm#dt-static-analysis">static 
analysis phase</A>.</P>
<P>The dynamic evaluation phase can occur only if no errors were detected during 
the <A title="static analysis phase" 
href="REC-xquery-20070123.htm#dt-static-analysis">static 
analysis phase</A>. If the <A title="static typing feature" 
href="REC-xquery-20070123.htm#dt-static-typing-feature">Static 
Typing Feature</A> is in effect, all <A title="type error" 
href="REC-xquery-20070123.htm#dt-type-error">type 
errors</A> are detected during static analysis and serve to inhibit the dynamic 
evaluation phase.</P>
<P>The dynamic evaluation phase depends on the <B>operation tree</B> of the 
expression being evaluated (step DQ1), on the input data (step DQ4), and on the 
<A title="dynamic context" 
href="REC-xquery-20070123.htm#dt-dynamic-context">dynamic 
context</A> (step DQ5), which in turn draws information from the external 
environment (step DQ3) and the <A title="static context" 
href="REC-xquery-20070123.htm#dt-static-context">static 
context</A> (step DQ2). The dynamic evaluation phase may create new data-model 
values (step DQ4) and it may extend the <A title="dynamic context" 
href="REC-xquery-20070123.htm#dt-dynamic-context">dynamic 
context</A> (step DQ5)—for example, by binding values to variables.</P>
<P>[<A id=dt-dynamic-type title="dynamic type" 
name=dt-dynamic-type>Definition</A>: A <B>dynamic type</B> is associated with 
each value as it is computed. The dynamic type of a value may be more specific 
than the <A title="static type" 
href="REC-xquery-20070123.htm#dt-static-type">static 
type</A> of the expression that computed it (for example, the static type of an 
expression might be <CODE>xs:integer*</CODE>, denoting a sequence of zero or 
more integers, but at evaluation time its value may have the dynamic type 
<CODE>xs:integer</CODE>, denoting exactly one integer.)]</P>
<P>If an operand of an expression is found to have a <A title="dynamic type" 
href="REC-xquery-20070123.htm#dt-dynamic-type">dynamic 
type</A> that is not appropriate for that operand, a <A title="type error" 
href="REC-xquery-20070123.htm#dt-type-error">type 
error</A> is raised [<A title=err:XPTY0004 
href="REC-xquery-20070123.htm#ERRXPTY0004">err:XPTY0004</A>].</P>
<P>Even though static typing can catch many <A title="type error" 
href="REC-xquery-20070123.htm#dt-type-error">type 
errors</A> before an expression is executed, it is possible for an expression to 
raise an error during evaluation that was not detected by static analysis. For 
example, an expression may contain a cast of a string into an integer, which is 
statically valid. However, if the actual value of the string at run time cannot 
be cast into an integer, a <A title="dynamic error" 
href="REC-xquery-20070123.htm#dt-dynamic-error">dynamic 
error</A> will result. Similarly, an expression may apply an arithmetic operator 
to a value whose <A title="static type" 
href="REC-xquery-20070123.htm#dt-static-type">static 
type</A> is <CODE>xs:untypedAtomic</CODE>. This is not a <A title="static error" 
href="REC-xquery-20070123.htm#dt-static-error">static 
error</A>, but at run time, if the value cannot be successfully cast to a <A 
title=numeric 
href="REC-xquery-20070123.htm#dt-numeric">numeric</A> 
type, a <A title="dynamic error" 
href="REC-xquery-20070123.htm#dt-dynamic-error">dynamic 
error</A> will be raised.</P>
<P>When the <A title="static typing feature" 
href="REC-xquery-20070123.htm#dt-static-typing-feature">Static 
Typing Feature</A> is in effect, it is also possible for static analysis of an 
expression to raise a <A title="type error" 
href="REC-xquery-20070123.htm#dt-type-error">type 
error</A>, even though execution of the expression on certain inputs would be 
successful. For example, an expression might contain a function that requires an 
element as its parameter, and the static analysis phase might infer the <A 
title="static type" 
href="REC-xquery-20070123.htm#dt-static-type">static 
type</A> of the function parameter to be an optional element. This case is 
treated as a <A title="type error" 
href="REC-xquery-20070123.htm#dt-type-error">type 
error</A> and inhibits evaluation, even though the function call would have been 
successful for input data in which the optional element is 
present.</P></DIV></DIV>
<DIV class=div3>
<H4><A id=id-serialization name=id-serialization></A>2.2.4 Serialization</H4>
<P>[<A id=dt-serialization title=serialization 
name=dt-serialization>Definition</A>: <B>Serialization</B> is the process of 
converting an <A title="XDM instance" 
href="REC-xquery-20070123.htm#dt-data-model-instance">XDM 
instance</A> into a sequence of octets (step DM4 in Figure 1.) ] The general 
framework for serialization is described in <A 
href="REC-xquery-20070123.htm#serialization">[XSLT 2.0 
and XQuery 1.0 Serialization]</A>.</P>
<DIV class=xquery>
<P class=xquery>An XQuery implementation is not required to provide a 
serialization interface. For example, an implementation may only provide a DOM 
interface (see <A 
href="REC-xquery-20070123.htm#DOM">[Document Object 
Model]</A>) or an interface based on an event stream. In these cases, 
serialization would be outside of the scope of this specification.</P></DIV>
<DIV class=xquery>
<P class=xquery><A 
href="REC-xquery-20070123.htm#serialization">[XSLT 2.0 
and XQuery 1.0 Serialization]</A> defines a set of <B>serialization 
parameters</B> that govern the serialization process. If an XQuery 
implementation provides a serialization interface, it may support (and may 
expose to users) any of the serialization parameters listed (with default 
values) in <A 
href="REC-xquery-20070123.htm#id-xq-serialization-parameters"><B>C.3 
Serialization Parameters</B></A>. An XQuery implementation that provides a 
serialization interface must support some combination of serialization 
parameters in which <CODE>method = "xml"</CODE> and <CODE>version = 
"1.0"</CODE>.</P></DIV>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>The <A title="data model" 
href="REC-xquery-20070123.htm#dt-datamodel">data 
model</A> permits an element node to have fewer <A title="in-scope namespaces" 
href="REC-xquery-20070123.htm#dt-in-scope-namespaces">in-scope 
namespaces</A> than its parent. Correct serialization of such an element node 
would require "undeclaration" of namespaces, which is a feature of <A 
href="REC-xquery-20070123.htm#XMLNAMES11">[XML Names 
1.1]</A>. An implementation that does not support <A 
href="REC-xquery-20070123.htm#XMLNAMES11">[XML Names 
1.1]</A> is permitted to serialize such an element without "undeclaration" of 
namespaces, which effectively causes the element to inherit the in-scope 
namespaces of its parent.</P></DIV></DIV>
<DIV class=div3>
<H4><A id=id-consistency-constraints name=id-consistency-constraints></A>2.2.5 
Consistency Constraints</H4>
<P>In order for XQuery to be well defined, the input <A title="XDM instance" 
href="REC-xquery-20070123.htm#dt-data-model-instance">XDM 
instance</A>, the <A title="static context" 
href="REC-xquery-20070123.htm#dt-static-context">static 
context</A>, and the <A title="dynamic context" 
href="REC-xquery-20070123.htm#dt-dynamic-context">dynamic 
context</A> must be mutually consistent. The consistency constraints listed 
below are prerequisites for correct functioning of an XQuery implementation. 
Enforcement of these consistency constraints is beyond the scope of this 
specification. This specification does not define the result of <SPAN 
class=xquery><SPAN class=xquery>a query</SPAN></SPAN> under any condition in 
which one or more of these constraints is not satisfied.</P>
<P>Some of the consistency constraints use the term <B>data model schema</B>. 
[<A id=dt-data-model-schema title="data model schema" 
name=dt-data-model-schema>Definition</A>: For a given node in an <A 
title="XDM instance" 
href="REC-xquery-20070123.htm#dt-data-model-instance">XDM 
instance</A>, the <B>data model schema</B> is defined as the schema from which 
the <A title="type annotation" 
href="REC-xquery-20070123.htm#dt-type-annotation">type 
annotation</A> of that node was derived.] For a node that was constructed by 
some process other than schema validation, the <B>data model schema</B> consists 
simply of the schema type definition that is represented by the <A 
title="type annotation" 
href="REC-xquery-20070123.htm#dt-type-annotation">type 
annotation</A> of the node.</P>
<UL>
  <LI>
  <P>For every node that has a type annotation, if that type annotation is found 
  in the <A title="in-scope schema definitions" 
  href="REC-xquery-20070123.htm#dt-issd">in-scope schema 
  definitions</A> (ISSD), then its definition in the ISSD must be equivalent to 
  its definition in the <A title="data model schema" 
  href="REC-xquery-20070123.htm#dt-data-model-schema">data 
  model schema</A>. Furthermore, all types that are derived by extension from 
  the given type in the <A title="data model schema" 
  href="REC-xquery-20070123.htm#dt-data-model-schema">data 
  model schema</A> must also be known by equivalent definitions in the ISSD.</P>
  <LI>
  <P>For every element name <EM>EN</EM> that is found both in an <A 
  title="XDM instance" 
  href="REC-xquery-20070123.htm#dt-data-model-instance">XDM 
  instance</A> and in the <A title="in-scope schema definitions" 
  href="REC-xquery-20070123.htm#dt-issd">in-scope schema 
  definitions</A> (ISSD), all elements that are known in the <A 
  title="data model schema" 
  href="REC-xquery-20070123.htm#dt-data-model-schema">data 
  model schema</A> to be in the <A title="substitution group" 
  href="REC-xquery-20070123.htm#dt-substitution-group">substitution 
  group</A> headed by <EM>EN</EM> must also be known in the ISSD to be in the <A 
  title="substitution group" 
  href="REC-xquery-20070123.htm#dt-substitution-group">substitution 
  group</A> headed by <EM>EN</EM>.</P>
  <LI>
  <P>Every element name, attribute name, or schema type name referenced in <A 
  title="in-scope variables" 
  href="REC-xquery-20070123.htm#dt-in-scope-variables">in-scope 
  variables</A> or <A title="function signature" 
  href="REC-xquery-20070123.htm#dt-function-signature">function 
  signatures</A> must be in the <A title="in-scope schema definitions" 
  href="REC-xquery-20070123.htm#dt-issd">in-scope schema 
  definitions</A>, unless it is an element name referenced as part of an <A 
  href="REC-xquery-20070123.htm#doc-xquery-ElementTest">ElementTest</A> 
  or an attribute name referenced as part of an <A 
  href="REC-xquery-20070123.htm#doc-xquery-AttributeTest">AttributeTest</A>.</P>
  <LI>
  <P>Any reference to a global element, attribute, or type name in the <A 
  title="in-scope schema definitions" 
  href="REC-xquery-20070123.htm#dt-issd">in-scope schema 
  definitions</A> must have a corresponding element, attribute or type 
  definition in the <A title="in-scope schema definitions" 
  href="REC-xquery-20070123.htm#dt-issd">in-scope schema 
  definitions</A>.</P>
  <LI>
  <P>For each mapping of a string to a document node in <A 
  title="available documents" 
  href="REC-xquery-20070123.htm#dt-available-docs">available 
  documents</A>, if there exists a mapping of the same string to a document type 
  in <A title="statically known documents" 
  href="REC-xquery-20070123.htm#dt-known-docs">statically 
  known documents</A>, the document node must match the document type, using the 
  matching rules in <A 
  href="REC-xquery-20070123.htm#id-sequencetype-matching"><B>2.5.4 
  SequenceType Matching</B></A>.</P>
  <LI>
  <P>For each mapping of a string to a sequence of nodes in <A 
  title="available collections" 
  href="REC-xquery-20070123.htm#dt-available-collections">available 
  collections</A>, if there exists a mapping of the same string to a type in <A 
  title="statically known collections" 
  href="REC-xquery-20070123.htm#dt-known-collections">statically 
  known collections</A>, the sequence of nodes must match the type, using the 
  matching rules in <A 
  href="REC-xquery-20070123.htm#id-sequencetype-matching"><B>2.5.4 
  SequenceType Matching</B></A>.</P>
  <LI>
  <P>The sequence of nodes in the <A title="default collection" 
  href="REC-xquery-20070123.htm#dt-default-collection">default 
  collection</A> must match the <A 
  title="statically known default collection type" 
  href="REC-xquery-20070123.htm#dt-known-default-collection">statically 
  known default collection type</A>, using the matching rules in <A 
  href="REC-xquery-20070123.htm#id-sequencetype-matching"><B>2.5.4 
  SequenceType Matching</B></A>.</P>
  <LI>
  <P>The value of the <A title="context item" 
  href="REC-xquery-20070123.htm#dt-context-item">context 
  item</A> must match the <A title="context item static type" 
  href="REC-xquery-20070123.htm#dt-context-item-static-type">context 
  item static type</A>, using the matching rules in <A 
  href="REC-xquery-20070123.htm#id-sequencetype-matching"><B>2.5.4 
  SequenceType Matching</B></A>.</P>
  <LI>
  <P>For each (variable, type) pair in <A title="in-scope variables" 
  href="REC-xquery-20070123.htm#dt-in-scope-variables">in-scope 
  variables</A> and the corresponding (variable, value) pair in <A 
  title="variable values" 
  href="REC-xquery-20070123.htm#dt-variable-values">variable 
  values</A> such that the variable names are equal, the value must match the 
  type, using the matching rules in <A 
  href="REC-xquery-20070123.htm#id-sequencetype-matching"><B>2.5.4 
  SequenceType Matching</B></A>.</P>
  <LI class=xquery>
  <P>For each variable declared as <CODE>external</CODE>: If the variable 
  declaration includes a declared type, the external environment must provide a 
  value for the variable that matches the declared type, using the matching 
  rules in <A 
  href="REC-xquery-20070123.htm#id-sequencetype-matching"><B>2.5.4 
  SequenceType Matching</B></A>. If the variable declaration does not include a 
  declared type, the external environment must provide a type and a matching 
  value, using the same matching rules.</P>
  <LI class=xquery>
  <P>For each function declared as external: the <A 
  title="function implementation" 
  href="REC-xquery-20070123.htm#dt-function-implementation">function 
  implementation</A> must either return a value that matches the declared result 
  type, using the matching rules in <A 
  href="REC-xquery-20070123.htm#id-sequencetype-matching"><B>2.5.4 
  SequenceType Matching</B></A>, or raise an <A title="implementation defined" 
  href="REC-xquery-20070123.htm#dt-implementation-defined">implementation-defined</A> 
  error.</P>
  <LI class=xquery>
  <P>For a given query, define a <B>participating ISSD</B> as the <A 
  title="in-scope schema definitions" 
  href="REC-xquery-20070123.htm#dt-issd">in-scope schema 
  definitions</A> of a module that is used in evaluating the query. If two 
  participating ISSDs contain a definition for the same schema type, element 
  name, or attribute name, the definitions must be equivalent in both ISSDs. 
  Furthermore, if two participating ISSDs each contain a definition of a schema 
  type <EM>T</EM>, the set of types derived by extension from <EM>T</EM> must be 
  equivalent in both ISSDs. Also, if two participating ISSDs each contain a 
  definition of an element name <EM>E</EM>, the substitution group headed by 
  <EM>E</EM> must be equivalent in both ISSDs.</P>
  <LI>
  <P>In the <A title="statically known namespaces" 
  href="REC-xquery-20070123.htm#dt-static-namespaces">statically 
  known namespaces</A>, the prefix <CODE>xml</CODE> must not be bound to any 
  namespace URI other than <CODE>http://www.w3.org/XML/1998/namespace</CODE>, 
  and no prefix other than <CODE>xml</CODE> may be bound to this namespace 
  URI.</P></LI></UL></DIV></DIV>
<DIV class=div2>
<H3><A id=errors name=errors></A>2.3 Error Handling</H3>
<DIV class=div3>
<H4><A id=id-kinds-of-errors name=id-kinds-of-errors></A>2.3.1 Kinds of 
Errors</H4>
<P>As described in <A 
href="REC-xquery-20070123.htm#id-expression-processing"><B>2.2.3 
Expression Processing</B></A>, XQuery defines a <A title="static analysis phase" 
href="REC-xquery-20070123.htm#dt-static-analysis">static 
analysis phase</A>, which does not depend on input data, and a <A 
title="dynamic evaluation phase" 
href="REC-xquery-20070123.htm#dt-dynamic-evaluation">dynamic 
evaluation phase</A>, which does depend on input data. Errors may be raised 
during each phase.</P>
<P>[<A id=dt-static-error title="static error" 
name=dt-static-error>Definition</A>: A <B>static error</B> is an error that must 
be detected during the static analysis phase. A syntax error is an example of a 
<A title="static error" 
href="REC-xquery-20070123.htm#dt-static-error">static 
error</A>.]</P>
<P>[<A id=dt-dynamic-error title="dynamic error" 
name=dt-dynamic-error>Definition</A>: A <B>dynamic error</B> is an error that 
must be detected during the dynamic evaluation phase and may be detected during 
the static analysis phase. Numeric overflow is an example of a dynamic error. 
]</P>
<P>[<A id=dt-type-error title="type error" name=dt-type-error>Definition</A>: A 
<B>type error</B> may be raised during the static analysis phase or the dynamic 
evaluation phase. During the static analysis phase, a <A title="type error" 
href="REC-xquery-20070123.htm#dt-type-error">type 
error</A> occurs when the <A title="static type" 
href="REC-xquery-20070123.htm#dt-static-type">static 
type</A> of an expression does not match the expected type of the context in 
which the expression occurs. During the dynamic evaluation phase, a <A 
title="type error" 
href="REC-xquery-20070123.htm#dt-type-error">type 
error</A> occurs when the <A title="dynamic type" 
href="REC-xquery-20070123.htm#dt-dynamic-type">dynamic 
type</A> of a value does not match the expected type of the context in which the 
value occurs.]</P>
<P>The outcome of the <A title="static analysis phase" 
href="REC-xquery-20070123.htm#dt-static-analysis">static 
analysis phase</A> is either success or one or more <A title="type error" 
href="REC-xquery-20070123.htm#dt-type-error">type 
errors</A>, <A title="static error" 
href="REC-xquery-20070123.htm#dt-static-error">static 
errors</A>, or statically-detected <A title="dynamic error" 
href="REC-xquery-20070123.htm#dt-dynamic-error">dynamic 
errors</A>. The result of the <A title="dynamic evaluation phase" 
href="REC-xquery-20070123.htm#dt-dynamic-evaluation">dynamic 
evaluation phase</A> is either a result value, a <A title="type error" 
href="REC-xquery-20070123.htm#dt-type-error">type 
error</A>, or a <A title="dynamic error" 
href="REC-xquery-20070123.htm#dt-dynamic-error">dynamic 
error</A>.</P>
<P>If more than one error is present, or if an error condition comes within the 
scope of more than one error defined in this specification, then any non-empty 
subset of these errors may be reported.</P>
<P>During the <A title="static analysis phase" 
href="REC-xquery-20070123.htm#dt-static-analysis">static 
analysis phase</A>, if the <A title="static typing feature" 
href="REC-xquery-20070123.htm#dt-static-typing-feature">Static 
Typing Feature</A> is in effect and the <A title="static type" 
href="REC-xquery-20070123.htm#dt-static-type">static 
type</A> assigned to an expression other than <CODE>()</CODE> or 
<CODE>data(())</CODE> is <CODE>empty-sequence()</CODE>, a <A 
title="static error" 
href="REC-xquery-20070123.htm#dt-static-error">static 
error</A> is raised [<A title=err:XPST0005 
href="REC-xquery-20070123.htm#ERRXPST0005">err:XPST0005</A>]. 
This catches cases in which a query refers to an element or attribute that is 
not present in the <A title="in-scope schema definitions" 
href="REC-xquery-20070123.htm#dt-issd">in-scope schema 
definitions</A>, possibly because of a spelling error.</P>
<P>Independently of whether the <A title="static typing feature" 
href="REC-xquery-20070123.htm#dt-static-typing-feature">Static 
Typing Feature</A> is in effect, if an implementation can determine during the 
<A title="static analysis phase" 
href="REC-xquery-20070123.htm#dt-static-analysis">static 
analysis phase</A> that an expression, if evaluated, would necessarily raise a 
<A title="type error" 
href="REC-xquery-20070123.htm#dt-type-error">type 
error</A> or a <A title="dynamic error" 
href="REC-xquery-20070123.htm#dt-dynamic-error">dynamic 
error</A>, the implementation may (but is not required to) report that error 
during the <A title="static analysis phase" 
href="REC-xquery-20070123.htm#dt-static-analysis">static 
analysis phase</A>. However, the <CODE>fn:error()</CODE> function must not be 
evaluated during the <A title="static analysis phase" 
href="REC-xquery-20070123.htm#dt-static-analysis">static 
analysis phase</A>.</P>
<P>[<A id=dt-warning title=warning name=dt-warning>Definition</A>: In addition 
to <A title="static error" 
href="REC-xquery-20070123.htm#dt-static-error">static 
errors</A>, <A title="dynamic error" 
href="REC-xquery-20070123.htm#dt-dynamic-error">dynamic 
errors</A>, and <A title="type error" 
href="REC-xquery-20070123.htm#dt-type-error">type 
errors</A>, an XQuery implementation may raise <B>warnings</B>, either during 
the <A title="static analysis phase" 
href="REC-xquery-20070123.htm#dt-static-analysis">static 
analysis phase</A> or the <A title="dynamic evaluation phase" 
href="REC-xquery-20070123.htm#dt-dynamic-evaluation">dynamic 
evaluation phase</A>. The circumstances in which warnings are raised, and the 
ways in which warnings are handled, are <A title="implementation defined" 
href="REC-xquery-20070123.htm#dt-implementation-defined">implementation-defined</A>.]</P>
<P>In addition to the errors defined in this specification, an implementation 
may raise a <A title="dynamic error" 
href="REC-xquery-20070123.htm#dt-dynamic-error">dynamic 
error</A> for a reason beyond the scope of this specification. For example, 
limitations may exist on the maximum numbers or sizes of various objects. Any 
such limitations, and the consequences of exceeding them, are <A 
title="implementation dependent" 
href="REC-xquery-20070123.htm#dt-implementation-dependent">implementation-dependent</A>.</P></DIV>
<DIV class=div3>
<H4><A id=id-identifying-errors name=id-identifying-errors></A>2.3.2 Identifying 
and Reporting Errors</H4>
<P>The errors defined in this specification are identified by QNames that have 
the form <CODE>err:XXYYnnnn</CODE>, where:</P>
<UL>
  <LI>
  <P><CODE>err</CODE> denotes the namespace for XPath and XQuery errors, 
  <CODE>http://www.w3.org/2005/xqt-errors</CODE>. This binding of the namespace 
  prefix <CODE>err</CODE> is used for convenience in this document, and is not 
  normative.</P>
  <LI class=xquery>
  <P><CODE>XX</CODE> denotes the language in which the error is defined, using 
  the following encoding:</P>
  <UL>
    <LI>
    <P><CODE>XP</CODE> denotes an error defined by XPath. Such an error may also 
    occur XQuery since XQuery includes XPath as a subset.</P>
    <LI>
    <P><CODE>XQ</CODE> denotes an error defined by XQuery.</P></LI></UL>
  <LI>
  <P><CODE>YY</CODE> denotes the error category, using the following 
  encoding:</P>
  <UL>
    <LI>
    <P><CODE>ST</CODE> denotes a static error.</P>
    <LI>
    <P><CODE>DY</CODE> denotes a dynamic error.</P>
    <LI>
    <P><CODE>TY</CODE> denotes a type error.</P></LI></UL>
  <LI>
  <P><CODE>nnnn</CODE> is a unique numeric code.</P></LI></UL>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>The namespace URI for XPath and XQuery errors is not expected to change from 
one version of XQuery to another. However, the contents of this namespace may be 
extended to include additional error definitions.</P></DIV>
<P>The method by which an XQuery processor reports error information to the 
external environment is <A title="implementation defined" 
href="REC-xquery-20070123.htm#dt-implementation-defined">implementation-defined</A>.</P>
<P>An error can be represented by a URI reference that is derived from the error 
QName as follows: an error with namespace URI <EM><CODE>NS</CODE></EM> and local 
part <EM><CODE>LP</CODE></EM> can be represented as the URI reference 
<EM><CODE>NS</CODE></EM><CODE>#</CODE><EM><CODE>LP</CODE></EM>. For example, an 
error whose QName is <CODE>err:XPST0017</CODE> could be represented as 
<CODE>http://www.w3.org/2005/xqt-errors#XPST0017</CODE>.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>Along with a code identifying an error, implementations may wish to return 
additional information, such as the location of the error or the processing 
phase in which it was detected. If an implementation chooses to do so, then the 
mechanism that it uses to return this information is <A 
title="implementation defined" 
href="REC-xquery-20070123.htm#dt-implementation-defined">implementation-defined</A>.</P></DIV></DIV>
<DIV class=div3>
<H4><A id=id-handling-dynamic name=id-handling-dynamic></A>2.3.3 Handling 
Dynamic Errors</H4>
<P>Except as noted in this document, if any operand of an expression raises a <A 
title="dynamic error" 
href="REC-xquery-20070123.htm#dt-dynamic-error">dynamic 
error</A>, the expression also raises a <A title="dynamic error" 
href="REC-xquery-20070123.htm#dt-dynamic-error">dynamic 
error</A>. If an expression can validly return a value or raise a dynamic error, 
the implementation may choose to return the value or raise the dynamic error. 
For example, the logical expression <CODE>expr1 and expr2</CODE> may return the 
value <CODE>false</CODE> if either operand returns <CODE>false</CODE>, or may 
raise a dynamic error if either operand raises a dynamic error.</P>
<P>If more than one operand of an expression raises an error, the implementation 
may choose which error is raised by the expression. For example, in this 
expression:</P>
<DIV class=parse-test>
<DIV class=exampleInner><PRE>($x div $y) + xs:decimal($z)
</PRE></DIV></DIV>
<P>both the sub-expressions <CODE>($x div $y)</CODE> and 
<CODE>xs:decimal($z)</CODE> may raise an error. The implementation may choose 
which error is raised by the "<CODE>+</CODE>" expression. Once one operand 
raises an error, the implementation is not required, but is permitted, to 
evaluate any other operands.</P>
<P>[<A id=dt-error-value title="error value" name=dt-error-value>Definition</A>: 
In addition to its identifying QName, a dynamic error may also carry a 
descriptive string and one or more additional values called <B>error 
values</B>.] An implementation may provide a mechanism whereby an 
application-defined error handler can process error values and produce 
diagnostic messages.</P>
<P>A dynamic error may be raised by a <A title="built-in function" 
href="REC-xquery-20070123.htm#dt-built-in-function">built-in 
function</A> or operator. For example, the <CODE>div</CODE> operator raises an 
error if its operands are <CODE>xs:decimal</CODE> values and its second operand 
is equal to zero. Errors raised by built-in functions and operators are defined 
in <A 
href="REC-xquery-20070123.htm#FunctionsAndOperators">[XQuery 
1.0 and XPath 2.0 Functions and Operators]</A>.</P>
<P>A dynamic error can also be raised explicitly by calling the 
<CODE>fn:error</CODE> function, which only raises an error and never returns a 
value. This function is defined in <A 
href="REC-xquery-20070123.htm#FunctionsAndOperators">[XQuery 
1.0 and XPath 2.0 Functions and Operators]</A>. For example, the following 
function call raises a dynamic error, providing a QName that identifies the 
error, a descriptive string, and a diagnostic value (assuming that the prefix 
<CODE>app</CODE> is bound to a namespace containing application-defined error 
codes):</P>
<DIV class=parse-test>
<DIV class=exampleInner><PRE>fn:error(xs:QName("app:err057"), "Unexpected value", fn:string($v))
</PRE></DIV></DIV></DIV>
<DIV class=div3>
<H4><A id=id-errors-and-opt name=id-errors-and-opt></A>2.3.4 Errors and 
Optimization</H4>
<P>Because different implementations may choose to evaluate or optimize an 
expression in different ways, certain aspects of the detection and reporting of 
<A title="dynamic error" 
href="REC-xquery-20070123.htm#dt-dynamic-error">dynamic 
errors</A> are <A title="implementation dependent" 
href="REC-xquery-20070123.htm#dt-implementation-dependent">implementation-dependent</A>, 
as described in this section.</P>
<P>An implementation is always free to evaluate the operands of an operator in 
any order.</P>
<P>In some cases, a processor can determine the result of an expression without 
accessing all the data that would be implied by the formal expression semantics. 
For example, the formal description of <A title="filter expression" 
href="REC-xquery-20070123.htm#dt-filter-expression">filter 
expressions</A> suggests that <CODE>$s[1]</CODE> should be evaluated by 
examining all the items in sequence <CODE>$s</CODE>, and selecting all those 
that satisfy the predicate <CODE>position()=1</CODE>. In practice, many 
implementations will recognize that they can evaluate this expression by taking 
the first item in the sequence and then exiting. If <CODE>$s</CODE> is defined 
by an expression such as <CODE>//book[author eq 'Berners-Lee']</CODE>, then this 
strategy may avoid a complete scan of a large document and may therefore greatly 
improve performance. However, a consequence of this strategy is that a dynamic 
error or type error that would be detected if the expression semantics were 
followed literally might not be detected at all if the evaluation exits early. 
In this example, such an error might occur if there is a <CODE>book</CODE> 
element in the input data with more than one <CODE>author</CODE> subelement.</P>
<P>The extent to which a processor may optimize its access to data, at the cost 
of not detecting errors, is defined by the following rules.</P>
<P>Consider an expression <EM>Q</EM> that has an operand (sub-expression) 
<EM>E</EM>. In general the value of <EM>E</EM> is a sequence. At an intermediate 
stage during evaluation of the sequence, some of its items will be known and 
others will be unknown. If, at such an intermediate stage of evaluation, a 
processor is able to establish that there are only two possible outcomes of 
evaluating <EM>Q</EM>, namely the value <EM>V</EM> or an error, then the 
processor may deliver the result <EM>V</EM> without evaluating further items in 
the operand <EM>E</EM>. For this purpose, two values are considered to represent 
the same outcome if their items are pairwise the same, where nodes are the same 
if they have the same identity, and values are the same if they are equal and 
have exactly the same type.</P>
<P>There is an exception to this rule: If a processor evaluates an operand 
<EM>E</EM> (wholly or in part), then it is required to establish that the actual 
value of the operand <EM>E</EM> does not violate any constraints on its 
cardinality. For example, the expression <CODE>$e eq 0</CODE> results in a type 
error if the value of <CODE>$e</CODE> contains two or more items. A processor is 
not allowed to decide, after evaluating the first item in the value of 
<CODE>$e</CODE> and finding it equal to zero, that the only possible outcomes 
are the value <CODE>true</CODE> or a type error caused by the cardinality 
violation. It must establish that the value of <CODE>$e</CODE> contains no more 
than one item.</P>
<P>These rules apply to all the operands of an expression considered in 
combination: thus if an expression has two operands <EM>E1</EM> and <EM>E2</EM>, 
it may be evaluated using any samples of the respective sequences that satisfy 
the above rules.</P>
<P>The rules cascade: if <EM>A</EM> is an operand of <EM>B</EM> and <EM>B</EM> 
is an operand of <EM>C</EM>, then the processor needs to evaluate only a 
sufficient sample of <EM>B</EM> to determine the value of <EM>C</EM>, and needs 
to evaluate only a sufficient sample of <EM>A</EM> to determine this sample of 
<EM>B</EM>.</P>
<P>The effect of these rules is that the processor is free to stop examining 
further items in a sequence as soon as it can establish that further items would 
not affect the result except possibly by causing an error. For example, the 
processor may return <CODE>true</CODE> as the result of the expression <CODE>S1 
= S2</CODE> as soon as it finds a pair of equal values from the two 
sequences.</P>
<P>Another consequence of these rules is that where none of the items in a 
sequence contributes to the result of an expression, the processor is not 
obliged to evaluate any part of the sequence. Again, however, the processor 
cannot dispense with a required cardinality check: if an empty sequence is not 
permitted in the relevant context, then the processor must ensure that the 
operand is not an empty sequence.</P>
<P>Examples:</P>
<UL>
  <LI>
  <P>If an implementation can find (for example, by using an index) that at 
  least one item returned by <CODE>$expr1</CODE> in the following example has 
  the value <CODE>47</CODE>, it is allowed to return <CODE>true</CODE> as the 
  result of the <CODE>some</CODE> expression, without searching for another item 
  returned by <CODE>$expr1</CODE> that would raise an error if it were 
  evaluated.</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>some $x in $expr1 satisfies $x = 47
</PRE></DIV></DIV>
  <LI>
  <P>In the following example, if an implementation can find (for example, by 
  using an index) the <CODE>product</CODE> element-nodes that have an 
  <CODE>id</CODE> child with the value <CODE>47</CODE>, it is allowed to return 
  these nodes as the result of the <A title="path expression" 
  href="REC-xquery-20070123.htm#dt-path-expression">path 
  expression</A>, without searching for another <CODE>product</CODE> node that 
  would raise an error because it has an <CODE>id</CODE> child whose value is 
  not an integer.</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>//product[id = 47]
</PRE></DIV></DIV></LI></UL>
<P>For a variety of reasons, including optimization, implementations are free to 
rewrite expressions into equivalent expressions. Other than the raising or not 
raising of errors, the result of evaluating an equivalent expression must be the 
same as the result of evaluating the original expression. Expression rewrite is 
illustrated by the following examples.</P>
<UL>
  <LI>
  <P>Consider the expression <CODE>//part[color eq "Red"]</CODE>. An 
  implementation might choose to rewrite this expression as <CODE>//part[color = 
  "Red"][color eq "Red"]</CODE>. The implementation might then process the 
  expression as follows: First process the "<CODE>=</CODE>" predicate by probing 
  an index on parts by color to quickly find all the parts that have a Red 
  color; then process the "<CODE>eq</CODE>" predicate by checking each of these 
  parts to make sure it has only a single color. The result would be as 
  follows:</P>
  <UL>
    <LI>
    <P>Parts that have exactly one color that is Red are returned.</P>
    <LI>
    <P>If some part has color Red together with some other color, an error is 
    raised.</P>
    <LI>
    <P>The existence of some part that has no color Red but has multiple non-Red 
    colors does not trigger an error.</P></LI></UL>
  <LI>
  <P>The expression in the following example cannot raise a casting error if it 
  is evaluated exactly as written (i.e., left to right). Since neither predicate 
  depends on the context position, an implementation might choose to reorder the 
  predicates to achieve better performance (for example, by taking advantage of 
  an index). This reordering could cause the expression to raise an error.</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>$N[@x castable as xs:date][xs:date(@x) gt xs:date("2000-01-01")]
</PRE></DIV></DIV>
  <P>To avoid unexpected errors caused by expression rewrite, tests that are 
  designed to prevent dynamic errors should be expressed using conditional <SPAN 
  class=xquery><SPAN class=xquery>or <CODE>typeswitch</CODE></SPAN></SPAN> 
  expressions. Conditional <SPAN class=xquery><SPAN class=xquery>and 
  <CODE>typeswitch</CODE></SPAN></SPAN> expressions raise only dynamic errors 
  that occur in the branch that is actually selected. Thus, unlike the previous 
  example, the following example cannot raise a dynamic error if <CODE>@x</CODE> 
  is not castable into an <CODE>xs:date</CODE>:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>$N[if (@x castable as xs:date)
   then xs:date(@x) gt xs:date("2000-01-01")
   else false()]
</PRE></DIV></DIV></LI></UL></DIV></DIV>
<DIV class=div2>
<H3><A id=id-important-concepts name=id-important-concepts></A>2.4 Concepts</H3>
<P>This section explains some concepts that are important to the processing of 
XQuery expressions.</P>
<DIV class=div3>
<H4><A id=id-document-order name=id-document-order></A>2.4.1 Document Order</H4>
<P>An ordering called <B>document order</B> is defined among all the nodes 
accessible during processing of a given <SPAN class=xquery><SPAN 
class=xquery>query</SPAN></SPAN>, which may consist of one or more <B>trees</B> 
(documents or fragments). Document order is defined in <A 
href="REC-xquery-20070123.htm#datamodel">[XQuery/XPath 
Data Model (XDM)]</A>, and its definition is repeated here for convenience. [<A 
id=dt-reverse-document-order title="reverse document order" 
name=dt-reverse-document-order>Definition</A>: The node ordering that is the 
reverse of document order is called <B>reverse document order</B>.]</P>
<P>Document order is a total ordering, although the relative order of some nodes 
is <A title="implementation dependent" 
href="REC-xquery-20070123.htm#dt-implementation-dependent">implementation-dependent</A>. 
[<A id=dt-document-order title="document order" 
name=dt-document-order>Definition</A>: Informally, <B>document order</B> is the 
order in which nodes appear in the XML serialization of a document.] [<A 
id=stable title=stable name=stable>Definition</A>: Document order is 
<B>stable</B>, which means that the relative order of two nodes will not change 
during the processing of a given <SPAN class=xquery><SPAN 
class=xquery>query</SPAN></SPAN>, even if this order is <A 
title="implementation dependent" 
href="REC-xquery-20070123.htm#dt-implementation-dependent">implementation-dependent</A>.]</P>
<P>Within a tree, document order satisfies the following constraints:</P>
<OL class=enumar>
  <LI>
  <P>The root node is the first node.</P>
  <LI>
  <P>Every node occurs before all of its children and descendants.</P>
  <LI>
  <P>Attribute nodes immediately follow the element node with which they are 
  associated. The relative order of attribute nodes is stable but <A 
  title="implementation dependent" 
  href="REC-xquery-20070123.htm#dt-implementation-dependent">implementation-dependent</A>.</P>
  <LI>
  <P>The relative order of siblings is the order in which they occur in the 
  <CODE>children</CODE> property of their parent node.</P>
  <LI>
  <P>Children and descendants occur before following siblings.</P></LI></OL>
<P>The relative order of nodes in distinct trees is stable but <A 
title="implementation dependent" 
href="REC-xquery-20070123.htm#dt-implementation-dependent">implementation-dependent</A>, 
subject to the following constraint: If any node in a given tree T1 is before 
any node in a different tree T2, then all nodes in tree T1 are before all nodes 
in tree T2.</P></DIV>
<DIV class=div3>
<H4><A id=id-atomization name=id-atomization></A>2.4.2 Atomization</H4>
<P>The semantics of some XQuery operators depend on a process called <A 
title=atomization 
href="REC-xquery-20070123.htm#dt-atomization">atomization</A>. 
Atomization is applied to a value when the value is used in a context in which a 
sequence of atomic values is required. The result of atomization is either a 
sequence of atomic values or a <A title="type error" 
href="REC-xquery-20070123.htm#dt-type-error">type 
error</A> [err:FOTY0012]. [<A id=dt-atomization title=atomization 
name=dt-atomization>Definition</A>: <B>Atomization</B> of a sequence is defined 
as the result of invoking the <CODE>fn:data</CODE> function on the sequence, as 
defined in <A 
href="REC-xquery-20070123.htm#FunctionsAndOperators">[XQuery 
1.0 and XPath 2.0 Functions and Operators]</A>.]</P>
<P>The semantics of <CODE>fn:data</CODE> are repeated here for convenience. The 
result of <CODE>fn:data</CODE> is the sequence of atomic values produced by 
applying the following rules to each item in the input sequence:</P>
<UL>
  <LI>
  <P>If the item is an atomic value, it is returned.</P>
  <LI>
  <P>If the item is a node, its <A title="typed value" 
  href="REC-xquery-20070123.htm#dt-typed-value">typed 
  value</A> is returned (err:FOTY0012 is raised if the node has no typed 
  value.)</P></LI></UL>
<P>Atomization is used in processing the following types of expressions:</P>
<UL>
  <LI>
  <P>Arithmetic expressions</P>
  <LI>
  <P>Comparison expressions</P>
  <LI>
  <P>Function calls and returns</P>
  <LI>
  <P>Cast expressions</P>
  <LI class=xquery>
  <P>Constructor expressions for various kinds of nodes</P>
  <LI class=xquery>
  <P><CODE>order by</CODE> clauses in FLWOR expressions</P></LI></UL></DIV>
<DIV class=div3>
<H4><A id=id-ebv name=id-ebv></A>2.4.3 Effective Boolean Value</H4>
<P>Under certain circumstances (listed below), it is necessary to find the <A 
title="effective boolean value" 
href="REC-xquery-20070123.htm#dt-ebv">effective boolean 
value</A> of a value. [<A id=dt-ebv title="effective boolean value" 
name=dt-ebv>Definition</A>: The <B>effective boolean value</B> of a value is 
defined as the result of applying the <CODE>fn:boolean</CODE> function to the 
value, as defined in <A 
href="REC-xquery-20070123.htm#FunctionsAndOperators">[XQuery 
1.0 and XPath 2.0 Functions and Operators]</A>.]</P>
<P>The dynamic semantics of <CODE>fn:boolean</CODE> are repeated here for 
convenience:</P>
<OL class=enumar>
  <LI>
  <P>If its operand is an empty sequence, <CODE>fn:boolean</CODE> returns 
  <CODE>false</CODE>.</P>
  <LI>
  <P>If its operand is a sequence whose first item is a node, 
  <CODE>fn:boolean</CODE> returns <CODE>true</CODE>.</P>
  <LI>
  <P>If its operand is a <A title=singleton 
  href="REC-xquery-20070123.htm#dt-singleton">singleton</A> 
  value of type <CODE>xs:boolean</CODE> or derived from <CODE>xs:boolean</CODE>, 
  <CODE>fn:boolean</CODE> returns the value of its operand unchanged.</P>
  <LI>
  <P>If its operand is a <A title=singleton 
  href="REC-xquery-20070123.htm#dt-singleton">singleton</A> 
  value of type <CODE>xs:string</CODE>, <CODE>xs:anyURI</CODE>, 
  <CODE>xs:untypedAtomic</CODE>, or a type derived from one of these, 
  <CODE>fn:boolean</CODE> returns <CODE>false</CODE> if the operand value has 
  zero length; otherwise it returns <CODE>true</CODE>.</P>
  <LI>
  <P>If its operand is a <A title=singleton 
  href="REC-xquery-20070123.htm#dt-singleton">singleton</A> 
  value of any <A title=numeric 
  href="REC-xquery-20070123.htm#dt-numeric">numeric</A> 
  type or derived from a numeric type, <CODE>fn:boolean</CODE> returns 
  <CODE>false</CODE> if the operand value is <CODE>NaN</CODE> or is numerically 
  equal to zero; otherwise it returns <CODE>true</CODE>.</P>
  <LI>
  <P>In all other cases, <CODE>fn:boolean</CODE> raises a type error 
  [err:FORG0006].</P></LI></OL>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>The static semantics of <CODE>fn:boolean</CODE> are defined in <A 
href="http://www.w3.org/TR/xquery-semantics/#sec_fn_boolean">Section 7.2.4 The 
fn:boolean function</A><SUP><SMALL>FS</SMALL></SUP>.</P></DIV>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>The <A title="effective boolean value" 
href="REC-xquery-20070123.htm#dt-ebv">effective boolean 
value</A> of a sequence that contains at least one node and at least one atomic 
value may be nondeterministic in regions of a query where <A 
title="ordering mode" 
href="REC-xquery-20070123.htm#dt-ordering-mode">ordering 
mode</A> is <CODE>unordered</CODE>.</P></DIV>
<P>The <A title="effective boolean value" 
href="REC-xquery-20070123.htm#dt-ebv">effective boolean 
value</A> of a sequence is computed implicitly during processing of the 
following types of expressions:</P>
<UL>
  <LI>
  <P>Logical expressions (<CODE>and</CODE>, <CODE>or</CODE>)</P>
  <LI>
  <P>The <CODE>fn:not</CODE> function</P>
  <LI class=xquery>
  <P>The <CODE>where</CODE> clause of a FLWOR expression</P>
  <LI>
  <P>Certain types of <A title=predicate 
  href="REC-xquery-20070123.htm#dt-predicate">predicates</A>, 
  such as <CODE>a[b]</CODE></P>
  <LI>
  <P>Conditional expressions (<CODE>if</CODE>)</P>
  <LI>
  <P>Quantified expressions (<CODE>some</CODE>, <CODE>every</CODE>)</P></LI></UL>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>The definition of <A title="effective boolean value" 
href="REC-xquery-20070123.htm#dt-ebv">effective boolean 
value</A> is <EM>not</EM> used when casting a value to the type 
<CODE>xs:boolean</CODE>, for example in a <CODE>cast</CODE> expression or when 
passing a value to a function whose expected parameter is of type 
<CODE>xs:boolean</CODE>.</P></DIV></DIV>
<DIV class=div3>
<H4><A id=id-input-sources name=id-input-sources></A>2.4.4 Input Sources</H4>
<P>XQuery has a set of functions that provide access to input data. These 
functions are of particular importance because they provide a way in which an 
expression can reference a document or a collection of documents. The input 
functions are described informally here; they are defined in <A 
href="REC-xquery-20070123.htm#FunctionsAndOperators">[XQuery 
1.0 and XPath 2.0 Functions and Operators]</A>.</P>
<P>An expression can access input data either by calling one of the input 
functions or by referencing some part of the <A title="dynamic context" 
href="REC-xquery-20070123.htm#dt-dynamic-context">dynamic 
context</A> that is initialized by the external environment, such as a <A 
title="variable values" 
href="REC-xquery-20070123.htm#dt-variable-values">variable</A> 
or <A title="context item" 
href="REC-xquery-20070123.htm#dt-context-item">context 
item</A>.</P>
<P>The input functions supported by XQuery are as follows:</P>
<UL>
  <LI>
  <P>The <CODE>fn:doc</CODE> function takes a string containing a URI. If that 
  URI is associated with a document in <A title="available documents" 
  href="REC-xquery-20070123.htm#dt-available-docs">available 
  documents</A>, <CODE>fn:doc</CODE> returns a document node whose content is 
  the <A title="data model" 
  href="REC-xquery-20070123.htm#dt-datamodel">data 
  model</A> representation of the given document; otherwise it raises a <A 
  title="dynamic error" 
  href="REC-xquery-20070123.htm#dt-dynamic-error">dynamic 
  error</A> (see <A 
  href="REC-xquery-20070123.htm#FunctionsAndOperators">[XQuery 
  1.0 and XPath 2.0 Functions and Operators]</A> for details).</P>
  <LI>
  <P>The <CODE>fn:collection</CODE> function with one argument takes a string 
  containing a URI. If that URI is associated with a collection in <A 
  title="available collections" 
  href="REC-xquery-20070123.htm#dt-available-collections">available 
  collections</A>, <CODE>fn:collection</CODE> returns the data model 
  representation of that collection; otherwise it raises a <A 
  title="dynamic error" 
  href="REC-xquery-20070123.htm#dt-dynamic-error">dynamic 
  error</A> (see <A 
  href="REC-xquery-20070123.htm#FunctionsAndOperators">[XQuery 
  1.0 and XPath 2.0 Functions and Operators]</A> for details). A collection may 
  be any sequence of nodes. For example, the expression 
  <CODE>fn:collection("http://example.org")//customer</CODE> identifies all the 
  <CODE>customer</CODE> elements that are descendants of nodes found in the 
  collection whose URI is <CODE>http://example.org</CODE>.</P>
  <LI>
  <P>The <CODE>fn:collection</CODE> function with zero arguments returns the <A 
  title="default collection" 
  href="REC-xquery-20070123.htm#dt-default-collection">default 
  collection</A>, an <A title="implementation dependent" 
  href="REC-xquery-20070123.htm#dt-implementation-dependent">implementation-dependent</A> 
  sequence of nodes.</P></LI></UL></DIV>
<DIV class=xquery>
<DIV class=div3>
<H4><A id=id-uri-literals name=id-uri-literals></A>2.4.5 URI Literals</H4>
<P>In certain places in the XQuery grammar, a statically known valid URI is 
required. These places are denoted by the grammatical symbol <A 
href="REC-xquery-20070123.htm#doc-xquery-URILiteral">URILiteral</A>. 
For example, URILiterals are used to specify namespaces and collations, both of 
which must be statically known.</P>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-URILiteral 
      name=doc-xquery-URILiteral></A>[140]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-URILiteral">URILiteral</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-StringLiteral">StringLiteral</A></CODE></TD></TR></TBODY></TABLE>
<P>Syntactically, a URILiteral is identical to a <A 
href="REC-xquery-20070123.htm#doc-xquery-StringLiteral">StringLiteral</A>: 
a sequence of zero or more characters enclosed in single or double quotes. 
However, an implementation <A title=may 
href="REC-xquery-20070123.htm#may">MAY</A> raise a <A 
title="static error" 
href="REC-xquery-20070123.htm#dt-static-error">static 
error</A> [<A title=err:XQST0046 
href="REC-xquery-20070123.htm#ERRXQST0046">err:XQST0046</A>] 
if the value of a URILiteral is of nonzero length and is not in the lexical 
space of <CODE>xs:anyURI</CODE>.</P>
<P>As in a string literal, any <A title="predefined entity reference" 
href="REC-xquery-20070123.htm#dt-predefined-entity-reference">predefined 
entity reference</A> (such as <CODE>&amp;amp;</CODE>), <A 
title="character reference" 
href="REC-xquery-20070123.htm#dt-character-reference">character 
reference</A> (such as <CODE>&amp;#x2022;</CODE>), or <A 
href="REC-xquery-20070123.htm#doc-xquery-EscapeQuot">EscapeQuot</A> 
or <A 
href="REC-xquery-20070123.htm#doc-xquery-EscapeApos">EscapeApos</A> 
(for example, <CODE>""</CODE>) is replaced by its appropriate expansion. Certain 
characters, notably the ampersand, can only be represented using a <A 
title="predefined entity reference" 
href="REC-xquery-20070123.htm#dt-predefined-entity-reference">predefined 
entity reference</A> or a <A title="character reference" 
href="REC-xquery-20070123.htm#dt-character-reference">character 
reference</A>.</P>
<P>The URILiteral is subjected to whitespace normalization as defined for the 
<CODE>xs:anyURI</CODE> type in <A 
href="REC-xquery-20070123.htm#XMLSchema">[XML 
Schema]</A>: this means that leading and trailing whitespace is removed, and any 
other sequence of whitespace characters is replaced by a single space (#x20) 
character. Whitespace normalization is done after the expansion of <A 
title="character reference" 
href="REC-xquery-20070123.htm#dt-character-reference">character 
references</A>, so writing a newline (for example) as <CODE>&amp;#xA;</CODE> 
does not prevent its being normalized to a space character.</P>
<P>The URILiteral is not automatically subjected to percent-encoding or decoding 
as defined in <A 
href="REC-xquery-20070123.htm#RFC3986">[RFC3986]</A>. Any 
process that attempts to resolve the URI against a base URI, or to dereference 
the URI, may however apply percent-encoding or decoding as defined in the 
relevant RFCs.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>The <CODE>xs:anyURI</CODE> type is designed to anticipate the introduction of 
Internationalized Resource Identifiers (IRI's) as defined in <A 
href="REC-xquery-20070123.htm#RFC3987">[RFC3987]</A>.</P></DIV>
<P>The following is an example of a valid URILiteral:</P>
<DIV class=exampleInner><PRE>"http://www.w3.org/2005/xpath-functions/collation/codepoint"
</PRE></DIV></DIV></DIV></DIV>
<DIV class=div2>
<H3><A id=id-types name=id-types></A>2.5 Types</H3>
<P>The type system of XQuery is based on <A 
href="REC-xquery-20070123.htm#XMLSchema">[XML 
Schema]</A>, and is formally defined in <A 
href="REC-xquery-20070123.htm#XQueryFormalSemantics">[XQuery 
1.0 and XPath 2.0 Formal Semantics]</A>.</P>
<P>[<A id=dt-sequence-type title="sequence type" 
name=dt-sequence-type>Definition</A>: A <B>sequence type</B> is a type that can 
be expressed using the <A 
href="REC-xquery-20070123.htm#doc-xquery-SequenceType">SequenceType</A> 
syntax. Sequence types are used whenever it is necessary to refer to a type in 
an XQuery expression. The term <B>sequence type</B> suggests that this syntax is 
used to describe the type of an XQuery value, which is always a sequence.]</P>
<P>[<A id=dt-schema-type title="schema type" name=dt-schema-type>Definition</A>: 
A <B>schema type</B> is a type that is (or could be) defined using the 
facilities of <A 
href="REC-xquery-20070123.htm#XMLSchema">[XML Schema]</A> 
(including the built-in types of <A 
href="REC-xquery-20070123.htm#XMLSchema">[XML 
Schema]</A>).] A schema type can be used as a type annotation on an element or 
attribute node (unless it is a non-instantiable type such as 
<CODE>xs:NOTATION</CODE> or <CODE>xs:anyAtomicType</CODE>, in which case its 
derived types can be so used). Every schema type is either a <B>complex type</B> 
or a <B>simple type</B>; simple types are further subdivided into <B>list 
types</B>, <B>union types</B>, and <B>atomic types</B> (see <A 
href="REC-xquery-20070123.htm#XMLSchema">[XML Schema]</A> 
for definitions and explanations of these terms.)</P>
<P>Atomic types represent the intersection between the categories of <A 
title="sequence type" 
href="REC-xquery-20070123.htm#dt-sequence-type">sequence 
type</A> and <A title="schema type" 
href="REC-xquery-20070123.htm#dt-schema-type">schema 
type</A>. An atomic type, such as <CODE>xs:integer</CODE> or 
<CODE>my:hatsize</CODE>, is both a <A title="sequence type" 
href="REC-xquery-20070123.htm#dt-sequence-type">sequence 
type</A> and a <A title="schema type" 
href="REC-xquery-20070123.htm#dt-schema-type">schema 
type</A>.</P>
<DIV class=div3>
<H4><A id=id-predefined-types name=id-predefined-types></A>2.5.1 Predefined 
Schema Types</H4>
<DIV class=xquery>
<P class=xquery>The <A title="in-scope schema type" 
href="REC-xquery-20070123.htm#dt-is-types">in-scope 
schema types</A> in the <A title="static context" 
href="REC-xquery-20070123.htm#dt-static-context">static 
context</A> are initialized with certain predefined schema types, including the 
built-in schema types in the namespace 
<CODE>http://www.w3.org/2001/XMLSchema</CODE>, which has the predefined 
namespace prefix <CODE>xs</CODE>. The schema types in this namespace are defined 
in <A href="REC-xquery-20070123.htm#XMLSchema">[XML 
Schema]</A> and augmented by additional types defined in <A 
href="REC-xquery-20070123.htm#datamodel">[XQuery/XPath 
Data Model (XDM)]</A>. Element and attribute declarations in the <CODE>xs</CODE> 
namespace are not implicitly included in the static context. The schema types 
defined in <A 
href="REC-xquery-20070123.htm#datamodel">[XQuery/XPath 
Data Model (XDM)]</A> are summarized below.</P></DIV>
<OL class=enumar>
  <LI>
  <P>[<A id=dt-untyped title=xs:untyped name=dt-untyped>Definition</A>: 
  <CODE>xs:untyped</CODE> is used as the <A title="type annotation" 
  href="REC-xquery-20070123.htm#dt-type-annotation">type 
  annotation</A> of an element node that has not been validated, or has been 
  validated in <CODE>skip</CODE> mode.] No predefined schema types are derived 
  from <CODE>xs:untyped</CODE>.</P>
  <LI>
  <P>[<A id=dt-untypedAtomic title=xs:untypedAtomic 
  name=dt-untypedAtomic>Definition</A>: <CODE>xs:untypedAtomic</CODE> is an 
  atomic type that is used to denote untyped atomic data, such as text that has 
  not been assigned a more specific type.] An attribute that has been validated 
  in <CODE>skip</CODE> mode is represented in the <A title="data model" 
  href="REC-xquery-20070123.htm#dt-datamodel">data 
  model</A> by an attribute node with the <A title="type annotation" 
  href="REC-xquery-20070123.htm#dt-type-annotation">type 
  annotation</A> <CODE>xs:untypedAtomic</CODE>. No predefined schema types are 
  derived from <CODE>xs:untypedAtomic</CODE>.</P>
  <LI>
  <P>[<A id=dt-dayTimeDuration title=xs:dayTimeDuration 
  name=dt-dayTimeDuration>Definition</A>: <CODE>xs:dayTimeDuration</CODE> is 
  derived by restriction from <CODE>xs:duration</CODE>. The lexical 
  representation of <CODE>xs:dayTimeDuration</CODE> is restricted to contain 
  only day, hour, minute, and second components.]</P>
  <LI>
  <P>[<A id=dt-yearMonthDuration title=xs:yearMonthDuration 
  name=dt-yearMonthDuration>Definition</A>: <CODE>xs:yearMonthDuration</CODE> is 
  derived by restriction from <CODE>xs:duration</CODE>. The lexical 
  representation of <CODE>xs:yearMonthDuration</CODE> is restricted to contain 
  only year and month components.]</P>
  <LI>
  <P>[<A id=dt-anyAtomicType title=xs:anyAtomicType 
  name=dt-anyAtomicType>Definition</A>: <CODE>xs:anyAtomicType</CODE> is an 
  atomic type that includes all atomic values (and no values that are not 
  atomic). Its base type is <CODE>xs:anySimpleType</CODE> from which all simple 
  types, including atomic, list, and union types, are derived. All primitive 
  atomic types, such as <CODE>xs:integer</CODE>, <CODE>xs:string</CODE>, and 
  <CODE>xs:untypedAtomic</CODE>, have <CODE>xs:anyAtomicType</CODE> as their 
  base type.]</P>
  <DIV class=note>
  <P class=prefix><B>Note:</B></P>
  <P><CODE>xs:anyAtomicType</CODE> will not appear as the type of an actual 
  value in an <A title="XDM instance" 
  href="REC-xquery-20070123.htm#dt-data-model-instance">XDM 
  instance</A>.</P></DIV></LI></OL>
<P>The relationships among the schema types in the <CODE>xs</CODE> namespace are 
illustrated in Figure 2. A more complete description of the XQuery type 
hierarchy can be found in <A 
href="REC-xquery-20070123.htm#FunctionsAndOperators">[XQuery 
1.0 and XPath 2.0 Functions and Operators]</A>.</P><IMG 
alt="Type Hierarchy Diagram" src="REC-xquery-20070123_files/types.jpg"> 
<P>Figure 2: Hierarchy of Schema Types used in XQuery</P></DIV>
<DIV class=div3>
<H4><A id=id-typed-value name=id-typed-value></A>2.5.2 Typed Value and String 
Value</H4>
<P>Every node has a <B>typed value</B> and a <B>string value</B>. [<A 
id=dt-typed-value title="typed value" name=dt-typed-value>Definition</A>: The 
<B>typed value</B> of a node is a sequence of atomic values and can be extracted 
by applying the <CODE>fn:data</CODE> function to the node.] [<A 
id=dt-string-value title="string value" name=dt-string-value>Definition</A>: The 
<B>string value</B> of a node is a string and can be extracted by applying the 
<CODE>fn:string</CODE> function to the node.] Definitions of 
<CODE>fn:data</CODE> and <CODE>fn:string</CODE> can be found in <A 
href="REC-xquery-20070123.htm#FunctionsAndOperators">[XQuery 
1.0 and XPath 2.0 Functions and Operators]</A>.</P>
<P>An implementation may store both the <A title="typed value" 
href="REC-xquery-20070123.htm#dt-typed-value">typed 
value</A> and the <A title="string value" 
href="REC-xquery-20070123.htm#dt-string-value">string 
value</A> of a node, or it may store only one of these and derive the other as 
needed. The string value of a node must be a valid lexical representation of the 
typed value of the node, but the node is not required to preserve the string 
representation from the original source document. For example, if the typed 
value of a node is the <CODE>xs:integer</CODE> value <CODE>30</CODE>, its string 
value might be "<CODE>30</CODE>" or "<CODE>0030</CODE>".</P>
<DIV class=xquery>
<P class=xquery>The <A title="typed value" 
href="REC-xquery-20070123.htm#dt-typed-value">typed 
value</A>, <A title="string value" 
href="REC-xquery-20070123.htm#dt-string-value">string 
value</A>, and <A title="type annotation" 
href="REC-xquery-20070123.htm#dt-type-annotation">type 
annotation</A> of a node are closely related, and are defined by rules found in 
the following locations:</P></DIV>
<UL>
  <LI>
  <P>If the node was created by mapping from an Infoset or PSVI, see rules in <A 
  href="REC-xquery-20070123.htm#datamodel">[XQuery/XPath 
  Data Model (XDM)]</A>.</P>
  <LI>
  <P>If the node was created by an XQuery node constructor, see rules in <A 
  href="REC-xquery-20070123.htm#id-element-constructor"><B>3.7.1 
  Direct Element Constructors</B></A>, <A 
  href="REC-xquery-20070123.htm#id-computedElements"><B>3.7.3.1 
  Computed Element Constructors</B></A>, or <A 
  href="REC-xquery-20070123.htm#id-computedAttributes"><B>3.7.3.2 
  Computed Attribute Constructors</B></A>.</P>
  <LI>
  <P>If the node was created by a <CODE>validate</CODE> expression, see rules in 
  <A href="REC-xquery-20070123.htm#id-validate"><B>3.13 
  Validate Expressions</B></A>.</P></LI></UL>
<P>As a convenience to the reader, the relationship between <A 
title="typed value" 
href="REC-xquery-20070123.htm#dt-typed-value">typed 
value</A> and <A title="string value" 
href="REC-xquery-20070123.htm#dt-string-value">string 
value</A> for various kinds of nodes is summarized and illustrated by examples 
below.</P>
<OL class=enumar>
  <LI>
  <P>For text and document nodes, the typed value of the node is the same as its 
  string value, as an instance of the type <CODE>xs:untypedAtomic</CODE>. The 
  string value of a document node is formed by concatenating the string values 
  of all its descendant text nodes, in <A title="document order" 
  href="REC-xquery-20070123.htm#dt-document-order">document 
  order</A>.</P>
  <LI>
  <P>The typed value of a comment or processing instruction node is the same as 
  its string value. It is an instance of the type <CODE>xs:string</CODE>.</P>
  <LI>
  <P>The typed value of an attribute node with the <A title="type annotation" 
  href="REC-xquery-20070123.htm#dt-type-annotation">type 
  annotation</A> <CODE>xs:anySimpleType</CODE> or <CODE>xs:untypedAtomic</CODE> 
  is the same as its string value, as an instance of 
  <CODE>xs:untypedAtomic</CODE>. The typed value of an attribute node with any 
  other type annotation is derived from its string value and type annotation 
  using the lexical-to-value-space mapping defined in <A 
  href="REC-xquery-20070123.htm#XMLSchema">[XML 
  Schema]</A> Part 2 for the relevant type.</P>
  <P>Example: A1 is an attribute having string value <CODE>"3.14E-2"</CODE> and 
  type annotation <CODE>xs:double</CODE>. The typed value of A1 is the 
  <CODE>xs:double</CODE> value whose lexical representation is 
  <CODE>3.14E-2</CODE>.</P>
  <P>Example: A2 is an attribute with type annotation <CODE>xs:IDREFS</CODE>, 
  which is a list datatype whose item type is the atomic datatype 
  <CODE>xs:IDREF</CODE>. Its string value is "<CODE>bar baz faz</CODE>". The 
  typed value of A2 is a sequence of three atomic values ("<CODE>bar</CODE>", 
  "<CODE>baz</CODE>", "<CODE>faz</CODE>"), each of type <CODE>xs:IDREF</CODE>. 
  The typed value of a node is never treated as an instance of a named list 
  type. Instead, if the type annotation of a node is a list type (such as 
  <CODE>xs:IDREFS</CODE>), its typed value is treated as a sequence of the 
  atomic type from which it is derived (such as <CODE>xs:IDREF</CODE>).</P>
  <LI>
  <P>For an element node, the relationship between typed value and string value 
  depends on the node's <A title="type annotation" 
  href="REC-xquery-20070123.htm#dt-type-annotation">type 
  annotation</A>, as follows:</P>
  <OL class=enumla>
    <LI>
    <P>If the type annotation is <CODE>xs:untyped</CODE> or 
    <CODE>xs:anySimpleType</CODE> or denotes a complex type with mixed content 
    (including <CODE>xs:anyType</CODE>), then the typed value of the node is 
    equal to its string value, as an instance of <CODE>xs:untypedAtomic</CODE>. 
    However, if the <CODE>nilled</CODE> property of the node is 
    <CODE>true</CODE>, then its typed value is the empty sequence.</P>
    <P>Example: E1 is an element node having type annotation 
    <CODE>xs:untyped</CODE> and string value "<CODE>1999-05-31</CODE>". The 
    typed value of E1 is "<CODE>1999-05-31</CODE>", as an instance of 
    <CODE>xs:untypedAtomic</CODE>.</P>
    <P>Example: E2 is an element node with the type annotation 
    <CODE>formula</CODE>, which is a complex type with mixed content. The 
    content of E2 consists of the character "<CODE>H</CODE>", a child element 
    named <CODE>subscript</CODE> with string value "<CODE>2</CODE>", and the 
    character "<CODE>O</CODE>". The typed value of E2 is "<CODE>H2O</CODE>" as 
    an instance of <CODE>xs:untypedAtomic</CODE>.</P>
    <LI>
    <P>If the type annotation denotes a simple type or a complex type with 
    simple content, then the typed value of the node is derived from its string 
    value and its type annotation in a way that is consistent with schema 
    validation. However, if the <CODE>nilled</CODE> property of the node is 
    <CODE>true</CODE>, then its typed value is the empty sequence.</P>
    <P>Example: E3 is an element node with the type annotation 
    <CODE>cost</CODE>, which is a complex type that has several attributes and a 
    simple content type of <CODE>xs:decimal</CODE>. The string value of E3 is 
    "<CODE>74.95</CODE>". The typed value of E3 is <CODE>74.95</CODE>, as an 
    instance of <CODE>xs:decimal</CODE>.</P>
    <P>Example: E4 is an element node with the type annotation 
    <CODE>hatsizelist</CODE>, which is a simple type derived from the atomic 
    type <CODE>hatsize</CODE>, which in turn is derived from 
    <CODE>xs:integer</CODE>. The string value of E4 is "<CODE>7 8 9</CODE>". The 
    typed value of E4 is a sequence of three values (<CODE>7</CODE>, 
    <CODE>8</CODE>, <CODE>9</CODE>), each of type <CODE>hatsize</CODE>.</P>
    <P>Example: E5 is an element node with the type annotation 
    <CODE>my:integer-or-string</CODE> which is a union type with member types 
    <CODE>xs:integer</CODE> and <CODE>xs:string</CODE>. The string value of E5 
    is "<CODE>47</CODE>". The typed value of E5 is <CODE>47</CODE> as an 
    <CODE>xs:integer</CODE>, since <CODE>xs:integer</CODE> is the member type 
    that validated the content of E5. In general, when the type annotation of a 
    node is a union type, the typed value of the node will be an instance of one 
    of the member types of the union.</P>
    <DIV class=note>
    <P class=prefix><B>Note:</B></P>
    <P>If an implementation stores only the string value of a node, and the type 
    annotation of the node is a union type, the implementation must be able to 
    deliver the typed value of the node as an instance of the appropriate member 
    type.</P></DIV>
    <LI>
    <P>If the type annotation denotes a complex type with empty content, then 
    the typed value of the node is the empty sequence and its string value is 
    the zero-length string.</P>
    <LI>
    <P>If the type annotation denotes a complex type with element-only content, 
    then the typed value of the node is undefined. The <CODE>fn:data</CODE> 
    function raises a <A title="type error" 
    href="REC-xquery-20070123.htm#dt-type-error">type 
    error</A> [err:FOTY0012] when applied to such a node. The string value of 
    such a node is equal to the concatenated string values of all its text node 
    descendants, in document order.</P>
    <P>Example: E6 is an element node with the type annotation 
    <CODE>weather</CODE>, which is a complex type whose content type specifies 
    <CODE>element-only</CODE>. E6 has two child elements named 
    <CODE>temperature</CODE> and <CODE>precipitation</CODE>. The typed value of 
    E6 is undefined, and the <CODE>fn:data</CODE> function applied to E6 raises 
    an error.</P></LI></OL></LI></OL></DIV>
<DIV class=div3>
<H4><A id=id-sequencetype-syntax name=id-sequencetype-syntax></A>2.5.3 
SequenceType Syntax</H4>
<P>Whenever it is necessary to refer to a type in an XQuery expression, the <A 
href="REC-xquery-20070123.htm#doc-xquery-SequenceType">SequenceType</A> 
syntax is used.</P>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-SequenceType 
      name=doc-xquery-SequenceType></A>[119]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-SequenceType">SequenceType</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>("empty-sequence" "(" ")")<BR>| (<A 
      href="REC-xquery-20070123.htm#doc-xquery-ItemType">ItemType</A> 
      <A 
      href="REC-xquery-20070123.htm#doc-xquery-OccurrenceIndicator">OccurrenceIndicator</A>?)</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-ItemType 
      name=doc-xquery-ItemType></A>[121]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-ItemType">ItemType</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-KindTest">KindTest</A> 
      | ("item" "(" ")") | <A 
      href="REC-xquery-20070123.htm#doc-xquery-AtomicType">AtomicType</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-OccurrenceIndicator 
      name=doc-xquery-OccurrenceIndicator></A>[120]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-OccurrenceIndicator">OccurrenceIndicator</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"?" | "*" | "+"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-AtomicType 
      name=doc-xquery-AtomicType></A>[122]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-AtomicType">AtomicType</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-QName">QName</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-KindTest 
      name=doc-xquery-KindTest></A>[123]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-KindTest">KindTest</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-DocumentTest">DocumentTest</A><BR>| 
      <A 
      href="REC-xquery-20070123.htm#doc-xquery-ElementTest">ElementTest</A><BR>| 
      <A 
      href="REC-xquery-20070123.htm#doc-xquery-AttributeTest">AttributeTest</A><BR>| 
      <A 
      href="REC-xquery-20070123.htm#doc-xquery-SchemaElementTest">SchemaElementTest</A><BR>| 
      <A 
      href="REC-xquery-20070123.htm#doc-xquery-SchemaAttributeTest">SchemaAttributeTest</A><BR>| 
      <A 
      href="REC-xquery-20070123.htm#doc-xquery-PITest">PITest</A><BR>| 
      <A 
      href="REC-xquery-20070123.htm#doc-xquery-CommentTest">CommentTest</A><BR>| 
      <A 
      href="REC-xquery-20070123.htm#doc-xquery-TextTest">TextTest</A><BR>| 
      <A 
      href="REC-xquery-20070123.htm#doc-xquery-AnyKindTest">AnyKindTest</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-DocumentTest 
      name=doc-xquery-DocumentTest></A>[125]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-DocumentTest">DocumentTest</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"document-node" "(" (<A 
      href="REC-xquery-20070123.htm#doc-xquery-ElementTest">ElementTest</A> 
      | <A 
      href="REC-xquery-20070123.htm#doc-xquery-SchemaElementTest">SchemaElementTest</A>)? 
      ")"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-ElementTest 
      name=doc-xquery-ElementTest></A>[133]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-ElementTest">ElementTest</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"element" "(" (<A 
      href="REC-xquery-20070123.htm#doc-xquery-ElementNameOrWildcard">ElementNameOrWildcard</A> 
      ("," <A 
      href="REC-xquery-20070123.htm#doc-xquery-TypeName">TypeName</A> 
      "?"?)?)? ")"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-SchemaElementTest 
      name=doc-xquery-SchemaElementTest></A>[135]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-SchemaElementTest">SchemaElementTest</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"schema-element" "(" <A 
      href="REC-xquery-20070123.htm#doc-xquery-ElementDeclaration">ElementDeclaration</A> 
      ")"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-ElementDeclaration 
      name=doc-xquery-ElementDeclaration></A>[136]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-ElementDeclaration">ElementDeclaration</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-ElementName">ElementName</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-AttributeTest 
      name=doc-xquery-AttributeTest></A>[129]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-AttributeTest">AttributeTest</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"attribute" "(" (<A 
      href="REC-xquery-20070123.htm#doc-xquery-AttribNameOrWildcard">AttribNameOrWildcard</A> 
      ("," <A 
      href="REC-xquery-20070123.htm#doc-xquery-TypeName">TypeName</A>)?)? 
      ")"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-SchemaAttributeTest 
      name=doc-xquery-SchemaAttributeTest></A>[131]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-SchemaAttributeTest">SchemaAttributeTest</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"schema-attribute" "(" <A 
      href="REC-xquery-20070123.htm#doc-xquery-AttributeDeclaration">AttributeDeclaration</A> 
      ")"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-AttributeDeclaration 
      name=doc-xquery-AttributeDeclaration></A>[132]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-AttributeDeclaration">AttributeDeclaration</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-AttributeName">AttributeName</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-ElementNameOrWildcard 
      name=doc-xquery-ElementNameOrWildcard></A>[134]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-ElementNameOrWildcard">ElementNameOrWildcard</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-ElementName">ElementName</A> 
      | "*"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-ElementName 
      name=doc-xquery-ElementName></A>[138]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-ElementName">ElementName</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-QName">QName</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-AttribNameOrWildcard 
      name=doc-xquery-AttribNameOrWildcard></A>[130]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-AttribNameOrWildcard">AttribNameOrWildcard</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-AttributeName">AttributeName</A> 
      | "*"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-AttributeName 
      name=doc-xquery-AttributeName></A>[137]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-AttributeName">AttributeName</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-QName">QName</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-TypeName 
      name=doc-xquery-TypeName></A>[139]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-TypeName">TypeName</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-QName">QName</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-PITest 
    name=doc-xquery-PITest></A>[128]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-PITest">PITest</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"processing-instruction" "(" (<A 
      href="REC-xquery-20070123.htm#prod-xquery-NCName">NCName</A> 
      | <A 
      href="REC-xquery-20070123.htm#doc-xquery-StringLiteral">StringLiteral</A>)? 
      ")"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-CommentTest 
      name=doc-xquery-CommentTest></A>[127]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-CommentTest">CommentTest</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"comment" "(" ")"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-TextTest 
      name=doc-xquery-TextTest></A>[126]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-TextTest">TextTest</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"text" "(" ")"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-AnyKindTest 
      name=doc-xquery-AnyKindTest></A>[124]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-AnyKindTest">AnyKindTest</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"node" "(" ")"</CODE></TD></TR></TBODY></TABLE>
<P>With the exception of the special type <CODE>empty-sequence()</CODE>, a <A 
title="sequence type" 
href="REC-xquery-20070123.htm#dt-sequence-type">sequence 
type</A> consists of an <B>item type</B> that constrains the type of each item 
in the sequence, and a <B>cardinality</B> that constrains the number of items in 
the sequence. Apart from the item type <CODE>item()</CODE>, which permits any 
kind of item, item types divide into <B>node types</B> (such as 
<CODE>element()</CODE>) and <B>atomic types</B> (such as 
<CODE>xs:integer</CODE>).</P>
<P>Item types representing element and attribute nodes may specify the required 
<A title="type annotation" 
href="REC-xquery-20070123.htm#dt-type-annotation">type 
annotations</A> of those nodes, in the form of a <A title="schema type" 
href="REC-xquery-20070123.htm#dt-schema-type">schema 
type</A>. Thus the item type <CODE>element(*, us:address)</CODE> denotes any 
element node whose type annotation is (or is derived from) the schema type named 
<CODE>us:address</CODE>.</P>
<P>Here are some examples of <A title="sequence type" 
href="REC-xquery-20070123.htm#dt-sequence-type">sequence 
types</A> that might be used in XQuery expressions:</P>
<UL>
  <LI>
  <P><CODE>xs:date</CODE> refers to the built-in atomic schema type named 
  <CODE>xs:date</CODE></P>
  <LI>
  <P><CODE>attribute()?</CODE> refers to an optional attribute node</P>
  <LI>
  <P><CODE>element()</CODE> refers to any element node</P>
  <LI>
  <P><CODE>element(po:shipto, po:address)</CODE> refers to an element node that 
  has the name <CODE>po:shipto</CODE> and has the type annotation 
  <CODE>po:address</CODE> (or a schema type derived from 
  <CODE>po:address</CODE>)</P>
  <LI>
  <P><CODE>element(*, po:address)</CODE> refers to an element node of any name 
  that has the type annotation <CODE>po:address</CODE> (or a type derived from 
  <CODE>po:address</CODE>)</P>
  <LI>
  <P><CODE>element(customer)</CODE> refers to an element node named 
  <CODE>customer</CODE> with any type annotation</P>
  <LI>
  <P><CODE>schema-element(customer)</CODE> refers to an element node whose name 
  is <CODE>customer</CODE> (or is in the substitution group headed by 
  <CODE>customer</CODE>) and whose type annotation matches the schema type 
  declared for a <CODE>customer</CODE> element in the <A 
  title="in-scope element declarations" 
  href="REC-xquery-20070123.htm#dt-is-elems">in-scope 
  element declarations</A></P>
  <LI>
  <P><CODE>node()*</CODE> refers to a sequence of zero or more nodes of any 
  kind</P>
  <LI>
  <P><CODE>item()+</CODE> refers to a sequence of one or more nodes or atomic 
  values</P></LI></UL></DIV>
<DIV class=div3>
<H4><A id=id-sequencetype-matching name=id-sequencetype-matching></A>2.5.4 
SequenceType Matching</H4>
<P>[<A id=dt-sequencetype-matching title="SequenceType matching" 
name=dt-sequencetype-matching>Definition</A>: During evaluation of an 
expression, it is sometimes necessary to determine whether a value with a known 
<A title="dynamic type" 
href="REC-xquery-20070123.htm#dt-dynamic-type">dynamic 
type</A> "matches" an expected <A title="sequence type" 
href="REC-xquery-20070123.htm#dt-sequence-type">sequence 
type</A>. This process is known as <B>SequenceType matching</B>.] For example, 
an <CODE>instance of</CODE> expression returns <CODE>true</CODE> if the <A 
title="dynamic type" 
href="REC-xquery-20070123.htm#dt-dynamic-type">dynamic 
type</A> of a given value matches a given <A title="sequence type" 
href="REC-xquery-20070123.htm#dt-sequence-type">sequence 
type</A>, or <CODE>false</CODE> if it does not.</P>
<P>QNames appearing in a <A title="sequence type" 
href="REC-xquery-20070123.htm#dt-sequence-type">sequence 
type</A> have their prefixes expanded to namespace URIs by means of the <A 
title="statically known namespaces" 
href="REC-xquery-20070123.htm#dt-static-namespaces">statically 
known namespaces</A> and (where applicable) the <A 
title="default element/type namespace" 
href="REC-xquery-20070123.htm#dt-def-elemtype-ns">default 
element/type namespace</A>. An unprefixed attribute QName is in no namespace. 
Equality of QNames is defined by the <CODE>eq</CODE> operator.</P>
<P>The rules for <A title="SequenceType matching" 
href="REC-xquery-20070123.htm#dt-sequencetype-matching">SequenceType 
matching</A> compare the <A title="dynamic type" 
href="REC-xquery-20070123.htm#dt-dynamic-type">dynamic 
type</A> of a value with an expected <A title="sequence type" 
href="REC-xquery-20070123.htm#dt-sequence-type">sequence 
type</A>. These rules are a subset of the formal rules that match a value with 
an expected type defined in <A 
href="REC-xquery-20070123.htm#XQueryFormalSemantics">[XQuery 
1.0 and XPath 2.0 Formal Semantics]</A>, because the Formal Semantics must be 
able to match values against types that are not expressible using the <A 
href="REC-xquery-20070123.htm#doc-xquery-SequenceType">SequenceType</A> 
syntax.</P>
<P>Some of the rules for <A title="SequenceType matching" 
href="REC-xquery-20070123.htm#dt-sequencetype-matching">SequenceType 
matching</A> require determining whether a given schema type is the same as or 
derived from an expected schema type. The given schema type may be "known" 
(defined in the <A title="in-scope schema definitions" 
href="REC-xquery-20070123.htm#dt-issd">in-scope schema 
definitions</A>), or "unknown" (not defined in the <A 
title="in-scope schema definitions" 
href="REC-xquery-20070123.htm#dt-issd">in-scope schema 
definitions</A>). An unknown schema type might be encountered, for example, if a 
source document has been validated using a schema that was not imported into the 
<A title="static context" 
href="REC-xquery-20070123.htm#dt-static-context">static 
context</A>. In this case, an implementation is allowed (but is not required) to 
provide an <A title="implementation dependent" 
href="REC-xquery-20070123.htm#dt-implementation-dependent">implementation-dependent</A> 
mechanism for determining whether the unknown schema type is derived from the 
expected schema type. For example, an implementation might maintain a data 
dictionary containing information about type hierarchies.</P>
<P>[<A id=dt-subtype-substitution title="subtype substitution" 
name=dt-subtype-substitution>Definition</A>: The use of a value whose <A 
title="dynamic type" 
href="REC-xquery-20070123.htm#dt-dynamic-type">dynamic 
type</A> is derived from an expected type is known as <B>subtype 
substitution</B>.] Subtype substitution does not change the actual type of a 
value. For example, if an <CODE>xs:integer</CODE> value is used where an 
<CODE>xs:decimal</CODE> value is expected, the value retains its type as 
<CODE>xs:integer</CODE>.</P>
<P>The definition of <A title="SequenceType matching" 
href="REC-xquery-20070123.htm#dt-sequencetype-matching">SequenceType 
matching</A> relies on a pseudo-function named <CODE>derives-from(</CODE><EM>AT, 
ET</EM><CODE>)</CODE>, which takes an actual simple or complex schema type 
<EM>AT</EM> and an expected simple or complex schema type <EM>ET</EM>, and 
either returns a boolean value or raises a <A title="type error" 
href="REC-xquery-20070123.htm#dt-type-error">type 
error</A> [<A title=err:XPTY0004 
href="REC-xquery-20070123.htm#ERRXPTY0004">err:XPTY0004</A>]. 
The pseudo-function <CODE>derives-from</CODE> is defined below and is defined 
formally in <A 
href="REC-xquery-20070123.htm#XQueryFormalSemantics">[XQuery 
1.0 and XPath 2.0 Formal Semantics]</A>.</P>
<UL>
  <LI>
  <P><CODE>derives-from(</CODE><EM>AT</EM>, <EM>ET</EM><CODE>)</CODE> returns 
  <CODE>true</CODE> if <EM>ET</EM> is a known type and any of the following 
  three conditions is true:</P>
  <OL class=enumar>
    <LI>
    <P><EM>AT</EM> is a schema type found in the <A 
    title="in-scope schema definitions" 
    href="REC-xquery-20070123.htm#dt-issd">in-scope 
    schema definitions</A>, and is the same as <EM>ET</EM> or is derived by 
    restriction or extension from <EM>ET</EM></P>
    <LI>
    <P><EM>AT</EM> is a schema type not found in the <A 
    title="in-scope schema definitions" 
    href="REC-xquery-20070123.htm#dt-issd">in-scope 
    schema definitions</A>, and an <A title="implementation dependent" 
    href="REC-xquery-20070123.htm#dt-implementation-dependent">implementation-dependent</A> 
    mechanism is able to determine that <EM>AT</EM> is derived by restriction 
    from <EM>ET</EM></P>
    <LI>
    <P>There exists some schema type <EM>IT</EM> such that 
    <CODE>derives-from(</CODE><EM>IT, ET</EM><CODE>)</CODE> and 
    <CODE>derives-from(</CODE><EM>AT, IT</EM><CODE>)</CODE> are 
true.</P></LI></OL>
  <LI>
  <P><CODE>derives-from(</CODE><EM>AT</EM>, <EM>ET</EM><CODE>)</CODE> returns 
  <CODE>false</CODE> if <EM>ET</EM> is a known type and either the first and 
  third or the second and third of the following conditions are true:</P>
  <OL class=enumar>
    <LI>
    <P><EM>AT</EM> is a schema type found in the <A 
    title="in-scope schema definitions" 
    href="REC-xquery-20070123.htm#dt-issd">in-scope 
    schema definitions</A>, and is not the same as <EM>ET</EM>, and is not 
    derived by restriction or extension from <EM>ET</EM></P>
    <LI>
    <P><EM>AT</EM> is a schema type not found in the <A 
    title="in-scope schema definitions" 
    href="REC-xquery-20070123.htm#dt-issd">in-scope 
    schema definitions</A>, and an <A title="implementation dependent" 
    href="REC-xquery-20070123.htm#dt-implementation-dependent">implementation-dependent</A> 
    mechanism is able to determine that <EM>AT</EM> is not derived by 
    restriction from <EM>ET</EM></P>
    <LI>
    <P>No schema type <EM>IT</EM> exists such that 
    <CODE>derives-from(</CODE><EM>IT, ET</EM><CODE>)</CODE> and 
    <CODE>derives-from(</CODE><EM>AT, IT</EM><CODE>)</CODE> are 
true.</P></LI></OL>
  <LI>
  <P><CODE>derives-from(</CODE><EM>AT</EM>, <EM>ET</EM><CODE>)</CODE> raises a 
  <A title="type error" 
  href="REC-xquery-20070123.htm#dt-type-error">type 
  error</A> [<A title=err:XPTY0004 
  href="REC-xquery-20070123.htm#ERRXPTY0004">err:XPTY0004</A>] 
  if:</P>
  <OL class=enumar>
    <LI>
    <P><EM>ET</EM> is an unknown type, or</P>
    <LI>
    <P><EM>AT</EM> is an unknown type, and the implementation is not able to 
    determine whether <EM>AT</EM> is derived by restriction from 
    <EM>ET</EM>.</P></LI></OL></LI></UL>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>The <CODE>derives-from</CODE> pseudo-function cannot be written as a real 
XQuery function, because types are not valid function parameters.</P></DIV>
<P>The rules for <A title="SequenceType matching" 
href="REC-xquery-20070123.htm#dt-sequencetype-matching">SequenceType 
matching</A> are given below, with examples (the examples are for purposes of 
illustration, and do not cover all possible cases).</P>
<DIV class=div4>
<H5><A id=id-matching-value name=id-matching-value></A>2.5.4.1 Matching a 
SequenceType and a Value</H5>
<UL>
  <LI>
  <P>The <A title="sequence type" 
  href="REC-xquery-20070123.htm#dt-sequence-type">sequence 
  type</A> <CODE>empty-sequence()</CODE> matches a value that is the empty 
  sequence.</P>
  <LI>
  <P>An <A 
  href="REC-xquery-20070123.htm#doc-xquery-ItemType">ItemType</A> 
  with no <A 
  href="REC-xquery-20070123.htm#doc-xquery-OccurrenceIndicator">OccurrenceIndicator</A> 
  matches any value that contains exactly one item if the <A 
  href="REC-xquery-20070123.htm#doc-xquery-ItemType">ItemType</A> 
  matches that item (see <A 
  href="REC-xquery-20070123.htm#id-matching-item"><B>2.5.4.2 
  Matching an ItemType and an Item</B></A>).</P>
  <LI>
  <P>An <A 
  href="REC-xquery-20070123.htm#doc-xquery-ItemType">ItemType</A> 
  with an <A 
  href="REC-xquery-20070123.htm#doc-xquery-OccurrenceIndicator">OccurrenceIndicator</A> 
  matches a value if the number of items in the value matches the <A 
  href="REC-xquery-20070123.htm#doc-xquery-OccurrenceIndicator">OccurrenceIndicator</A> 
  and the <A 
  href="REC-xquery-20070123.htm#doc-xquery-ItemType">ItemType</A> 
  matches each of the items in the value.</P></LI></UL>
<P>An <A 
href="REC-xquery-20070123.htm#doc-xquery-OccurrenceIndicator">OccurrenceIndicator</A> 
specifies the number of items in a sequence, as follows:</P>
<UL>
  <LI>
  <P><CODE>?</CODE> matches zero or one items</P>
  <LI>
  <P><CODE>*</CODE> matches zero or more items</P>
  <LI>
  <P><CODE>+</CODE> matches one or more items</P></LI></UL>
<P>As a consequence of these rules, any <A title="sequence type" 
href="REC-xquery-20070123.htm#dt-sequence-type">sequence 
type</A> whose <A 
href="REC-xquery-20070123.htm#doc-xquery-OccurrenceIndicator">OccurrenceIndicator</A> 
is <CODE>*</CODE> or <CODE>?</CODE> matches a value that is an empty 
sequence.</P></DIV>
<DIV class=div4>
<H5><A id=id-matching-item name=id-matching-item></A>2.5.4.2 Matching an 
ItemType and an Item</H5>
<UL>
  <LI>
  <P>An <A 
  href="REC-xquery-20070123.htm#doc-xquery-ItemType">ItemType</A> 
  consisting simply of a QName is interpreted as an <A 
  href="REC-xquery-20070123.htm#doc-xquery-AtomicType">AtomicType</A>. 
  An AtomicType <EM>AtomicType</EM> matches an atomic value whose actual type is 
  <EM>AT</EM> if <CODE>derives-from(</CODE><EM>AT, AtomicType</EM><CODE>)</CODE> 
  is <CODE>true</CODE>. If a QName that is used as an <A 
  href="REC-xquery-20070123.htm#doc-xquery-AtomicType">AtomicType</A> 
  is not defined as an atomic type in the <A title="in-scope schema type" 
  href="REC-xquery-20070123.htm#dt-is-types">in-scope 
  schema types</A>, a <A title="static error" 
  href="REC-xquery-20070123.htm#dt-static-error">static 
  error</A> is raised [<A title=err:XPST0051 
  href="REC-xquery-20070123.htm#ERRXPST0051">err:XPST0051</A>].</P>
  <P>Example: The <A 
  href="REC-xquery-20070123.htm#doc-xquery-AtomicType">AtomicType</A> 
  <CODE>xs:decimal</CODE> matches the value <CODE>12.34</CODE> (a decimal 
  literal). <CODE>xs:decimal</CODE> also matches a value whose type is 
  <CODE>shoesize</CODE>, if <CODE>shoesize</CODE> is an atomic type derived by 
  restriction from <CODE>xs:decimal</CODE>.</P>
  <DIV class=note>
  <P class=prefix><B>Note:</B></P>
  <P>The names of non-atomic types such as <CODE>xs:IDREFS</CODE> are not 
  accepted in this context, but can often be replaced by an atomic type with an 
  occurrence indicator, such as <CODE>xs:IDREF+</CODE>.</P></DIV>
  <LI>
  <P><CODE>item()</CODE> matches any single item.</P>
  <P>Example: <CODE>item()</CODE> matches the atomic value <CODE>1</CODE> or the 
  element <CODE>&lt;a/&gt;</CODE>.</P>
  <LI>
  <P><CODE>node()</CODE> matches any node.</P>
  <LI>
  <P><CODE>text()</CODE> matches any text node.</P>
  <LI>
  <P><CODE>processing-instruction()</CODE> matches any processing-instruction 
  node.</P>
  <LI>
  <P><CODE>processing-instruction(</CODE><EM>N</EM><CODE>)</CODE> matches any 
  processing-instruction node whose name (called its "PITarget" in XML) is equal 
  to <EM>N</EM>, where <EM>N</EM> is an NCName.</P>
  <P>Example: <CODE>processing-instruction(xml-stylesheet)</CODE> matches any 
  processing instruction whose PITarget is <CODE>xml-stylesheet</CODE>.</P>
  <P>For backward compatibility with XPath 1.0, the PITarget of a processing 
  instruction may also be expressed as a string literal, as in this example: 
  <CODE>processing-instruction("xml-stylesheet")</CODE>.</P>
  <LI>
  <P><CODE>comment()</CODE> matches any comment node.</P>
  <LI>
  <P><CODE>document-node()</CODE> matches any document node.</P>
  <LI>
  <P><CODE>document-node(</CODE><EM>E</EM><CODE>)</CODE> matches any document 
  node that contains exactly one element node, optionally accompanied by one or 
  more comment and processing instruction nodes, if <EM>E</EM> is an <A 
  href="REC-xquery-20070123.htm#doc-xquery-ElementTest">ElementTest</A> 
  or <A 
  href="REC-xquery-20070123.htm#doc-xquery-SchemaElementTest">SchemaElementTest</A> 
  that matches the element node (see <A 
  href="REC-xquery-20070123.htm#id-element-test"><B>2.5.4.3 
  Element Test</B></A> and <A 
  href="REC-xquery-20070123.htm#id-schema-element-test"><B>2.5.4.4 
  Schema Element Test</B></A>).</P>
  <P>Example: <CODE>document-node(element(book))</CODE> matches a document node 
  containing exactly one element node that is matched by the ElementTest 
  <CODE>element(book)</CODE>.</P>
  <LI>
  <P>An <A 
  href="REC-xquery-20070123.htm#doc-xquery-ItemType">ItemType</A> 
  that is an <A 
  href="REC-xquery-20070123.htm#doc-xquery-ElementTest">ElementTest</A>, 
  <A 
  href="REC-xquery-20070123.htm#doc-xquery-SchemaElementTest">SchemaElementTest</A>, 
  <A 
  href="REC-xquery-20070123.htm#doc-xquery-AttributeTest">AttributeTest</A>, 
  or <A 
  href="REC-xquery-20070123.htm#doc-xquery-SchemaAttributeTest">SchemaAttributeTest</A> 
  matches an element or attribute node as described in the following 
  sections.</P></LI></UL></DIV>
<DIV class=div4>
<H5><A id=id-element-test name=id-element-test></A>2.5.4.3 Element Test</H5>
<P>An <A 
href="REC-xquery-20070123.htm#doc-xquery-ElementTest">ElementTest</A> 
is used to match an element node by its name and/or <A title="type annotation" 
href="REC-xquery-20070123.htm#dt-type-annotation">type 
annotation</A>. An <A 
href="REC-xquery-20070123.htm#doc-xquery-ElementTest">ElementTest</A> 
may take any of the following forms. In these forms, <A 
href="REC-xquery-20070123.htm#doc-xquery-ElementName">ElementName</A> 
need not be present in the <A title="in-scope element declarations" 
href="REC-xquery-20070123.htm#dt-is-elems">in-scope 
element declarations</A>, but <A 
href="REC-xquery-20070123.htm#doc-xquery-TypeName">TypeName</A> 
must be present in the <A title="in-scope schema type" 
href="REC-xquery-20070123.htm#dt-is-types">in-scope 
schema types</A> [<A title=err:XPST0008 
href="REC-xquery-20070123.htm#ERRXPST0008">err:XPST0008</A>]. 
Note that <A title="substitution group" 
href="REC-xquery-20070123.htm#dt-substitution-group">substitution 
groups</A> do not affect the semantics of <A 
href="REC-xquery-20070123.htm#doc-xquery-ElementTest">ElementTest</A>.</P>
<OL class=enumar>
  <LI>
  <P><CODE>element()</CODE> and <CODE>element(*)</CODE> match any single element 
  node, regardless of its name or type annotation.</P>
  <LI>
  <P><CODE>element(</CODE><A 
  href="REC-xquery-20070123.htm#doc-xquery-ElementName">ElementName</A><CODE>)</CODE> 
  matches any element node whose name is <A 
  href="REC-xquery-20070123.htm#doc-xquery-ElementName">ElementName</A>, 
  regardless of its type annotation or <CODE>nilled</CODE> property.</P>
  <P>Example: <CODE>element(person)</CODE> matches any element node whose name 
  is <CODE>person</CODE>.</P>
  <LI>
  <P><CODE>element(</CODE><A 
  href="REC-xquery-20070123.htm#doc-xquery-ElementName">ElementName</A><CODE>,</CODE> 
  <A 
  href="REC-xquery-20070123.htm#doc-xquery-TypeName">TypeName</A><CODE>)</CODE> 
  matches an element node whose name is <A 
  href="REC-xquery-20070123.htm#doc-xquery-ElementName">ElementName</A> 
  if <CODE>derives-from(</CODE><EM>AT</EM>, <A 
  href="REC-xquery-20070123.htm#doc-xquery-TypeName">TypeName</A> 
  <CODE>)</CODE> is <CODE>true</CODE>, where <EM>AT</EM> is the type annotation 
  of the element node, and the <CODE>nilled</CODE> property of the node is 
  <CODE>false</CODE>.</P>
  <P>Example: <CODE>element(person, surgeon)</CODE> matches a non-nilled element 
  node whose name is <CODE>person</CODE> and whose type annotation is 
  <CODE>surgeon</CODE> (or is derived from <CODE>surgeon</CODE>).</P>
  <LI>
  <P><CODE>element(</CODE><A 
  href="REC-xquery-20070123.htm#doc-xquery-ElementName">ElementName</A>, 
  <A 
  href="REC-xquery-20070123.htm#doc-xquery-TypeName">TypeName</A> 
  <CODE>?)</CODE> matches an element node whose name is <A 
  href="REC-xquery-20070123.htm#doc-xquery-ElementName">ElementName</A> 
  if <CODE>derives-from(</CODE><EM>AT</EM>, <A 
  href="REC-xquery-20070123.htm#doc-xquery-TypeName">TypeName</A><CODE>)</CODE> 
  is <CODE>true</CODE>, where <EM>AT</EM> is the type annotation of the element 
  node. The <CODE>nilled</CODE> property of the node may be either 
  <CODE>true</CODE> or <CODE>false</CODE>.</P>
  <P>Example: <CODE>element(person, surgeon?)</CODE> matches a nilled or 
  non-nilled element node whose name is <CODE>person</CODE> and whose type 
  annotation is <CODE>surgeon</CODE> (or is derived from 
  <CODE>surgeon</CODE>).</P>
  <LI>
  <P><CODE>element(*,</CODE> <A 
  href="REC-xquery-20070123.htm#doc-xquery-TypeName">TypeName</A><CODE>)</CODE> 
  matches an element node regardless of its name, if 
  <CODE>derives-from(</CODE><EM>AT</EM>, <A 
  href="REC-xquery-20070123.htm#doc-xquery-TypeName">TypeName</A> 
  <CODE>)</CODE> is <CODE>true</CODE>, where <EM>AT</EM> is the type annotation 
  of the element node, and the <CODE>nilled</CODE> property of the node is 
  <CODE>false</CODE>.</P>
  <P>Example: <CODE>element(*, surgeon)</CODE> matches any non-nilled element 
  node whose type annotation is <CODE>surgeon</CODE> (or is derived from 
  <CODE>surgeon</CODE>), regardless of its name.</P>
  <LI>
  <P><CODE>element(*,</CODE> <A 
  href="REC-xquery-20070123.htm#doc-xquery-TypeName">TypeName</A> 
  <CODE>?)</CODE> matches an element node regardless of its name, if 
  <CODE>derives-from(</CODE><EM>AT</EM>, <A 
  href="REC-xquery-20070123.htm#doc-xquery-TypeName">TypeName</A> 
  <CODE>)</CODE> is <CODE>true</CODE>, where <EM>AT</EM> is the type annotation 
  of the element node. The <CODE>nilled</CODE> property of the node may be 
  either <CODE>true</CODE> or <CODE>false</CODE>.</P>
  <P>Example: <CODE>element(*, surgeon?)</CODE> matches any nilled or non-nilled 
  element node whose type annotation is <CODE>surgeon</CODE> (or is derived from 
  <CODE>surgeon</CODE>), regardless of its name.</P></LI></OL></DIV>
<DIV class=div4>
<H5><A id=id-schema-element-test name=id-schema-element-test></A>2.5.4.4 Schema 
Element Test</H5>
<P>A <A 
href="REC-xquery-20070123.htm#doc-xquery-SchemaElementTest">SchemaElementTest</A> 
matches an element node against a corresponding element declaration found in the 
<A title="in-scope element declarations" 
href="REC-xquery-20070123.htm#dt-is-elems">in-scope 
element declarations</A>. It takes the following form:</P>
<P><CODE>schema-element(</CODE><A 
href="REC-xquery-20070123.htm#doc-xquery-ElementName">ElementName</A><CODE>)</CODE></P>
<P>If the <A 
href="REC-xquery-20070123.htm#doc-xquery-ElementName">ElementName</A> 
specified in the <A 
href="REC-xquery-20070123.htm#doc-xquery-SchemaElementTest">SchemaElementTest</A> 
is not found in the <A title="in-scope element declarations" 
href="REC-xquery-20070123.htm#dt-is-elems">in-scope 
element declarations</A>, a <A title="static error" 
href="REC-xquery-20070123.htm#dt-static-error">static 
error</A> is raised [<A title=err:XPST0008 
href="REC-xquery-20070123.htm#ERRXPST0008">err:XPST0008</A>].</P>
<P>A <A 
href="REC-xquery-20070123.htm#doc-xquery-SchemaElementTest">SchemaElementTest</A> 
matches a candidate element node if all three of the following conditions are 
satisfied:</P>
<OL class=enumar>
  <LI>
  <P>The name of the candidate node matches the specified <A 
  href="REC-xquery-20070123.htm#doc-xquery-ElementName">ElementName</A> 
  or matches the name of an element in a <A title="substitution group" 
  href="REC-xquery-20070123.htm#dt-substitution-group">substitution 
  group</A> headed by an element named <A 
  href="REC-xquery-20070123.htm#doc-xquery-ElementName">ElementName</A>.</P>
  <LI>
  <P><CODE>derives-from(</CODE><EM>AT, ET</EM><CODE>)</CODE> is 
  <CODE>true</CODE>, where <EM>AT</EM> is the type annotation of the candidate 
  node and <EM>ET</EM> is the schema type declared for element <A 
  href="REC-xquery-20070123.htm#doc-xquery-ElementName">ElementName</A> 
  in the <A title="in-scope element declarations" 
  href="REC-xquery-20070123.htm#dt-is-elems">in-scope 
  element declarations</A>.</P>
  <LI>
  <P>If the element declaration for <A 
  href="REC-xquery-20070123.htm#doc-xquery-ElementName">ElementName</A> 
  in the <A title="in-scope element declarations" 
  href="REC-xquery-20070123.htm#dt-is-elems">in-scope 
  element declarations</A> is not <CODE>nillable</CODE>, then the 
  <CODE>nilled</CODE> property of the candidate node is 
  <CODE>false</CODE>.</P></LI></OL>
<P>Example: The <A 
href="REC-xquery-20070123.htm#doc-xquery-SchemaElementTest">SchemaElementTest</A> 
<CODE>schema-element(customer)</CODE> matches a candidate element node if 
<CODE>customer</CODE> is a top-level element declaration in the <A 
title="in-scope element declarations" 
href="REC-xquery-20070123.htm#dt-is-elems">in-scope 
element declarations</A>, the name of the candidate node is 
<CODE>customer</CODE> or is in a <A title="substitution group" 
href="REC-xquery-20070123.htm#dt-substitution-group">substitution 
group</A> headed by <CODE>customer</CODE>, the type annotation of the candidate 
node is the same as or derived from the schema type declared for the 
<CODE>customer</CODE> element, and either the candidate node is not 
<CODE>nilled</CODE> or <CODE>customer</CODE> is declared to be 
<CODE>nillable</CODE>.</P></DIV>
<DIV class=div4>
<H5><A id=id-attribute-test name=id-attribute-test></A>2.5.4.5 Attribute 
Test</H5>
<P>An <A 
href="REC-xquery-20070123.htm#doc-xquery-AttributeTest">AttributeTest</A> 
is used to match an attribute node by its name and/or <A title="type annotation" 
href="REC-xquery-20070123.htm#dt-type-annotation">type 
annotation</A>. An <A 
href="REC-xquery-20070123.htm#doc-xquery-AttributeTest">AttributeTest</A> 
any take any of the following forms. In these forms, <A 
href="REC-xquery-20070123.htm#doc-xquery-AttributeName">AttributeName</A> 
need not be present in the <A title="in-scope attribute declarations" 
href="REC-xquery-20070123.htm#dt-is-attrs">in-scope 
attribute declarations</A>, but <A 
href="REC-xquery-20070123.htm#doc-xquery-TypeName">TypeName</A> 
must be present in the <A title="in-scope schema type" 
href="REC-xquery-20070123.htm#dt-is-types">in-scope 
schema types</A> [<A title=err:XPST0008 
href="REC-xquery-20070123.htm#ERRXPST0008">err:XPST0008</A>].</P>
<OL class=enumar>
  <LI>
  <P><CODE>attribute()</CODE> and <CODE>attribute(*)</CODE> match any single 
  attribute node, regardless of its name or type annotation.</P>
  <LI>
  <P><CODE>attribute(</CODE><A 
  href="REC-xquery-20070123.htm#doc-xquery-AttributeName">AttributeName</A><CODE>)</CODE> 
  matches any attribute node whose name is <A 
  href="REC-xquery-20070123.htm#doc-xquery-AttributeName">AttributeName</A>, 
  regardless of its type annotation.</P>
  <P>Example: <CODE>attribute(price)</CODE> matches any attribute node whose 
  name is <CODE>price</CODE>.</P>
  <LI>
  <P><CODE>attribute(</CODE><A 
  href="REC-xquery-20070123.htm#doc-xquery-AttributeName">AttributeName</A>, 
  <A 
  href="REC-xquery-20070123.htm#doc-xquery-TypeName">TypeName</A><CODE>)</CODE> 
  matches an attribute node whose name is <A 
  href="REC-xquery-20070123.htm#doc-xquery-AttributeName">AttributeName</A> 
  if <CODE>derives-from(</CODE><EM>AT</EM>, <A 
  href="REC-xquery-20070123.htm#doc-xquery-TypeName">TypeName</A> 
  <CODE>)</CODE> is <CODE>true</CODE>, where <EM>AT</EM> is the type annotation 
  of the attribute node.</P>
  <P>Example: <CODE>attribute(price, currency)</CODE> matches an attribute node 
  whose name is <CODE>price</CODE> and whose type annotation is 
  <CODE>currency</CODE> (or is derived from <CODE>currency</CODE>).</P>
  <LI>
  <P><CODE>attribute(*,</CODE> <A 
  href="REC-xquery-20070123.htm#doc-xquery-TypeName">TypeName</A><CODE>)</CODE> 
  matches an attribute node regardless of its name, if 
  <CODE>derives-from(</CODE><EM>AT</EM>, <A 
  href="REC-xquery-20070123.htm#doc-xquery-TypeName">TypeName</A><CODE>)</CODE> 
  is <CODE>true</CODE>, where <EM>AT</EM> is the type annotation of the 
  attribute node.</P>
  <P>Example: <CODE>attribute(*, currency)</CODE> matches any attribute node 
  whose type annotation is <CODE>currency</CODE> (or is derived from 
  <CODE>currency</CODE>), regardless of its name.</P></LI></OL></DIV>
<DIV class=div4>
<H5><A id=id-schema-attribute-test name=id-schema-attribute-test></A>2.5.4.6 
Schema Attribute Test</H5>
<P>A <A 
href="REC-xquery-20070123.htm#doc-xquery-SchemaAttributeTest">SchemaAttributeTest</A> 
matches an attribute node against a corresponding attribute declaration found in 
the <A title="in-scope attribute declarations" 
href="REC-xquery-20070123.htm#dt-is-attrs">in-scope 
attribute declarations</A>. It takes the following form:</P>
<P><CODE>schema-attribute(</CODE><A 
href="REC-xquery-20070123.htm#doc-xquery-AttributeName">AttributeName</A><CODE>)</CODE></P>
<P>If the <A 
href="REC-xquery-20070123.htm#doc-xquery-AttributeName">AttributeName</A> 
specified in the <A 
href="REC-xquery-20070123.htm#doc-xquery-SchemaAttributeTest">SchemaAttributeTest</A> 
is not found in the <A title="in-scope attribute declarations" 
href="REC-xquery-20070123.htm#dt-is-attrs">in-scope 
attribute declarations</A>, a <A title="static error" 
href="REC-xquery-20070123.htm#dt-static-error">static 
error</A> is raised [<A title=err:XPST0008 
href="REC-xquery-20070123.htm#ERRXPST0008">err:XPST0008</A>].</P>
<P>A <A 
href="REC-xquery-20070123.htm#doc-xquery-SchemaAttributeTest">SchemaAttributeTest</A> 
matches a candidate attribute node if both of the following conditions are 
satisfied:</P>
<OL class=enumar>
  <LI>
  <P>The name of the candidate node matches the specified <A 
  href="REC-xquery-20070123.htm#doc-xquery-AttributeName">AttributeName</A>.</P>
  <LI>
  <P><CODE>derives-from(</CODE><EM>AT, ET</EM><CODE>)</CODE> is 
  <CODE>true</CODE>, where <EM>AT</EM> is the type annotation of the candidate 
  node and <EM>ET</EM> is the schema type declared for attribute <A 
  href="REC-xquery-20070123.htm#doc-xquery-AttributeName">AttributeName</A> 
  in the <A title="in-scope attribute declarations" 
  href="REC-xquery-20070123.htm#dt-is-attrs">in-scope 
  attribute declarations</A>.</P></LI></OL>
<P>Example: The <A 
href="REC-xquery-20070123.htm#doc-xquery-SchemaAttributeTest">SchemaAttributeTest</A> 
<CODE>schema-attribute(color)</CODE> matches a candidate attribute node if 
<CODE>color</CODE> is a top-level attribute declaration in the <A 
title="in-scope attribute declarations" 
href="REC-xquery-20070123.htm#dt-is-attrs">in-scope 
attribute declarations</A>, the name of the candidate node is 
<CODE>color</CODE>, and the type annotation of the candidate node is the same as 
or derived from the schema type declared for the <CODE>color</CODE> 
attribute.</P></DIV></DIV></DIV>
<DIV class=div2>
<H3><A id=comments name=comments></A>2.6 Comments</H3>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-Comment 
    name=doc-xquery-Comment></A>[151]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-Comment">Comment</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"(:" (<A 
      href="REC-xquery-20070123.htm#doc-xquery-CommentContents">CommentContents</A> 
      | <A 
      href="REC-xquery-20070123.htm#doc-xquery-Comment">Comment</A>)* 
      ":)"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-CommentContents 
      name=doc-xquery-CommentContents></A>[159]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-CommentContents">CommentContents</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>(<A 
      href="REC-xquery-20070123.htm#prod-xquery-Char">Char</A>+ 
      - (Char* ('(:' | ':)') Char*))</CODE></TD></TR></TBODY></TABLE>
<P>Comments may be used to provide informative annotation for <SPAN 
class=xquery><SPAN class=xquery>a query, either in the <A title=Prolog 
href="REC-xquery-20070123.htm#dt-prolog">Prolog</A> or in 
the <A title="query body" 
href="REC-xquery-20070123.htm#dt-queryBody">Query 
Body</A></SPAN></SPAN>. Comments are lexical constructs only, and do not affect 
<SPAN class=xquery><SPAN class=xquery>query</SPAN></SPAN> processing.</P>
<P>Comments are strings, delimited by the symbols <CODE>(:</CODE> and 
<CODE>:)</CODE>. Comments may be nested.</P>
<P>A comment may be used anywhere <A title="ignorable whitespace" 
href="REC-xquery-20070123.htm#IgnorableWhitespace">ignorable 
whitespace</A> is allowed (see <A 
href="REC-xquery-20070123.htm#DefaultWhitespaceHandling"><B>A.2.4.1 
Default Whitespace Handling</B></A>).</P>
<P>The following is an example of a comment:</P>
<DIV class=exampleInner><PRE>(: Houston, we have a problem :)
</PRE></DIV></DIV></DIV>
<DIV class=div1>
<H2><A id=id-expressions name=id-expressions></A>3 Expressions</H2>
<P>This section discusses each of the basic kinds of expression. Each kind of 
expression has a name such as <CODE>PathExpr</CODE>, which is introduced on the 
left side of the grammar production that defines the expression. Since XQuery is 
a composable language, each kind of expression is defined in terms of other 
expressions whose operators have a higher precedence. In this way, the 
precedence of operators is represented explicitly in the grammar.</P>
<P>The order in which expressions are discussed in this document does not 
reflect the order of operator precedence. In general, this document introduces 
the simplest kinds of expressions first, followed by more complex expressions. 
For the complete grammar, see Appendix [<A 
href="REC-xquery-20070123.htm#nt-bnf"><B>A XQuery 
Grammar</B></A>].</P>
<P><SPAN class=xquery><SPAN class=xquery>[<A id=dt-query title=query 
name=dt-query>Definition</A>: A <B>query</B> consists of one or more <A 
title=module 
href="REC-xquery-20070123.htm#dt-module">modules</A>.] If 
a query is executable, one of its modules has a <A title="query body" 
href="REC-xquery-20070123.htm#dt-queryBody">Query 
Body</A> containing an expression whose value is the result of the query. An 
expression is represented in the XQuery grammar by the symbol <A 
href="REC-xquery-20070123.htm#doc-xquery-Expr">Expr</A>.</SPAN></SPAN></P>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-Expr 
    name=doc-xquery-Expr></A>[31]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-Expr">Expr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-ExprSingle">ExprSingle</A> 
      ("," <A 
      href="REC-xquery-20070123.htm#doc-xquery-ExprSingle">ExprSingle</A>)*</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-ExprSingle 
      name=doc-xquery-ExprSingle></A>[32]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-ExprSingle">ExprSingle</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-FLWORExpr">FLWORExpr</A><BR>| 
      <A 
      href="REC-xquery-20070123.htm#doc-xquery-QuantifiedExpr">QuantifiedExpr</A><BR>| 
      <A 
      href="REC-xquery-20070123.htm#doc-xquery-TypeswitchExpr">TypeswitchExpr</A><BR>| 
      <A 
      href="REC-xquery-20070123.htm#doc-xquery-IfExpr">IfExpr</A><BR>| 
      <A 
      href="REC-xquery-20070123.htm#doc-xquery-OrExpr">OrExpr</A></CODE></TD></TR></TBODY></TABLE>
<P>The XQuery operator that has lowest precedence is the <A 
title="comma operator" 
href="REC-xquery-20070123.htm#dt-comma-operator">comma 
operator</A>, which is used to combine two operands to form a sequence. As shown 
in the grammar, a general expression (<A 
href="REC-xquery-20070123.htm#doc-xquery-Expr">Expr</A>) 
can consist of multiple <A 
href="REC-xquery-20070123.htm#doc-xquery-ExprSingle">ExprSingle</A> 
operands, separated by commas. The name <A 
href="REC-xquery-20070123.htm#doc-xquery-ExprSingle">ExprSingle</A> 
denotes an expression that does not contain a top-level <A 
title="comma operator" 
href="REC-xquery-20070123.htm#dt-comma-operator">comma 
operator</A> (despite its name, an <A 
href="REC-xquery-20070123.htm#doc-xquery-ExprSingle">ExprSingle</A> 
may evaluate to a sequence containing more than one item.)</P>
<P>The symbol <A 
href="REC-xquery-20070123.htm#doc-xquery-ExprSingle">ExprSingle</A> 
is used in various places in the grammar where an expression is not allowed to 
contain a top-level comma. For example, each of the arguments of a function call 
must be an <A 
href="REC-xquery-20070123.htm#doc-xquery-ExprSingle">ExprSingle</A>, 
because commas are used to separate the arguments of a function call.</P>
<P>After the comma, the expressions that have next lowest precedence are <SPAN 
class=xquery><SPAN class=xquery><A 
href="REC-xquery-20070123.htm#doc-xquery-FLWORExpr">FLWORExpr</A>,</SPAN></SPAN> 
<A 
href="REC-xquery-20070123.htm#doc-xquery-QuantifiedExpr">QuantifiedExpr</A>, 
<SPAN class=xquery><SPAN class=xquery><A 
href="REC-xquery-20070123.htm#doc-xquery-TypeswitchExpr">TypeswitchExpr</A>,</SPAN></SPAN> 
<A 
href="REC-xquery-20070123.htm#doc-xquery-IfExpr">IfExpr</A>, 
and <A 
href="REC-xquery-20070123.htm#doc-xquery-OrExpr">OrExpr</A>. 
Each of these expressions is described in a separate section of this 
document.</P>
<DIV class=div2>
<H3><A id=id-primary-expressions name=id-primary-expressions></A>3.1 Primary 
Expressions</H3>
<P>[<A id=dt-primary-expression title="primary expression" 
name=dt-primary-expression>Definition</A>: <B>Primary expressions</B> are the 
basic primitives of the language. They include literals, variable references, 
context item expressions, <SPAN class=xquery><SPAN 
class=xquery>constructors,</SPAN></SPAN> and function calls. A primary 
expression may also be created by enclosing any expression in parentheses, which 
is sometimes helpful in controlling the precedence of operators.] <SPAN 
class=xquery><SPAN class=xquery>Constructors are described in <A 
href="REC-xquery-20070123.htm#id-constructors"><B>3.7 
Constructors</B></A>.</SPAN></SPAN></P>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-PrimaryExpr 
      name=doc-xquery-PrimaryExpr></A>[84]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-PrimaryExpr">PrimaryExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-Literal">Literal</A> 
      | <A 
      href="REC-xquery-20070123.htm#doc-xquery-VarRef">VarRef</A> 
      | <A 
      href="REC-xquery-20070123.htm#doc-xquery-ParenthesizedExpr">ParenthesizedExpr</A> 
      | <A 
      href="REC-xquery-20070123.htm#doc-xquery-ContextItemExpr">ContextItemExpr</A> 
      | <A 
      href="REC-xquery-20070123.htm#doc-xquery-FunctionCall">FunctionCall</A> 
      | <A 
      href="REC-xquery-20070123.htm#doc-xquery-OrderedExpr">OrderedExpr</A> 
      | <A 
      href="REC-xquery-20070123.htm#doc-xquery-UnorderedExpr">UnorderedExpr</A> 
      | <A 
      href="REC-xquery-20070123.htm#doc-xquery-Constructor">Constructor</A></CODE></TD></TR></TBODY></TABLE>
<DIV class=div3>
<H4><A id=id-literals name=id-literals></A>3.1.1 Literals</H4>
<P>[<A id=dt-literal title=literal name=dt-literal>Definition</A>: A 
<B>literal</B> is a direct syntactic representation of an atomic value.] XQuery 
supports two kinds of literals: numeric literals and string literals.</P>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-Literal 
    name=doc-xquery-Literal></A>[85]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-Literal">Literal</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-NumericLiteral">NumericLiteral</A> 
      | <A 
      href="REC-xquery-20070123.htm#doc-xquery-StringLiteral">StringLiteral</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-NumericLiteral 
      name=doc-xquery-NumericLiteral></A>[86]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-NumericLiteral">NumericLiteral</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-IntegerLiteral">IntegerLiteral</A> 
      | <A 
      href="REC-xquery-20070123.htm#doc-xquery-DecimalLiteral">DecimalLiteral</A> 
      | <A 
      href="REC-xquery-20070123.htm#doc-xquery-DoubleLiteral">DoubleLiteral</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-IntegerLiteral 
      name=doc-xquery-IntegerLiteral></A>[141]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-IntegerLiteral">IntegerLiteral</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-Digits">Digits</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-DecimalLiteral 
      name=doc-xquery-DecimalLiteral></A>[142]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-DecimalLiteral">DecimalLiteral</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>("." <A 
      href="REC-xquery-20070123.htm#doc-xquery-Digits">Digits</A>) 
      | (<A 
      href="REC-xquery-20070123.htm#doc-xquery-Digits">Digits</A> 
      "." [0-9]*)</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-DoubleLiteral 
      name=doc-xquery-DoubleLiteral></A>[143]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-DoubleLiteral">DoubleLiteral</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>(("." <A 
      href="REC-xquery-20070123.htm#doc-xquery-Digits">Digits</A>) 
      | (<A 
      href="REC-xquery-20070123.htm#doc-xquery-Digits">Digits</A> 
      ("." [0-9]*)?)) [eE] [+-]? <A 
      href="REC-xquery-20070123.htm#doc-xquery-Digits">Digits</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-StringLiteral 
      name=doc-xquery-StringLiteral></A>[144]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-StringLiteral">StringLiteral</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>('"' (<A 
      href="REC-xquery-20070123.htm#doc-xquery-PredefinedEntityRef">PredefinedEntityRef</A> 
      | <A 
      href="REC-xquery-20070123.htm#prod-xquery-CharRef">CharRef</A> 
      | <A 
      href="REC-xquery-20070123.htm#doc-xquery-EscapeQuot">EscapeQuot</A> 
      | [^"&amp;])* '"') | ("'" (<A 
      href="REC-xquery-20070123.htm#doc-xquery-PredefinedEntityRef">PredefinedEntityRef</A> 
      | <A 
      href="REC-xquery-20070123.htm#prod-xquery-CharRef">CharRef</A> 
      | <A 
      href="REC-xquery-20070123.htm#doc-xquery-EscapeApos">EscapeApos</A> 
      | [^'&amp;])* "'")</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-PredefinedEntityRef 
      name=doc-xquery-PredefinedEntityRef></A>[145]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-PredefinedEntityRef">PredefinedEntityRef</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"&amp;" ("lt" | "gt" | "amp" | "quot" | "apos") 
  ";"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-Digits 
    name=doc-xquery-Digits></A>[158]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-Digits">Digits</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>[0-9]+</CODE></TD></TR></TBODY></TABLE>
<P>The value of a <B>numeric literal</B> containing no "<CODE>.</CODE>" and no 
<CODE>e</CODE> or <CODE>E</CODE> character is an atomic value of type 
<CODE>xs:integer</CODE>. The value of a numeric literal containing 
"<CODE>.</CODE>" but no <CODE>e</CODE> or <CODE>E</CODE> character is an atomic 
value of type <CODE>xs:decimal</CODE>. The value of a numeric literal containing 
an <CODE>e</CODE> or <CODE>E</CODE> character is an atomic value of type 
<CODE>xs:double</CODE>. The value of the numeric literal is determined by 
casting it to the appropriate type according to the rules for casting from 
<CODE>xs:untypedAtomic</CODE> to a numeric type as specified in <A 
href="http://www.w3.org/TR/xpath-functions/#casting-from-strings">Section 17.1.1 
Casting from xs:string and xs:untypedAtomic</A><SUP><SMALL>FO</SMALL></SUP>.</P>
<P>The value of a <B>string literal</B> is an atomic value whose type is 
<CODE>xs:string</CODE> and whose value is the string denoted by the characters 
between the delimiting apostrophes or quotation marks. If the literal is 
delimited by apostrophes, two adjacent apostrophes within the literal are 
interpreted as a single apostrophe. Similarly, if the literal is delimited by 
quotation marks, two adjacent quotation marks within the literal are interpreted 
as one quotation mark.</P>
<DIV class=xquery>
<P class=xquery>A string literal may contain a <B>predefined entity 
reference</B>. [<A id=dt-predefined-entity-reference 
title="predefined entity reference" 
name=dt-predefined-entity-reference>Definition</A>: A <B>predefined entity 
reference</B> is a short sequence of characters, beginning with an ampersand, 
that represents a single character that might otherwise have syntactic 
significance.] Each predefined entity reference is replaced by the character it 
represents when the string literal is processed. The predefined entity 
references recognized by XQuery are as follows:</P></DIV>
<DIV class=xquery>
<TABLE class=xquery width="60%" summary="Special characters" border=1>
  <TBODY>
  <TR>
    <TD align=middle>Entity Reference</TD>
    <TD align=middle>Character Represented</TD></TR>
  <TR>
    <TD align=middle><CODE>&amp;lt;</CODE></TD>
    <TD align=middle><CODE>&lt;</CODE></TD></TR>
  <TR>
    <TD align=middle><CODE>&amp;gt;</CODE></TD>
    <TD align=middle><CODE>&gt;</CODE></TD></TR>
  <TR>
    <TD align=middle><CODE>&amp;amp;</CODE></TD>
    <TD align=middle><CODE>&amp;</CODE></TD></TR>
  <TR>
    <TD align=middle><CODE>&amp;quot;</CODE></TD>
    <TD align=middle><CODE>"</CODE></TD></TR>
  <TR>
    <TD align=middle><CODE>&amp;apos;</CODE></TD>
    <TD align=middle><CODE>'</CODE></TD></TR></TBODY></TABLE></DIV>
<DIV class=xquery>
<P class=xquery>A string literal may also contain a <B>character reference</B>. 
[<A id=dt-character-reference title="character reference" 
name=dt-character-reference>Definition</A>: A <B>character reference</B> is an 
XML-style reference to a <A 
href="REC-xquery-20070123.htm#Unicode">[Unicode]</A> 
character, identified by its decimal or hexadecimal code point.] For example, 
the Euro symbol (€) can be represented by the character reference 
<CODE>&amp;#8364;</CODE>. Character references are normatively defined in 
Section 4.1 of the XML specification (it is <A title="implementation defined" 
href="REC-xquery-20070123.htm#dt-implementation-defined">implementation-defined</A> 
whether the rules in <A 
href="REC-xquery-20070123.htm#XML">[XML 1.0]</A> or <A 
href="REC-xquery-20070123.htm#XML1.1">[XML 1.1]</A> 
apply.) A <A title="static error" 
href="REC-xquery-20070123.htm#dt-static-error">static 
error</A> [<A title=err:XQST0090 
href="REC-xquery-20070123.htm#ERRXQST0090">err:XQST0090</A>] 
is raised if a character reference does not identify a valid character in the 
version of XML that is in use.</P></DIV>
<P>Here are some examples of literal expressions:</P>
<UL>
  <LI>
  <P><CODE>"12.5"</CODE> denotes the string containing the characters '1', '2', 
  '.', and '5'.</P>
  <LI>
  <P><CODE>12</CODE> denotes the <CODE>xs:integer</CODE> value twelve.</P>
  <LI>
  <P><CODE>12.5</CODE> denotes the <CODE>xs:decimal</CODE> value twelve and one 
  half.</P>
  <LI>
  <P><CODE>125E2</CODE> denotes the <CODE>xs:double</CODE> value twelve 
  thousand, five hundred.</P>
  <LI>
  <P><CODE>"He said, ""I don't like it."""</CODE> denotes a string containing 
  two quotation marks and one apostrophe.</P>
  <LI class=xquery>
  <P><CODE>"Ben &amp;amp; Jerry&amp;apos;s"</CODE> denotes the 
  <CODE>xs:string</CODE> value "<CODE>Ben &amp; Jerry's</CODE>".</P>
  <LI class=xquery>
  <P><CODE>"&amp;#8364;99.50"</CODE> denotes the <CODE>xs:string</CODE> value 
  "<CODE>€99.50</CODE>".</P></LI></UL>
<P>The <CODE>xs:boolean</CODE> values <CODE>true</CODE> and <CODE>false</CODE> 
can be represented by calls to the <A title="built-in function" 
href="REC-xquery-20070123.htm#dt-built-in-function">built-in 
functions</A> <CODE>fn:true()</CODE> and <CODE>fn:false()</CODE>, 
respectively.</P>
<P>Values of other atomic types can be constructed by calling the <A 
title="constructor function" 
href="REC-xquery-20070123.htm#dt-constructor-function">constructor 
function</A> for the given type. The constructor functions for XML Schema 
built-in types are defined in <A 
href="REC-xquery-20070123.htm#FunctionsAndOperators">[XQuery 
1.0 and XPath 2.0 Functions and Operators]</A>. In general, the name of a 
constructor function for a given type is the same as the name of the type 
(including its namespace). For example:</P>
<UL>
  <LI>
  <P><CODE>xs:integer("12")</CODE> returns the integer value twelve.</P>
  <LI>
  <P><CODE>xs:date("2001-08-25")</CODE> returns an item whose type is 
  <CODE>xs:date</CODE> and whose value represents the date 25th August 2001.</P>
  <LI>
  <P><CODE>xs:dayTimeDuration("PT5H")</CODE> returns an item whose type is 
  <CODE>xs:dayTimeDuration</CODE> and whose value represents a duration of five 
  hours.</P></LI></UL>
<P>Constructor functions can also be used to create special values that have no 
literal representation, as in the following examples:</P>
<UL>
  <LI>
  <P><CODE>xs:float("NaN")</CODE> returns the special floating-point value, "Not 
  a Number."</P>
  <LI>
  <P><CODE>xs:double("INF")</CODE> returns the special double-precision value, 
  "positive infinity."</P></LI></UL>
<P>It is also possible to construct values of various types by using a 
<CODE>cast</CODE> expression. For example:</P>
<UL>
  <LI>
  <P><CODE>9 cast as hatsize</CODE> returns the atomic value <CODE>9</CODE> 
  whose type is <CODE>hatsize</CODE>.</P></LI></UL></DIV>
<DIV class=div3>
<H4><A id=id-variables name=id-variables></A>3.1.2 Variable References</H4>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-VarRef 
    name=doc-xquery-VarRef></A>[87]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-VarRef">VarRef</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"$" <A 
      href="REC-xquery-20070123.htm#doc-xquery-VarName">VarName</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-VarName 
    name=doc-xquery-VarName></A>[88]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-VarName">VarName</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-QName">QName</A></CODE></TD></TR></TBODY></TABLE>
<P>[<A id=dt-variable-reference title="variable reference" 
name=dt-variable-reference>Definition</A>: A <B>variable reference</B> is a 
QName preceded by a $-sign.] Two variable references are equivalent if their 
local names are the same and their namespace prefixes are bound to the same 
namespace URI in the <A title="statically known namespaces" 
href="REC-xquery-20070123.htm#dt-static-namespaces">statically 
known namespaces</A>. An unprefixed variable reference is in no namespace.</P>
<P>Every variable reference must match a name in the <A 
title="in-scope variables" 
href="REC-xquery-20070123.htm#dt-in-scope-variables">in-scope 
variables</A>, which include variables from the following sources:</P>
<OL class=enumar>
  <LI class=xquery>
  <P>A variable may be declared in a <A title=Prolog 
  href="REC-xquery-20070123.htm#dt-prolog">Prolog</A>, in 
  the current <A title=module 
  href="REC-xquery-20070123.htm#dt-module">module</A> or 
  an <B>imported module</B>. See <A 
  href="REC-xquery-20070123.htm#id-query-prolog"><B>4 
  Modules and Prologs</B></A> for a discussion of modules and Prologs.</P>
  <LI>
  <P>The <A title="in-scope variables" 
  href="REC-xquery-20070123.htm#dt-in-scope-variables">in-scope 
  variables</A> may be augmented by <A title="implementation defined" 
  href="REC-xquery-20070123.htm#dt-implementation-defined">implementation-defined</A> 
  variables.</P>
  <LI>
  <P>A variable may be bound by an XQuery expression. <SPAN class=xquery><SPAN 
  class=xquery>The kinds of expressions that can bind variables are FLWOR 
  expressions (<A 
  href="REC-xquery-20070123.htm#id-flwor-expressions"><B>3.8 
  FLWOR Expressions</B></A>), quantified expressions (<A 
  href="REC-xquery-20070123.htm#id-quantified-expressions"><B>3.11 
  Quantified Expressions</B></A>), and <CODE>typeswitch</CODE> expressions (<A 
  href="REC-xquery-20070123.htm#id-typeswitch"><B>3.12.2 
  Typeswitch</B></A>). Function calls also bind values to the formal parameters 
  of functions before executing the function body.</SPAN></SPAN></P></LI></OL>
<P>Every variable binding has a static scope. The scope defines where references 
to the variable can validly occur. It is a <A title="static error" 
href="REC-xquery-20070123.htm#dt-static-error">static 
error</A> [<A title=err:XPST0008 
href="REC-xquery-20070123.htm#ERRXPST0008">err:XPST0008</A>] 
to reference a variable that is not in scope. If a variable is bound in the <A 
title="static context" 
href="REC-xquery-20070123.htm#dt-static-context">static 
context</A> for an expression, that variable is in scope for the entire 
expression.</P>
<DIV class=xquery>
<P class=xquery>A reference to a variable that was declared 
<CODE>external</CODE>, but was not bound to a value by the external environment, 
raises a dynamic error [<A title=err:XPDY0002 
href="REC-xquery-20070123.htm#ERRXPDY0002">err:XPDY0002</A>].</P></DIV>
<P>If a variable reference matches two or more variable bindings that are in 
scope, then the reference is taken as referring to the inner binding, that is, 
the one whose scope is smaller. At evaluation time, the value of a variable 
reference is the value of the expression to which the relevant variable is 
bound. The scope of a variable binding is defined separately for each kind of 
expression that can bind variables.</P></DIV>
<DIV class=div3>
<H4><A id=id-paren-expressions name=id-paren-expressions></A>3.1.3 Parenthesized 
Expressions</H4>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-ParenthesizedExpr 
      name=doc-xquery-ParenthesizedExpr></A>[89]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-ParenthesizedExpr">ParenthesizedExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"(" <A 
      href="REC-xquery-20070123.htm#doc-xquery-Expr">Expr</A>? 
      ")"</CODE></TD></TR></TBODY></TABLE>
<P>Parentheses may be used to enforce a particular evaluation order in 
expressions that contain multiple operators. For example, the expression 
<CODE>(2 + 4) * 5</CODE> evaluates to thirty, since the parenthesized expression 
<CODE>(2 + 4)</CODE> is evaluated first and its result is multiplied by five. 
Without parentheses, the expression <CODE>2 + 4 * 5</CODE> evaluates to 
twenty-two, because the multiplication operator has higher precedence than the 
addition operator.</P>
<P>Empty parentheses are used to denote an empty sequence, as described in <A 
href="REC-xquery-20070123.htm#construct_seq"><B>3.3.1 
Constructing Sequences</B></A>.</P></DIV>
<DIV class=div3>
<H4><A id=id-context-item-expression name=id-context-item-expression></A>3.1.4 
Context Item Expression</H4>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-ContextItemExpr 
      name=doc-xquery-ContextItemExpr></A>[90]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-ContextItemExpr">ContextItemExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"."</CODE></TD></TR></TBODY></TABLE>
<P>A <B>context item expression</B> evaluates to the <A title="context item" 
href="REC-xquery-20070123.htm#dt-context-item">context 
item</A>, which may be either a node (as in the expression 
<CODE>fn:doc("bib.xml")/books/book[fn:count(./author)&gt;1]</CODE>) or an atomic 
value (as in the expression <CODE>(1 to 100)[. mod 5 eq 0]</CODE>).</P>
<P>If the <A title="context item" 
href="REC-xquery-20070123.htm#dt-context-item">context 
item</A> is undefined, a context item expression raises a dynamic error [<A 
title=err:XPDY0002 
href="REC-xquery-20070123.htm#ERRXPDY0002">err:XPDY0002</A>].</P></DIV>
<DIV class=div3>
<H4><A id=id-function-calls name=id-function-calls></A>3.1.5 Function Calls</H4>
<P>[<A id=dt-built-in-function title="built-in function" 
name=dt-built-in-function>Definition</A>: The <B>built-in functions</B> 
supported by XQuery are defined in <A 
href="REC-xquery-20070123.htm#FunctionsAndOperators">[XQuery 
1.0 and XPath 2.0 Functions and Operators]</A>.] <SPAN class=xquery><SPAN 
class=xquery>Additional functions may be declared in a <A title=Prolog 
href="REC-xquery-20070123.htm#dt-prolog">Prolog</A>, 
imported from a <A title="library module" 
href="REC-xquery-20070123.htm#dt-library-module">library 
module</A>, or provided by the external environment as part of the <A 
title="static context" 
href="REC-xquery-20070123.htm#dt-static-context">static 
context</A>.</SPAN></SPAN></P>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-FunctionCall 
      name=doc-xquery-FunctionCall></A>[93]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-FunctionCall">FunctionCall</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-QName">QName</A> 
      "(" (<A 
      href="REC-xquery-20070123.htm#doc-xquery-ExprSingle">ExprSingle</A> 
      ("," <A 
      href="REC-xquery-20070123.htm#doc-xquery-ExprSingle">ExprSingle</A>)*)? 
      ")"</CODE></TD></TR></TBODY></TABLE>
<P>A <B>function call</B> consists of a QName followed by a parenthesized list 
of zero or more expressions, called <B>arguments</B>. If the QName in the 
function call has no namespace prefix, it is considered to be in the <A 
title="default function namespace" 
href="REC-xquery-20070123.htm#dt-def-fn-ns">default 
function namespace.</A></P>
<P>If the <A title="expanded QName" 
href="REC-xquery-20070123.htm#dt-expanded-qname">expanded 
QName</A> and number of arguments in a function call do not match the name and 
arity of a <A title="function signature" 
href="REC-xquery-20070123.htm#dt-function-signature">function 
signature</A> in the <A title="static context" 
href="REC-xquery-20070123.htm#dt-static-context">static 
context</A>, a <A title="static error" 
href="REC-xquery-20070123.htm#dt-static-error">static 
error</A> is raised [<A title=err:XPST0017 
href="REC-xquery-20070123.htm#ERRXPST0017">err:XPST0017</A>].</P>
<P>A function call is evaluated as follows:</P>
<OL class=enumar>
  <LI>
  <P>Argument expressions are evaluated, producing argument values. The order of 
  argument evaluation is <A title="implementation dependent" 
  href="REC-xquery-20070123.htm#dt-implementation-dependent">implementation-dependent</A> 
  and a function need not evaluate an argument if the function can evaluate its 
  body without evaluating that argument.</P>
  <LI>
  <P>Each argument value is converted by applying the function conversion rules 
  listed below.</P>
  <LI class=xquery>
  <P>If the function is a built-in function, it is evaluated using the converted 
  argument values. The result is either an instance of the function's declared 
  return type or a dynamic error. Errors raised by built-in functions are 
  defined in <A 
  href="REC-xquery-20070123.htm#FunctionsAndOperators">[XQuery 
  1.0 and XPath 2.0 Functions and Operators]</A>.</P>
  <LI class=xquery>
  <P>If the function is a user-declared function that has a body, the converted 
  argument values are bound to the formal parameters of the function, and the 
  function body is evaluated. The value returned by the function body is then 
  converted to the declared return type of the function by applying the function 
  conversion rules.</P>
  <P>When a converted argument value is bound to a function parameter, the 
  argument value retains its most specific <A title="dynamic type" 
  href="REC-xquery-20070123.htm#dt-dynamic-type">dynamic 
  type</A>, even though this type may be derived from the type of the formal 
  parameter. For example, a function with a parameter <CODE>$p</CODE> of type 
  <CODE>xs:decimal</CODE> can be invoked with an argument of type 
  <CODE>xs:integer</CODE>, which is derived from <CODE>xs:decimal</CODE>. During 
  the processing of this function invocation, the <A title="dynamic type" 
  href="REC-xquery-20070123.htm#dt-dynamic-type">dynamic 
  type</A> of <CODE>$p</CODE> inside the body of the function is considered to 
  be <CODE>xs:integer</CODE>. Similarly, the value returned by a function 
  retains its most specific type, which may be derived from the declared return 
  type of the function. For example, a function that has a declared return type 
  of <CODE>xs:decimal</CODE> may in fact return a value of dynamic type 
  <CODE>xs:integer</CODE>.</P>
  <P>During evaluation of a function body, the <A title="static context" 
  href="REC-xquery-20070123.htm#dt-static-context">static 
  context</A> and <A title="dynamic context" 
  href="REC-xquery-20070123.htm#dt-dynamic-context">dynamic 
  context</A> for expression evaluation are defined by the <A title=module 
  href="REC-xquery-20070123.htm#dt-module">module</A> in 
  which the function is declared, which is not necessarily the same as the <A 
  title=module 
  href="REC-xquery-20070123.htm#dt-module">module</A> in 
  which the function is called. For example, the variables in scope while 
  evaluating a function body are defined by in-scope variables of the module 
  that declares the function rather than the module in which the function is 
  called. During evaluation of a function body, the <A title=focus 
  href="REC-xquery-20070123.htm#dt-focus">focus</A> 
  (context item, context position, and context size) is undefined, except where 
  it is defined by some expression inside the function body.</P>
  <LI class=xquery>
  <P>If the function is a user-declared external function, its <A 
  title="function implementation" 
  href="REC-xquery-20070123.htm#dt-function-implementation">function 
  implementation</A> is invoked with the converted argument values. The result 
  is either a value of the declared type or an <A title="implementation defined" 
  href="REC-xquery-20070123.htm#dt-implementation-defined">implementation-defined</A> 
  error (see <A 
  href="REC-xquery-20070123.htm#id-consistency-constraints"><B>2.2.5 
  Consistency Constraints</B></A>).</P></LI></OL>
<P>The <B>function conversion rules</B> are used to convert an argument value 
<SPAN class=xquery><SPAN class=xquery>or a return value</SPAN></SPAN> to its 
expected type; that is, to the declared type of the function <SPAN 
class=xquery><SPAN class=xquery>parameter or return.</SPAN></SPAN> The expected 
type is expressed as a <A title="sequence type" 
href="REC-xquery-20070123.htm#dt-sequence-type">sequence 
type</A>. The function conversion rules are applied to a given value as 
follows:</P>
<UL>
  <LI>
  <P>If the expected type is a sequence of an atomic type (possibly with an 
  occurrence indicator <CODE>*</CODE>, <CODE>+</CODE>, or <CODE>?</CODE>), the 
  following conversions are applied:</P>
  <OL class=enumar>
    <LI>
    <P><A title=atomization 
    href="REC-xquery-20070123.htm#dt-atomization">Atomization</A> 
    is applied to the given value, resulting in a sequence of atomic values.</P>
    <LI>
    <P>Each item in the atomic sequence that is of type 
    <CODE>xs:untypedAtomic</CODE> is cast to the expected atomic type. For <A 
    title="built-in function" 
    href="REC-xquery-20070123.htm#dt-built-in-function">built-in 
    functions</A> where the expected type is specified as <A title=numeric 
    href="REC-xquery-20070123.htm#dt-numeric">numeric</A>, 
    arguments of type <CODE>xs:untypedAtomic</CODE> are cast to 
    <CODE>xs:double</CODE>.</P>
    <LI>
    <P>For each <A title=numeric 
    href="REC-xquery-20070123.htm#dt-numeric">numeric</A> 
    item in the atomic sequence that can be <A title="type promotion" 
    href="REC-xquery-20070123.htm#dt-type-promotion">promoted</A> 
    to the expected atomic type using numeric promotion as described in <A 
    href="REC-xquery-20070123.htm#promotion"><B>B.1 Type 
    Promotion</B></A>, the promotion is done.</P>
    <LI>
    <P>For each item of type <CODE>xs:anyURI</CODE> in the atomic sequence that 
    can be <A title="type promotion" 
    href="REC-xquery-20070123.htm#dt-type-promotion">promoted</A> 
    to the expected atomic type using URI promotion as described in <A 
    href="REC-xquery-20070123.htm#promotion"><B>B.1 Type 
    Promotion</B></A>, the promotion is done.</P></LI></OL>
  <LI>
  <P>If, after the above conversions, the resulting value does not match the 
  expected type according to the rules for <A title="SequenceType matching" 
  href="REC-xquery-20070123.htm#dt-sequencetype-matching">SequenceType 
  Matching</A>, a <A title="type error" 
  href="REC-xquery-20070123.htm#dt-type-error">type 
  error</A> is raised [<A title=err:XPTY0004 
  href="REC-xquery-20070123.htm#ERRXPTY0004">err:XPTY0004</A>]. 
  <SPAN class=xquery><SPAN class=xquery>If the function call takes place in a <A 
  title=module 
  href="REC-xquery-20070123.htm#dt-module">module</A> 
  other than the <A title=module 
  href="REC-xquery-20070123.htm#dt-module">module</A> in 
  which the function is defined, this rule must be satisfied in both the module 
  where the function is called and the module where the function is defined (the 
  test is repeated because the two modules may have different <A 
  title="in-scope schema definitions" 
  href="REC-xquery-20070123.htm#dt-issd">in-scope schema 
  definitions</A>.)</SPAN></SPAN> Note that the rules for <A 
  title="SequenceType matching" 
  href="REC-xquery-20070123.htm#dt-sequencetype-matching">SequenceType 
  Matching</A> permit a value of a derived type to be substituted for a value of 
  its base type.</P></LI></UL>
<P>Since the arguments of a function call are separated by commas, any argument 
expression that contains a top-level <A title="comma operator" 
href="REC-xquery-20070123.htm#dt-comma-operator">comma 
operator</A> must be enclosed in parentheses. Here are some illustrative 
examples of function calls:</P>
<UL>
  <LI>
  <P><CODE>my:three-argument-function(1, 2, 3)</CODE> denotes a function call 
  with three arguments.</P>
  <LI>
  <P><CODE>my:two-argument-function((1, 2), 3)</CODE> denotes a function call 
  with two arguments, the first of which is a sequence of two values.</P>
  <LI>
  <P><CODE>my:two-argument-function(1, ())</CODE> denotes a function call with 
  two arguments, the second of which is an empty sequence.</P>
  <LI>
  <P><CODE>my:one-argument-function((1, 2, 3))</CODE> denotes a function call 
  with one argument that is a sequence of three values.</P>
  <LI>
  <P><CODE>my:one-argument-function(( ))</CODE> denotes a function call with one 
  argument that is an empty sequence.</P>
  <LI>
  <P><CODE>my:zero-argument-function( )</CODE> denotes a function call with zero 
  arguments.</P></LI></UL></DIV></DIV>
<DIV class=div2>
<H3><A id=id-path-expressions name=id-path-expressions></A>3.2 Path 
Expressions</H3>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-PathExpr 
      name=doc-xquery-PathExpr></A>[68]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-PathExpr">PathExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>("/" <A 
      href="REC-xquery-20070123.htm#doc-xquery-RelativePathExpr">RelativePathExpr</A>?)<BR>| 
      ("//" <A 
      href="REC-xquery-20070123.htm#doc-xquery-RelativePathExpr">RelativePathExpr</A>)<BR>| 
      <A 
      href="REC-xquery-20070123.htm#doc-xquery-RelativePathExpr">RelativePathExpr</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-RelativePathExpr 
      name=doc-xquery-RelativePathExpr></A>[69]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-RelativePathExpr">RelativePathExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-StepExpr">StepExpr</A> 
      (("/" | "//") <A 
      href="REC-xquery-20070123.htm#doc-xquery-StepExpr">StepExpr</A>)*</CODE></TD></TR></TBODY></TABLE>
<P>[<A id=dt-path-expression title="path expression" 
name=dt-path-expression>Definition</A>: A <B>path expression</B> can be used to 
locate nodes within trees. A path expression consists of a series of one or more 
<A title=step 
href="REC-xquery-20070123.htm#dt-step">steps</A>, 
separated by "<CODE>/</CODE>" or "<CODE>//</CODE>", and optionally beginning 
with "<CODE>/</CODE>" or "<CODE>//</CODE>".] An initial "<CODE>/</CODE>" or 
"<CODE>//</CODE>" is an abbreviation for one or more initial steps that are 
implicitly added to the beginning of the path expression, as described 
below.</P>
<P>A path expression consisting of a single step is evaluated as described in <A 
href="REC-xquery-20070123.htm#id-steps"><B>3.2.1 
Steps</B></A>.</P>
<P>A "<CODE>/</CODE>" at the beginning of a path expression is an abbreviation 
for the initial step <CODE>fn:root(self::node()) treat as 
document-node()/</CODE> (however, if the "<CODE>/</CODE>" is the entire path 
expression, the trailing "<CODE>/</CODE>" is omitted from the expansion.) The 
effect of this initial step is to begin the path at the root node of the tree 
that contains the context node. If the context item is not a node, a <A 
title="type error" 
href="REC-xquery-20070123.htm#dt-type-error">type 
error</A> is raised [<A title=err:XPTY0020 
href="REC-xquery-20070123.htm#ERRXPTY0020">err:XPTY0020</A>]. 
At evaluation time, if the root node above the context node is not a document 
node, a <A title="dynamic error" 
href="REC-xquery-20070123.htm#dt-dynamic-error">dynamic 
error</A> is raised [<A title=err:XPDY0050 
href="REC-xquery-20070123.htm#ERRXPDY0050">err:XPDY0050</A>].</P>
<P>A "<CODE>//</CODE>" at the beginning of a path expression is an abbreviation 
for the initial steps <CODE>fn:root(self::node()) treat as 
document-node()/descendant-or-self::node()/</CODE> (however, "<CODE>//</CODE>" 
by itself is not a valid path expression [<A title=err:XPST0003 
href="REC-xquery-20070123.htm#ERRXPST0003">err:XPST0003</A>].) 
The effect of these initial steps is to establish an initial node sequence that 
contains the root of the tree in which the context node is found, plus all nodes 
descended from this root. This node sequence is used as the input to subsequent 
steps in the path expression. If the context item is not a node, a <A 
title="type error" 
href="REC-xquery-20070123.htm#dt-type-error">type 
error</A> is raised [<A title=err:XPTY0020 
href="REC-xquery-20070123.htm#ERRXPTY0020">err:XPTY0020</A>]. 
At evaluation time, if the root node above the context node is not a document 
node, a <A title="dynamic error" 
href="REC-xquery-20070123.htm#dt-dynamic-error">dynamic 
error</A> is raised [<A title=err:XPDY0050 
href="REC-xquery-20070123.htm#ERRXPDY0050">err:XPDY0050</A>].</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>The descendants of a node do not include attribute nodes .</P></DIV>
<P>Each non-initial occurrence of "<CODE>//</CODE>" in a path expression is 
expanded as described in <A 
href="REC-xquery-20070123.htm#abbrev"><B>3.2.4 
Abbreviated Syntax</B></A>, leaving a sequence of steps separated by 
"<CODE>/</CODE>". This sequence of steps is then evaluated from left to right. 
Each operation <CODE>E1/E2</CODE> is evaluated as follows: Expression 
<CODE>E1</CODE> is evaluated, and if the result is not a (possibly empty) 
sequence of nodes, a <A title="type error" 
href="REC-xquery-20070123.htm#dt-type-error">type 
error</A> is raised [<A title=err:XPTY0019 
href="REC-xquery-20070123.htm#ERRXPTY0019">err:XPTY0019</A>]. 
Each node resulting from the evaluation of <CODE>E1</CODE> then serves in turn 
to provide an <B>inner focus</B> for an evaluation of <CODE>E2</CODE>, as 
described in <A 
href="REC-xquery-20070123.htm#eval_context"><B>2.1.2 
Dynamic Context</B></A>. The sequences resulting from all the evaluations of 
<CODE>E2</CODE> are combined as follows:</P>
<OL class=enumar>
  <LI>
  <P>If every evaluation of <CODE>E2</CODE> returns a (possibly empty) sequence 
  of nodes, these sequences are combined, and duplicate nodes are eliminated 
  based on node identity. <SPAN class=xquery><SPAN class=xquery>If <A 
  title="ordering mode" 
  href="REC-xquery-20070123.htm#dt-ordering-mode">ordering 
  mode</A> is <CODE>ordered</CODE>, the resulting node sequence is returned in 
  <A title="document order" 
  href="REC-xquery-20070123.htm#dt-document-order">document 
  order</A>; otherwise it is returned in <A title="implementation dependent" 
  href="REC-xquery-20070123.htm#dt-implementation-dependent">implementation-dependent</A> 
  order.</SPAN></SPAN></P>
  <LI>
  <P>If every evaluation of <CODE>E2</CODE> returns a (possibly empty) sequence 
  of atomic values, these sequences are concatenated and returned. <SPAN 
  class=xquery><SPAN class=xquery>If <A title="ordering mode" 
  href="REC-xquery-20070123.htm#dt-ordering-mode">ordering 
  mode</A> is <CODE>ordered</CODE>, the returned sequence preserves the 
  orderings within and among the subsequences generated by the evaluations of 
  <CODE>E2</CODE>; otherwise the order of the returned sequence is <A 
  title="implementation dependent" 
  href="REC-xquery-20070123.htm#dt-implementation-dependent">implementation-dependent</A>.</SPAN></SPAN></P>
  <LI>
  <P>If the multiple evaluations of <CODE>E2</CODE> return at least one node and 
  at least one atomic value, a <A title="type error" 
  href="REC-xquery-20070123.htm#dt-type-error">type 
  error</A> is raised [<A title=err:XPTY0018 
  href="REC-xquery-20070123.htm#ERRXPTY0018">err:XPTY0018</A>].</P></LI></OL>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>Since each step in a path provides context nodes for the following step, in 
effect, only the last step in a path is allowed to return a sequence of atomic 
values.</P></DIV>
<P>As an example of a path expression, <CODE>child::div1/child::para</CODE> 
selects the <CODE>para</CODE> element children of the <CODE>div1</CODE> element 
children of the context node, or, in other words, the <CODE>para</CODE> element 
grandchildren of the context node that have <CODE>div1</CODE> parents.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P id=Chg-slash-note>The "<CODE>/</CODE>" character can be used either as a 
complete path expression or as the beginning of a longer path expression such as 
"<CODE>/*</CODE>". Also, "<CODE>*</CODE>" is both the multiply operator and a 
wildcard in path expressions. This can cause parsing difficulties when 
"<CODE>/</CODE>" appears on the left hand side of "<CODE>*</CODE>". This is 
resolved using the <A 
href="REC-xquery-20070123.htm#parse-note-leading-lone-slash">leading-lone-slash</A> 
constraint. For example, "<CODE>/*</CODE>" and "<CODE>/ *</CODE>" are valid path 
expressions containing wildcards, but "<CODE>/*5</CODE>" and "<CODE>/ * 
5</CODE>" raise syntax errors. Parentheses must be used when "<CODE>/</CODE>" is 
used on the left hand side of an operator, as in "<CODE>(/) * 5</CODE>". 
Similarly, "<CODE>4 + / * 5</CODE>" raises a syntax error, but "<CODE>4 + (/) * 
5</CODE>" is a valid expression. The expression "<CODE>4 + /</CODE>" is also 
valid, because <CODE>/</CODE> does not occur on the left hand side of the 
operator.</P></DIV>
<DIV class=div3>
<H4><A id=id-steps name=id-steps></A>3.2.1 Steps</H4>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-StepExpr 
      name=doc-xquery-StepExpr></A>[70]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-StepExpr">StepExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-FilterExpr">FilterExpr</A> 
      | <A 
      href="REC-xquery-20070123.htm#doc-xquery-AxisStep">AxisStep</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-AxisStep 
      name=doc-xquery-AxisStep></A>[71]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-AxisStep">AxisStep</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>(<A 
      href="REC-xquery-20070123.htm#doc-xquery-ReverseStep">ReverseStep</A> 
      | <A 
      href="REC-xquery-20070123.htm#doc-xquery-ForwardStep">ForwardStep</A>) 
      <A 
      href="REC-xquery-20070123.htm#doc-xquery-PredicateList">PredicateList</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-ForwardStep 
      name=doc-xquery-ForwardStep></A>[72]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-ForwardStep">ForwardStep</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>(<A 
      href="REC-xquery-20070123.htm#doc-xquery-ForwardAxis">ForwardAxis</A> 
      <A 
      href="REC-xquery-20070123.htm#doc-xquery-NodeTest">NodeTest</A>) 
      | <A 
      href="REC-xquery-20070123.htm#doc-xquery-AbbrevForwardStep">AbbrevForwardStep</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-ReverseStep 
      name=doc-xquery-ReverseStep></A>[75]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-ReverseStep">ReverseStep</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>(<A 
      href="REC-xquery-20070123.htm#doc-xquery-ReverseAxis">ReverseAxis</A> 
      <A 
      href="REC-xquery-20070123.htm#doc-xquery-NodeTest">NodeTest</A>) 
      | <A 
      href="REC-xquery-20070123.htm#doc-xquery-AbbrevReverseStep">AbbrevReverseStep</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-PredicateList 
      name=doc-xquery-PredicateList></A>[82]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-PredicateList">PredicateList</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-Predicate">Predicate</A>*</CODE></TD></TR></TBODY></TABLE>
<P>[<A id=dt-step title=step name=dt-step>Definition</A>: A <B>step</B> is a 
part of a <A title="path expression" 
href="REC-xquery-20070123.htm#dt-path-expression">path 
expression</A> that generates a sequence of items and then filters the sequence 
by zero or more <A title=predicate 
href="REC-xquery-20070123.htm#dt-predicate">predicates</A>. 
The value of the step consists of those items that satisfy the predicates, 
working from left to right. A step may be either an <A title="axis step" 
href="REC-xquery-20070123.htm#dt-axis-step">axis step</A> 
or a <A title="filter expression" 
href="REC-xquery-20070123.htm#dt-filter-expression">filter 
expression</A>.] Filter expressions are described in <A 
href="REC-xquery-20070123.htm#id-filter-expr"><B>3.3.2 
Filter Expressions</B></A>.</P>
<P>[<A id=dt-axis-step title="axis step" name=dt-axis-step>Definition</A>: An 
<B>axis step</B> returns a sequence of nodes that are reachable from the context 
node via a specified axis. Such a step has two parts: an <B>axis</B>, which 
defines the "direction of movement" for the step, and a <A title="node test" 
href="REC-xquery-20070123.htm#dt-node-test">node 
test</A>, which selects nodes based on their kind, name, and/or <A 
title="type annotation" 
href="REC-xquery-20070123.htm#dt-type-annotation">type 
annotation</A>.] If the context item is a node, an axis step returns a sequence 
of zero or more nodes; otherwise, a <A title="type error" 
href="REC-xquery-20070123.htm#dt-type-error">type 
error</A> is raised [<A title=err:XPTY0020 
href="REC-xquery-20070123.htm#ERRXPTY0020">err:XPTY0020</A>]. 
<SPAN class=xquery><SPAN class=xquery>If <A title="ordering mode" 
href="REC-xquery-20070123.htm#dt-ordering-mode">ordering 
mode</A> is <CODE>ordered</CODE>, the resulting node sequence is returned in <A 
title="document order" 
href="REC-xquery-20070123.htm#dt-document-order">document 
order</A>; otherwise it is returned in <A title="implementation dependent" 
href="REC-xquery-20070123.htm#dt-implementation-dependent">implementation-dependent</A> 
order.</SPAN></SPAN> An axis step may be either a <B>forward step</B> or a 
<B>reverse step</B>, followed by zero or more <A title=predicate 
href="REC-xquery-20070123.htm#dt-predicate">predicates</A>.</P>
<P>In the <B>abbreviated syntax</B> for a step, the axis can be omitted and 
other shorthand notations can be used as described in <A 
href="REC-xquery-20070123.htm#abbrev"><B>3.2.4 
Abbreviated Syntax</B></A>.</P>
<P>The unabbreviated syntax for an axis step consists of the axis name and node 
test separated by a double colon. The result of the step consists of the nodes 
reachable from the context node via the specified axis that have the node kind, 
name, and/or <A title="type annotation" 
href="REC-xquery-20070123.htm#dt-type-annotation">type 
annotation</A> specified by the node test. For example, the step 
<CODE>child::para</CODE> selects the <CODE>para</CODE> element children of the 
context node: <CODE>child</CODE> is the name of the axis, and <CODE>para</CODE> 
is the name of the element nodes to be selected on this axis. The available axes 
are described in <A 
href="REC-xquery-20070123.htm#axes"><B>3.2.1.1 
Axes</B></A>. The available node tests are described in <A 
href="REC-xquery-20070123.htm#node-tests"><B>3.2.1.2 Node 
Tests</B></A>. Examples of steps are provided in <A 
href="REC-xquery-20070123.htm#unabbrev"><B>3.2.3 
Unabbreviated Syntax</B></A> and <A 
href="REC-xquery-20070123.htm#abbrev"><B>3.2.4 
Abbreviated Syntax</B></A>.</P>
<DIV class=div4>
<H5><A id=axes name=axes></A>3.2.1.1 Axes</H5>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-ForwardAxis 
      name=doc-xquery-ForwardAxis></A>[73]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-ForwardAxis">ForwardAxis</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>("child" "::")<BR>| ("descendant" "::")<BR>| ("attribute" 
      "::")<BR>| ("self" "::")<BR>| ("descendant-or-self" "::")<BR>| 
      ("following-sibling" "::")<BR>| ("following" "::")</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-ReverseAxis 
      name=doc-xquery-ReverseAxis></A>[76]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-ReverseAxis">ReverseAxis</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>("parent" "::")<BR>| ("ancestor" "::")<BR>| ("preceding-sibling" 
      "::")<BR>| ("preceding" "::")<BR>| ("ancestor-or-self" 
  "::")</CODE></TD></TR></TBODY></TABLE>
<DIV class=xquery>
<P class=xquery>XQuery supports the following axes (subject to limitations as 
described in <A 
href="REC-xquery-20070123.htm#id-full-axis-feature"><B>5.2.4 
Full Axis Feature</B></A>):</P></DIV>
<UL>
  <LI>
  <P>The <CODE>child</CODE> axis contains the children of the context node, 
  which are the nodes returned by the <CODE>dm:children</CODE> accessor in <A 
  href="REC-xquery-20070123.htm#datamodel">[XQuery/XPath 
  Data Model (XDM)]</A>.</P>
  <DIV class=note>
  <P class=prefix><B>Note:</B></P>
  <P>Only document nodes and element nodes have children. If the context node is 
  any other kind of node, or if the context node is an empty document or element 
  node, then the child axis is an empty sequence. The children of a document 
  node or element node may be element, processing instruction, comment, or text 
  nodes. Attribute and document nodes can never appear as children.</P></DIV>
  <LI>
  <P>the <CODE>descendant</CODE> axis is defined as the transitive closure of 
  the child axis; it contains the descendants of the context node (the children, 
  the children of the children, and so on)</P>
  <LI>
  <P>the <CODE>parent</CODE> axis contains the sequence returned by the 
  <CODE>dm:parent</CODE> accessor in <A 
  href="REC-xquery-20070123.htm#datamodel">[XQuery/XPath 
  Data Model (XDM)]</A>, which returns the parent of the context node, or an 
  empty sequence if the context node has no parent</P>
  <DIV class=note>
  <P class=prefix><B>Note:</B></P>
  <P>An attribute node may have an element node as its parent, even though the 
  attribute node is not a child of the element node.</P></DIV>
  <LI>
  <P>the <CODE>ancestor</CODE> axis is defined as the transitive closure of the 
  parent axis; it contains the ancestors of the context node (the parent, the 
  parent of the parent, and so on)</P>
  <DIV class=note>
  <P class=prefix><B>Note:</B></P>
  <P>The ancestor axis includes the root node of the tree in which the context 
  node is found, unless the context node is the root node.</P></DIV>
  <LI>
  <P>the <CODE>following-sibling</CODE> axis contains the context node's 
  following siblings, those children of the context node's parent that occur 
  after the context node in <A title="document order" 
  href="REC-xquery-20070123.htm#dt-document-order">document 
  order</A>; if the context node is an attribute node, the 
  <CODE>following-sibling</CODE> axis is empty</P>
  <LI>
  <P>the <CODE>preceding-sibling</CODE> axis contains the context node's 
  preceding siblings, those children of the context node's parent that occur 
  before the context node in <A title="document order" 
  href="REC-xquery-20070123.htm#dt-document-order">document 
  order</A>; if the context node is an attribute node, the 
  <CODE>preceding-sibling</CODE> axis is empty</P>
  <LI>
  <P>the <CODE>following</CODE> axis contains all nodes that are descendants of 
  the root of the tree in which the context node is found, are not descendants 
  of the context node, and occur after the context node in <A 
  title="document order" 
  href="REC-xquery-20070123.htm#dt-document-order">document 
  order</A></P>
  <LI>
  <P>the <CODE>preceding</CODE> axis contains all nodes that are descendants of 
  the root of the tree in which the context node is found, are not ancestors of 
  the context node, and occur before the context node in <A 
  title="document order" 
  href="REC-xquery-20070123.htm#dt-document-order">document 
  order</A></P>
  <LI>
  <P>the <CODE>attribute</CODE> axis contains the attributes of the context 
  node, which are the nodes returned by the <CODE>dm:attributes</CODE> accessor 
  in <A 
  href="REC-xquery-20070123.htm#datamodel">[XQuery/XPath 
  Data Model (XDM)]</A>; the axis will be empty unless the context node is an 
  element</P>
  <LI>
  <P>the <CODE>self</CODE> axis contains just the context node itself</P>
  <LI>
  <P>the <CODE>descendant-or-self</CODE> axis contains the context node and the 
  descendants of the context node</P>
  <LI>
  <P>the <CODE>ancestor-or-self</CODE> axis contains the context node and the 
  ancestors of the context node; thus, the ancestor-or-self axis will always 
  include the root node</P></LI></UL>
<P>Axes can be categorized as <B>forward axes</B> and <B>reverse axes</B>. An 
axis that only ever contains the context node or nodes that are after the 
context node in <A title="document order" 
href="REC-xquery-20070123.htm#dt-document-order">document 
order</A> is a forward axis. An axis that only ever contains the context node or 
nodes that are before the context node in <A title="document order" 
href="REC-xquery-20070123.htm#dt-document-order">document 
order</A> is a reverse axis.</P>
<P>The <CODE>parent</CODE>, <CODE>ancestor</CODE>, 
<CODE>ancestor-or-self</CODE>, <CODE>preceding</CODE>, and 
<CODE>preceding-sibling</CODE> axes are reverse axes; all other axes are forward 
axes. The <CODE>ancestor</CODE>, <CODE>descendant</CODE>, 
<CODE>following</CODE>, <CODE>preceding</CODE> and <CODE>self</CODE> axes 
partition a document (ignoring attribute nodes): they do not overlap and 
together they contain all the nodes in the document.</P>
<P>[<A id=dt-principal-node-kind title="principal node kind" 
name=dt-principal-node-kind>Definition</A>: Every axis has a <B>principal node 
kind</B>. If an axis can contain elements, then the principal node kind is 
element; otherwise, it is the kind of nodes that the axis can contain.] 
Thus:</P>
<UL>
  <LI>
  <P>For the attribute axis, the principal node kind is attribute.</P>
  <LI>
  <P>For all other axes, the principal node kind is element.</P></LI></UL></DIV>
<DIV class=div4>
<H5><A id=node-tests name=node-tests></A>3.2.1.2 Node Tests</H5>
<P>[<A id=dt-node-test title="node test" name=dt-node-test>Definition</A>: A 
<B>node test</B> is a condition that must be true for each node selected by a <A 
title=step 
href="REC-xquery-20070123.htm#dt-step">step</A>.] The 
condition may be based on the kind of the node (element, attribute, text, 
document, comment, or processing instruction), the name of the node, or (in the 
case of element, attribute, and document nodes), the <A title="type annotation" 
href="REC-xquery-20070123.htm#dt-type-annotation">type 
annotation</A> of the node.</P>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-NodeTest 
      name=doc-xquery-NodeTest></A>[78]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-NodeTest">NodeTest</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-KindTest">KindTest</A> 
      | <A 
      href="REC-xquery-20070123.htm#doc-xquery-NameTest">NameTest</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-NameTest 
      name=doc-xquery-NameTest></A>[79]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-NameTest">NameTest</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-QName">QName</A> 
      | <A 
      href="REC-xquery-20070123.htm#doc-xquery-Wildcard">Wildcard</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-Wildcard 
      name=doc-xquery-Wildcard></A>[80]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-Wildcard">Wildcard</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"*"<BR>| (<A 
      href="REC-xquery-20070123.htm#prod-xquery-NCName">NCName</A> 
      ":" "*")<BR>| ("*" ":" <A 
      href="REC-xquery-20070123.htm#prod-xquery-NCName">NCName</A>)</CODE></TD></TR></TBODY></TABLE>
<P>[<A id=dt-name-test title="name test" name=dt-name-test>Definition</A>: A 
node test that consists only of a QName or a Wildcard is called a <B>name 
test</B>.] A name test is true if and only if the <B>kind</B> of the node is the 
<A title="principal node kind" 
href="REC-xquery-20070123.htm#dt-principal-node-kind">principal 
node kind</A> for the step axis and the <A title="expanded QName" 
href="REC-xquery-20070123.htm#dt-expanded-qname">expanded 
QName</A> of the node is equal (as defined by the <CODE>eq</CODE> operator) to 
the <A title="expanded QName" 
href="REC-xquery-20070123.htm#dt-expanded-qname">expanded 
QName</A> specified by the name test. For example, <CODE>child::para</CODE> 
selects the <CODE>para</CODE> element children of the context node; if the 
context node has no <CODE>para</CODE> children, it selects an empty set of 
nodes. <CODE>attribute::abc:href</CODE> selects the attribute of the context 
node with the QName <CODE>abc:href</CODE>; if the context node has no such 
attribute, it selects an empty set of nodes.</P>
<P>A QName in a name test is resolved into an <A title="expanded QName" 
href="REC-xquery-20070123.htm#dt-expanded-qname">expanded 
QName</A> using the <A title="statically known namespaces" 
href="REC-xquery-20070123.htm#dt-static-namespaces">statically 
known namespaces</A> in the expression context. It is a <A title="static error" 
href="REC-xquery-20070123.htm#dt-static-error">static 
error</A> [<A title=err:XPST0081 
href="REC-xquery-20070123.htm#ERRXPST0081">err:XPST0081</A>] 
if the QName has a prefix that does not correspond to any statically known 
namespace. An unprefixed QName, when used as a name test on an axis whose <A 
title="principal node kind" 
href="REC-xquery-20070123.htm#dt-principal-node-kind">principal 
node kind</A> is element, has the namespace URI of the <A 
title="default element/type namespace" 
href="REC-xquery-20070123.htm#dt-def-elemtype-ns">default 
element/type namespace</A> in the expression context; otherwise, it has no 
namespace URI.</P>
<P>A name test is not satisfied by an element node whose name does not match the 
<A title="expanded QName" 
href="REC-xquery-20070123.htm#dt-expanded-qname">expanded 
QName</A> of the name test, even if it is in a <A title="substitution group" 
href="REC-xquery-20070123.htm#dt-substitution-group">substitution 
group</A> whose head is the named element.</P>
<P>A node test <CODE>*</CODE> is true for any node of the <A 
title="principal node kind" 
href="REC-xquery-20070123.htm#dt-principal-node-kind">principal 
node kind</A> of the step axis. For example, <CODE>child::*</CODE> will select 
all element children of the context node, and <CODE>attribute::*</CODE> will 
select all attributes of the context node.</P>
<P>A node test can have the form <CODE>NCName:*</CODE>. In this case, the prefix 
is expanded in the same way as with a QName, using the <A 
title="statically known namespaces" 
href="REC-xquery-20070123.htm#dt-static-namespaces">statically 
known namespaces</A> in the <A title="static context" 
href="REC-xquery-20070123.htm#dt-static-context">static 
context</A>. If the prefix is not found in the statically known namespaces, a <A 
title="static error" 
href="REC-xquery-20070123.htm#dt-static-error">static 
error</A> is raised [<A title=err:XPST0081 
href="REC-xquery-20070123.htm#ERRXPST0081">err:XPST0081</A>]. 
The node test is true for any node of the <A title="principal node kind" 
href="REC-xquery-20070123.htm#dt-principal-node-kind">principal 
node kind</A> of the step axis whose <A title="expanded QName" 
href="REC-xquery-20070123.htm#dt-expanded-qname">expanded 
QName</A> has the namespace URI to which the prefix is bound, regardless of the 
local part of the name.</P>
<P>A node test can also have the form <CODE>*:NCName</CODE>. In this case, the 
node test is true for any node of the <A title="principal node kind" 
href="REC-xquery-20070123.htm#dt-principal-node-kind">principal 
node kind</A> of the step axis whose local name matches the given NCName, 
regardless of its namespace or lack of a namespace.</P>
<P>[<A id=dt-kind-test title="kind test" name=dt-kind-test>Definition</A>: An 
alternative form of a node test called a <B>kind test</B> can select nodes based 
on their kind, name, and <A title="type annotation" 
href="REC-xquery-20070123.htm#dt-type-annotation">type 
annotation</A>.] The syntax and semantics of a kind test are described in <A 
href="REC-xquery-20070123.htm#id-sequencetype-syntax"><B>2.5.3 
SequenceType Syntax</B></A> and <A 
href="REC-xquery-20070123.htm#id-sequencetype-matching"><B>2.5.4 
SequenceType Matching</B></A>. When a kind test is used in a <A 
title="node test" 
href="REC-xquery-20070123.htm#dt-node-test">node 
test</A>, only those nodes on the designated axis that match the kind test are 
selected. Shown below are several examples of kind tests that might be used in 
path expressions:</P>
<UL>
  <LI>
  <P><CODE>node()</CODE> matches any node.</P>
  <LI>
  <P><CODE>text()</CODE> matches any text node.</P>
  <LI>
  <P><CODE>comment()</CODE> matches any comment node.</P>
  <LI>
  <P><CODE>element()</CODE> matches any element node.</P>
  <LI>
  <P><CODE>schema-element(person)</CODE> matches any element node whose name is 
  <CODE>person</CODE> (or is in the <A title="substitution group" 
  href="REC-xquery-20070123.htm#dt-substitution-group">substitution 
  group</A> headed by <CODE>person</CODE>), and whose type annotation is the 
  same as (or is derived from) the declared type of the <CODE>person</CODE> 
  element in the <A title="in-scope element declarations" 
  href="REC-xquery-20070123.htm#dt-is-elems">in-scope 
  element declarations</A>.</P>
  <LI>
  <P><CODE>element(person)</CODE> matches any element node whose name is 
  <CODE>person</CODE>, regardless of its type annotation.</P>
  <LI>
  <P><CODE>element(person, surgeon)</CODE> matches any non-nilled element node 
  whose name is <CODE>person</CODE>, and whose type annotation is 
  <CODE>surgeon</CODE> or is derived from <CODE>surgeon</CODE>.</P>
  <LI>
  <P><CODE>element(*, surgeon)</CODE> matches any non-nilled element node whose 
  type annotation is <CODE>surgeon</CODE> (or is derived from 
  <CODE>surgeon</CODE>), regardless of its name.</P>
  <LI>
  <P><CODE>attribute()</CODE> matches any attribute node.</P>
  <LI>
  <P><CODE>attribute(price)</CODE> matches any attribute whose name is 
  <CODE>price</CODE>, regardless of its type annotation.</P>
  <LI>
  <P><CODE>attribute(*, xs:decimal)</CODE> matches any attribute whose type 
  annotation is <CODE>xs:decimal</CODE> (or is derived from 
  <CODE>xs:decimal</CODE>), regardless of its name.</P>
  <LI>
  <P><CODE>document-node()</CODE> matches any document node.</P>
  <LI>
  <P><CODE>document-node(element(book))</CODE> matches any document node whose 
  content consists of a single element node that satisfies the <A 
  title="kind test" 
  href="REC-xquery-20070123.htm#dt-kind-test">kind 
  test</A> <CODE>element(book)</CODE>, interleaved with zero or more comments 
  and processing instructions.</P></LI></UL></DIV></DIV>
<DIV class=div3>
<H4><A id=id-predicates name=id-predicates></A>3.2.2 Predicates</H4>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-Predicate 
      name=doc-xquery-Predicate></A>[83]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-Predicate">Predicate</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"[" <A 
      href="REC-xquery-20070123.htm#doc-xquery-Expr">Expr</A> 
      "]"</CODE></TD></TR></TBODY></TABLE>
<P>[<A id=dt-predicate title=predicate name=dt-predicate>Definition</A>: A 
<B>predicate</B> consists of an expression, called a <B>predicate 
expression</B>, enclosed in square brackets. A predicate serves to filter a 
sequence, retaining some items and discarding others.] In the case of multiple 
adjacent predicates, the predicates are applied from left to right, and the 
result of applying each predicate serves as the input sequence for the following 
predicate.</P>
<P>For each item in the input sequence, the predicate expression is evaluated 
using an <B>inner focus</B>, defined as follows: The context item is the item 
currently being tested against the predicate. The context size is the number of 
items in the input sequence. The context position is the position of the context 
item within the input sequence. For the purpose of evaluating the context 
position within a predicate, the input sequence is considered to be sorted as 
follows: into document order if the predicate is in a forward-axis step, into 
reverse document order if the predicate is in a reverse-axis step, or in its 
original order if the predicate is not in a step.</P>
<P>For each item in the input sequence, the result of the predicate expression 
is coerced to an <CODE>xs:boolean</CODE> value, called the <B>predicate truth 
value</B>, as described below. Those items for which the predicate truth value 
is <CODE>true</CODE> are retained, and those for which the predicate truth value 
is <CODE>false</CODE> are discarded.</P>
<P>The predicate truth value is derived by applying the following rules, in 
order:</P>
<OL class=enumar>
  <LI>
  <P>If the value of the predicate expression is a <A title=singleton 
  href="REC-xquery-20070123.htm#dt-singleton">singleton</A> 
  atomic value of a <A title=numeric 
  href="REC-xquery-20070123.htm#dt-numeric">numeric</A> 
  type or derived from a <A title=numeric 
  href="REC-xquery-20070123.htm#dt-numeric">numeric</A> 
  type, the predicate truth value is <CODE>true</CODE> if the value of the 
  predicate expression is equal (by the <CODE>eq</CODE> operator) to the 
  <B>context position</B>, and is <CODE>false</CODE> otherwise. [<A 
  id=dt-numeric-predicate title="numeric predicate" 
  name=dt-numeric-predicate>Definition</A>: A predicate whose predicate 
  expression returns a numeric type is called a <B>numeric predicate</B>.]</P>
  <DIV class=note>
  <P class=prefix><B>Note:</B></P>
  <P>In a region of a query where <A title="ordering mode" 
  href="REC-xquery-20070123.htm#dt-ordering-mode">ordering 
  mode</A> is <CODE>unordered</CODE>, the result of a numeric predicate is 
  nondeterministic, as explained in <A 
  href="REC-xquery-20070123.htm#id-unordered-expressions"><B>3.9 
  Ordered and Unordered Expressions</B></A>.</P></DIV>
  <LI>
  <P>Otherwise, the predicate truth value is the <A 
  title="effective boolean value" 
  href="REC-xquery-20070123.htm#dt-ebv">effective boolean 
  value</A> of the predicate expression.</P></LI></OL>
<P>Here are some examples of <A title="axis step" 
href="REC-xquery-20070123.htm#dt-axis-step">axis 
steps</A> that contain predicates:</P>
<UL>
  <LI>
  <P>This example selects the second <CODE>chapter</CODE> element that is a 
  child of the context node:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>child::chapter[2]
</PRE></DIV></DIV>
  <LI>
  <P>This example selects all the descendants of the context node that are 
  elements named <CODE>"toy"</CODE> and whose <CODE>color</CODE> attribute has 
  the value <CODE>"red"</CODE>:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>descendant::toy[attribute::color = "red"]
</PRE></DIV></DIV>
  <LI>
  <P>This example selects all the <CODE>employee</CODE> children of the context 
  node that have both a <CODE>secretary</CODE> child element and an 
  <CODE>assistant</CODE> child element:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>child::employee[secretary][assistant]
</PRE></DIV></DIV></LI></UL>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>When using <A title=predicate 
href="REC-xquery-20070123.htm#dt-predicate">predicates</A> 
with a sequence of nodes selected using a <B>reverse axis</B>, it is important 
to remember that the the context positions for such a sequence are assigned in 
<A title="reverse document order" 
href="REC-xquery-20070123.htm#dt-reverse-document-order">reverse 
document order</A>. For example, <CODE>preceding::foo[1]</CODE> returns the 
first qualifying <CODE>foo</CODE> element in <A title="reverse document order" 
href="REC-xquery-20070123.htm#dt-reverse-document-order">reverse 
document order</A>, because the predicate is part of an <A title="axis step" 
href="REC-xquery-20070123.htm#dt-axis-step">axis step</A> 
using a reverse axis. By contrast, <CODE>(preceding::foo)[1]</CODE> returns the 
first qualifying <CODE>foo</CODE> element in <A title="document order" 
href="REC-xquery-20070123.htm#dt-document-order">document 
order</A>, because the parentheses cause <CODE>(preceding::foo)</CODE> to be 
parsed as a <A title="primary expression" 
href="REC-xquery-20070123.htm#dt-primary-expression">primary 
expression</A> in which context positions are assigned in document order. 
Similarly, <CODE>ancestor::*[1]</CODE> returns the nearest ancestor element, 
because the <CODE>ancestor</CODE> axis is a reverse axis, whereas 
<CODE>(ancestor::*)[1]</CODE> returns the root element (first ancestor in 
document order).</P>
<P>The fact that a reverse-axis step assigns context positions in reverse 
document order for the purpose of evaluating predicates does not alter the fact 
that the final result of the step <SPAN class=xquery><SPAN class=xquery>(when in 
ordered mode)</SPAN></SPAN> is always in document order.</P></DIV></DIV>
<DIV class=div3>
<H4><A id=unabbrev name=unabbrev></A>3.2.3 Unabbreviated Syntax</H4>
<P>This section provides a number of examples of path expressions in which the 
axis is explicitly specified in each <A title=step 
href="REC-xquery-20070123.htm#dt-step">step</A>. The 
syntax used in these examples is called the <B>unabbreviated syntax</B>. In many 
common cases, it is possible to write path expressions more concisely using an 
<B>abbreviated syntax</B>, as explained in <A 
href="REC-xquery-20070123.htm#abbrev"><B>3.2.4 
Abbreviated Syntax</B></A>.</P>
<UL>
  <LI>
  <P><CODE>child::para</CODE> selects the <CODE>para</CODE> element children of 
  the context node</P>
  <LI>
  <P><CODE>child::*</CODE> selects all element children of the context node</P>
  <LI>
  <P><CODE>child::text()</CODE> selects all text node children of the context 
  node</P>
  <LI>
  <P><CODE>child::node()</CODE> selects all the children of the context node. 
  Note that no attribute nodes are returned, because attributes are not 
  children.</P>
  <LI>
  <P><CODE>attribute::name</CODE> selects the <CODE>name</CODE> attribute of the 
  context node</P>
  <LI>
  <P><CODE>attribute::*</CODE> selects all the attributes of the context 
node</P>
  <LI>
  <P><CODE>parent::node()</CODE> selects the parent of the context node. If the 
  context node is an attribute node, this expression returns the element node 
  (if any) to which the attribute node is attached.</P>
  <LI>
  <P><CODE>descendant::para</CODE> selects the <CODE>para</CODE> element 
  descendants of the context node</P>
  <LI>
  <P><CODE>ancestor::div</CODE> selects all <CODE>div</CODE> ancestors of the 
  context node</P>
  <LI>
  <P><CODE>ancestor-or-self::div</CODE> selects the <CODE>div</CODE> ancestors 
  of the context node and, if the context node is a <CODE>div</CODE> element, 
  the context node as well</P>
  <LI>
  <P><CODE>descendant-or-self::para</CODE> selects the <CODE>para</CODE> element 
  descendants of the context node and, if the context node is a 
  <CODE>para</CODE> element, the context node as well</P>
  <LI>
  <P><CODE>self::para</CODE> selects the context node if it is a 
  <CODE>para</CODE> element, and otherwise returns an empty sequence</P>
  <LI>
  <P><CODE>child::chapter/descendant::para</CODE> selects the <CODE>para</CODE> 
  element descendants of the <CODE>chapter</CODE> element children of the 
  context node</P>
  <LI>
  <P><CODE>child::*/child::para</CODE> selects all <CODE>para</CODE> 
  grandchildren of the context node</P>
  <LI>
  <P><CODE>/</CODE> selects the root of the tree that contains the context node, 
  but raises a dynamic error if this root is not a document node</P>
  <LI>
  <P><CODE>/descendant::para</CODE> selects all the <CODE>para</CODE> elements 
  in the same document as the context node</P>
  <LI>
  <P><CODE>/descendant::list/child::member</CODE> selects all the 
  <CODE>member</CODE> elements that have a <CODE>list</CODE> parent and that are 
  in the same document as the context node</P>
  <LI>
  <P><CODE>child::para[fn:position() = 1]</CODE> selects the first 
  <CODE>para</CODE> child of the context node</P>
  <LI>
  <P><CODE>child::para[fn:position() = fn:last()]</CODE> selects the last 
  <CODE>para</CODE> child of the context node</P>
  <LI>
  <P><CODE>child::para[fn:position() = fn:last()-1]</CODE> selects the last but 
  one <CODE>para</CODE> child of the context node</P>
  <LI>
  <P><CODE>child::para[fn:position() &gt; 1]</CODE> selects all the 
  <CODE>para</CODE> children of the context node other than the first 
  <CODE>para</CODE> child of the context node</P>
  <LI>
  <P><CODE>following-sibling::chapter[fn:position() = 1]</CODE>selects the next 
  <CODE>chapter</CODE> sibling of the context node</P>
  <LI>
  <P><CODE>preceding-sibling::chapter[fn:position() = 1]</CODE>selects the 
  previous <CODE>chapter</CODE> sibling of the context node</P>
  <LI>
  <P><CODE>/descendant::figure[fn:position() = 42]</CODE> selects the 
  forty-second <CODE>figure</CODE> element in the document containing the 
  context node</P>
  <LI>
  <P><CODE>/child::book/child::chapter[fn:position() = 
  5]/child::section[fn:position() = 2]</CODE> selects the second 
  <CODE>section</CODE> of the fifth <CODE>chapter</CODE> of the 
  <CODE>book</CODE> whose parent is the document node that contains the context 
  node</P>
  <LI>
  <P><CODE>child::para[attribute::type eq "warning"]</CODE>selects all 
  <CODE>para</CODE> children of the context node that have a <CODE>type</CODE> 
  attribute with value <CODE>warning</CODE></P>
  <LI>
  <P><CODE>child::para[attribute::type eq 'warning'][fn:position() = 
  5]</CODE>selects the fifth <CODE>para</CODE> child of the context node that 
  has a <CODE>type</CODE> attribute with value <CODE>warning</CODE></P>
  <LI>
  <P><CODE>child::para[fn:position() = 5][attribute::type eq 
  "warning"]</CODE>selects the fifth <CODE>para</CODE> child of the context node 
  if that child has a <CODE>type</CODE> attribute with value 
  <CODE>warning</CODE></P>
  <LI>
  <P><CODE>child::chapter[child::title = 'Introduction']</CODE>selects the 
  <CODE>chapter</CODE> children of the context node that have one or more 
  <CODE>title</CODE> children whose <A title="typed value" 
  href="REC-xquery-20070123.htm#dt-typed-value">typed 
  value</A> is equal to the string <CODE>Introduction</CODE></P>
  <LI>
  <P><CODE>child::chapter[child::title]</CODE> selects the <CODE>chapter</CODE> 
  children of the context node that have one or more <CODE>title</CODE> 
  children</P>
  <LI>
  <P><CODE>child::*[self::chapter or self::appendix]</CODE> selects the 
  <CODE>chapter</CODE> and <CODE>appendix</CODE> children of the context 
node</P>
  <LI>
  <P><CODE>child::*[self::chapter or self::appendix][fn:position() = 
  fn:last()]</CODE> selects the last <CODE>chapter</CODE> or 
  <CODE>appendix</CODE> child of the context node</P></LI></UL></DIV>
<DIV class=div3>
<H4><A id=abbrev name=abbrev></A>3.2.4 Abbreviated Syntax</H4>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-AbbrevForwardStep 
      name=doc-xquery-AbbrevForwardStep></A>[74]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-AbbrevForwardStep">AbbrevForwardStep</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"@"? <A 
      href="REC-xquery-20070123.htm#doc-xquery-NodeTest">NodeTest</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-AbbrevReverseStep 
      name=doc-xquery-AbbrevReverseStep></A>[77]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-AbbrevReverseStep">AbbrevReverseStep</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>".."</CODE></TD></TR></TBODY></TABLE>
<P>The abbreviated syntax permits the following abbreviations:</P>
<OL class=enumar>
  <LI>
  <P>The attribute axis <CODE>attribute::</CODE> can be abbreviated by 
  <CODE>@</CODE>. For example, a path expression 
  <CODE>para[@type="warning"]</CODE> is short for 
  <CODE>child::para[attribute::type="warning"]</CODE> and so selects 
  <CODE>para</CODE> children with a <CODE>type</CODE> attribute with value equal 
  to <CODE>warning</CODE>.</P>
  <LI>
  <P>If the axis name is omitted from an <A title="axis step" 
  href="REC-xquery-20070123.htm#dt-axis-step">axis 
  step</A>, the default axis is <CODE>child</CODE> unless the axis step contains 
  an <A 
  href="REC-xquery-20070123.htm#doc-xquery-AttributeTest">AttributeTest</A> 
  or <A 
  href="REC-xquery-20070123.htm#doc-xquery-SchemaAttributeTest">SchemaAttributeTest</A>; 
  in that case, the default axis is <CODE>attribute</CODE>. For example, the 
  path expression <CODE>section/para</CODE> is an abbreviation for 
  <CODE>child::section/child::para</CODE>, and the path expression 
  <CODE>section/@id</CODE> is an abbreviation for 
  <CODE>child::section/attribute::id</CODE>. Similarly, 
  <CODE>section/attribute(id)</CODE> is an abbreviation for 
  <CODE>child::section/attribute::attribute(id)</CODE>. Note that the latter 
  expression contains both an axis specification and a <A title="node test" 
  href="REC-xquery-20070123.htm#dt-node-test">node 
  test</A>.</P>
  <LI>
  <P>Each non-initial occurrence of <CODE>//</CODE> is effectively replaced by 
  <CODE>/descendant-or-self::node()/</CODE> during processing of a path 
  expression. For example, <CODE>div1//para</CODE> is short for 
  <CODE>child::div1/descendant-or-self::node()/child::para</CODE> and so will 
  select all <CODE>para</CODE> descendants of <CODE>div1</CODE> children.</P>
  <DIV class=note>
  <P class=prefix><B>Note:</B></P>
  <P>The path expression <CODE>//para[1]</CODE> does <EM>not</EM> mean the same 
  as the path expression <CODE>/descendant::para[1]</CODE>. The latter selects 
  the first descendant <CODE>para</CODE> element; the former selects all 
  descendant <CODE>para</CODE> elements that are the first <CODE>para</CODE> 
  children of their respective parents.</P></DIV>
  <LI>
  <P>A step consisting of <CODE>..</CODE> is short for 
  <CODE>parent::node()</CODE>. For example, <CODE>../title</CODE> is short for 
  <CODE>parent::node()/child::title</CODE> and so will select the 
  <CODE>title</CODE> children of the parent of the context node.</P>
  <DIV class=note>
  <P class=prefix><B>Note:</B></P>
  <P>The expression <CODE>.</CODE>, known as a <B>context item expression</B>, 
  is a <A title="primary expression" 
  href="REC-xquery-20070123.htm#dt-primary-expression">primary 
  expression</A>, and is described in <A 
  href="REC-xquery-20070123.htm#id-context-item-expression"><B>3.1.4 
  Context Item Expression</B></A>.</P></DIV></LI></OL>
<P>Here are some examples of path expressions that use the abbreviated 
syntax:</P>
<UL>
  <LI>
  <P><CODE>para</CODE> selects the <CODE>para</CODE> element children of the 
  context node</P>
  <LI>
  <P><CODE>*</CODE> selects all element children of the context node</P>
  <LI>
  <P><CODE>text()</CODE> selects all text node children of the context node</P>
  <LI>
  <P><CODE>@name</CODE> selects the <CODE>name</CODE> attribute of the context 
  node</P>
  <LI>
  <P><CODE>@*</CODE> selects all the attributes of the context node</P>
  <LI>
  <P><CODE>para[1]</CODE> selects the first <CODE>para</CODE> child of the 
  context node</P>
  <LI>
  <P><CODE>para[fn:last()]</CODE> selects the last <CODE>para</CODE> child of 
  the context node</P>
  <LI>
  <P><CODE>*/para</CODE> selects all <CODE>para</CODE> grandchildren of the 
  context node</P>
  <LI>
  <P><CODE>/book/chapter[5]/section[2]</CODE> selects the second 
  <CODE>section</CODE> of the fifth <CODE>chapter</CODE> of the 
  <CODE>book</CODE> whose parent is the document node that contains the context 
  node</P>
  <LI>
  <P><CODE>chapter//para</CODE> selects the <CODE>para</CODE> element 
  descendants of the <CODE>chapter</CODE> element children of the context 
  node</P>
  <LI>
  <P><CODE>//para</CODE> selects all the <CODE>para</CODE> descendants of the 
  root document node and thus selects all <CODE>para</CODE> elements in the same 
  document as the context node</P>
  <LI>
  <P><CODE>//@version</CODE> selects all the <CODE>version</CODE> attribute 
  nodes that are in the same document as the context node</P>
  <LI>
  <P><CODE>//list/member</CODE> selects all the <CODE>member</CODE> elements in 
  the same document as the context node that have a <CODE>list</CODE> parent</P>
  <LI>
  <P><CODE>.//para</CODE> selects the <CODE>para</CODE> element descendants of 
  the context node</P>
  <LI>
  <P><CODE>..</CODE> selects the parent of the context node</P>
  <LI>
  <P><CODE>../@lang</CODE> selects the <CODE>lang</CODE> attribute of the parent 
  of the context node</P>
  <LI>
  <P><CODE>para[@type="warning"]</CODE> selects all <CODE>para</CODE> children 
  of the context node that have a <CODE>type</CODE> attribute with value 
  <CODE>warning</CODE></P>
  <LI>
  <P><CODE>para[@type="warning"][5]</CODE> selects the fifth <CODE>para</CODE> 
  child of the context node that has a <CODE>type</CODE> attribute with value 
  <CODE>warning</CODE></P>
  <LI>
  <P><CODE>para[5][@type="warning"]</CODE> selects the fifth <CODE>para</CODE> 
  child of the context node if that child has a <CODE>type</CODE> attribute with 
  value <CODE>warning</CODE></P>
  <LI>
  <P><CODE>chapter[title="Introduction"]</CODE> selects the <CODE>chapter</CODE> 
  children of the context node that have one or more <CODE>title</CODE> children 
  whose <A title="typed value" 
  href="REC-xquery-20070123.htm#dt-typed-value">typed 
  value</A> is equal to the string <CODE>Introduction</CODE></P>
  <LI>
  <P><CODE>chapter[title]</CODE> selects the <CODE>chapter</CODE> children of 
  the context node that have one or more <CODE>title</CODE> children</P>
  <LI>
  <P><CODE>employee[@secretary and @assistant]</CODE> selects all the 
  <CODE>employee</CODE> children of the context node that have both a 
  <CODE>secretary</CODE> attribute and an <CODE>assistant</CODE> attribute</P>
  <LI>
  <P><CODE>book/(chapter|appendix)/section</CODE> selects every 
  <CODE>section</CODE> element that has a parent that is either a 
  <CODE>chapter</CODE> or an <CODE>appendix</CODE> element, that in turn is a 
  child of a <CODE>book</CODE> element that is a child of the context node.</P>
  <LI>
  <P>If <CODE>E</CODE> is any expression that returns a sequence of nodes, then 
  the expression <CODE>E/.</CODE> returns the same nodes in <A 
  title="document order" 
  href="REC-xquery-20070123.htm#dt-document-order">document 
  order</A>, with duplicates eliminated based on node 
identity.</P></LI></UL></DIV></DIV>
<DIV class=div2>
<H3><A id=id-sequence-expressions name=id-sequence-expressions></A>3.3 Sequence 
Expressions</H3>
<P>XQuery supports operators to construct, filter, and combine <A title=sequence 
href="REC-xquery-20070123.htm#dt-sequence">sequences</A> 
of <A title=item 
href="REC-xquery-20070123.htm#dt-item">items</A>. 
Sequences are never nested—for example, combining the values <CODE>1</CODE>, 
<CODE>(2, 3)</CODE>, and <CODE>( )</CODE> into a single sequence results in the 
sequence <CODE>(1, 2, 3)</CODE>.</P>
<DIV class=div3>
<H4><A id=construct_seq name=construct_seq></A>3.3.1 Constructing Sequences</H4>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=noid_N12B32.doc-xquery-Expr 
      name=noid_N12B32.doc-xquery-Expr></A>[31]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-Expr">Expr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-ExprSingle">ExprSingle</A> 
      ("," <A 
      href="REC-xquery-20070123.htm#doc-xquery-ExprSingle">ExprSingle</A>)*</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-RangeExpr 
      name=doc-xquery-RangeExpr></A>[49]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-RangeExpr">RangeExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-AdditiveExpr">AdditiveExpr</A> 
      ( "to" <A 
      href="REC-xquery-20070123.htm#doc-xquery-AdditiveExpr">AdditiveExpr</A> 
      )?</CODE></TD></TR></TBODY></TABLE>
<P>[<A id=dt-comma-operator title="comma operator" 
name=dt-comma-operator>Definition</A>: One way to construct a sequence is by 
using the <B>comma operator</B>, which evaluates each of its operands and 
concatenates the resulting sequences, in order, into a single result sequence.] 
Empty parentheses can be used to denote an empty sequence.</P>
<P>A sequence may contain duplicate atomic values or nodes, but a sequence is 
never an item in another sequence. When a new sequence is created by 
concatenating two or more input sequences, the new sequence contains all the 
items of the input sequences and its length is the sum of the lengths of the 
input sequences.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>In places where the grammar calls for <A 
href="REC-xquery-20070123.htm#doc-xquery-ExprSingle">ExprSingle</A>, 
such as the arguments of a function call, any expression that contains a 
top-level comma operator must be enclosed in parentheses.</P></DIV>
<P>Here are some examples of expressions that construct sequences:</P>
<UL>
  <LI>
  <P>The result of this expression is a sequence of five integers:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>(10, 1, 2, 3, 4)
</PRE></DIV></DIV>
  <LI>
  <P>This expression combines four sequences of length one, two, zero, and two, 
  respectively, into a single sequence of length five. The result of this 
  expression is the sequence <CODE>10, 1, 2, 3, 4</CODE>.</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>(10, (1, 2), (), (3, 4))
</PRE></DIV></DIV>
  <LI>
  <P>The result of this expression is a sequence containing all 
  <CODE>salary</CODE> children of the context node followed by all 
  <CODE>bonus</CODE> children.</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>(salary, bonus)
</PRE></DIV></DIV>
  <LI>
  <P>Assuming that <CODE>$price</CODE> is bound to the value <CODE>10.50</CODE>, 
  the result of this expression is the sequence <CODE>10.50, 10.50</CODE>.</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>($price, $price)
</PRE></DIV></DIV></LI></UL>
<P>A <B>range expression</B> can be used to construct a sequence of consecutive 
integers. Each of the operands of the <CODE>to</CODE> operator is converted as 
though it was an argument of a function with the expected parameter type 
<CODE>xs:integer?</CODE>. If either operand is an empty sequence, or if the 
integer derived from the first operand is greater than the integer derived from 
the second operand, the result of the range expression is an empty sequence. If 
the two operands convert to the same integer, the result of the range expression 
is that integer. Otherwise, the result is a sequence containing the two integer 
operands and every integer between the two operands, in increasing order.</P>
<UL>
  <LI>
  <P>This example uses a range expression as one operand in constructing a 
  sequence. It evaluates to the sequence <CODE>10, 1, 2, 3, 4</CODE>.</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>(10, 1 to 4)
</PRE></DIV></DIV>
  <LI>
  <P>This example constructs a sequence of length one containing the single 
  integer <CODE>10</CODE>.</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>10 to 10
</PRE></DIV></DIV>
  <LI>
  <P>The result of this example is a sequence of length zero.</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>15 to 10
</PRE></DIV></DIV>
  <LI>
  <P>This example uses the <CODE>fn:reverse</CODE> function to construct a 
  sequence of six integers in decreasing order. It evaluates to the sequence 
  <CODE>15, 14, 13, 12, 11, 10</CODE>.</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>fn:reverse(10 to 15)
</PRE></DIV></DIV></LI></UL></DIV>
<DIV class=div3>
<H4><A id=id-filter-expr name=id-filter-expr></A>3.3.2 Filter Expressions</H4>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-FilterExpr 
      name=doc-xquery-FilterExpr></A>[81]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-FilterExpr">FilterExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-PrimaryExpr">PrimaryExpr</A> 
      <A 
      href="REC-xquery-20070123.htm#doc-xquery-PredicateList">PredicateList</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=noid_N12BD9.doc-xquery-PredicateList 
      name=noid_N12BD9.doc-xquery-PredicateList></A>[82]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-PredicateList">PredicateList</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-Predicate">Predicate</A>*</CODE></TD></TR></TBODY></TABLE>
<P>[<A id=dt-filter-expression title="filter expression" 
name=dt-filter-expression>Definition</A>: A <B>filter expression</B> consists 
simply of a <B>primary expression</B> followed by zero or more <A 
title=predicate 
href="REC-xquery-20070123.htm#dt-predicate">predicates</A>. 
The result of the filter expression consists of the items returned by the 
primary expression, filtered by applying each predicate in turn, working from 
left to right.] If no predicates are specified, the result is simply the result 
of the primary expression. The ordering of the items returned by a filter 
expression is the same as their order in the result of the primary expression. 
Context positions are assigned to items based on their ordinal position in the 
result sequence. The first context position is 1.</P>
<P>Here are some examples of filter expressions:</P>
<UL>
  <LI>
  <P>Given a sequence of products in a variable, return only those products 
  whose price is greater than 100.</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>$products[price gt 100]
</PRE></DIV></DIV>
  <LI>
  <P>List all the integers from 1 to 100 that are divisible by 5. (See <A 
  href="REC-xquery-20070123.htm#construct_seq"><B>3.3.1 
  Constructing Sequences</B></A> for an explanation of the <CODE>to</CODE> 
  operator.)</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>(1 to 100)[. mod 5 eq 0]
</PRE></DIV></DIV>
  <LI>
  <P>The result of the following expression is the integer 25:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>(21 to 29)[5]
</PRE></DIV></DIV>
  <LI>
  <P>The following example returns the fifth through ninth items in the sequence 
  bound to variable <CODE>$orders</CODE>.</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>$orders[fn:position() = (5 to 9)]
</PRE></DIV></DIV>
  <LI>
  <P>The following example illustrates the use of a filter expression as a <A 
  title=step 
  href="REC-xquery-20070123.htm#dt-step">step</A> in a <A 
  title="path expression" 
  href="REC-xquery-20070123.htm#dt-path-expression">path 
  expression</A>. It returns the last chapter or appendix within the book bound 
  to variable <CODE>$book</CODE>:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>$book/(chapter | appendix)[fn:last()]
</PRE></DIV></DIV>
  <LI>
  <P>The following example also illustrates the use of a filter expression as a 
  <A title=step 
  href="REC-xquery-20070123.htm#dt-step">step</A> in a <A 
  title="path expression" 
  href="REC-xquery-20070123.htm#dt-path-expression">path 
  expression</A>. It returns the element node within the specified document 
  whose ID value is <CODE>tiger</CODE>:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>fn:doc("zoo.xml")/fn:id('tiger')
</PRE></DIV></DIV></LI></UL></DIV>
<DIV class=div3>
<H4><A id=combining_seq name=combining_seq></A>3.3.3 Combining Node 
Sequences</H4>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-UnionExpr 
      name=doc-xquery-UnionExpr></A>[52]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-UnionExpr">UnionExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-IntersectExceptExpr">IntersectExceptExpr</A> 
      ( ("union" | "|") <A 
      href="REC-xquery-20070123.htm#doc-xquery-IntersectExceptExpr">IntersectExceptExpr</A> 
      )*</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-IntersectExceptExpr 
      name=doc-xquery-IntersectExceptExpr></A>[53]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-IntersectExceptExpr">IntersectExceptExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-InstanceofExpr">InstanceofExpr</A> 
      ( ("intersect" | "except") <A 
      href="REC-xquery-20070123.htm#doc-xquery-InstanceofExpr">InstanceofExpr</A> 
      )*</CODE></TD></TR></TBODY></TABLE>
<P>XQuery provides the following operators for combining sequences of nodes:</P>
<UL>
  <LI>
  <P>The <CODE>union</CODE> and <CODE>|</CODE> operators are equivalent. They 
  take two node sequences as operands and return a sequence containing all the 
  nodes that occur in either of the operands.</P>
  <LI>
  <P>The <CODE>intersect</CODE> operator takes two node sequences as operands 
  and returns a sequence containing all the nodes that occur in both 
  operands.</P>
  <LI>
  <P>The <CODE>except</CODE> operator takes two node sequences as operands and 
  returns a sequence containing all the nodes that occur in the first operand 
  but not in the second operand.</P></LI></UL>
<P>All these operators eliminate duplicate nodes from their result sequences 
based on node identity. <SPAN class=xquery><SPAN class=xquery>If <A 
title="ordering mode" 
href="REC-xquery-20070123.htm#dt-ordering-mode">ordering 
mode</A> is <CODE>ordered</CODE>, the resulting sequence is returned in <A 
title="document order" 
href="REC-xquery-20070123.htm#dt-document-order">document 
order</A>; otherwise it is returned in <A title="implementation dependent" 
href="REC-xquery-20070123.htm#dt-implementation-dependent">implementation-dependent</A> 
order.</SPAN></SPAN></P>
<P>If an operand of <CODE>union</CODE>, <CODE>intersect</CODE>, or 
<CODE>except</CODE> contains an item that is not a node, a <A title="type error" 
href="REC-xquery-20070123.htm#dt-type-error">type 
error</A> is raised [<A title=err:XPTY0004 
href="REC-xquery-20070123.htm#ERRXPTY0004">err:XPTY0004</A>].</P>
<P>Here are some examples of expressions that combine sequences. Assume the 
existence of three element nodes that we will refer to by symbolic names A, B, 
and C. Assume that the variables <CODE>$seq1</CODE>, <CODE>$seq2</CODE> and 
<CODE>$seq3</CODE> are bound to the following sequences of these nodes:</P>
<UL>
  <LI>
  <P><CODE>$seq1</CODE> is bound to (A, B)</P>
  <LI>
  <P><CODE>$seq2</CODE> is bound to (A, B)</P>
  <LI>
  <P><CODE>$seq3</CODE> is bound to (B, C)</P></LI></UL>
<P>Then:</P>
<UL>
  <LI>
  <P><CODE>$seq1 union $seq2</CODE> evaluates to the sequence (A, B).</P>
  <LI>
  <P><CODE>$seq2 union $seq3</CODE> evaluates to the sequence (A, B, C).</P>
  <LI>
  <P><CODE>$seq1 intersect $seq2</CODE> evaluates to the sequence (A, B).</P>
  <LI>
  <P><CODE>$seq2 intersect $seq3</CODE> evaluates to the sequence containing B 
  only.</P>
  <LI>
  <P><CODE>$seq1 except $seq2</CODE> evaluates to the empty sequence.</P>
  <LI>
  <P><CODE>$seq2 except $seq3</CODE> evaluates to the sequence containing A 
  only.</P></LI></UL>
<P>In addition to the sequence operators described here, <A 
href="REC-xquery-20070123.htm#FunctionsAndOperators">[XQuery 
1.0 and XPath 2.0 Functions and Operators]</A> includes functions for indexed 
access to items or sub-sequences of a sequence, for indexed insertion or removal 
of items in a sequence, and for removing duplicate items from a 
sequence.</P></DIV></DIV>
<DIV class=div2>
<H3><A id=id-arithmetic name=id-arithmetic></A>3.4 Arithmetic Expressions</H3>
<P>XQuery provides arithmetic operators for addition, subtraction, 
multiplication, division, and modulus, in their usual binary and unary 
forms.</P>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-AdditiveExpr 
      name=doc-xquery-AdditiveExpr></A>[50]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-AdditiveExpr">AdditiveExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-MultiplicativeExpr">MultiplicativeExpr</A> 
      ( ("+" | "-") <A 
      href="REC-xquery-20070123.htm#doc-xquery-MultiplicativeExpr">MultiplicativeExpr</A> 
      )*</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-MultiplicativeExpr 
      name=doc-xquery-MultiplicativeExpr></A>[51]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-MultiplicativeExpr">MultiplicativeExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-UnionExpr">UnionExpr</A> 
      ( ("*" | "div" | "idiv" | "mod") <A 
      href="REC-xquery-20070123.htm#doc-xquery-UnionExpr">UnionExpr</A> 
      )*</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-UnaryExpr 
      name=doc-xquery-UnaryExpr></A>[58]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-UnaryExpr">UnaryExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>("-" | "+")* <A 
      href="REC-xquery-20070123.htm#doc-xquery-ValueExpr">ValueExpr</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-ValueExpr 
      name=doc-xquery-ValueExpr></A>[59]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-ValueExpr">ValueExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-ValidateExpr">ValidateExpr</A> 
      | <A 
      href="REC-xquery-20070123.htm#doc-xquery-PathExpr">PathExpr</A> 
      | <A 
      href="REC-xquery-20070123.htm#doc-xquery-ExtensionExpr">ExtensionExpr</A></CODE></TD></TR></TBODY></TABLE>
<P>A subtraction operator must be preceded by whitespace if it could otherwise 
be interpreted as part of the previous token. For example, <CODE>a-b</CODE> will 
be interpreted as a name, but <CODE>a - b</CODE> and <CODE>a -b</CODE> will be 
interpreted as arithmetic expressions. (See <A 
href="REC-xquery-20070123.htm#whitespace-rules"><B>A.2.4 
Whitespace Rules</B></A> for further details on whitespace handling.)</P>
<P>The first step in evaluating an arithmetic expression is to evaluate its 
operands. The order in which the operands are evaluated is <A 
title="implementation dependent" 
href="REC-xquery-20070123.htm#dt-implementation-dependent">implementation-dependent</A>.</P>
<P><SPAN class=xquery><SPAN class=xquery>Each</SPAN></SPAN> operand is evaluated 
by applying the following steps, in order:</P>
<OL class=enumar>
  <LI>
  <P><A title=atomization 
  href="REC-xquery-20070123.htm#dt-atomization">Atomization</A> 
  is applied to the operand. The result of this operation is called the 
  <B>atomized operand</B>.</P>
  <LI>
  <P>If the atomized operand is an empty sequence, the result of the arithmetic 
  expression is an empty sequence, and the implementation need not evaluate the 
  other operand or apply the operator. However, an implementation may choose to 
  evaluate the other operand in order to determine whether it raises an 
  error.</P>
  <LI>
  <P>If the atomized operand is a sequence of length greater than one, a <A 
  title="type error" 
  href="REC-xquery-20070123.htm#dt-type-error">type 
  error</A> is raised [<A title=err:XPTY0004 
  href="REC-xquery-20070123.htm#ERRXPTY0004">err:XPTY0004</A>].</P>
  <LI>
  <P>If the atomized operand is of type <CODE>xs:untypedAtomic</CODE>, it is 
  cast to <CODE>xs:double</CODE>. If the cast fails, a <A title="dynamic error" 
  href="REC-xquery-20070123.htm#dt-dynamic-error">dynamic 
  error</A> is raised. [err:FORG0001]</P></LI></OL>
<P>After evaluation of the operands, if the types of the operands are a valid 
combination for the given arithmetic operator, the operator is applied to the 
operands, resulting in an atomic value or a <A title="dynamic error" 
href="REC-xquery-20070123.htm#dt-dynamic-error">dynamic 
error</A> (for example, an error might result from dividing by zero.) The 
combinations of atomic types that are accepted by the various arithmetic 
operators, and their respective result types, are listed in <A 
href="REC-xquery-20070123.htm#mapping"><B>B.2 Operator 
Mapping</B></A> together with the <A title="operator function" 
href="REC-xquery-20070123.htm#dt-operator-function">operator 
functions</A> that define the semantics of the operator for each type 
combination, including the dynamic errors that can be raised by the operator. 
The definitions of the operator functions are found in <A 
href="REC-xquery-20070123.htm#FunctionsAndOperators">[XQuery 
1.0 and XPath 2.0 Functions and Operators]</A>.</P>
<P>If the types of the operands, after evaluation, are not a valid combination 
for the given operator, according to the rules in <A 
href="REC-xquery-20070123.htm#mapping"><B>B.2 Operator 
Mapping</B></A>, a <A title="type error" 
href="REC-xquery-20070123.htm#dt-type-error">type 
error</A> is raised [<A title=err:XPTY0004 
href="REC-xquery-20070123.htm#ERRXPTY0004">err:XPTY0004</A>].</P>
<P>XQuery supports two division operators named <CODE>div</CODE> and 
<CODE>idiv</CODE>. Each of these operators accepts two operands of any <A 
title=numeric 
href="REC-xquery-20070123.htm#dt-numeric">numeric</A> 
type. As described in <A 
href="REC-xquery-20070123.htm#FunctionsAndOperators">[XQuery 
1.0 and XPath 2.0 Functions and Operators]</A>, <CODE>$arg1 idiv $arg2</CODE> is 
equivalent to <CODE>($arg1 div $arg2) cast as xs:integer?</CODE> except for 
error cases.</P>
<P>Here are some examples of arithmetic expressions:</P>
<UL>
  <LI>
  <P>The first expression below returns the <CODE>xs:decimal</CODE> value 
  <CODE>-1.5</CODE>, and the second expression returns the 
  <CODE>xs:integer</CODE> value <CODE>-1</CODE>:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>-3 div 2
-3 idiv 2
</PRE></DIV></DIV>
  <LI>
  <P>Subtraction of two date values results in a value of type 
  <CODE>xs:dayTimeDuration</CODE>:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>$emp/hiredate - $emp/birthdate
</PRE></DIV></DIV>
  <LI>
  <P>This example illustrates the difference between a subtraction operator and 
  a hyphen:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>$unit-price - $unit-discount
</PRE></DIV></DIV>
  <LI>
  <P>Unary operators have higher precedence than binary operators, subject of 
  course to the use of parentheses. Therefore, the following two examples have 
  different meanings:</P>
  <DIV class=exampleInner><PRE>-$bellcost + $whistlecost
-($bellcost + $whistlecost)
</PRE></DIV></LI></UL>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P id=note-consecutive-unary-ops>Multiple consecutive unary arithmetic operators 
are permitted by XQuery for compatibility with <A 
href="REC-xquery-20070123.htm#XPath">[XPath 
1.0]</A>.</P></DIV></DIV>
<DIV class=div2>
<H3><A id=id-comparisons name=id-comparisons></A>3.5 Comparison Expressions</H3>
<P>Comparison expressions allow two values to be compared. XQuery provides three 
kinds of comparison expressions, called value comparisons, general comparisons, 
and node comparisons.</P>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-ComparisonExpr 
      name=doc-xquery-ComparisonExpr></A>[48]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-ComparisonExpr">ComparisonExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-RangeExpr">RangeExpr</A> 
      ( (<A 
      href="REC-xquery-20070123.htm#doc-xquery-ValueComp">ValueComp</A><BR>| 
      <A 
      href="REC-xquery-20070123.htm#doc-xquery-GeneralComp">GeneralComp</A><BR>| 
      <A 
      href="REC-xquery-20070123.htm#doc-xquery-NodeComp">NodeComp</A>) 
      <A 
      href="REC-xquery-20070123.htm#doc-xquery-RangeExpr">RangeExpr</A> 
      )?</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-ValueComp 
      name=doc-xquery-ValueComp></A>[61]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-ValueComp">ValueComp</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"eq" | "ne" | "lt" | "le" | "gt" | "ge"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-GeneralComp 
      name=doc-xquery-GeneralComp></A>[60]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-GeneralComp">GeneralComp</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"=" | "!=" | "&lt;" | "&lt;=" | "&gt;" | 
  "&gt;="</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-NodeComp 
      name=doc-xquery-NodeComp></A>[62]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-NodeComp">NodeComp</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"is" | "&lt;&lt;" | "&gt;&gt;"</CODE></TD></TR></TBODY></TABLE>
<DIV class=div3>
<H4><A id=id-value-comparisons name=id-value-comparisons></A>3.5.1 Value 
Comparisons</H4>
<P>The value comparison operators are <CODE>eq</CODE>, <CODE>ne</CODE>, 
<CODE>lt</CODE>, <CODE>le</CODE>, <CODE>gt</CODE>, and <CODE>ge</CODE>. Value 
comparisons are used for comparing single values.</P>
<P>The first step in evaluating a value comparison is to evaluate its operands. 
The order in which the operands are evaluated is <A 
title="implementation dependent" 
href="REC-xquery-20070123.htm#dt-implementation-dependent">implementation-dependent</A>. 
Each operand is evaluated by applying the following steps, in order:</P>
<OL class=enumar>
  <LI>
  <P><A title=atomization 
  href="REC-xquery-20070123.htm#dt-atomization">Atomization</A> 
  is applied to the operand. The result of this operation is called the 
  <B>atomized operand</B>.</P>
  <LI>
  <P>If the atomized operand is an empty sequence, the result of the value 
  comparison is an empty sequence, and the implementation need not evaluate the 
  other operand or apply the operator. However, an implementation may choose to 
  evaluate the other operand in order to determine whether it raises an 
  error.</P>
  <LI>
  <P>If the atomized operand is a sequence of length greater than one, a <A 
  title="type error" 
  href="REC-xquery-20070123.htm#dt-type-error">type 
  error</A> is raised [<A title=err:XPTY0004 
  href="REC-xquery-20070123.htm#ERRXPTY0004">err:XPTY0004</A>].</P>
  <LI>
  <P>If the atomized operand is of type <CODE>xs:untypedAtomic</CODE>, it is 
  cast to <CODE>xs:string</CODE>.</P>
  <DIV class=note>
  <P class=prefix><B>Note:</B></P>
  <P>The purpose of this rule is to make value comparisons transitive. Users 
  should be aware that the general comparison operators have a different rule 
  for casting of <CODE>xs:untypedAtomic</CODE> operands. Users should also be 
  aware that transitivity of value comparisons may be compromised by loss of 
  precision during type conversion (for example, two <CODE>xs:integer</CODE> 
  values that differ slightly may both be considered equal to the same 
  <CODE>xs:float</CODE> value because <CODE>xs:float</CODE> has less precision 
  than <CODE>xs:integer</CODE>).</P></DIV></LI></OL>
<P>Next, if possible, the two operands are converted to their least common type 
by a combination of <A title="type promotion" 
href="REC-xquery-20070123.htm#dt-type-promotion">type 
promotion</A> and <A title="subtype substitution" 
href="REC-xquery-20070123.htm#dt-subtype-substitution">subtype 
substitution</A>. For example, if the operands are of type <CODE>hatsize</CODE> 
(derived from <CODE>xs:integer</CODE>) and <CODE>shoesize</CODE> (derived from 
<CODE>xs:float</CODE>), their least common type is <CODE>xs:float</CODE>.</P>
<P>Finally, if the types of the operands are a valid combination for the given 
operator, the operator is applied to the operands. The combinations of atomic 
types that are accepted by the various value comparison operators, and their 
respective result types, are listed in <A 
href="REC-xquery-20070123.htm#mapping"><B>B.2 Operator 
Mapping</B></A> together with the <A title="operator function" 
href="REC-xquery-20070123.htm#dt-operator-function">operator 
functions</A> that define the semantics of the operator for each type 
combination. The definitions of the operator functions are found in <A 
href="REC-xquery-20070123.htm#FunctionsAndOperators">[XQuery 
1.0 and XPath 2.0 Functions and Operators]</A>.</P>
<P>Informally, if both atomized operands consist of exactly one atomic value, 
then the result of the comparison is <CODE>true</CODE> if the value of the first 
operand is (equal, not equal, less than, less than or equal, greater than, 
greater than or equal) to the value of the second operand; otherwise the result 
of the comparison is <CODE>false</CODE>.</P>
<P>If the types of the operands, after evaluation, are not a valid combination 
for the given operator, according to the rules in <A 
href="REC-xquery-20070123.htm#mapping"><B>B.2 Operator 
Mapping</B></A>, a <A title="type error" 
href="REC-xquery-20070123.htm#dt-type-error">type 
error</A> is raised [<A title=err:XPTY0004 
href="REC-xquery-20070123.htm#ERRXPTY0004">err:XPTY0004</A>].</P>
<P>Here are some examples of value comparisons:</P>
<UL>
  <LI>
  <P>The following comparison atomizes the node(s) that are returned by the 
  expression <CODE>$book/author</CODE>. The comparison is true only if the 
  result of atomization is the value "Kennedy" as an instance of 
  <CODE>xs:string</CODE> or <CODE>xs:untypedAtomic</CODE>. If the result of 
  atomization is an empty sequence, the result of the comparison is an empty 
  sequence. If the result of atomization is a sequence containing more than one 
  value, a <A title="type error" 
  href="REC-xquery-20070123.htm#dt-type-error">type 
  error</A> is raised [<A title=err:XPTY0004 
  href="REC-xquery-20070123.htm#ERRXPTY0004">err:XPTY0004</A>].</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>$book1/author eq "Kennedy"
</PRE></DIV></DIV>
  <LI>
  <P>The following <A title="path expression" 
  href="REC-xquery-20070123.htm#dt-path-expression">path 
  expression</A> contains a predicate that selects products whose weight is 
  greater than 100. For any product that does not have a <CODE>weight</CODE> 
  subelement, the value of the predicate is the empty sequence, and the product 
  is not selected. This example assumes that <CODE>weight</CODE> is a validated 
  element with a numeric type.</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>//product[weight gt 100]
</PRE></DIV></DIV>
  <LI class=xquery>
  <P>The following comparisons are true because, in each case, the two 
  constructed nodes have the same value after atomization, even though they have 
  different identities and/or names:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>&lt;a&gt;5&lt;/a&gt; eq &lt;a&gt;5&lt;/a&gt;
</PRE></DIV></DIV>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>&lt;a&gt;5&lt;/a&gt; eq &lt;b&gt;5&lt;/b&gt;
</PRE></DIV></DIV>
  <LI>
  <P>The following comparison is true if <CODE>my:hatsize</CODE> and 
  <CODE>my:shoesize</CODE> are both user-defined types that are derived by 
  restriction from a primitive <A title=numeric 
  href="REC-xquery-20070123.htm#dt-numeric">numeric</A> 
  type:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>my:hatsize(5) eq my:shoesize(5)
</PRE></DIV></DIV>
  <LI>
  <P>The following comparison is true. The <CODE>eq</CODE> operator compares two 
  QNames by performing codepoint-comparisons of their namespace URIs and their 
  local names, ignoring their namespace prefixes.</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>fn:QName("http://example.com/ns1", "this:color")
   eq fn:QName("http://example.com/ns1", "that:color")
</PRE></DIV></DIV></LI></UL></DIV>
<DIV class=div3>
<H4><A id=id-general-comparisons name=id-general-comparisons></A>3.5.2 General 
Comparisons</H4>
<P>The general comparison operators are <CODE>=</CODE>, <CODE>!=</CODE>, 
<CODE>&lt;</CODE>, <CODE>&lt;=</CODE>, <CODE>&gt;</CODE>, and 
<CODE>&gt;=</CODE>. General comparisons are existentially quantified comparisons 
that may be applied to operand sequences of any length. The result of a general 
comparison that does not raise an error is always <CODE>true</CODE> or 
<CODE>false</CODE>.</P>
<P><SPAN class=xquery><SPAN class=xquery>A</SPAN></SPAN> general comparison is 
evaluated by applying the following rules, in order:</P>
<OL class=enumar>
  <LI>
  <P><A title=atomization 
  href="REC-xquery-20070123.htm#dt-atomization">Atomization</A> 
  is applied to each operand. After atomization, each operand is a sequence of 
  atomic values.</P>
  <LI>
  <P>The result of the comparison is <CODE>true</CODE> if and only if there is a 
  pair of atomic values, one in the first operand sequence and the other in the 
  second operand sequence, that have the required <B>magnitude relationship</B>. 
  Otherwise the result of the comparison is <CODE>false</CODE>. The <B>magnitude 
  relationship</B> between two atomic values is determined by applying the 
  following rules. If a <CODE>cast</CODE> operation called for by these rules is 
  not successful, a dynamic error is raised. [err:FORG0001]</P>
  <DIV class=note>
  <P class=prefix><B>Note:</B></P>
  <P>The purpose of these rules is to preserve compatibility with XPath 1.0, in 
  which (for example) <CODE>x &lt; 17</CODE> is a numeric comparison if 
  <CODE>x</CODE> is an untyped value. Users should be aware that the value 
  comparison operators have different rules for casting of 
  <CODE>xs:untypedAtomic</CODE> operands.</P></DIV>
  <OL class=enumla>
    <LI>
    <P>If one of the atomic values is an instance of 
    <CODE>xs:untypedAtomic</CODE> and the other is an instance of a <A 
    title=numeric 
    href="REC-xquery-20070123.htm#dt-numeric">numeric</A> 
    type, then the <CODE>xs:untypedAtomic</CODE> value is cast to the type 
    <CODE>xs:double</CODE>.</P>
    <LI>
    <P>If one of the atomic values is an instance of 
    <CODE>xs:untypedAtomic</CODE> and the other is an instance of 
    <CODE>xs:untypedAtomic</CODE> or <CODE>xs:string</CODE>, then the 
    <CODE>xs:untypedAtomic</CODE> value (or values) is (are) cast to the type 
    <CODE>xs:string</CODE>.</P>
    <LI>
    <P>If one of the atomic values is an instance of 
    <CODE>xs:untypedAtomic</CODE> and the other is not an instance of 
    <CODE>xs:string</CODE>, <CODE>xs:untypedAtomic</CODE>, or any <A 
    title=numeric 
    href="REC-xquery-20070123.htm#dt-numeric">numeric</A> 
    type, then the <CODE>xs:untypedAtomic</CODE> value is cast to the <A 
    title="dynamic type" 
    href="REC-xquery-20070123.htm#dt-dynamic-type">dynamic 
    type</A> of the other value.</P>
    <LI>
    <P>After performing the conversions described above, the atomic values are 
    compared using one of the value comparison operators <CODE>eq</CODE>, 
    <CODE>ne</CODE>, <CODE>lt</CODE>, <CODE>le</CODE>, <CODE>gt</CODE>, or 
    <CODE>ge</CODE>, depending on whether the general comparison operator was 
    <CODE>=</CODE>, <CODE>!=</CODE>, <CODE>&lt;</CODE>, <CODE>&lt;=</CODE>, 
    <CODE>&gt;</CODE>, or <CODE>&gt;=</CODE>. The values have the required 
    <B>magnitude relationship</B> if and only if the result of this value 
    comparison is <CODE>true</CODE>.</P></LI></OL></LI></OL>
<P>When evaluating a general comparison in which either operand is a sequence of 
items, an implementation may return <CODE>true</CODE> as soon as it finds an 
item in the first operand and an item in the second operand that have the 
required <B>magnitude relationship</B>. Similarly, a general comparison may 
raise a <A title="dynamic error" 
href="REC-xquery-20070123.htm#dt-dynamic-error">dynamic 
error</A> as soon as it encounters an error in evaluating either operand, or in 
comparing a pair of items from the two operands. As a result of these rules, the 
result of a general comparison is not deterministic in the presence of 
errors.</P>
<P>Here are some examples of general comparisons:</P>
<UL>
  <LI>
  <P>The following comparison is true if the <A title="typed value" 
  href="REC-xquery-20070123.htm#dt-typed-value">typed 
  value</A> of any <CODE>author</CODE> subelement of <CODE>$book1</CODE> is 
  "Kennedy" as an instance of <CODE>xs:string</CODE> or 
  <CODE>xs:untypedAtomic</CODE>:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>$book1/author = "Kennedy"
</PRE></DIV></DIV>
  <LI>
  <P>The following example contains three general comparisons. The value of the 
  first two comparisons is <CODE>true</CODE>, and the value of the third 
  comparison is <CODE>false</CODE>. This example illustrates the fact that 
  general comparisons are not transitive.</P>
  <DIV class=exampleInner><PRE>(1, 2) = (2, 3)
(2, 3) = (3, 4)
(1, 2) = (3, 4)
</PRE></DIV>
  <LI>
  <P>The following example contains two general comparisons, both of which are 
  <CODE>true</CODE>. This example illustrates the fact that the <CODE>=</CODE> 
  and <CODE>!=</CODE> operators are not inverses of each other.</P>
  <DIV class=exampleInner><PRE>(1, 2) = (2, 3)
(1, 2) != (2, 3)
</PRE></DIV>
  <LI>
  <P>Suppose that <CODE>$a</CODE>, <CODE>$b</CODE>, and <CODE>$c</CODE> are 
  bound to element nodes with type annotation <CODE>xs:untypedAtomic</CODE>, 
  with <A title="string value" 
  href="REC-xquery-20070123.htm#dt-string-value">string 
  values</A> "<CODE>1</CODE>", "<CODE>2</CODE>", and "<CODE>2.0</CODE>" 
  respectively. Then <CODE>($a, $b) = ($c, 3.0)</CODE> returns 
  <CODE>false</CODE>, because <CODE>$b</CODE> and <CODE>$c</CODE> are compared 
  as strings. However, <CODE>($a, $b) = ($c, 2.0)</CODE> returns 
  <CODE>true</CODE>, because <CODE>$b</CODE> and <CODE>2.0</CODE> are compared 
  as numbers.</P></LI></UL></DIV>
<DIV class=div3>
<H4><A id=id-node-comparisons name=id-node-comparisons></A>3.5.3 Node 
Comparisons</H4>
<P>Node comparisons are used to compare two nodes, by their identity or by their 
<A title="document order" 
href="REC-xquery-20070123.htm#dt-document-order">document 
order</A>. The result of a node comparison is defined by the following 
rules:</P>
<OL class=enumar>
  <LI>
  <P>The operands of a node comparison are evaluated in <A 
  title="implementation dependent" 
  href="REC-xquery-20070123.htm#dt-implementation-dependent">implementation-dependent</A> 
  order.</P>
  <LI>
  <P>If either operand is an empty sequence, the result of the comparison is an 
  empty sequence, and the implementation need not evaluate the other operand or 
  apply the operator. However, an implementation may choose to evaluate the 
  other operand in order to determine whether it raises an error.</P>
  <LI>
  <P>Each operand must be either a single node or an empty sequence; otherwise a 
  <A title="type error" 
  href="REC-xquery-20070123.htm#dt-type-error">type 
  error</A> is raised [<A title=err:XPTY0004 
  href="REC-xquery-20070123.htm#ERRXPTY0004">err:XPTY0004</A>].</P>
  <LI>
  <P>A comparison with the <CODE>is</CODE> operator is <CODE>true</CODE> if the 
  two operand nodes have the same identity, and are thus the same node; 
  otherwise it is <CODE>false</CODE>. See <A 
  href="REC-xquery-20070123.htm#datamodel">[XQuery/XPath 
  Data Model (XDM)]</A> for a definition of node identity.</P>
  <LI>
  <P>A comparison with the <CODE>&lt;&lt;</CODE> operator returns 
  <CODE>true</CODE> if the left operand node precedes the right operand node in 
  <A title="document order" 
  href="REC-xquery-20070123.htm#dt-document-order">document 
  order</A>; otherwise it returns <CODE>false</CODE>.</P>
  <LI>
  <P>A comparison with the <CODE>&gt;&gt;</CODE> operator returns 
  <CODE>true</CODE> if the left operand node follows the right operand node in 
  <A title="document order" 
  href="REC-xquery-20070123.htm#dt-document-order">document 
  order</A>; otherwise it returns <CODE>false</CODE>.</P></LI></OL>
<P>Here are some examples of node comparisons:</P>
<UL>
  <LI>
  <P>The following comparison is true only if the left and right sides each 
  evaluate to exactly the same single node:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>/books/book[isbn="1558604820"] is /books/book[call="QA76.9 C3845"]
</PRE></DIV></DIV>
  <LI class=xquery>
  <P>The following comparison is false because each constructed node has its own 
  identity:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>&lt;a&gt;5&lt;/a&gt; is &lt;a&gt;5&lt;/a&gt;
</PRE></DIV></DIV>
  <LI>
  <P>The following comparison is true only if the node identified by the left 
  side occurs before the node identified by the right side in document 
order:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>/transactions/purchase[parcel="28-451"] 
   &lt;&lt; /transactions/sale[parcel="33-870"]
</PRE></DIV></DIV></LI></UL></DIV></DIV>
<DIV class=div2>
<H3><A id=id-logical-expressions name=id-logical-expressions></A>3.6 Logical 
Expressions</H3>
<P>A <B>logical expression</B> is either an <B>and-expression</B> or an 
<B>or-expression</B>. If a logical expression does not raise an error, its value 
is always one of the boolean values <CODE>true</CODE> or <CODE>false</CODE>.</P>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-OrExpr 
    name=doc-xquery-OrExpr></A>[46]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-OrExpr">OrExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-AndExpr">AndExpr</A> 
      ( "or" <A 
      href="REC-xquery-20070123.htm#doc-xquery-AndExpr">AndExpr</A> 
      )*</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-AndExpr 
    name=doc-xquery-AndExpr></A>[47]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-AndExpr">AndExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-ComparisonExpr">ComparisonExpr</A> 
      ( "and" <A 
      href="REC-xquery-20070123.htm#doc-xquery-ComparisonExpr">ComparisonExpr</A> 
      )*</CODE></TD></TR></TBODY></TABLE>
<P>The first step in evaluating a logical expression is to find the <A 
title="effective boolean value" 
href="REC-xquery-20070123.htm#dt-ebv">effective boolean 
value</A> of each of its operands (see <A 
href="REC-xquery-20070123.htm#id-ebv"><B>2.4.3 Effective 
Boolean Value</B></A>).</P>
<P>The value of an and-expression is determined by the effective boolean values 
(EBV's) of its operands, as shown in the following table:</P>
<TABLE cellSpacing=1 cellPadding=4 width="80%" summary="AND EBV" border=1>
  <TBODY>
  <TR>
    <TD>AND:</TD>
    <TD>EBV<SUB>2</SUB> = <CODE>true</CODE></TD>
    <TD>EBV<SUB>2</SUB> = <CODE>false</CODE></TD>
    <TD>error in EBV<SUB>2</SUB></TD></TR>
  <TR>
    <TD>EBV<SUB>1</SUB> = <CODE>true</CODE></TD>
    <TD><CODE>true</CODE></TD>
    <TD><CODE>false</CODE></TD>
    <TD>error</TD></TR>
  <TR>
    <TD>EBV<SUB>1</SUB> = <CODE>false</CODE></TD>
    <TD><CODE>false</CODE></TD>
    <TD><CODE>false</CODE></TD>
    <TD><SPAN class=xquery><SPAN class=xquery>either <CODE>false</CODE> or 
      error</SPAN></SPAN></TD></TR>
  <TR>
    <TD>error in EBV<SUB>1</SUB></TD>
    <TD>error</TD>
    <TD><SPAN class=xquery><SPAN class=xquery>either <CODE>false</CODE> or 
      error</SPAN></SPAN></TD>
    <TD>error</TD></TR></TBODY></TABLE>
<P>The value of an or-expression is determined by the effective boolean values 
(EBV's) of its operands, as shown in the following table:</P>
<TABLE cellSpacing=1 cellPadding=4 width="80%" summary="OR EBV" border=1>
  <TBODY>
  <TR>
    <TD>OR:</TD>
    <TD>EBV<SUB>2</SUB> = <CODE>true</CODE></TD>
    <TD>EBV<SUB>2</SUB> = <CODE>false</CODE></TD>
    <TD>error in EBV<SUB>2</SUB></TD></TR>
  <TR>
    <TD>EBV<SUB>1</SUB> = <CODE>true</CODE></TD>
    <TD><CODE>true</CODE></TD>
    <TD><CODE>true</CODE></TD>
    <TD><SPAN class=xquery><SPAN class=xquery>either <CODE>true</CODE> or 
      error</SPAN></SPAN></TD></TR>
  <TR>
    <TD>EBV<SUB>1</SUB> = <CODE>false</CODE></TD>
    <TD><CODE>true</CODE></TD>
    <TD><CODE>false</CODE></TD>
    <TD>error</TD></TR>
  <TR>
    <TD>error in EBV<SUB>1</SUB></TD>
    <TD><SPAN class=xquery><SPAN class=xquery>either <CODE>true</CODE> or 
      error</SPAN></SPAN></TD>
    <TD>error</TD>
    <TD>error</TD></TR></TBODY></TABLE>
<P><SPAN class=xquery><SPAN class=xquery>The order in which the operands of a 
logical expression are evaluated is <A title="implementation dependent" 
href="REC-xquery-20070123.htm#dt-implementation-dependent">implementation-dependent</A>. 
The tables above are defined in such a way that</SPAN></SPAN> an or-expression 
can return <CODE>true</CODE> if the first expression evaluated is true, and it 
can raise an error if evaluation of the first expression raises an error. 
Similarly, an and-expression can return <CODE>false</CODE> if the first 
expression evaluated is false, and it can raise an error if evaluation of the 
first expression raises an error. As a result of these rules, a logical 
expression is not deterministic in the presence of errors, as illustrated in the 
examples below.</P>
<P>Here are some examples of logical expressions:</P>
<UL>
  <LI>
  <P>The following expressions return <CODE>true</CODE>:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>1 eq 1 and 2 eq 2
</PRE></DIV></DIV>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>1 eq 1 or 2 eq 3
</PRE></DIV></DIV>
  <LI>
  <P>The following expression may return either <CODE>false</CODE> or raise a <A 
  title="dynamic error" 
  href="REC-xquery-20070123.htm#dt-dynamic-error">dynamic 
  error</A>:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>1 eq 2 and 3 idiv 0 = 1
</PRE></DIV></DIV>
  <LI>
  <P>The following expression may return either <CODE>true</CODE> or raise a <A 
  title="dynamic error" 
  href="REC-xquery-20070123.htm#dt-dynamic-error">dynamic 
  error</A>:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>1 eq 1 or 3 idiv 0 = 1
</PRE></DIV></DIV>
  <LI>
  <P>The following expression must raise a <A title="dynamic error" 
  href="REC-xquery-20070123.htm#dt-dynamic-error">dynamic 
  error</A>:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>1 eq 1 and 3 idiv 0 = 1
</PRE></DIV></DIV></LI></UL>
<P>In addition to and- and or-expressions, XQuery provides a function named 
<CODE>fn:not</CODE> that takes a general sequence as parameter and returns a 
boolean value. The <CODE>fn:not</CODE> function is defined in <A 
href="REC-xquery-20070123.htm#FunctionsAndOperators">[XQuery 
1.0 and XPath 2.0 Functions and Operators]</A>. The <CODE>fn:not</CODE> function 
reduces its parameter to an <A title="effective boolean value" 
href="REC-xquery-20070123.htm#dt-ebv">effective boolean 
value</A>. It then returns <CODE>true</CODE> if the effective boolean value of 
its parameter is <CODE>false</CODE>, and <CODE>false</CODE> if the effective 
boolean value of its parameter is <CODE>true</CODE>. If an error is encountered 
in finding the effective boolean value of its operand, <CODE>fn:not</CODE> 
raises the same error.</P></DIV>
<DIV class=xquery>
<DIV class=div2>
<DIV class=xquery>
<H3><A id=id-constructors name=id-constructors></A>3.7 Constructors</H3></DIV>
<P>XQuery provides constructors that can create XML structures within a query. 
Constructors are provided for element, attribute, document, text, comment, and 
processing instruction nodes. Two kinds of constructors are provided: <B>direct 
constructors</B>, which use an XML-like notation, and <B>computed 
constructors</B>, which use a notation based on enclosed expressions.</P>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-Constructor 
      name=doc-xquery-Constructor></A>[94]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-Constructor">Constructor</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-DirectConstructor">DirectConstructor</A><BR>| 
      <A 
      href="REC-xquery-20070123.htm#doc-xquery-ComputedConstructor">ComputedConstructor</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-DirectConstructor 
      name=doc-xquery-DirectConstructor></A>[95]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-DirectConstructor">DirectConstructor</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-DirElemConstructor">DirElemConstructor</A><BR>| 
      <A 
      href="REC-xquery-20070123.htm#doc-xquery-DirCommentConstructor">DirCommentConstructor</A><BR>| 
      <A 
      href="REC-xquery-20070123.htm#doc-xquery-DirPIConstructor">DirPIConstructor</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-DirElemConstructor 
      name=doc-xquery-DirElemConstructor></A>[96]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-DirElemConstructor">DirElemConstructor</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"&lt;" <A 
      href="REC-xquery-20070123.htm#prod-xquery-QName">QName</A> 
      <A 
      href="REC-xquery-20070123.htm#doc-xquery-DirAttributeList">DirAttributeList</A> 
      ("/&gt;" | ("&gt;" <A 
      href="REC-xquery-20070123.htm#doc-xquery-DirElemContent">DirElemContent</A>* 
      "&lt;/" <A 
      href="REC-xquery-20070123.htm#prod-xquery-QName">QName</A> 
      <A 
      href="REC-xquery-20070123.htm#prod-xquery-S">S</A>? 
      "&gt;"))</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-DirElemContent 
      name=doc-xquery-DirElemContent></A>[101]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-DirElemContent">DirElemContent</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-DirectConstructor">DirectConstructor</A><BR>| 
      <A 
      href="REC-xquery-20070123.htm#doc-xquery-CDataSection">CDataSection</A><BR>| 
      <A 
      href="REC-xquery-20070123.htm#doc-xquery-CommonContent">CommonContent</A><BR>| 
      <A 
      href="REC-xquery-20070123.htm#doc-xquery-ElementContentChar">ElementContentChar</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-ElementContentChar 
      name=doc-xquery-ElementContentChar></A>[148]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-ElementContentChar">ElementContentChar</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-Char">Char</A> 
      - [{}&lt;&amp;]</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-CommonContent 
      name=doc-xquery-CommonContent></A>[102]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-CommonContent">CommonContent</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-PredefinedEntityRef">PredefinedEntityRef</A> 
      | <A 
      href="REC-xquery-20070123.htm#prod-xquery-CharRef">CharRef</A> 
      | "{{" | "}}" | <A 
      href="REC-xquery-20070123.htm#doc-xquery-EnclosedExpr">EnclosedExpr</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-CDataSection 
      name=doc-xquery-CDataSection></A>[107]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-CDataSection">CDataSection</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"&lt;![CDATA[" <A 
      href="REC-xquery-20070123.htm#doc-xquery-CDataSectionContents">CDataSectionContents</A> 
      "]]&gt;"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-CDataSectionContents 
      name=doc-xquery-CDataSectionContents></A>[108]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-CDataSectionContents">CDataSectionContents</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>(<A 
      href="REC-xquery-20070123.htm#prod-xquery-Char">Char</A>* 
      - (Char* ']]&gt;' Char*))</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-DirAttributeList 
      name=doc-xquery-DirAttributeList></A>[97]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-DirAttributeList">DirAttributeList</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>(<A 
      href="REC-xquery-20070123.htm#prod-xquery-S">S</A> 
      (<A 
      href="REC-xquery-20070123.htm#prod-xquery-QName">QName</A> 
      <A 
      href="REC-xquery-20070123.htm#prod-xquery-S">S</A>? 
      "=" <A 
      href="REC-xquery-20070123.htm#prod-xquery-S">S</A>? 
      <A 
      href="REC-xquery-20070123.htm#doc-xquery-DirAttributeValue">DirAttributeValue</A>)?)*</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-DirAttributeValue 
      name=doc-xquery-DirAttributeValue></A>[98]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-DirAttributeValue">DirAttributeValue</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>('"' (<A 
      href="REC-xquery-20070123.htm#doc-xquery-EscapeQuot">EscapeQuot</A> 
      | <A 
      href="REC-xquery-20070123.htm#doc-xquery-QuotAttrValueContent">QuotAttrValueContent</A>)* 
      '"')<BR>| ("'" (<A 
      href="REC-xquery-20070123.htm#doc-xquery-EscapeApos">EscapeApos</A> 
      | <A 
      href="REC-xquery-20070123.htm#doc-xquery-AposAttrValueContent">AposAttrValueContent</A>)* 
      "'")</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-QuotAttrValueContent 
      name=doc-xquery-QuotAttrValueContent></A>[99]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-QuotAttrValueContent">QuotAttrValueContent</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-QuotAttrContentChar">QuotAttrContentChar</A><BR>| 
      <A 
      href="REC-xquery-20070123.htm#doc-xquery-CommonContent">CommonContent</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-AposAttrValueContent 
      name=doc-xquery-AposAttrValueContent></A>[100]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-AposAttrValueContent">AposAttrValueContent</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-AposAttrContentChar">AposAttrContentChar</A><BR>| 
      <A 
      href="REC-xquery-20070123.htm#doc-xquery-CommonContent">CommonContent</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-QuotAttrContentChar 
      name=doc-xquery-QuotAttrContentChar></A>[149]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-QuotAttrContentChar">QuotAttrContentChar</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-Char">Char</A> 
      - ["{}&lt;&amp;]</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-AposAttrContentChar 
      name=doc-xquery-AposAttrContentChar></A>[150]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-AposAttrContentChar">AposAttrContentChar</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-Char">Char</A> 
      - ['{}&lt;&amp;]</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-EscapeQuot 
      name=doc-xquery-EscapeQuot></A>[146]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-EscapeQuot">EscapeQuot</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>'""'</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-EscapeApos 
      name=doc-xquery-EscapeApos></A>[147]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-EscapeApos">EscapeApos</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"''"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-EnclosedExpr 
      name=doc-xquery-EnclosedExpr></A>[29]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-EnclosedExpr">EnclosedExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"{" <A 
      href="REC-xquery-20070123.htm#doc-xquery-Expr">Expr</A> 
      "}"</CODE></TD></TR></TBODY></TABLE>
<P>This section contains a conceptual description of the semantics of various 
kinds of constructor expressions. An XQuery implementation is free to use any 
implementation technique that produces the same result as the processing steps 
described in this section.</P>
<DIV class=div3>
<H4><A id=id-element-constructor name=id-element-constructor></A>3.7.1 Direct 
Element Constructors</H4>
<P>An <B>element constructor</B> creates an element node. [<A 
id=dt-direct-elem-const title="direct element constructor" 
name=dt-direct-elem-const>Definition</A>: A <B>direct element constructor</B> is 
a form of element constructor in which the name of the constructed element is a 
constant.] Direct element constructors are based on standard XML notation. For 
example, the following expression is a direct element constructor that creates a 
<CODE>book</CODE> element containing an attribute and some nested elements:</P>
<DIV class=parse-test>
<DIV class=exampleInner><PRE>&lt;book isbn="isbn-0060229357"&gt;
    &lt;title&gt;Harold and the Purple Crayon&lt;/title&gt;
    &lt;author&gt;
        &lt;first&gt;Crockett&lt;/first&gt;
        &lt;last&gt;Johnson&lt;/last&gt;
    &lt;/author&gt;
&lt;/book&gt;
</PRE></DIV></DIV>
<P>If the element name in a direct element constructor has a namespace prefix, 
the namespace prefix is resolved to a namespace URI using the <A 
title="statically known namespaces" 
href="REC-xquery-20070123.htm#dt-static-namespaces">statically 
known namespaces</A>. If the element name has no namespace prefix, it is 
implicitly qualified by the <A title="default element/type namespace" 
href="REC-xquery-20070123.htm#dt-def-elemtype-ns">default 
element/type namespace</A>. Note that both the statically known namespaces and 
the default element/type namespace may be affected by <A 
title="namespace declaration attribute" 
href="REC-xquery-20070123.htm#dt-namespace-decl-attr">namespace 
declaration attributes</A> found inside the element constructor. The namespace 
prefix of the element name is retained after expansion of the QName, as 
described in <A 
href="REC-xquery-20070123.htm#datamodel">[XQuery/XPath 
Data Model (XDM)]</A>. The resulting <A title="expanded QName" 
href="REC-xquery-20070123.htm#dt-expanded-qname">expanded 
QName</A> becomes the <CODE>node-name</CODE> property of the constructed element 
node.</P>
<P>In a direct element constructor, the name used in the end tag must exactly 
match the name used in the corresponding start tag, including its prefix or 
absence of a prefix.</P>
<P>In a direct element constructor, curly braces { } delimit <B>enclosed 
expressions</B>, distinguishing them from literal text. Enclosed expressions are 
evaluated and replaced by their value, as illustrated by the following 
example:</P>
<DIV class=parse-test>
<DIV class=exampleInner><PRE>&lt;example&gt;
   &lt;p&gt; Here is a query. &lt;/p&gt;
   &lt;eg&gt; $b/title &lt;/eg&gt;
   &lt;p&gt; Here is the result of the query. &lt;/p&gt;
   &lt;eg&gt;{ $b/title }&lt;/eg&gt;
&lt;/example&gt;
</PRE></DIV></DIV>
<P>The above query might generate the following result (whitespace has been 
added for readability to this result and other result examples in this 
document):</P>
<DIV class=parse-test>
<DIV class=exampleInner><PRE>&lt;example&gt;
  &lt;p&gt; Here is a query. &lt;/p&gt;
  &lt;eg&gt; $b/title &lt;/eg&gt;
  &lt;p&gt; Here is the result of the query. &lt;/p&gt;
  &lt;eg&gt;&lt;title&gt;Harold and the Purple Crayon&lt;/title&gt;&lt;/eg&gt;
&lt;/example&gt;
</PRE></DIV></DIV>
<P>Since XQuery uses curly braces to denote enclosed expressions, some 
convention is needed to denote a curly brace used as an ordinary character. For 
this purpose, a pair of identical curly brace characters within the content of 
an element or attribute are interpreted by XQuery as a single curly brace 
character (that is, the pair "<CODE>{{</CODE>" represents the character 
"<CODE>{</CODE>" and the pair "<CODE>}}</CODE>" represents the character 
"<CODE>}</CODE>".) Alternatively, the <A title="character reference" 
href="REC-xquery-20070123.htm#dt-character-reference">character 
references</A> <CODE>&amp;#x7b;</CODE> and <CODE>&amp;#x7d;</CODE> can be used 
to denote curly brace characters. A single left curly brace ("<CODE>{</CODE>") 
is interpreted as the beginning delimiter for an enclosed expression. A single 
right curly brace ("<CODE>}</CODE>") without a matching left curly brace is 
treated as a <A title="static error" 
href="REC-xquery-20070123.htm#dt-static-error">static 
error</A> [<A title=err:XPST0003 
href="REC-xquery-20070123.htm#ERRXPST0003">err:XPST0003</A>].</P>
<P>The result of an element constructor is a new element node, with its own node 
identity. All the attribute and descendant nodes of the new element node are 
also new nodes with their own identities, even if they are copies of existing 
nodes.</P>
<DIV class=div4>
<H5><A id=id-attributes name=id-attributes></A>3.7.1.1 Attributes</H5>
<P>The start tag of a direct element constructor may contain one or more 
attributes. As in XML, each attribute is specified by a name and a value. In a 
direct element constructor, the name of each attribute is specified by a 
constant QName, and the value of the attribute is specified by a string of 
characters enclosed in single or double quotes. As in the main content of the 
element constructor, an attribute value may contain expressions enclosed in 
curly braces, which are evaluated and replaced by their value during processing 
of the element constructor.</P>
<P>Each attribute in a direct element constructor creates a new attribute node, 
with its own node identity, whose parent is the constructed element node. 
However, note that <A title="namespace declaration attribute" 
href="REC-xquery-20070123.htm#dt-namespace-decl-attr">namespace 
declaration attributes</A> (see <A 
href="REC-xquery-20070123.htm#id-namespaces"><B>3.7.1.2 
Namespace Declaration Attributes</B></A>) do not create attribute nodes.</P>
<P>If an attribute name has a namespace prefix, the prefix is resolved to a 
namespace URI using the <A title="statically known namespaces" 
href="REC-xquery-20070123.htm#dt-static-namespaces">statically 
known namespaces</A>. If the attribute name has no namespace prefix, the 
attribute is in no namespace. Note that the statically known namespaces used in 
resolving an attribute name may be affected by <A 
title="namespace declaration attribute" 
href="REC-xquery-20070123.htm#dt-namespace-decl-attr">namespace 
declaration attributes</A> that are found inside the same element constructor. 
The namespace prefix of the attribute name is retained after expansion of the 
QName, as described in <A 
href="REC-xquery-20070123.htm#datamodel">[XQuery/XPath 
Data Model (XDM)]</A>. The resulting <A title="expanded QName" 
href="REC-xquery-20070123.htm#dt-expanded-qname">expanded 
QName</A> becomes the <CODE>node-name</CODE> property of the constructed 
attribute node.</P>
<P>If the attributes in a direct element constructor do not have distinct <A 
title="expanded QName" 
href="REC-xquery-20070123.htm#dt-expanded-qname">expanded 
QNames</A> as their respective <CODE>node-name</CODE> properties, a <A 
title="static error" 
href="REC-xquery-20070123.htm#dt-static-error">static 
error</A> is raised [<A title=err:XQST0040 
href="REC-xquery-20070123.htm#ERRXQST0040">err:XQST0040</A>].</P>
<P>Conceptually, an attribute (other than a namespace declaration attribute) in 
a direct element constructor is processed by the following steps:</P>
<OL class=enumar>
  <LI>
  <P>Each consecutive sequence of literal characters in the attribute content is 
  treated as a string containing those characters. Attribute value normalization 
  is then applied to normalize whitespace and expand <A 
  title="character reference" 
  href="REC-xquery-20070123.htm#dt-character-reference">character 
  references</A> and <A title="predefined entity reference" 
  href="REC-xquery-20070123.htm#dt-predefined-entity-reference">predefined 
  entity references</A>. An XQuery processor that supports XML 1.0 uses the 
  rules for attribute value normalization in Section 3.3.3 of <A 
  href="REC-xquery-20070123.htm#XML">[XML 1.0]</A>; an 
  XQuery processor that supports XML 1.1 uses the rules for attribute value 
  normalization in Section 3.3.3 of <A 
  href="REC-xquery-20070123.htm#XML1.1">[XML 1.1]</A>. In 
  either case, the normalization rules are applied as though the type of the 
  attribute were CDATA (leading and trailing whitespace characters are not 
  stripped.) The choice between XML 1.0 and XML 1.1 rules is <A 
  title="implementation defined" 
  href="REC-xquery-20070123.htm#dt-implementation-defined">implementation-defined</A>.</P>
  <LI>
  <P>Each enclosed expression is converted to a string as follows:</P>
  <OL class=enumla>
    <LI>
    <P><A title=atomization 
    href="REC-xquery-20070123.htm#dt-atomization">Atomization</A> 
    is applied to the value of the enclosed expression, converting it to a 
    sequence of atomic values.</P>
    <LI>
    <P>If the result of atomization is an empty sequence, the result is the 
    zero-length string. Otherwise, each atomic value in the atomized sequence is 
    cast into a string.</P>
    <LI>
    <P>The individual strings resulting from the previous step are merged into a 
    single string by concatenating them with a single space character between 
    each pair.</P></LI></OL>
  <LI>
  <P>Adjacent strings resulting from the above steps are concatenated with no 
  intervening blanks. The resulting string becomes the <CODE>string-value</CODE> 
  property of the attribute node. The attribute node is given a <A 
  title="type annotation" 
  href="REC-xquery-20070123.htm#dt-type-annotation">type 
  annotation</A> (<CODE>type-name</CODE> property) of 
  <CODE>xs:untypedAtomic</CODE> (this type annotation may change if the parent 
  element is validated). The <CODE>typed-value</CODE> property of the attribute 
  node is the same as its <CODE>string-value</CODE>, as an instance of 
  <CODE>xs:untypedAtomic</CODE>.</P>
  <LI>
  <P>The <CODE>parent</CODE> property of the attribute node is set to the 
  element node constructed by the direct element constructor that contains this 
  attribute.</P>
  <LI>
  <P>If the attribute name is <CODE>xml:id</CODE>, then <CODE>xml:id</CODE> 
  processing is performed as defined in <A 
  href="REC-xquery-20070123.htm#XMLID">[XML ID]</A>. This 
  ensures that the attribute has the type <CODE>xs:ID</CODE> and that its value 
  is properly normalized. If an error is encountered during <CODE>xml:id</CODE> 
  processing, an implementation <A title=may 
  href="REC-xquery-20070123.htm#may">MAY</A> raise a <A 
  title="dynamic error" 
  href="REC-xquery-20070123.htm#dt-dynamic-error">dynamic 
  error</A> [<A title=err:XQDY0091 
  href="REC-xquery-20070123.htm#ERRXQDY0091">err:XQDY0091</A>].</P>
  <LI>
  <P>If the attribute name is <CODE>xml:id</CODE>, the <CODE>is-id</CODE> 
  property of the resulting attribute node is set to <CODE>true</CODE>; 
  otherwise the <CODE>is-id</CODE> property is set to <CODE>false</CODE>. The 
  <CODE>is-idrefs</CODE> property of the attribute node is unconditionally set 
  to <CODE>false</CODE>.</P></LI></OL>
<UL>
  <LI>
  <P>Example:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>&lt;shoe size="7"/&gt;
</PRE></DIV></DIV>
  <P>The string value of the <CODE>size</CODE> attribute is 
"<CODE>7</CODE>".</P>
  <LI>
  <P>Example:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>&lt;shoe size="{7}"/&gt;
</PRE></DIV></DIV>
  <P>The string value of the <CODE>size</CODE> attribute is 
"<CODE>7</CODE>".</P>
  <LI>
  <P>Example:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>&lt;shoe size="{()}"/&gt;
</PRE></DIV></DIV>
  <P>The string value of the <CODE>size</CODE> attribute is the zero-length 
  string.</P>
  <LI>
  <P>Example:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>&lt;chapter ref="[{1, 5 to 7, 9}]"/&gt;
</PRE></DIV></DIV>
  <P>The string value of the <CODE>ref</CODE> attribute is "<CODE>[1 5 6 7 
  9]</CODE>".</P>
  <LI>
  <P>Example:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>&lt;shoe size="As big as {$hat/@size}"/&gt;
</PRE></DIV></DIV>
  <P>The string value of the <CODE>size</CODE> attribute is the string "<CODE>As 
  big as</CODE> ", concatenated with the string value of the node denoted by the 
  expression <CODE>$hat/@size</CODE>.</P></LI></UL></DIV>
<DIV class=div4>
<H5><A id=id-namespaces name=id-namespaces></A>3.7.1.2 Namespace Declaration 
Attributes</H5>
<P>The names of a constructed element and its attributes may be <A title=QName 
href="REC-xquery-20070123.htm#dt-qname">QNames</A> that 
include <B>namespace prefixes</B>. Namespace prefixes can be bound to namespaces 
in the <A title=Prolog 
href="REC-xquery-20070123.htm#dt-prolog">Prolog</A> or by 
<B>namespace declaration attributes</B>. It is a <A title="static error" 
href="REC-xquery-20070123.htm#dt-static-error">static 
error</A> to use a namespace prefix that has not been bound to a namespace [<A 
title=err:XPST0081 
href="REC-xquery-20070123.htm#ERRXPST0081">err:XPST0081</A>].</P>
<P>[<A id=dt-namespace-decl-attr title="namespace declaration attribute" 
name=dt-namespace-decl-attr>Definition</A>: A <B>namespace declaration 
attribute</B> is used inside a direct element constructor. Its purpose is to 
bind a namespace prefix or to set the <A title="default element/type namespace" 
href="REC-xquery-20070123.htm#dt-def-elemtype-ns">default 
element/type namespace</A> for the constructed element node, including its 
attributes.] Syntactically, a namespace declaration attribute has the form of an 
attribute with namespace prefix <CODE>xmlns</CODE>, or with name 
<CODE>xmlns</CODE> and no namespace prefix. The value of a namespace declaration 
attribute must be a <A 
href="REC-xquery-20070123.htm#doc-xquery-URILiteral">URILiteral</A>; 
otherwise a <A title="static error" 
href="REC-xquery-20070123.htm#dt-static-error">static 
error</A> is raised [<A title=err:XQST0022 
href="REC-xquery-20070123.htm#ERRXQST0022">err:XQST0022</A>]. 
All the namespace declaration attributes of a given element must have distinct 
names [<A title=err:XQST0071 
href="REC-xquery-20070123.htm#ERRXQST0071">err:XQST0071</A>]. 
Each namespace declaration attribute is processed as follows:</P>
<UL>
  <LI>
  <P>The local part of the attribute name is interpreted as a namespace prefix 
  and the value of the attribute is interpreted as a namespace URI. This prefix 
  and URI are added to the <A title="statically known namespaces" 
  href="REC-xquery-20070123.htm#dt-static-namespaces">statically 
  known namespaces</A> of the constructor expression (overriding any existing 
  binding of the given prefix), and are also added as a namespace binding to the 
  <A title="in-scope namespaces" 
  href="REC-xquery-20070123.htm#dt-in-scope-namespaces">in-scope 
  namespaces</A> of the constructed element. If the namespace URI is a 
  zero-length string and the implementation supports <A 
  href="REC-xquery-20070123.htm#XMLNAMES11">[XML Names 
  1.1]</A>, any existing namespace binding for the given prefix is removed from 
  the <A title="in-scope namespaces" 
  href="REC-xquery-20070123.htm#dt-in-scope-namespaces">in-scope 
  namespaces</A> of the constructed element and from the <A 
  title="statically known namespaces" 
  href="REC-xquery-20070123.htm#dt-static-namespaces">statically 
  known namespaces</A> of the constructor expression. If the namespace URI is a 
  zero-length string and the implementation does not support <A 
  href="REC-xquery-20070123.htm#XMLNAMES11">[XML Names 
  1.1]</A>, a static error is raised [<A title=err:XQST0085 
  href="REC-xquery-20070123.htm#ERRXQST0085">err:XQST0085</A>]. 
  It is <A title="implementation defined" 
  href="REC-xquery-20070123.htm#dt-implementation-defined">implementation-defined</A> 
  whether an implementation supports <A 
  href="REC-xquery-20070123.htm#XMLNAMES">[XML Names]</A> 
  or <A href="REC-xquery-20070123.htm#XMLNAMES11">[XML 
  Names 1.1]</A>.</P>
  <LI>
  <P>If the name of the namespace declaration attribute is <CODE>xmlns</CODE> 
  with no prefix, the value of the attribute is interpreted as a namespace URI. 
  This URI specifies the <A title="default element/type namespace" 
  href="REC-xquery-20070123.htm#dt-def-elemtype-ns">default 
  element/type namespace</A> of the constructor expression (overriding any 
  existing default), and is added (with no prefix) to the <A 
  title="in-scope namespaces" 
  href="REC-xquery-20070123.htm#dt-in-scope-namespaces">in-scope 
  namespaces</A> of the constructed element (overriding any existing namespace 
  binding with no prefix). If the namespace URI is a zero-length string, the <A 
  title="default element/type namespace" 
  href="REC-xquery-20070123.htm#dt-def-elemtype-ns">default 
  element/type namespace</A> of the constructor expression is set to "none," and 
  any no-prefix namespace binding is removed from the <A 
  title="in-scope namespaces" 
  href="REC-xquery-20070123.htm#dt-in-scope-namespaces">in-scope 
  namespaces</A> of the constructed element.</P>
  <LI>
  <P>It is a <A title="static error" 
  href="REC-xquery-20070123.htm#dt-static-error">static 
  error</A> [<A title=err:XQST0070 
  href="REC-xquery-20070123.htm#ERRXQST0070">err:XQST0070</A>] 
  if a namespace declaration attribute binds a namespace URI to the predefined 
  prefix <CODE>xmlns</CODE>. It is also a <A title="static error" 
  href="REC-xquery-20070123.htm#dt-static-error">static 
  error</A> [<A title=err:XQST0070 
  href="REC-xquery-20070123.htm#ERRXQST0070">err:XQST0070</A>] 
  if a namespace declaration attribute binds a namespace URI other than 
  <CODE>http://www.w3.org/XML/1998/namespace</CODE> to the prefix 
  <CODE>xml</CODE>, or binds a prefix other than <CODE>xml</CODE> to the 
  namespace URI <CODE>http://www.w3.org/XML/1998/namespace</CODE>.</P></LI></UL>
<P>A namespace declaration attribute does not cause an attribute node to be 
created.</P>
<P>The following examples illustrate namespace declaration attributes:</P>
<UL>
  <LI>
  <P>In this element constructor, a namespace declaration attribute is used to 
  set the <A title="default element/type namespace" 
  href="REC-xquery-20070123.htm#dt-def-elemtype-ns">default 
  element/type namespace</A> to <CODE>http://example.org/animals</CODE>:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>&lt;cat xmlns = "http://example.org/animals"&gt;
  &lt;breed&gt;Persian&lt;/breed&gt;
&lt;/cat&gt;
</PRE></DIV></DIV>
  <LI>
  <P>In this element constructor, namespace declaration attributes are used to 
  bind the namespace prefixes <CODE>metric</CODE> and <CODE>english</CODE>:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>&lt;box xmlns:metric = "http://example.org/metric/units"
     xmlns:english = "http://example.org/english/units"&gt;
  &lt;height&gt; &lt;metric:meters&gt;3&lt;/metric:meters&gt; &lt;/height&gt;
  &lt;width&gt; &lt;english:feet&gt;6&lt;/english:feet&gt; &lt;/width&gt;
  &lt;depth&gt; &lt;english:inches&gt;18&lt;/english:inches&gt; &lt;/depth&gt;
&lt;/box&gt;
</PRE></DIV></DIV></LI></UL></DIV>
<DIV class=div4>
<H5><A id=id-content name=id-content></A>3.7.1.3 Content</H5>
<P>The part of a direct element constructor between the start tag and the end 
tag is called the <B>content</B> of the element constructor. This content may 
consist of text characters (parsed as <A 
href="REC-xquery-20070123.htm#doc-xquery-ElementContentChar">ElementContentChar</A>), 
nested direct constructors, <A 
href="REC-xquery-20070123.htm#doc-xquery-CDataSection">CdataSections</A>, 
character and <A title="predefined entity reference" 
href="REC-xquery-20070123.htm#dt-predefined-entity-reference">predefined 
entity references</A>, and expressions enclosed in curly braces. In general, the 
value of an enclosed expression may be any sequence of nodes and/or atomic 
values. Enclosed expressions can be used in the content of an element 
constructor to compute both the content and the attributes of the constructed 
node.</P>
<P>Conceptually, the content of an element constructor is processed as 
follows:</P>
<OL class=enumar>
  <LI>
  <P>The content is evaluated to produce a sequence of nodes called the 
  <B>content sequence</B>, as follows:</P>
  <OL class=enumla>
    <LI>
    <P>If the <A title="boundary-space policy" 
    href="REC-xquery-20070123.htm#dt-boundary-space-policy">boundary-space 
    policy</A> in the <A title="static context" 
    href="REC-xquery-20070123.htm#dt-static-context">static 
    context</A> is <CODE>strip</CODE>, <A title="boundary whitespace" 
    href="REC-xquery-20070123.htm#dt-boundary-whitespace">boundary 
    whitespace</A> is identified and deleted (see <A 
    href="REC-xquery-20070123.htm#id-whitespace"><B>3.7.1.4 
    Boundary Whitespace</B></A> for a definition of boundary whitespace.)</P>
    <LI>
    <P><A title="predefined entity reference" 
    href="REC-xquery-20070123.htm#dt-predefined-entity-reference">Predefined 
    entity references</A> and <A title="character reference" 
    href="REC-xquery-20070123.htm#dt-character-reference">character 
    references</A> are expanded into their referenced strings, as described in 
    <A 
    href="REC-xquery-20070123.htm#id-literals"><B>3.1.1 
    Literals</B></A>. Characters inside a <A 
    href="REC-xquery-20070123.htm#doc-xquery-CDataSection">CDataSection</A>, 
    including special characters such as <CODE>&lt;</CODE> and 
    <CODE>&amp;</CODE>, are treated as literal characters rather than as markup 
    characters (except for the sequence <CODE>]]&gt;</CODE>, which terminates 
    the CDataSection).</P>
    <LI>
    <P>Each consecutive sequence of literal characters evaluates to a single 
    text node containing the characters.</P>
    <LI>
    <P>Each nested direct constructor is evaluated according to the rules in <A 
    href="REC-xquery-20070123.htm#id-element-constructor"><B>3.7.1 
    Direct Element Constructors</B></A> or <A 
    href="REC-xquery-20070123.htm#id-otherConstructors"><B>3.7.2 
    Other Direct Constructors</B></A>, resulting in a new element, comment, or 
    processing instruction node. Then:</P>
    <OL class=enumlr>
      <LI>
      <P>The <CODE>parent</CODE> property of the resulting node is then set to 
      the newly constructed element node.</P>
      <LI>
      <P>The <CODE>base-uri</CODE> property of the resulting node, and of each 
      of its descendants, is set to be the same as that of its new parent, 
      unless it (the child node) has an <CODE>xml:base</CODE> attribute, in 
      which case its <CODE>base-uri</CODE> property is set to the value of that 
      attribute, resolved (if it is relative) against the <CODE>base-uri</CODE> 
      property of its new parent node.</P></LI></OL>
    <LI>
    <P>Enclosed expressions are evaluated as follows:</P>
    <OL class=enumlr>
      <LI>
      <P>For each adjacent sequence of one or more atomic values returned by an 
      enclosed expression, a new text node is constructed, containing the result 
      of casting each atomic value to a string, with a single space character 
      inserted between adjacent values.</P>
      <DIV class=note>
      <P class=prefix><B>Note:</B></P>
      <P>The insertion of blank characters between adjacent values applies even 
      if one or both of the values is a zero-length string.</P></DIV>
      <LI>
      <P>For each node returned by an enclosed expression, a new copy is made of 
      the given node and all nodes that have the given node as an ancestor, 
      collectively referred to as <B>copied nodes</B>. The properties of the 
      copied nodes are as follows:</P>
      <OL class=enumua>
        <LI>
        <P>Each copied node receives a new node identity.</P>
        <LI>
        <P>The <CODE>parent</CODE>, <CODE>children</CODE>, and 
        <CODE>attributes</CODE> properties of the copied nodes are set so as to 
        preserve their inter-node relationships. For the topmost node (the node 
        directly returned by the enclosed expression), the <CODE>parent</CODE> 
        property is set to the node constructed by this constructor.</P>
        <LI>
        <P>If <A title="construction mode" 
        href="REC-xquery-20070123.htm#dt-construction-mode">construction 
        mode</A> in the <A title="static context" 
        href="REC-xquery-20070123.htm#dt-static-context">static 
        context</A> is <CODE>strip</CODE>:</P>
        <OL class=enumur>
          <LI>
          <P>If the copied node is an element node, its <CODE>type-name</CODE> 
          property is set to <CODE>xs:untyped</CODE>. Its <CODE>nilled</CODE>, 
          <CODE>is-id</CODE>, and <CODE>is-idrefs</CODE> properties are set to 
          <CODE>false</CODE>.</P>
          <LI>
          <P>If the copied node is an attribute node, its <CODE>type-name</CODE> 
          property is set to <CODE>xs:untypedAtomic</CODE>. Its 
          <CODE>is-idrefs</CODE> property is set to <CODE>false</CODE>. Its 
          <CODE>is-id</CODE> property is set to <CODE>true</CODE> if the 
          qualified name of the attribute node is <CODE>xml:id</CODE>; otherwise 
          it is set to <CODE>false</CODE>.</P>
          <LI>
          <P>The <CODE>string-value</CODE> of each copied element and attribute 
          node remains unchanged, and its <CODE>typed-value</CODE> becomes equal 
          to its <CODE>string-value</CODE> as an instance of 
          <CODE>xs:untypedAtomic</CODE>.</P>
          <DIV class=note>
          <P class=prefix><B>Note:</B></P>
          <P>Implementations that store only the <A title="typed value" 
          href="REC-xquery-20070123.htm#dt-typed-value">typed 
          value</A> of a node are required at this point to convert the typed 
          value to a string form.</P></DIV></LI></OL>
        <P>On the other hand, if <A title="construction mode" 
        href="REC-xquery-20070123.htm#dt-construction-mode">construction 
        mode</A> in the <A title="static context" 
        href="REC-xquery-20070123.htm#dt-static-context">static 
        context</A> is <CODE>preserve</CODE>, the <CODE>type-name</CODE>, 
        <CODE>nilled</CODE>, <CODE>string-value</CODE>, 
        <CODE>typed-value</CODE>, <CODE>is-id</CODE>, and <CODE>is-idrefs</CODE> 
        properties of the copied nodes are preserved.</P>
        <LI>
        <P>The <CODE>in-scope-namespaces</CODE> property of a copied element 
        node is determined by the following rules. In applying these rules, the 
        default namespace or absence of a default namespace is treated like any 
        other namespace binding:</P>
        <OL class=enumur>
          <LI>
          <P>If <A title="copy-namespaces mode" 
          href="REC-xquery-20070123.htm#dt-copy-namespaces-mode">copy-namespaces 
          mode</A> specifies <CODE>preserve</CODE>, all in-scope-namespaces of 
          the original element are retained in the new copy. If <A 
          title="copy-namespaces mode" 
          href="REC-xquery-20070123.htm#dt-copy-namespaces-mode">copy-namespaces 
          mode</A> specifies <CODE>no-preserve</CODE>, the new copy retains only 
          those in-scope namespaces of the original element that are used in the 
          names of the element and its attributes. It is a <A title="type error" 
          href="REC-xquery-20070123.htm#dt-type-error">type 
          error</A> [<A title=err:XQTY0086 
          href="REC-xquery-20070123.htm#ERRXQTY0086">err:XQTY0086</A>] 
          in this case if the <A title="typed value" 
          href="REC-xquery-20070123.htm#dt-typed-value">typed 
          value</A> of the copied element or of any of its attributes is <A 
          title=namespace-sensitive 
          href="REC-xquery-20070123.htm#dt-namespace-sensitive">namespace-sensitive</A>. 
          [<A id=dt-namespace-sensitive title=namespace-sensitive 
          name=dt-namespace-sensitive>Definition</A>: A value is 
          <B>namespace-sensitive</B> if it includes an item whose <A 
          title="dynamic type" 
          href="REC-xquery-20070123.htm#dt-dynamic-type">dynamic 
          type</A> is <CODE>xs:QName</CODE> or <CODE>xs:NOTATION</CODE> or is 
          derived by restriction from <CODE>xs:QName</CODE> or 
          <CODE>xs:NOTATION</CODE>.]</P>
          <DIV class=note>
          <P class=prefix><B>Note:</B></P>
          <P>Error [<A title=err:XQTY0086 
          href="REC-xquery-20070123.htm#ERRXQTY0086">err:XQTY0086</A>] 
          can occur only if <A title="construction mode" 
          href="REC-xquery-20070123.htm#dt-construction-mode">construction 
          mode</A> is <CODE>preserve</CODE>, since otherwise the typed value of 
          the copied node is never namespace-sensitive.</P></DIV>
          <LI>
          <P>If <A title="copy-namespaces mode" 
          href="REC-xquery-20070123.htm#dt-copy-namespaces-mode">copy-namespaces 
          mode</A> specifies <CODE>inherit</CODE>, the copied node inherits all 
          the in-scope namespaces of the constructed node, augmented and 
          overridden by the in-scope namespaces of the original element that 
          were preserved by the preceding rule. If <A 
          title="copy-namespaces mode" 
          href="REC-xquery-20070123.htm#dt-copy-namespaces-mode">copy-namespaces 
          mode</A> specifies <CODE>no-inherit</CODE>, the copied node does not 
          inherit any in-scope namespaces from the constructed node.</P></LI></OL>
        <LI>
        <P>When an element or processing instruction node is copied, its 
        <CODE>base-uri</CODE> property is set to be the same as that of its new 
        parent, with the following exception: if a copied element node has an 
        <CODE>xml:base</CODE> attribute, its <CODE>base-uri</CODE> property is 
        set to the value of that attribute, resolved (if it is relative) against 
        the <CODE>base-uri</CODE> property of the new parent node.</P>
        <LI>
        <P>All other properties of the copied nodes are 
      preserved.</P></LI></OL></LI></OL></LI></OL>
  <LI>
  <P>If the content sequence contains a document node, the document node is 
  replaced in the content sequence by its children.</P>
  <LI>
  <P>Adjacent text nodes in the content sequence are merged into a single text 
  node by concatenating their contents, with no intervening blanks. After 
  concatenation, any text node whose content is a zero-length string is deleted 
  from the content sequence.</P>
  <LI>
  <P>If the content sequence contains an attribute node following a node that is 
  not an attribute node, a <A title="type error" 
  href="REC-xquery-20070123.htm#dt-type-error">type 
  error</A> is raised [<A title=err:XQTY0024 
  href="REC-xquery-20070123.htm#ERRXQTY0024">err:XQTY0024</A>].</P>
  <LI>
  <P>The properties of the newly constructed element node are determined as 
  follows:</P>
  <OL class=enumla>
    <LI>
    <P><CODE>node-name</CODE> is the <A title="expanded QName" 
    href="REC-xquery-20070123.htm#dt-expanded-qname">expanded 
    QName</A> resulting from resolving the element name in the start tag, 
    including its original namespace prefix (if any), as described in <A 
    href="REC-xquery-20070123.htm#id-element-constructor"><B>3.7.1 
    Direct Element Constructors</B></A>.</P>
    <LI>
    <P><CODE>parent</CODE> is set to empty.</P>
    <LI>
    <P><CODE>attributes</CODE> consist of all the attributes specified in the 
    start tag as described in <A 
    href="REC-xquery-20070123.htm#id-attributes"><B>3.7.1.1 
    Attributes</B></A>, together with all the attribute nodes in the content 
    sequence, in <A title="implementation dependent" 
    href="REC-xquery-20070123.htm#dt-implementation-dependent">implementation-dependent</A> 
    order. Note that the <CODE>parent</CODE> property of each of these attribute 
    nodes has been set to the newly constructed element node. If two or more 
    attributes have the same <CODE>node-name</CODE>, a <A title="dynamic error" 
    href="REC-xquery-20070123.htm#dt-dynamic-error">dynamic 
    error</A> is raised [<A title=err:XQDY0025 
    href="REC-xquery-20070123.htm#ERRXQDY0025">err:XQDY0025</A>]. 
    If an attribute named <CODE>xml:space</CODE> has a value other than 
    <CODE>preserve</CODE> or <CODE>default</CODE>, a dynamic error <A title=may 
    href="REC-xquery-20070123.htm#may">MAY</A> be raised 
    [<A title=err:XQDY0092 
    href="REC-xquery-20070123.htm#ERRXQDY0092">err:XQDY0092</A>].</P>
    <LI>
    <P><CODE>children</CODE> consist of all the element, text, comment, and 
    processing instruction nodes in the content sequence. Note that the 
    <CODE>parent</CODE> property of each of these nodes has been set to the 
    newly constructed element node.</P>
    <LI>
    <P><CODE>base-uri</CODE> is set to the following value:</P>
    <OL class=enumlr>
      <LI>
      <P>If the constructed node has an attribute named <CODE>xml:base</CODE>, 
      then the value of this attribute, resolved if it is relative against the 
      <A title="base URI" 
      href="REC-xquery-20070123.htm#dt-base-uri">base 
      URI</A> in the <A title="base URI" 
      href="REC-xquery-20070123.htm#dt-base-uri">static 
      context</A>. The value of the <CODE>xml:base</CODE> attribute is 
      normalized as described in <A 
      href="REC-xquery-20070123.htm#XMLBASE">[XML 
      Base]</A>.</P>
      <LI>
      <P>Otherwise, the value of the <A title="base URI" 
      href="REC-xquery-20070123.htm#dt-base-uri">base 
      URI</A> in the <A title="base URI" 
      href="REC-xquery-20070123.htm#dt-base-uri">static 
      context</A>.</P></LI></OL>
    <LI>
    <P><CODE>in-scope-namespaces</CODE> consist of all the namespace bindings 
    resulting from namespace declaration attributes as described in <A 
    href="REC-xquery-20070123.htm#id-namespaces"><B>3.7.1.2 
    Namespace Declaration Attributes</B></A>, and possibly additional namespace 
    bindings as described in <A 
    href="REC-xquery-20070123.htm#id-ns-nodes-on-elements"><B>3.7.4 
    In-scope Namespaces of a Constructed Element</B></A>.</P>
    <LI>
    <P>The <CODE>nilled</CODE> property is <CODE>false</CODE>.</P>
    <LI>
    <P>The <CODE>string-value</CODE> property is equal to the concatenated 
    contents of the text-node descendants in document order. If there are no 
    text-node descendants, the <CODE>string-value</CODE> property is a 
    zero-length string.</P>
    <LI>
    <P>The <CODE>typed-value</CODE> property is equal to the 
    <CODE>string-value</CODE> property, as an instance of 
    <CODE>xs:untypedAtomic</CODE>.</P>
    <LI>
    <P>If <A title="construction mode" 
    href="REC-xquery-20070123.htm#dt-construction-mode">construction 
    mode</A> in the <A title="static context" 
    href="REC-xquery-20070123.htm#dt-static-context">static 
    context</A> is <CODE>strip</CODE>, the <CODE>type-name</CODE> property is 
    <CODE>xs:untyped</CODE>. On the other hand, if construction mode is 
    <CODE>preserve</CODE>, the <CODE>type-name</CODE> property is 
    <CODE>xs:anyType</CODE>.</P>
    <LI>
    <P>The <CODE>is-id</CODE> and <CODE>is-idrefs</CODE> properties are set to 
    <CODE>false</CODE>.</P></LI></OL></LI></OL>
<UL>
  <LI>
  <P>Example:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>&lt;a&gt;{1}&lt;/a&gt;
</PRE></DIV></DIV>
  <P>The constructed element node has one child, a text node containing the 
  value "<CODE>1</CODE>".</P>
  <LI>
  <P>Example:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>&lt;a&gt;{1, 2, 3}&lt;/a&gt;
</PRE></DIV></DIV>
  <P>The constructed element node has one child, a text node containing the 
  value "<CODE>1 2 3</CODE>".</P>
  <LI>
  <P>Example:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>&lt;c&gt;{1}{2}{3}&lt;/c&gt;
</PRE></DIV></DIV>
  <P>The constructed element node has one child, a text node containing the 
  value "<CODE>123</CODE>".</P>
  <LI>
  <P>Example:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>&lt;b&gt;{1, "2", "3"}&lt;/b&gt;
</PRE></DIV></DIV>
  <P>The constructed element node has one child, a text node containing the 
  value "<CODE>1 2 3</CODE>".</P>
  <LI>
  <P>Example:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>&lt;fact&gt;I saw 8 cats.&lt;/fact&gt;
</PRE></DIV></DIV>
  <P>The constructed element node has one child, a text node containing the 
  value "<CODE>I saw 8 cats.</CODE>".</P>
  <LI>
  <P>Example:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>&lt;fact&gt;I saw {5 + 3} cats.&lt;/fact&gt;
</PRE></DIV></DIV>
  <P>The constructed element node has one child, a text node containing the 
  value "<CODE>I saw 8 cats.</CODE>".</P>
  <LI>
  <P>Example:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>&lt;fact&gt;I saw &lt;howmany&gt;{5 + 3}&lt;/howmany&gt; cats.&lt;/fact&gt;
</PRE></DIV></DIV>
  <P>The constructed element node has three children: a text node containing 
  "<CODE>I saw</CODE> ", a child element node named <CODE>howmany</CODE>, and a 
  text node containing " <CODE>cats.</CODE>". The child element node in turn has 
  a single text node child containing the value 
"<CODE>8</CODE>".</P></LI></UL></DIV>
<DIV class=div4>
<H5><A id=id-whitespace name=id-whitespace></A>3.7.1.4 Boundary Whitespace</H5>
<P>In a direct element constructor, whitespace characters may appear in the 
content of the constructed element. In some cases, enclosed expressions and/or 
nested elements may be separated only by whitespace characters. For example, in 
the expression below, the end-tag <CODE>&lt;/title&gt;</CODE> and the start-tag 
<CODE>&lt;author&gt;</CODE> are separated by a newline character and four space 
characters:</P>
<DIV class=parse-test>
<DIV class=exampleInner><PRE>&lt;book isbn="isbn-0060229357"&gt;
    &lt;title&gt;Harold and the Purple Crayon&lt;/title&gt;
    &lt;author&gt;
        &lt;first&gt;Crockett&lt;/first&gt;
        &lt;last&gt;Johnson&lt;/last&gt;
    &lt;/author&gt;
&lt;/book&gt;
</PRE></DIV></DIV>
<P>[<A id=dt-boundary-whitespace title="boundary whitespace" 
name=dt-boundary-whitespace>Definition</A>: <B>Boundary whitespace</B> is a 
sequence of consecutive whitespace characters within the content of a <A 
title="direct element constructor" 
href="REC-xquery-20070123.htm#dt-direct-elem-const">direct 
element constructor</A>, that is delimited at each end either by the start or 
end of the content, or by a <A 
href="REC-xquery-20070123.htm#doc-xquery-DirectConstructor">DirectConstructor</A>, 
or by an <A 
href="REC-xquery-20070123.htm#doc-xquery-EnclosedExpr">EnclosedExpr</A>. 
For this purpose, characters generated by <A title="character reference" 
href="REC-xquery-20070123.htm#dt-character-reference">character 
references</A> such as <CODE>&amp;#x20;</CODE> or by <A 
href="REC-xquery-20070123.htm#doc-xquery-CDataSection">CdataSections</A> 
are not considered to be whitespace characters.]</P>
<P>The <A title="boundary-space policy" 
href="REC-xquery-20070123.htm#dt-boundary-space-policy">boundary-space 
policy</A> in the <A title="static context" 
href="REC-xquery-20070123.htm#dt-static-context">static 
context</A> controls whether boundary whitespace is preserved by element 
constructors. If boundary-space policy is <CODE>strip</CODE>, boundary 
whitespace is not considered significant and is discarded. On the other hand, if 
boundary-space policy is <CODE>preserve</CODE>, boundary whitespace is 
considered significant and is preserved.</P>
<UL>
  <LI>
  <P>Example:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>&lt;cat&gt; 
   &lt;breed&gt;{$b}&lt;/breed&gt;
   &lt;color&gt;{$c}&lt;/color&gt; 
&lt;/cat&gt;
</PRE></DIV></DIV>
  <P>The constructed <CODE>cat</CODE> element node has two child element nodes 
  named <CODE>breed</CODE> and <CODE>color</CODE>. Whitespace surrounding the 
  child elements will be stripped away by the element constructor if 
  boundary-space policy is <CODE>strip</CODE>.</P>
  <LI>
  <P>Example:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>&lt;a&gt;  {"abc"}  &lt;/a&gt;
</PRE></DIV></DIV>
  <P>If boundary-space policy is <CODE>strip</CODE>, this example is equivalent 
  to <CODE>&lt;a&gt;abc&lt;/a&gt;</CODE>. However, if boundary-space policy is 
  <CODE>preserve</CODE>, this example is equivalent to 
  <CODE>&lt;a&gt;&nbsp;&nbsp;abc&nbsp;&nbsp;&lt;/a&gt;</CODE>.</P>
  <LI>
  <P>Example:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>&lt;a&gt; z {"abc"}&lt;/a&gt;
</PRE></DIV></DIV>
  <P>Since the whitespace surrounding the <CODE>z</CODE> is not boundary 
  whitespace, it is always preserved. This example is equivalent to 
  <CODE>&lt;a&gt;&nbsp;z&nbsp;abc&lt;/a&gt;</CODE>.</P>
  <LI>
  <P>Example:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>&lt;a&gt;&amp;#x20;{"abc"}&lt;/a&gt;
</PRE></DIV></DIV>
  <P>This example is equivalent to <CODE>&lt;a&gt;&nbsp;abc&lt;/a&gt;</CODE>, 
  regardless of the boundary-space policy, because the space generated by the <A 
  title="character reference" 
  href="REC-xquery-20070123.htm#dt-character-reference">character 
  reference</A> is not treated as a whitespace character.</P>
  <LI>
  <P>Example:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>&lt;a&gt;{"  "}&lt;/a&gt;
</PRE></DIV></DIV>
  <P>This example constructs an element containing two space characters, 
  regardless of the boundary-space policy, because whitespace inside an enclosed 
  expression is never considered to be boundary whitespace.</P></LI></UL>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>Element constructors treat attributes named <CODE>xml:space</CODE> as 
ordinary attributes. An <CODE>xml:space</CODE> attribute does not affect the 
handling of whitespace by an element constructor.</P></DIV></DIV></DIV>
<DIV class=div3>
<H4><A id=id-otherConstructors name=id-otherConstructors></A>3.7.2 Other Direct 
Constructors</H4>
<P>XQuery allows an expression to generate a processing instruction node or a 
comment node. This can be accomplished by using a <B>direct processing 
instruction constructor</B> or a <B>direct comment constructor</B>. In each 
case, the syntax of the constructor expression is based on the syntax of a 
similar construct in XML.</P>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-DirPIConstructor 
      name=doc-xquery-DirPIConstructor></A>[105]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-DirPIConstructor">DirPIConstructor</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"&lt;?" <A 
      href="REC-xquery-20070123.htm#prod-xquery-PITarget">PITarget</A> 
      (<A 
      href="REC-xquery-20070123.htm#prod-xquery-S">S</A> 
      <A 
      href="REC-xquery-20070123.htm#doc-xquery-DirPIContents">DirPIContents</A>)? 
      "?&gt;"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-DirPIContents 
      name=doc-xquery-DirPIContents></A>[106]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-DirPIContents">DirPIContents</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>(<A 
      href="REC-xquery-20070123.htm#prod-xquery-Char">Char</A>* 
      - (Char* '?&gt;' Char*))</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-DirCommentConstructor 
      name=doc-xquery-DirCommentConstructor></A>[103]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-DirCommentConstructor">DirCommentConstructor</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"&lt;!--" <A 
      href="REC-xquery-20070123.htm#doc-xquery-DirCommentContents">DirCommentContents</A> 
      "--&gt;"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-DirCommentContents 
      name=doc-xquery-DirCommentContents></A>[104]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-DirCommentContents">DirCommentContents</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>((<A 
      href="REC-xquery-20070123.htm#prod-xquery-Char">Char</A> 
      - '-') | ('-' (<A 
      href="REC-xquery-20070123.htm#prod-xquery-Char">Char</A> 
      - '-')))*</CODE></TD></TR></TBODY></TABLE>
<P>A direct processing instruction constructor creates a processing instruction 
node whose <CODE>target</CODE> property is <A 
href="REC-xquery-20070123.htm#prod-xquery-PITarget">PITarget</A> 
and whose <CODE>content</CODE> property is <A 
href="REC-xquery-20070123.htm#doc-xquery-DirPIContents">DirPIContents</A>. 
The <CODE>base-uri</CODE> property of the node is empty. The <CODE>parent</CODE> 
property of the node is empty.</P>
<P>The <A 
href="REC-xquery-20070123.htm#prod-xquery-PITarget">PITarget</A> 
of a processing instruction may not consist of the characters "XML" in any 
combination of upper and lower case. The <A 
href="REC-xquery-20070123.htm#doc-xquery-DirPIContents">DirPIContents</A> 
of a processing instruction may not contain the string "<CODE>?&gt;</CODE>".</P>
<P>The following example illustrates a direct processing instruction 
constructor:</P>
<DIV class=parse-test>
<DIV class=exampleInner><PRE>&lt;?format role="output" ?&gt;
</PRE></DIV></DIV>
<P>A direct comment constructor creates a comment node whose 
<CODE>content</CODE> property is <A 
href="REC-xquery-20070123.htm#doc-xquery-DirCommentContents">DirCommentContents</A>. 
Its <CODE>parent</CODE> property is empty.</P>
<P>The <A 
href="REC-xquery-20070123.htm#doc-xquery-DirCommentContents">DirCommentContents</A> 
of a comment may not contain two consecutive hyphens or end with a hyphen. These 
rules are syntactically enforced by the grammar shown above.</P>
<P>The following example illustrates a direct comment constructor:</P>
<DIV class=parse-test>
<DIV class=exampleInner><PRE>&lt;!-- Tags are ignored in the following section --&gt;
</PRE></DIV></DIV>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>A direct comment constructor is different from a <A 
href="REC-xquery-20070123.htm#doc-xquery-Comment">comment</A>, 
since a direct comment constructor actually constructs a comment node, whereas a 
<A 
href="REC-xquery-20070123.htm#doc-xquery-Comment">comment</A> 
is simply used in documenting a query and is not evaluated.</P></DIV></DIV>
<DIV class=div3>
<H4><A id=id-computedConstructors name=id-computedConstructors></A>3.7.3 
Computed Constructors</H4>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-ComputedConstructor 
      name=doc-xquery-ComputedConstructor></A>[109]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-ComputedConstructor">ComputedConstructor</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-CompDocConstructor">CompDocConstructor</A><BR>| 
      <A 
      href="REC-xquery-20070123.htm#doc-xquery-CompElemConstructor">CompElemConstructor</A><BR>| 
      <A 
      href="REC-xquery-20070123.htm#doc-xquery-CompAttrConstructor">CompAttrConstructor</A><BR>| 
      <A 
      href="REC-xquery-20070123.htm#doc-xquery-CompTextConstructor">CompTextConstructor</A><BR>| 
      <A 
      href="REC-xquery-20070123.htm#doc-xquery-CompCommentConstructor">CompCommentConstructor</A><BR>| 
      <A 
      href="REC-xquery-20070123.htm#doc-xquery-CompPIConstructor">CompPIConstructor</A></CODE></TD></TR></TBODY></TABLE>
<P>An alternative way to create nodes is by using a <B>computed constructor</B>. 
A computed constructor begins with a keyword that identifies the type of node to 
be created: <CODE>element</CODE>, <CODE>attribute</CODE>, <CODE>document</CODE>, 
<CODE>text</CODE>, <CODE>processing-instruction</CODE>, or 
<CODE>comment</CODE>.</P>
<P>For those kinds of nodes that have names (element, attribute, and processing 
instruction nodes), the keyword that specifies the node kind is followed by the 
name of the node to be created. This name may be specified either as a QName or 
as an expression enclosed in braces. [<A id=dt-name-expression 
title="name expression" name=dt-name-expression>Definition</A>: When an 
expression is used to specify the name of a constructed node, that expression is 
called the <B>name expression</B> of the constructor.]</P>
<P>[<A id=dt-content-expression title="content expression" 
name=dt-content-expression>Definition</A>: The final part of a computed 
constructor is an expression enclosed in braces, called the <B>content 
expression</B> of the constructor, that generates the content of the node.]</P>
<P>The following example illustrates the use of computed element and attribute 
constructors in a simple case where the names of the constructed nodes are 
constants. This example generates exactly the same result as the first example 
in <A 
href="REC-xquery-20070123.htm#id-element-constructor"><B>3.7.1 
Direct Element Constructors</B></A>:</P>
<DIV class=parse-test>
<DIV class=exampleInner><PRE>element book { 
   attribute isbn {"isbn-0060229357" }, 
   element title { "Harold and the Purple Crayon"},
   element author { 
      element first { "Crockett" }, 
      element last {"Johnson" }
   }
}
</PRE></DIV></DIV>
<DIV class=div4>
<H5><A id=id-computedElements name=id-computedElements></A>3.7.3.1 Computed 
Element Constructors</H5>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-CompElemConstructor 
      name=doc-xquery-CompElemConstructor></A>[111]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-CompElemConstructor">CompElemConstructor</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"element" (<A 
      href="REC-xquery-20070123.htm#prod-xquery-QName">QName</A> 
      | ("{" <A 
      href="REC-xquery-20070123.htm#doc-xquery-Expr">Expr</A> 
      "}")) "{" <A 
      href="REC-xquery-20070123.htm#doc-xquery-ContentExpr">ContentExpr</A>? 
      "}"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-ContentExpr 
      name=doc-xquery-ContentExpr></A>[112]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-ContentExpr">ContentExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-Expr">Expr</A></CODE></TD></TR></TBODY></TABLE>
<P>[<A id=dt-computed-elem-const title="computed element constructor" 
name=dt-computed-elem-const>Definition</A>: A <B>computed element 
constructor</B> creates an element node, allowing both the name and the content 
of the node to be computed.]</P>
<P>If the keyword <CODE>element</CODE> is followed by a QName, it is expanded 
using the <A title="statically known namespaces" 
href="REC-xquery-20070123.htm#dt-static-namespaces">statically 
known namespaces</A>, and the resulting <A title="expanded QName" 
href="REC-xquery-20070123.htm#dt-expanded-qname">expanded 
QName</A> is used as the <CODE>node-name</CODE> property of the constructed 
element node. If expansion of the QName is not successful, a <A 
title="static error" 
href="REC-xquery-20070123.htm#dt-static-error">static 
error</A> is raised [<A title=err:XPST0081 
href="REC-xquery-20070123.htm#ERRXPST0081">err:XPST0081</A>].</P>
<P>If the keyword <CODE>element</CODE> is followed by a <A 
title="name expression" 
href="REC-xquery-20070123.htm#dt-name-expression">name 
expression</A>, the name expression is processed as follows:</P>
<OL class=enumar>
  <LI>
  <P><A title=atomization 
  href="REC-xquery-20070123.htm#dt-atomization">Atomization</A> 
  is applied to the value of the <A title="name expression" 
  href="REC-xquery-20070123.htm#dt-name-expression">name 
  expression</A>. If the result of atomization is not a single atomic value of 
  type <CODE>xs:QName</CODE>, <CODE>xs:string</CODE>, or 
  <CODE>xs:untypedAtomic</CODE>, a <A title="type error" 
  href="REC-xquery-20070123.htm#dt-type-error">type 
  error</A> is raised [<A title=err:XPTY0004 
  href="REC-xquery-20070123.htm#ERRXPTY0004">err:XPTY0004</A>].</P>
  <LI>
  <P>If the atomized value of the <A title="name expression" 
  href="REC-xquery-20070123.htm#dt-name-expression">name 
  expression</A> is of type <CODE>xs:QName</CODE>, that <A 
  title="expanded QName" 
  href="REC-xquery-20070123.htm#dt-expanded-qname">expanded 
  QName</A> is used as the <CODE>node-name</CODE> property of the constructed 
  element, retaining the prefix part of the QName.</P>
  <LI>
  <P>If the atomized value of the <A title="name expression" 
  href="REC-xquery-20070123.htm#dt-name-expression">name 
  expression</A> is of type <CODE>xs:string</CODE> or 
  <CODE>xs:untypedAtomic</CODE>, that value is converted to an <A 
  title="expanded QName" 
  href="REC-xquery-20070123.htm#dt-expanded-qname">expanded 
  QName</A>. If the string value contains a namespace prefix, that prefix is 
  resolved to a namespace URI using the <A title="statically known namespaces" 
  href="REC-xquery-20070123.htm#dt-static-namespaces">statically 
  known namespaces</A>. If the string value contains no namespace prefix, it is 
  treated as a local name in the <A title="default element/type namespace" 
  href="REC-xquery-20070123.htm#dt-def-elemtype-ns">default 
  element/type namespace</A>. The resulting <A title="expanded QName" 
  href="REC-xquery-20070123.htm#dt-expanded-qname">expanded 
  QName</A> is used as the <CODE>node-name</CODE> property of the constructed 
  element, retaining the prefix part of the QName. If conversion of the atomized 
  <A title="name expression" 
  href="REC-xquery-20070123.htm#dt-name-expression">name 
  expression</A> to an expanded QName is not successful, a <A 
  title="dynamic error" 
  href="REC-xquery-20070123.htm#dt-dynamic-error">dynamic 
  error</A> is raised [<A title=err:XQDY0074 
  href="REC-xquery-20070123.htm#ERRXQDY0074">err:XQDY0074</A>].</P></LI></OL>
<P>The <A title="content expression" 
href="REC-xquery-20070123.htm#dt-content-expression">content 
expression</A> of a computed element constructor (if present) is processed in 
exactly the same way as an enclosed expression in the content of a <A 
title="direct element constructor" 
href="REC-xquery-20070123.htm#dt-direct-elem-const">direct 
element constructor</A>, as described in Step 1e of <A 
href="REC-xquery-20070123.htm#id-content"><B>3.7.1.3 
Content</B></A>. The result of processing the content expression is a sequence 
of nodes called the <B>content sequence</B>. If the <A 
title="content expression" 
href="REC-xquery-20070123.htm#dt-content-expression">content 
expression</A> is absent, the content sequence is an empty sequence.</P>
<P>Processing of the computed element constructor proceeds as follows:</P>
<OL class=enumar>
  <LI>
  <P>Adjacent text nodes in the content sequence are merged into a single text 
  node by concatenating their contents, with no intervening blanks. After 
  concatenation, any text node whose content is a zero-length string is deleted 
  from the content sequence.</P>
  <LI>
  <P>If the content sequence contains a document node, the document node is 
  replaced in the content sequence by its children.</P>
  <LI>
  <P>If the content sequence contains an attribute node following a node that is 
  not an attribute node, a <A title="type error" 
  href="REC-xquery-20070123.htm#dt-type-error">type 
  error</A> is raised [<A title=err:XQTY0024 
  href="REC-xquery-20070123.htm#ERRXQTY0024">err:XQTY0024</A>].</P>
  <LI>
  <P>The properties of the newly constructed element node are determined as 
  follows:</P>
  <OL class=enumla>
    <LI>
    <P><CODE>node-name</CODE> is the <A title="expanded QName" 
    href="REC-xquery-20070123.htm#dt-expanded-qname">expanded 
    QName</A> resulting from processing the specified QName or <A 
    title="name expression" 
    href="REC-xquery-20070123.htm#dt-name-expression">name 
    expression</A>, as described above.</P>
    <LI>
    <P><CODE>parent</CODE> is empty.</P>
    <LI>
    <P><CODE>attributes</CODE> consist of all the attribute nodes in the content 
    sequence, in <A title="implementation dependent" 
    href="REC-xquery-20070123.htm#dt-implementation-dependent">implementation-dependent</A> 
    order. Note that the <CODE>parent</CODE> property of each of these attribute 
    nodes has been set to the newly constructed element node. If two or more 
    attributes have the same <CODE>node-name</CODE>, a <A title="dynamic error" 
    href="REC-xquery-20070123.htm#dt-dynamic-error">dynamic 
    error</A> is raised [<A title=err:XQDY0025 
    href="REC-xquery-20070123.htm#ERRXQDY0025">err:XQDY0025</A>]. 
    If an attribute named <CODE>xml:space</CODE> has a value other than 
    <CODE>preserve</CODE> or <CODE>default</CODE>, a dynamic error <A title=may 
    href="REC-xquery-20070123.htm#may">MAY</A> be raised 
    [<A title=err:XQDY0092 
    href="REC-xquery-20070123.htm#ERRXQDY0092">err:XQDY0092</A>].</P>
    <LI>
    <P><CODE>children</CODE> consist of all the element, text, comment, and 
    processing instruction nodes in the content sequence. Note that the 
    <CODE>parent</CODE> property of each of these nodes has been set to the 
    newly constructed element node.</P>
    <LI>
    <P><CODE>base-uri</CODE> is set to the following value:</P>
    <OL class=enumlr>
      <LI>
      <P>If the constructed node has an attribute named <CODE>xml:base</CODE>, 
      then the value of this attribute, resolved if it is relative against the 
      <A title="base URI" 
      href="REC-xquery-20070123.htm#dt-base-uri">base 
      URI</A> in the <A title="base URI" 
      href="REC-xquery-20070123.htm#dt-base-uri">static 
      context</A>. The value of the <CODE>xml:base</CODE> attribute is 
      normalized as described in <A 
      href="REC-xquery-20070123.htm#XMLBASE">[XML 
      Base]</A>.</P>
      <LI>
      <P>Otherwise, the value of the <A title="base URI" 
      href="REC-xquery-20070123.htm#dt-base-uri">base 
      URI</A> in the <A title="base URI" 
      href="REC-xquery-20070123.htm#dt-base-uri">static 
      context</A>.</P></LI></OL>
    <LI>
    <P><CODE>in-scope-namespaces</CODE> are computed as described in <A 
    href="REC-xquery-20070123.htm#id-ns-nodes-on-elements"><B>3.7.4 
    In-scope Namespaces of a Constructed Element</B></A>.</P>
    <LI>
    <P>The <CODE>nilled</CODE> property is <CODE>false</CODE>.</P>
    <LI>
    <P>The <CODE>string-value</CODE> property is equal to the concatenated 
    contents of the text-node descendants in document order.</P>
    <LI>
    <P>The <CODE>typed-value</CODE> property is equal to the 
    <CODE>string-value</CODE> property, as an instance of 
    <CODE>xs:untypedAtomic</CODE>.</P>
    <LI>
    <P>If <A title="construction mode" 
    href="REC-xquery-20070123.htm#dt-construction-mode">construction 
    mode</A> in the <A title="static context" 
    href="REC-xquery-20070123.htm#dt-static-context">static 
    context</A> is <CODE>strip</CODE>, the <CODE>type-name</CODE> property is 
    <CODE>xs:untyped</CODE>. On the other hand, if construction mode is 
    <CODE>preserve</CODE>, the <CODE>type-name</CODE> property is 
    <CODE>xs:anyType</CODE>.</P>
    <LI>
    <P>The <CODE>is-id</CODE> and <CODE>is-idrefs</CODE> properties are set to 
    <CODE>false</CODE>.</P></LI></OL></LI></OL>
<P>A computed element constructor might be used to make a modified copy of an 
existing element. For example, if the variable <CODE>$e</CODE> is bound to an 
element with <A title=numeric 
href="REC-xquery-20070123.htm#dt-numeric">numeric</A> 
content, the following constructor might be used to create a new element with 
the same name and attributes as <CODE>$e</CODE> and with numeric content equal 
to twice the value of <CODE>$e</CODE>:</P>
<DIV class=parse-test>
<DIV class=exampleInner><PRE>element {fn:node-name($e)}
   {$e/@*, 2 * fn:data($e)}
</PRE></DIV></DIV>
<P>In this example, if <CODE>$e</CODE> is bound by the expression <CODE>let $e 
:= &lt;length units="inches"&gt;{5}&lt;/length&gt;</CODE>, then the result of 
the example expression is the element <CODE>&lt;length 
units="inches"&gt;10&lt;/length&gt;</CODE>.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>The <A title="static type" 
href="REC-xquery-20070123.htm#dt-static-type">static 
type</A> of the expression <CODE>fn:node-name($e)</CODE> is 
<CODE>xs:QName?</CODE>, denoting zero or one QName. Therefore, if the <A 
title="static typing feature" 
href="REC-xquery-20070123.htm#dt-static-typing-feature">Static 
Typing Feature</A> is in effect, the above example raises a static type error, 
since the name expression in a computed element constructor is required to 
return exactly one string or QName. In order to avoid the static type error, the 
name expression <CODE>fn:node-name($e)</CODE> could be rewritten as 
<CODE>fn:exactly-one(fn:node-name($e))</CODE>. If the <A 
title="static typing feature" 
href="REC-xquery-20070123.htm#dt-static-typing-feature">Static 
Typing Feature</A> is not in effect, the example can be successfully evaluated 
as written, provided that <CODE>$e</CODE> is bound to exactly one element node 
with numeric content.</P></DIV>
<P>One important purpose of computed constructors is to allow the name of a node 
to be computed. We will illustrate this feature by an expression that translates 
the name of an element from one language to another. Suppose that the variable 
<CODE>$dict</CODE> is bound to a <CODE>dictionary</CODE> element containing a 
sequence of <CODE>entry</CODE> elements, each of which encodes translations for 
a specific word. Here is an example entry that encodes the German and Italian 
variants of the word "address":</P>
<DIV class=parse-test>
<DIV class=exampleInner><PRE>&lt;entry word="address"&gt;
   &lt;variant xml:lang="de"&gt;Adresse&lt;/variant&gt;
   &lt;variant xml:lang="it"&gt;indirizzo&lt;/variant&gt;
&lt;/entry&gt; 
</PRE></DIV></DIV>
<P>Suppose further that the variable <CODE>$e</CODE> is bound to the following 
element:</P>
<DIV class=parse-test>
<DIV class=exampleInner><PRE>&lt;address&gt;123 Roosevelt Ave. Flushing, NY 11368&lt;/address&gt;
</PRE></DIV></DIV>
<P>Then the following expression generates a new element in which the name of 
<CODE>$e</CODE> has been translated into Italian and the content of 
<CODE>$e</CODE> (including its attributes, if any) has been preserved. The first 
enclosed expression after the <CODE>element</CODE> keyword generates the name of 
the element, and the second enclosed expression generates the content and 
attributes:</P>
<DIV class=parse-test>
<DIV class=exampleInner><PRE>  element 
    {$dict/entry[@word=name($e)]/variant[@xml:lang="it"]}
    {$e/@*, $e/node()}
</PRE></DIV></DIV>
<P>The result of this expression is as follows:</P>
<DIV class=parse-test>
<DIV class=exampleInner><PRE>&lt;indirizzo&gt;123 Roosevelt Ave. Flushing, NY 11368&lt;/indirizzo&gt;
</PRE></DIV></DIV>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>As in the previous example, if the <A title="static typing feature" 
href="REC-xquery-20070123.htm#dt-static-typing-feature">Static 
Typing Feature</A> is in effect, the enclosed expression that computes the 
element name in the above computed element constructor must be wrapped in a call 
to the <CODE>fn:exactly-one</CODE> function in order to avoid a static type 
error.</P></DIV>
<P>Additional examples of computed element constructors can be found in <A 
href="REC-xquery-20070123.htm#id-recursive-transformations"><B>I.4 
Recursive Transformations</B></A>.</P></DIV>
<DIV class=div4>
<H5><A id=id-computedAttributes name=id-computedAttributes></A>3.7.3.2 Computed 
Attribute Constructors</H5>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-CompAttrConstructor 
      name=doc-xquery-CompAttrConstructor></A>[113]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-CompAttrConstructor">CompAttrConstructor</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"attribute" (<A 
      href="REC-xquery-20070123.htm#prod-xquery-QName">QName</A> 
      | ("{" <A 
      href="REC-xquery-20070123.htm#doc-xquery-Expr">Expr</A> 
      "}")) "{" <A 
      href="REC-xquery-20070123.htm#doc-xquery-Expr">Expr</A>? 
      "}"</CODE></TD></TR></TBODY></TABLE>
<P>A computed attribute constructor creates a new attribute node, with its own 
node identity.</P>
<P>If the keyword <CODE>attribute</CODE> is followed by a QName, that QName is 
expanded using the <A title="statically known namespaces" 
href="REC-xquery-20070123.htm#dt-static-namespaces">statically 
known namespaces</A>, and the resulting <A title="expanded QName" 
href="REC-xquery-20070123.htm#dt-expanded-qname">expanded 
QName</A> (including its prefix) is used as the <CODE>node-name</CODE> property 
of the constructed attribute node. If expansion of the QName is not successful, 
a <A title="static error" 
href="REC-xquery-20070123.htm#dt-static-error">static 
error</A> is raised [<A title=err:XPST0081 
href="REC-xquery-20070123.htm#ERRXPST0081">err:XPST0081</A>].</P>
<P>If the keyword <CODE>attribute</CODE> is followed by a <A 
title="name expression" 
href="REC-xquery-20070123.htm#dt-name-expression">name 
expression</A>, the name expression is processed as follows:</P>
<OL class=enumar>
  <LI>
  <P><A title=atomization 
  href="REC-xquery-20070123.htm#dt-atomization">Atomization</A> 
  is applied to the result of the <A title="name expression" 
  href="REC-xquery-20070123.htm#dt-name-expression">name 
  expression</A>. If the result of <A title=atomization 
  href="REC-xquery-20070123.htm#dt-atomization">atomization</A> 
  is not a single atomic value of type <CODE>xs:QName</CODE>, 
  <CODE>xs:string</CODE>, or <CODE>xs:untypedAtomic</CODE>, a <A 
  title="type error" 
  href="REC-xquery-20070123.htm#dt-type-error">type 
  error</A> is raised [<A title=err:XPTY0004 
  href="REC-xquery-20070123.htm#ERRXPTY0004">err:XPTY0004</A>].</P>
  <LI>
  <P>If the atomized value of the <A title="name expression" 
  href="REC-xquery-20070123.htm#dt-name-expression">name 
  expression</A> is of type <CODE>xs:QName</CODE>, that <A 
  title="expanded QName" 
  href="REC-xquery-20070123.htm#dt-expanded-qname">expanded 
  QName</A> (including its prefix) is used as the <CODE>node-name</CODE> 
  property of the constructed attribute node.</P>
  <LI>
  <P>If the atomized value of the <A title="name expression" 
  href="REC-xquery-20070123.htm#dt-name-expression">name 
  expression</A> is of type <CODE>xs:string</CODE> or 
  <CODE>xs:untypedAtomic</CODE>, that value is converted to an <A 
  title="expanded QName" 
  href="REC-xquery-20070123.htm#dt-expanded-qname">expanded 
  QName</A>. If the string value contains a namespace prefix, that prefix is 
  resolved to a namespace URI using the <A title="statically known namespaces" 
  href="REC-xquery-20070123.htm#dt-static-namespaces">statically 
  known namespaces</A>. If the string value contains no namespace prefix, it is 
  treated as a local name in no namespace. The resulting <A 
  title="expanded QName" 
  href="REC-xquery-20070123.htm#dt-expanded-qname">expanded 
  QName</A> (including its prefix) is used as the <CODE>node-name</CODE> 
  property of the constructed attribute. If conversion of the atomized <A 
  title="name expression" 
  href="REC-xquery-20070123.htm#dt-name-expression">name 
  expression</A> to an <A title="expanded QName" 
  href="REC-xquery-20070123.htm#dt-expanded-qname">expanded 
  QName</A> is not successful, a <A title="dynamic error" 
  href="REC-xquery-20070123.htm#dt-dynamic-error">dynamic 
  error</A> is raised [<A title=err:XQDY0074 
  href="REC-xquery-20070123.htm#ERRXQDY0074">err:XQDY0074</A>].</P></LI></OL>
<P>The <CODE>node-name</CODE> property of the constructed attribute (an <A 
title="expanded QName" 
href="REC-xquery-20070123.htm#dt-expanded-qname">expanded 
QName</A>) is checked as follows: If its URI part is 
<CODE>http://www.w3.org/2000/xmlns/</CODE> (corresponding to namespace prefix 
<CODE>xmlns</CODE>) or if it is in no namespace and its local name is 
<CODE>xmlns</CODE>, a <A title="dynamic error" 
href="REC-xquery-20070123.htm#dt-dynamic-error">dynamic 
error</A> [<A title=err:XQDY0044 
href="REC-xquery-20070123.htm#ERRXQDY0044">err:XQDY0044</A>] 
is raised.</P>
<P>The <A title="content expression" 
href="REC-xquery-20070123.htm#dt-content-expression">content 
expression</A> of a computed attribute constructor is processed as follows:</P>
<OL class=enumar>
  <LI>
  <P><A title=atomization 
  href="REC-xquery-20070123.htm#dt-atomization">Atomization</A> 
  is applied to the result of the <A title="content expression" 
  href="REC-xquery-20070123.htm#dt-content-expression">content 
  expression</A>, converting it to a sequence of atomic values. (If the <A 
  title="content expression" 
  href="REC-xquery-20070123.htm#dt-content-expression">content 
  expression</A> is absent, the result of this step is an empty sequence.)</P>
  <LI>
  <P>If the result of atomization is an empty sequence, the value of the 
  attribute is the zero-length string. Otherwise, each atomic value in the 
  atomized sequence is cast into a string.</P>
  <LI>
  <P>The individual strings resulting from the previous step are merged into a 
  single string by concatenating them with a single space character between each 
  pair. The resulting string becomes the <CODE>string-value</CODE> property of 
  the new attribute node. The <A title="type annotation" 
  href="REC-xquery-20070123.htm#dt-type-annotation">type 
  annotation</A> (<CODE>type-name</CODE> property) of the new attribute node is 
  <CODE>xs:untypedAtomic</CODE>. The <CODE>typed-value</CODE> property of the 
  attribute node is the same as its <CODE>string-value</CODE>, as an instance of 
  <CODE>xs:untypedAtomic</CODE>.</P>
  <LI>
  <P>The <CODE>parent</CODE> property of the attribute node is set to empty.</P>
  <LI>
  <P>If the attribute name is <CODE>xml:id</CODE>, then <CODE>xml:id</CODE> 
  processing is performed as defined in <A 
  href="REC-xquery-20070123.htm#XMLID">[XML ID]</A>. This 
  ensures that the attribute node has the type <CODE>xs:ID</CODE> and that its 
  value is properly normalized. If an error is encountered during 
  <CODE>xml:id</CODE> processing, an implementation <A title=may 
  href="REC-xquery-20070123.htm#may">MAY</A> raise a <A 
  title="dynamic error" 
  href="REC-xquery-20070123.htm#dt-dynamic-error">dynamic 
  error</A> [<A title=err:XQDY0091 
  href="REC-xquery-20070123.htm#ERRXQDY0091">err:XQDY0091</A>].</P>
  <LI>
  <P>If the attribute name is <CODE>xml:id</CODE>, the <CODE>is-id</CODE> 
  property of the resulting attribute node is set to <CODE>true</CODE>; 
  otherwise the <CODE>is-id</CODE> property is set to <CODE>false</CODE>. The 
  <CODE>is-idrefs</CODE> property of the attribute node is unconditionally set 
  to <CODE>false</CODE>.</P>
  <LI>
  <P>If the attribute name is <CODE>xml:space</CODE> and the attribute value is 
  other than <CODE>preserve</CODE> or <CODE>default</CODE>, a dynamic error <A 
  title=may href="REC-xquery-20070123.htm#may">MAY</A> be 
  raised [<A title=err:XQDY0092 
  href="REC-xquery-20070123.htm#ERRXQDY0092">err:XQDY0092</A>].</P></LI></OL>
<UL>
  <LI>
  <P>Example:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>attribute size {4 + 3}
</PRE></DIV></DIV>
  <P>The <A title="string value" 
  href="REC-xquery-20070123.htm#dt-string-value">string 
  value</A> of the <CODE>size</CODE> attribute is "<CODE>7</CODE>" and its type 
  is <CODE>xs:untypedAtomic</CODE>.</P>
  <LI>
  <P>Example:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>attribute
   { if ($sex = "M") then "husband" else "wife" }
   { &lt;a&gt;Hello&lt;/a&gt;, 1 to 3, &lt;b&gt;Goodbye&lt;/b&gt; }
</PRE></DIV></DIV>
  <P>The name of the constructed attribute is either <CODE>husband</CODE> or 
  <CODE>wife</CODE>. Its <A title="string value" 
  href="REC-xquery-20070123.htm#dt-string-value">string 
  value</A> is "<CODE>Hello 1 2 3 Goodbye</CODE>".</P></LI></UL></DIV>
<DIV class=div4>
<H5><A id=id-documentConstructors name=id-documentConstructors></A>3.7.3.3 
Document Node Constructors</H5>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-CompDocConstructor 
      name=doc-xquery-CompDocConstructor></A>[110]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-CompDocConstructor">CompDocConstructor</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"document" "{" <A 
      href="REC-xquery-20070123.htm#doc-xquery-Expr">Expr</A> 
      "}"</CODE></TD></TR></TBODY></TABLE>
<P>All document node constructors are computed constructors. The result of a 
document node constructor is a new document node, with its own node 
identity.</P>
<P>A document node constructor is useful when the result of a query is to be a 
document in its own right. The following example illustrates a query that 
returns an XML document containing a root element named 
<CODE>author-list</CODE>:</P>
<DIV class=parse-test>
<DIV class=exampleInner><PRE>document
   {
      &lt;author-list&gt;
         {fn:doc("bib.xml")/bib/book/author}
      &lt;/author-list&gt;
   }
</PRE></DIV></DIV>
<P>The <A title="content expression" 
href="REC-xquery-20070123.htm#dt-content-expression">content 
expression</A> of a document node constructor is processed in exactly the same 
way as an enclosed expression in the content of a <A 
title="direct element constructor" 
href="REC-xquery-20070123.htm#dt-direct-elem-const">direct 
element constructor</A>, as described in Step 1e of <A 
href="REC-xquery-20070123.htm#id-content"><B>3.7.1.3 
Content</B></A>. The result of processing the content expression is a sequence 
of nodes called the <B>content sequence</B>. Processing of the document node 
constructor then proceeds as follows:</P>
<OL class=enumar>
  <LI>
  <P>Adjacent text nodes in the content sequence are merged into a single text 
  node by concatenating their contents, with no intervening blanks. After 
  concatenation, any text node whose content is a zero-length string is deleted 
  from the content sequence.</P>
  <LI>
  <P>If the content sequence contains a document node, the document node is 
  replaced in the content sequence by its children.</P>
  <LI>
  <P>If the content sequence contains an attribute node, a <A title="type error" 
  href="REC-xquery-20070123.htm#dt-type-error">type 
  error</A> is raised [<A title=err:XPTY0004 
  href="REC-xquery-20070123.htm#ERRXPTY0004">err:XPTY0004</A>].</P>
  <LI>
  <P>The properties of the newly constructed document node are determined as 
  follows:</P>
  <OL class=enumla>
    <LI>
    <P><CODE>base-uri</CODE> is taken from <A title="base URI" 
    href="REC-xquery-20070123.htm#dt-base-uri">base 
    URI</A> in the <A title="base URI" 
    href="REC-xquery-20070123.htm#dt-base-uri">static 
    context</A>. If no base URI is defined in the static context, the 
    <CODE>base-uri</CODE> property is empty.</P>
    <LI>
    <P><CODE>children</CODE> consist of all the element, text, comment, and 
    processing instruction nodes in the content sequence. Note that the 
    <CODE>parent</CODE> property of each of these nodes has been set to the 
    newly constructed document node.</P>
    <LI>
    <P>The <CODE>unparsed-entities</CODE> and <CODE>document-uri</CODE> 
    properties are empty.</P>
    <LI>
    <P>The <CODE>string-value</CODE> property is equal to the concatenated 
    contents of the text-node descendants in document order.</P>
    <LI>
    <P>The <CODE>typed-value</CODE> property is equal to the 
    <CODE>string-value</CODE> property, as an instance of 
    <CODE>xs:untypedAtomic</CODE>.</P></LI></OL></LI></OL>
<P>No validation is performed on the constructed document node. The <A 
href="REC-xquery-20070123.htm#XML">[XML 1.0]</A> rules 
that govern the structure of an XML document (for example, the document node 
must have exactly one child that is an element node) are not enforced by the 
XQuery document node constructor.</P></DIV>
<DIV class=div4>
<H5><A id=id-textConstructors name=id-textConstructors></A>3.7.3.4 Text Node 
Constructors</H5>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-CompTextConstructor 
      name=doc-xquery-CompTextConstructor></A>[114]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-CompTextConstructor">CompTextConstructor</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"text" "{" <A 
      href="REC-xquery-20070123.htm#doc-xquery-Expr">Expr</A> 
      "}"</CODE></TD></TR></TBODY></TABLE>
<P>All text node constructors are computed constructors. The result of a text 
node constructor is a new text node, with its own node identity.</P>
<P>The <A title="content expression" 
href="REC-xquery-20070123.htm#dt-content-expression">content 
expression</A> of a text node constructor is processed as follows:</P>
<OL class=enumar>
  <LI>
  <P><A title=atomization 
  href="REC-xquery-20070123.htm#dt-atomization">Atomization</A> 
  is applied to the value of the <A title="content expression" 
  href="REC-xquery-20070123.htm#dt-content-expression">content 
  expression</A>, converting it to a sequence of atomic values.</P>
  <LI>
  <P>If the result of atomization is an empty sequence, no text node is 
  constructed. Otherwise, each atomic value in the atomized sequence is cast 
  into a string.</P>
  <LI>
  <P>The individual strings resulting from the previous step are merged into a 
  single string by concatenating them with a single space character between each 
  pair. The resulting string becomes the <CODE>content</CODE> property of the 
  constructed text node.</P></LI></OL>
<P>The <CODE>parent</CODE> property of the constructed text node is set to 
empty.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>It is possible for a text node constructor to construct a text node 
containing a zero-length string. However, if used in the content of a 
constructed element or document node, such a text node will be deleted or merged 
with another text node.</P></DIV>
<P>The following example illustrates a text node constructor:</P>
<DIV class=parse-test>
<DIV class=exampleInner><PRE>text {"Hello"}
</PRE></DIV></DIV></DIV>
<DIV class=div4>
<H5><A id=id-computed-pis name=id-computed-pis></A>3.7.3.5 Computed Processing 
Instruction Constructors</H5>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-CompPIConstructor 
      name=doc-xquery-CompPIConstructor></A>[116]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-CompPIConstructor">CompPIConstructor</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"processing-instruction" (<A 
      href="REC-xquery-20070123.htm#prod-xquery-NCName">NCName</A> 
      | ("{" <A 
      href="REC-xquery-20070123.htm#doc-xquery-Expr">Expr</A> 
      "}")) "{" <A 
      href="REC-xquery-20070123.htm#doc-xquery-Expr">Expr</A>? 
      "}"</CODE></TD></TR></TBODY></TABLE>
<P>A computed processing instruction constructor (<A 
href="REC-xquery-20070123.htm#doc-xquery-CompPIConstructor">CompPIConstructor</A>) 
constructs a new processing instruction node with its own node identity.</P>
<P>If the keyword <CODE>processing-instruction</CODE> is followed by an NCName, 
that NCName is used as the <CODE>target</CODE> property of the constructed node. 
If the keyword <CODE>processing-instruction</CODE> is followed by a <A 
title="name expression" 
href="REC-xquery-20070123.htm#dt-name-expression">name 
expression</A>, the name expression is processed as follows:</P>
<OL class=enumar>
  <LI>
  <P><A title=atomization 
  href="REC-xquery-20070123.htm#dt-atomization">Atomization</A> 
  is applied to the value of the <A title="name expression" 
  href="REC-xquery-20070123.htm#dt-name-expression">name 
  expression</A>. If the result of <A title=atomization 
  href="REC-xquery-20070123.htm#dt-atomization">atomization</A> 
  is not a single atomic value of type <CODE>xs:NCName</CODE>, 
  <CODE>xs:string</CODE>, or <CODE>xs:untypedAtomic</CODE>, a <A 
  title="type error" 
  href="REC-xquery-20070123.htm#dt-type-error">type 
  error</A> is raised [<A title=err:XPTY0004 
  href="REC-xquery-20070123.htm#ERRXPTY0004">err:XPTY0004</A>].</P>
  <LI>
  <P>If the atomized value of the <A title="name expression" 
  href="REC-xquery-20070123.htm#dt-name-expression">name 
  expression</A> is of type <CODE>xs:string</CODE> or 
  <CODE>xs:untypedAtomic</CODE>, that value is cast to the type 
  <CODE>xs:NCName</CODE>. If the value cannot be cast to <CODE>xs:NCName</CODE>, 
  a <A title="dynamic error" 
  href="REC-xquery-20070123.htm#dt-dynamic-error">dynamic 
  error</A> is raised [<A title=err:XQDY0041 
  href="REC-xquery-20070123.htm#ERRXQDY0041">err:XQDY0041</A>].</P>
  <LI>
  <P>The resulting NCName is then used as the <CODE>target</CODE> property of 
  the newly constructed processing instruction node. However, a <A 
  title="dynamic error" 
  href="REC-xquery-20070123.htm#dt-dynamic-error">dynamic 
  error</A> is raised if the NCName is equal to "<CODE>XML</CODE>" (in any 
  combination of upper and lower case) [<A title=err:XQDY0064 
  href="REC-xquery-20070123.htm#ERRXQDY0064">err:XQDY0064</A>].</P></LI></OL>
<P>The <A title="content expression" 
href="REC-xquery-20070123.htm#dt-content-expression">content 
expression</A> of a computed processing instruction constructor is processed as 
follows:</P>
<OL class=enumar>
  <LI>
  <P><A title=atomization 
  href="REC-xquery-20070123.htm#dt-atomization">Atomization</A> 
  is applied to the value of the <A title="content expression" 
  href="REC-xquery-20070123.htm#dt-content-expression">content 
  expression</A>, converting it to a sequence of atomic values. (If the <A 
  title="content expression" 
  href="REC-xquery-20070123.htm#dt-content-expression">content 
  expression</A> is absent, the result of this step is an empty sequence.)</P>
  <LI>
  <P>If the result of atomization is an empty sequence, it is replaced by a 
  zero-length string. Otherwise, each atomic value in the atomized sequence is 
  cast into a string. If any of the resulting strings contains the string 
  "<CODE>?&gt;</CODE>", a <A title="dynamic error" 
  href="REC-xquery-20070123.htm#dt-dynamic-error">dynamic 
  error</A> [<A title=err:XQDY0026 
  href="REC-xquery-20070123.htm#ERRXQDY0026">err:XQDY0026</A>] 
  is raised.</P>
  <LI>
  <P>The individual strings resulting from the previous step are merged into a 
  single string by concatenating them with a single space character between each 
  pair. Leading whitespace is removed from the resulting string. The resulting 
  string then becomes the <CODE>content</CODE> property of the constructed 
  processing instruction node.</P></LI></OL>
<P>The remaining properties of the new processing instruction node are 
determined as follows:</P>
<OL class=enumar>
  <LI>
  <P>The <CODE>parent</CODE> property is empty.</P>
  <LI>
  <P>The <CODE>base-uri</CODE> property is empty.</P></LI></OL>
<P>The following example illustrates a computed processing instruction 
constructor:</P>
<DIV class=parse-test>
<DIV class=exampleInner><PRE>let $target := "audio-output",
    $content := "beep" 
return processing-instruction {$target} {$content}
</PRE></DIV></DIV>
<P>The processing instruction node constructed by this example might be 
serialized as follows:</P>
<DIV class=exampleInner><PRE>&lt;?audio-output beep?&gt;
</PRE></DIV></DIV>
<DIV class=div4>
<H5><A id=id-computed-comments name=id-computed-comments></A>3.7.3.6 Computed 
Comment Constructors</H5>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-CompCommentConstructor 
      name=doc-xquery-CompCommentConstructor></A>[115]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-CompCommentConstructor">CompCommentConstructor</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"comment" "{" <A 
      href="REC-xquery-20070123.htm#doc-xquery-Expr">Expr</A> 
      "}"</CODE></TD></TR></TBODY></TABLE>
<P>A computed comment constructor (<A 
href="REC-xquery-20070123.htm#doc-xquery-CompCommentConstructor">CompCommentConstructor</A>) 
constructs a new comment node with its own node identity. The <A 
title="content expression" 
href="REC-xquery-20070123.htm#dt-content-expression">content 
expression</A> of a computed comment constructor is processed as follows:</P>
<OL class=enumar>
  <LI>
  <P><A title=atomization 
  href="REC-xquery-20070123.htm#dt-atomization">Atomization</A> 
  is applied to the value of the <A title="content expression" 
  href="REC-xquery-20070123.htm#dt-content-expression">content 
  expression</A>, converting it to a sequence of atomic values.</P>
  <LI>
  <P>If the result of atomization is an empty sequence, it is replaced by a 
  zero-length string. Otherwise, each atomic value in the atomized sequence is 
  cast into a string.</P>
  <LI>
  <P>The individual strings resulting from the previous step are merged into a 
  single string by concatenating them with a single space character between each 
  pair. The resulting string becomes the <CODE>content</CODE> property of the 
  constructed comment node.</P>
  <LI>
  <P>It is a <A title="dynamic error" 
  href="REC-xquery-20070123.htm#dt-dynamic-error">dynamic 
  error</A> [<A title=err:XQDY0072 
  href="REC-xquery-20070123.htm#ERRXQDY0072">err:XQDY0072</A>] 
  if the result of the <A title="content expression" 
  href="REC-xquery-20070123.htm#dt-content-expression">content 
  expression</A> of a computed comment constructor contains two adjacent hyphens 
  or ends with a hyphen.</P></LI></OL>
<P>The <CODE>parent</CODE> property of the constructed comment node is set to 
empty.</P>
<P>The following example illustrates a computed comment constructor:</P>
<DIV class=parse-test>
<DIV class=exampleInner><PRE>let $homebase := "Houston" 
return comment {fn:concat($homebase, ", we have a problem.")}
</PRE></DIV></DIV>
<P>The comment node constructed by this example might be serialized as 
follows:</P>
<DIV class=exampleInner><PRE>&lt;!--Houston, we have a problem.--&gt;
</PRE></DIV></DIV></DIV>
<DIV class=div3>
<H4><A id=id-ns-nodes-on-elements name=id-ns-nodes-on-elements></A>3.7.4 
In-scope Namespaces of a Constructed Element</H4>
<P>An element node constructed by a direct or computed element constructor has 
an <A title="in-scope namespaces" 
href="REC-xquery-20070123.htm#dt-in-scope-namespaces">in-scope 
namespaces</A> property that consists of a set of <A title="in-scope namespaces" 
href="REC-xquery-20070123.htm#dt-in-scope-namespaces">namespace 
bindings</A>. The in-scope namespaces of an element node may affect the way the 
node is serialized (see <A 
href="REC-xquery-20070123.htm#id-serialization"><B>2.2.4 
Serialization</B></A>), and may also affect the behavior of certain functions 
that operate on nodes, such as <CODE>fn:name</CODE>. Note the difference between 
<A title="in-scope namespaces" 
href="REC-xquery-20070123.htm#dt-in-scope-namespaces">in-scope 
namespaces</A>, which is a dynamic property of an element node, and <A 
title="statically known namespaces" 
href="REC-xquery-20070123.htm#dt-static-namespaces">statically 
known namespaces</A>, which is a static property of an expression. Also note 
that one of the namespace bindings in the in-scope namespaces may have no prefix 
(denoting the default namespace for the given element). The in-scope namespaces 
of a constructed element node consist of the following namespace bindings:</P>
<UL>
  <LI>
  <P>A namespace binding is created for each namespace declared in the current 
  element constructor by a <A title="namespace declaration attribute" 
  href="REC-xquery-20070123.htm#dt-namespace-decl-attr">namespace 
  declaration attribute</A>.</P>
  <LI>
  <P>A namespace binding is created for each namespace that is declared in a <A 
  title="namespace declaration attribute" 
  href="REC-xquery-20070123.htm#dt-namespace-decl-attr">namespace 
  declaration attribute</A> of an enclosing <A 
  title="direct element constructor" 
  href="REC-xquery-20070123.htm#dt-direct-elem-const">direct 
  element constructor</A> and not overridden by the current element constructor 
  or an intermediate constructor.</P>
  <LI>
  <P>A namespace binding is always created to bind the prefix <CODE>xml</CODE> 
  to the namespace URI <CODE>http://www.w3.org/XML/1998/namespace</CODE>.</P>
  <LI>
  <P>For each namespace used in the name of the constructed element or in the 
  names of its attributes, a namespace binding must exist. If a namespace 
  binding does not already exist for one of these namespaces, a new namespace 
  binding is created for it. If the name of the node includes a prefix, that 
  prefix is used in the namespace binding; if the name has no prefix, then a 
  binding is created for the empty prefix. If this would result in a conflict, 
  because it would require two different bindings of the same prefix, then the 
  prefix used in the node name is changed to an arbitrary <A 
  title="implementation dependent" 
  href="REC-xquery-20070123.htm#dt-implementation-dependent">implementation-dependent</A> 
  prefix that does not cause such a conflict, and a namespace binding is created 
  for this new prefix.</P></LI></UL>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P><A title="copy-namespaces mode" 
href="REC-xquery-20070123.htm#dt-copy-namespaces-mode">Copy-namespaces 
mode</A> does not affect the namespace bindings of a newly constructed element 
node. It applies only to existing nodes that are copied by a constructor 
expression.</P></DIV>
<P>The following query serves as an example:</P>
<DIV class=parse-test>
<DIV class=exampleInner><PRE>declare namespace p="http://example.com/ns/p";
declare namespace q="http://example.com/ns/q";
declare namespace f="http://example.com/ns/f";

&lt;p:a q:b="{f:func(2)}" xmlns:r="http://example.com/ns/r"/&gt;
</PRE></DIV></DIV>
<P>The <A title="in-scope namespaces" 
href="REC-xquery-20070123.htm#dt-in-scope-namespaces">in-scope 
namespaces</A> of the resulting <CODE>p:a</CODE> element consists of the 
following <A title="in-scope namespaces" 
href="REC-xquery-20070123.htm#dt-in-scope-namespaces">namespace 
bindings</A>:</P>
<UL>
  <LI>
  <P><CODE>p = "http://example.com/ns/p"</CODE></P>
  <LI>
  <P><CODE>q = "http://example.com/ns/q"</CODE></P>
  <LI>
  <P><CODE>r = "http://example.com/ns/r"</CODE></P>
  <LI>
  <P><CODE>xml = "http://www.w3.org/XML/1998/namespace"</CODE></P></LI></UL>
<P>The namespace bindings for <CODE>p</CODE> and <CODE>q</CODE> are added to the 
result element because their respective namespaces are used in the names of the 
element and its attributes. The namespace binding 
<CODE>r="http://example.com/ns/r"</CODE> is added to the in-scope namespaces of 
the constructed element because it is defined by a <A 
title="namespace declaration attribute" 
href="REC-xquery-20070123.htm#dt-namespace-decl-attr">namespace 
declaration attribute</A>, even though it is not used in a name.</P>
<P>No namespace binding corresponding to 
<CODE>f="http://example.com/ns/f"</CODE> is created, because the namespace 
prefix <CODE>f</CODE> appears only in the query prolog and is not used in an 
element or attribute name of the constructed node. This namespace binding does 
not appear in the query result, even though it is present in the <A 
title="statically known namespaces" 
href="REC-xquery-20070123.htm#dt-static-namespaces">statically 
known namespaces</A> and is available for use during processing of the 
query.</P>
<P>Note that the following constructed element, if nested within a 
<CODE>validate</CODE> expression, cannot be validated:</P>
<DIV class=parse-test>
<DIV class=exampleInner><PRE>&lt;p xsi:type="xs:integer"&gt;3&lt;/p&gt;
</PRE></DIV></DIV>
<P>The constructed element will have namespace bindings for the prefixes 
<CODE>xsi</CODE> (because it is used in a name) and <CODE>xml</CODE> (because it 
is defined for every constructed element node). During validation of the 
constructed element, the validator will be unable to interpret the namespace 
prefix <CODE>xs</CODE> because it is has no namespace binding. Validation of 
this constructed element could be made possible by providing a <A 
title="namespace declaration attribute" 
href="REC-xquery-20070123.htm#dt-namespace-decl-attr">namespace 
declaration attribute</A>, as in the following example:</P>
<DIV class=parse-test>
<DIV class=exampleInner><PRE>&lt;p xmlns:xs="http://www.w3.org/2001/XMLSchema"
   xsi:type="xs:integer"&gt;3&lt;/p&gt;
</PRE></DIV></DIV></DIV></DIV></DIV>
<DIV class=xquery>
<DIV class=div2>
<H3><A id=id-flwor-expressions name=id-flwor-expressions></A>3.8 FLWOR 
Expressions</H3>
<P>XQuery provides a feature called a FLWOR expression that supports iteration 
and binding of variables to intermediate results. This kind of expression is 
often useful for computing joins between two or more documents and for 
restructuring data. The name FLWOR, pronounced "flower", is suggested by the 
keywords <CODE>for</CODE>, <CODE>let</CODE>, <CODE>where</CODE>, <CODE>order 
by</CODE>, and <CODE>return</CODE>.</P>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-FLWORExpr 
      name=doc-xquery-FLWORExpr></A>[33]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-FLWORExpr">FLWORExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>(<A 
      href="REC-xquery-20070123.htm#doc-xquery-ForClause">ForClause</A> 
      | <A 
      href="REC-xquery-20070123.htm#doc-xquery-LetClause">LetClause</A>)+ 
      <A 
      href="REC-xquery-20070123.htm#doc-xquery-WhereClause">WhereClause</A>? 
      <A 
      href="REC-xquery-20070123.htm#doc-xquery-OrderByClause">OrderByClause</A>? 
      "return" <A 
      href="REC-xquery-20070123.htm#doc-xquery-ExprSingle">ExprSingle</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-ForClause 
      name=doc-xquery-ForClause></A>[34]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-ForClause">ForClause</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"for" "$" <A 
      href="REC-xquery-20070123.htm#doc-xquery-VarName">VarName</A> 
      <A 
      href="REC-xquery-20070123.htm#doc-xquery-TypeDeclaration">TypeDeclaration</A>? 
      <A 
      href="REC-xquery-20070123.htm#doc-xquery-PositionalVar">PositionalVar</A>? 
      "in" <A 
      href="REC-xquery-20070123.htm#doc-xquery-ExprSingle">ExprSingle</A> 
      ("," "$" <A 
      href="REC-xquery-20070123.htm#doc-xquery-VarName">VarName</A> 
      <A 
      href="REC-xquery-20070123.htm#doc-xquery-TypeDeclaration">TypeDeclaration</A>? 
      <A 
      href="REC-xquery-20070123.htm#doc-xquery-PositionalVar">PositionalVar</A>? 
      "in" <A 
      href="REC-xquery-20070123.htm#doc-xquery-ExprSingle">ExprSingle</A>)*</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-LetClause 
      name=doc-xquery-LetClause></A>[36]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-LetClause">LetClause</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"let" "$" <A 
      href="REC-xquery-20070123.htm#doc-xquery-VarName">VarName</A> 
      <A 
      href="REC-xquery-20070123.htm#doc-xquery-TypeDeclaration">TypeDeclaration</A>? 
      ":=" <A 
      href="REC-xquery-20070123.htm#doc-xquery-ExprSingle">ExprSingle</A> 
      ("," "$" <A 
      href="REC-xquery-20070123.htm#doc-xquery-VarName">VarName</A> 
      <A 
      href="REC-xquery-20070123.htm#doc-xquery-TypeDeclaration">TypeDeclaration</A>? 
      ":=" <A 
      href="REC-xquery-20070123.htm#doc-xquery-ExprSingle">ExprSingle</A>)*</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-TypeDeclaration 
      name=doc-xquery-TypeDeclaration></A>[118]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-TypeDeclaration">TypeDeclaration</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"as" <A 
      href="REC-xquery-20070123.htm#doc-xquery-SequenceType">SequenceType</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-PositionalVar 
      name=doc-xquery-PositionalVar></A>[35]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-PositionalVar">PositionalVar</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"at" "$" <A 
      href="REC-xquery-20070123.htm#doc-xquery-VarName">VarName</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-WhereClause 
      name=doc-xquery-WhereClause></A>[37]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-WhereClause">WhereClause</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"where" <A 
      href="REC-xquery-20070123.htm#doc-xquery-ExprSingle">ExprSingle</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-OrderByClause 
      name=doc-xquery-OrderByClause></A>[38]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-OrderByClause">OrderByClause</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>(("order" "by") | ("stable" "order" "by")) <A 
      href="REC-xquery-20070123.htm#doc-xquery-OrderSpecList">OrderSpecList</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-OrderSpecList 
      name=doc-xquery-OrderSpecList></A>[39]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-OrderSpecList">OrderSpecList</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-OrderSpec">OrderSpec</A> 
      ("," <A 
      href="REC-xquery-20070123.htm#doc-xquery-OrderSpec">OrderSpec</A>)*</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-OrderSpec 
      name=doc-xquery-OrderSpec></A>[40]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-OrderSpec">OrderSpec</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-ExprSingle">ExprSingle</A> 
      <A 
      href="REC-xquery-20070123.htm#doc-xquery-OrderModifier">OrderModifier</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-OrderModifier 
      name=doc-xquery-OrderModifier></A>[41]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-OrderModifier">OrderModifier</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>("ascending" | "descending")? ("empty" ("greatest" | "least"))? 
      ("collation" <A 
      href="REC-xquery-20070123.htm#doc-xquery-URILiteral">URILiteral</A>)?</CODE></TD></TR></TBODY></TABLE>
<P>The <CODE>for</CODE> and <CODE>let</CODE> clauses in a FLWOR expression 
generate an ordered sequence of tuples of bound variables, called the <B>tuple 
stream</B>. The optional <CODE>where</CODE> clause serves to filter the tuple 
stream, retaining some tuples and discarding others. The optional <CODE>order 
by</CODE> clause can be used to reorder the tuple stream. The 
<CODE>return</CODE> clause constructs the result of the FLWOR expression. The 
<CODE>return</CODE> clause is evaluated once for every tuple in the tuple 
stream, after filtering by the <CODE>where</CODE> clause, using the variable 
bindings in the respective tuples. The result of the FLWOR expression is an 
ordered sequence containing the results of these evaluations, concatenated as if 
by the <A title="comma operator" 
href="REC-xquery-20070123.htm#dt-comma-operator">comma 
operator</A>.</P>
<P>The following example of a FLWOR expression includes all of the possible 
clauses. The <CODE>for</CODE> clause iterates over all the departments in an 
input document, binding the variable <CODE>$d</CODE> to each department number 
in turn. For each binding of <CODE>$d</CODE>, the <CODE>let</CODE> clause binds 
variable <CODE>$e</CODE> to all the employees in the given department, selected 
from another input document. The result of the <CODE>for</CODE> and 
<CODE>let</CODE> clauses is a tuple stream in which each tuple contains a pair 
of bindings for <CODE>$d</CODE> and <CODE>$e</CODE> (<CODE>$d</CODE> is bound to 
a department number and <CODE>$e</CODE> is bound to a set of employees in that 
department). The <CODE>where</CODE> clause filters the tuple stream by keeping 
only those binding-pairs that represent departments having at least ten 
employees. The <CODE>order by</CODE> clause orders the surviving tuples in 
descending order by the average salary of the employees in the department. The 
<CODE>return</CODE> clause constructs a new <CODE>big-dept</CODE> element for 
each surviving tuple, containing the department number, headcount, and average 
salary.</P>
<DIV class=parse-test>
<DIV class=exampleInner><PRE><SPAN class=parse-test><SPAN class=parse-test>for $d in fn:doc("depts.xml")/depts/deptno
let $e := fn:doc("emps.xml")/emps/emp[deptno = $d]
where fn:count($e) &gt;= 10
order by fn:avg($e/salary) descending
return
   &lt;big-dept&gt;
      {
      $d,
      &lt;headcount&gt;{fn:count($e)}&lt;/headcount&gt;,
      &lt;avgsal&gt;{fn:avg($e/salary)}&lt;/avgsal&gt;
      }
   &lt;/big-dept&gt;</SPAN></SPAN>
</PRE></DIV></DIV>
<P>The clauses in a FLWOR expression are described in more detail below.</P>
<DIV class=div3>
<H4><A id=id-for-let name=id-for-let></A>3.8.1 For and Let Clauses</H4>
<P>The purpose of the <CODE>for</CODE> and <CODE>let</CODE> clauses in a FLWOR 
expression is to produce a tuple stream in which each tuple consists of one or 
more bound variables.</P>
<P>The simplest example of a <CODE>for</CODE> clause contains one variable and 
an associated expression. [<A id=dt-binding-sequence title="binding sequence" 
name=dt-binding-sequence>Definition</A>: The value of the expression associated 
with a variable in a <CODE>for</CODE> clause is called the <B>binding 
sequence</B> for that variable.] The <CODE>for</CODE> clause iterates over the 
items in the binding sequence, binding the variable to each item in turn. If <A 
title="ordering mode" 
href="REC-xquery-20070123.htm#dt-ordering-mode">ordering 
mode</A> is <CODE>ordered</CODE>, the resulting sequence of variable bindings is 
ordered according to the order of values in the binding sequence; otherwise the 
ordering of the variable bindings is <A title="implementation dependent" 
href="REC-xquery-20070123.htm#dt-implementation-dependent">implementation-dependent</A>.</P>
<P>A <CODE>for</CODE> clause may also contain multiple variables, each with an 
associated expression whose value is the binding sequence for that variable. In 
this case, the <CODE>for</CODE> clause iterates each variable over its binding 
sequence. The resulting tuple stream contains one tuple for each combination of 
values in the respective binding sequences. If <A title="ordering mode" 
href="REC-xquery-20070123.htm#dt-ordering-mode">ordering 
mode</A> is <CODE>ordered</CODE>, the order of the tuple stream is determined 
primarily by the order of the binding sequence of the leftmost variable, and 
secondarily by the binding sequences of the other variables, working from left 
to right. Otherwise, the ordering of the variable bindings is <A 
title="implementation dependent" 
href="REC-xquery-20070123.htm#dt-implementation-dependent">implementation-dependent</A>.</P>
<P>A <CODE>let</CODE> clause may also contain one or more variables, each with 
an associated expression. Unlike a <CODE>for</CODE> clause, however, a 
<CODE>let</CODE> clause binds each variable to the result of its associated 
expression, without iteration. The variable bindings generated by 
<CODE>let</CODE> clauses are added to the binding tuples generated by the 
<CODE>for</CODE> clauses. If there are no <CODE>for</CODE> clauses, the 
<CODE>let</CODE> clauses generate one tuple containing all the variable 
bindings.</P>
<P>Although <CODE>for</CODE> and <CODE>let</CODE> clauses both bind variables, 
the manner in which variables are bound is quite different, as illustrated by 
the following examples. The first example uses a <CODE>let</CODE> clause:</P>
<DIV class=parse-test>
<DIV class=exampleInner><PRE><SPAN class=parse-test><SPAN class=parse-test>let $s := (&lt;one/&gt;, &lt;two/&gt;, &lt;three/&gt;)
return &lt;out&gt;{$s}&lt;/out&gt;</SPAN></SPAN>
</PRE></DIV></DIV>
<P>The variable <CODE>$s</CODE> is bound to the result of the expression 
<CODE>(&lt;one/&gt;, &lt;two/&gt;, &lt;three/&gt;)</CODE>. Since there are no 
<CODE>for</CODE> clauses, the <CODE>let</CODE> clause generates one tuple that 
contains the binding of <CODE>$s</CODE>. The <CODE>return</CODE> clause is 
invoked for this tuple, creating the following output:</P>
<DIV class=exampleInner><PRE>&lt;out&gt;
   &lt;one/&gt;
   &lt;two/&gt;
   &lt;three/&gt;
&lt;/out&gt;
</PRE></DIV>
<P>The next example is a similar query that contains a <CODE>for</CODE> clause 
instead of a <CODE>let</CODE> clause:</P>
<DIV class=parse-test>
<DIV class=exampleInner><PRE><SPAN class=parse-test><SPAN class=parse-test>for $s in (&lt;one/&gt;, &lt;two/&gt;, &lt;three/&gt;)
return &lt;out&gt;{$s}&lt;/out&gt;</SPAN></SPAN>
</PRE></DIV></DIV>
<P>In this example, the variable <CODE>$s</CODE> iterates over the given 
expression. If <A title="ordering mode" 
href="REC-xquery-20070123.htm#dt-ordering-mode">ordering 
mode</A> is <CODE>ordered</CODE>, <CODE>$s</CODE> is first bound to 
<CODE>&lt;one/&gt;</CODE>, then to <CODE>&lt;two/&gt;</CODE>, and finally to 
<CODE>&lt;three/&gt;</CODE>. One tuple is generated for each of these bindings, 
and the <CODE>return</CODE> clause is invoked for each tuple, creating the 
following output:</P>
<DIV class=exampleInner><PRE>&lt;out&gt;
   &lt;one/&gt;
&lt;/out&gt;
&lt;out&gt;
   &lt;two/&gt;
&lt;/out&gt;
&lt;out&gt;
   &lt;three/&gt;
&lt;/out&gt;
</PRE></DIV>
<P>The following example illustrates how binding tuples are generated by a 
<CODE>for</CODE> clause that contains multiple variables when <A 
title="ordering mode" 
href="REC-xquery-20070123.htm#dt-ordering-mode">ordering 
mode</A> is <CODE>ordered</CODE>.</P>
<DIV class=exampleInner><PRE>for $i in (1, 2), $j in (3, 4)
</PRE></DIV>
<P>The tuple stream generated by the above <CODE>for</CODE> clause is as 
follows:</P>
<DIV class=exampleInner><PRE>($i = 1, $j = 3)
($i = 1, $j = 4)
($i = 2, $j = 3)
($i = 2, $j = 4)
</PRE></DIV>
<P>If <A title="ordering mode" 
href="REC-xquery-20070123.htm#dt-ordering-mode">ordering 
mode</A> were <CODE>unordered</CODE>, the <CODE>for</CODE> clause in the above 
example would generate the same tuple stream but the order of the tuples would 
be <A title="implementation dependent" 
href="REC-xquery-20070123.htm#dt-implementation-dependent">implementation-dependent</A>.</P>
<P>The scope of a variable bound in a <CODE>for</CODE> or <CODE>let</CODE> 
clause comprises all subexpressions of the containing FLWOR expression that 
appear after the variable binding. The scope does not include the expression to 
which the variable is bound. The following example illustrates how bindings in 
<CODE>for</CODE> and <CODE>let</CODE> clauses may reference variables that were 
bound in earlier clauses, or in earlier bindings in the same clause of the FLWOR 
expression:</P>
<DIV class=parse-test>
<DIV class=exampleInner><PRE>for $x in $w, $a in f($x)
let $y := g($a)
for $z in p($x, $y)
return q($x, $y, $z)
</PRE></DIV></DIV>
<P>The <CODE>for</CODE> and <CODE>let</CODE> clauses of a given FLWOR expression 
may bind the same variable name more than once. In this case, each new binding 
occludes the previous one, which becomes inaccessible in the remainder of the 
FLWOR expression.</P>
<P>Each variable bound in a <CODE>for</CODE> or <CODE>let</CODE> clause may have 
an optional <B>type declaration</B>, which is a type declared using the syntax 
in <A 
href="REC-xquery-20070123.htm#id-sequencetype-syntax"><B>2.5.3 
SequenceType Syntax</B></A>. If the type of a value bound to the variable does 
not match the declared type according to the rules for <A 
title="SequenceType matching" 
href="REC-xquery-20070123.htm#dt-sequencetype-matching">SequenceType 
matching</A>, a <A title="type error" 
href="REC-xquery-20070123.htm#dt-type-error">type 
error</A> is raised [<A title=err:XPTY0004 
href="REC-xquery-20070123.htm#ERRXPTY0004">err:XPTY0004</A>]. 
For example, the following expression raises a <A title="type error" 
href="REC-xquery-20070123.htm#dt-type-error">type 
error</A> because the variable <CODE>$salary</CODE> has a type declaration that 
is not satisfied by the value that is bound to the variable:</P>
<DIV class=parse-test>
<DIV class=exampleInner><PRE>let $salary as xs:decimal :=  "cat"
return $salary * 2
</PRE></DIV></DIV>
<P>Each variable bound in a <CODE>for</CODE> clause may have an associated 
<B>positional variable</B> that is bound at the same time. The name of the 
positional variable is preceded by the keyword <CODE>at</CODE>. The positional 
variable always has an implied type of <CODE>xs:integer</CODE>. As a variable 
iterates over the items in its <A title="binding sequence" 
href="REC-xquery-20070123.htm#dt-binding-sequence">binding 
sequence</A>, its positional variable iterates over the integers that represent 
the ordinal positions of those items in the binding sequence, starting with 1. 
The expanded QName of a positional variable must be distinct from the expanded 
QName of the variable with which it is associated [<A title=err:XQST0089 
href="REC-xquery-20070123.htm#ERRXQST0089">err:XQST0089</A>].</P>
<P>Positional variables are illustrated by the following <CODE>for</CODE> 
clause:</P>
<DIV class=exampleInner><PRE>for $car at $i in ("Ford", "Chevy"),
    $pet at $j in ("Cat", "Dog")
</PRE></DIV>
<P>If <A title="ordering mode" 
href="REC-xquery-20070123.htm#dt-ordering-mode">ordering 
mode</A> is <CODE>ordered</CODE>, the tuple stream generated by the above 
<CODE>for</CODE> clause is as follows:</P>
<DIV class=exampleInner><PRE>($i = 1, $car = "Ford", $j = 1, $pet = "Cat")
($i = 1, $car = "Ford", $j = 2, $pet = "Dog")
($i = 2, $car = "Chevy", $j = 1, $pet = "Cat")
($i = 2, $car = "Chevy", $j = 2, $pet = "Dog")
</PRE></DIV>
<P>If <A title="ordering mode" 
href="REC-xquery-20070123.htm#dt-ordering-mode">ordering 
mode</A> is <CODE>unordered</CODE>, the order of the tuple stream is <A 
title="implementation dependent" 
href="REC-xquery-20070123.htm#dt-implementation-dependent">implementation-dependent</A>. 
In addition, if a <CODE>for</CODE> clause contains subexpressions that are 
affected by <A title="ordering mode" 
href="REC-xquery-20070123.htm#dt-ordering-mode">ordering 
mode</A>, the association of positional variables with items returned by these 
subexpressions is <A title="implementation dependent" 
href="REC-xquery-20070123.htm#dt-implementation-dependent">implementation-dependent</A> 
if <A title="ordering mode" 
href="REC-xquery-20070123.htm#dt-ordering-mode">ordering 
mode</A> is <CODE>unordered</CODE>.</P></DIV>
<DIV class=div3>
<H4><A id=id-where name=id-where></A>3.8.2 Where Clause</H4>
<P>The optional <CODE>where</CODE> clause serves as a filter for the tuples of 
variable bindings generated by the <CODE>for</CODE> and <CODE>let</CODE> 
clauses. The expression in the <CODE>where</CODE> clause, called the 
<B>where-expression</B>, is evaluated once for each of these tuples. If the <A 
title="effective boolean value" 
href="REC-xquery-20070123.htm#dt-ebv">effective boolean 
value</A> of the where-expression is <CODE>true</CODE>, the tuple is retained 
and its variable bindings are used in an execution of the <CODE>return</CODE> 
clause. If the <A title="effective boolean value" 
href="REC-xquery-20070123.htm#dt-ebv">effective boolean 
value</A> of the where-expression is <CODE>false</CODE>, the tuple is discarded. 
The <A title="effective boolean value" 
href="REC-xquery-20070123.htm#dt-ebv">effective boolean 
value</A> of an expression is defined in <A 
href="REC-xquery-20070123.htm#id-ebv"><B>2.4.3 Effective 
Boolean Value</B></A>.</P>
<P>The following expression illustrates how a <CODE>where</CODE> clause might be 
applied to a <B>positional variable</B> in order to perform sampling on an input 
sequence. This expression approximates the average value in a sequence by 
sampling one value out of each one hundred input values.</P>
<DIV class=parse-test>
<DIV class=exampleInner><PRE><SPAN class=parse-test><SPAN class=parse-test>fn:avg(for $x at $i in $inputvalues
    where $i mod 100 = 0   
    return $x)</SPAN></SPAN>
</PRE></DIV></DIV></DIV>
<DIV class=div3>
<H4><A id=id-orderby-return name=id-orderby-return></A>3.8.3 Order By and Return 
Clauses</H4>
<P>The <CODE>return</CODE> clause of a FLWOR expression is evaluated once for 
each tuple in the tuple stream, and the results of these evaluations are 
concatenated, as if by the <A title="comma operator" 
href="REC-xquery-20070123.htm#dt-comma-operator">comma 
operator</A>, to form the result of the FLWOR expression.</P>
<P>If no <CODE>order by</CODE> clause is present, the order of the tuple stream 
is determined by the <CODE>for</CODE> and <CODE>let</CODE> clauses and by <A 
title="ordering mode" 
href="REC-xquery-20070123.htm#dt-ordering-mode">ordering 
mode</A>. If an <CODE>order by</CODE> clause is present, it reorders the tuples 
in the tuple stream into a new, value-based order. In either case, the resulting 
order determines the order in which the <CODE>return</CODE> clause is evaluated, 
once for each tuple, using the variable bindings in the respective tuples. Note 
that <A title="ordering mode" 
href="REC-xquery-20070123.htm#dt-ordering-mode">ordering 
mode</A> has no effect on a FLWOR expression if an <CODE>order by</CODE> clause 
is present, since <CODE>order by</CODE> takes precedence over <A 
title="ordering mode" 
href="REC-xquery-20070123.htm#dt-ordering-mode">ordering 
mode</A>.</P>
<P>An <CODE>order by</CODE> clause contains one or more ordering specifications, 
called <A 
href="REC-xquery-20070123.htm#doc-xquery-OrderSpec">orderspecs</A>, 
as shown in the grammar above. For each tuple in the tuple stream, after 
filtering by the <CODE>where</CODE> clause, the orderspecs are evaluated, using 
the variable bindings in that tuple. The relative order of two tuples is 
determined by comparing the values of their orderspecs, working from left to 
right until a pair of unequal values is encountered. If an orderspec specifies a 
<A title=collation 
href="REC-xquery-20070123.htm#dt-collation">collation</A>, 
that collation is used in comparing values of type <CODE>xs:string</CODE>, 
<CODE>xs:anyURI</CODE>, or types derived from them (otherwise, the <A 
title="default collation" 
href="REC-xquery-20070123.htm#dt-def-collation">default 
collation</A> is used). If an orderspec specifies a collation by a relative URI, 
that relative URI is resolved to an absolute URI using the <A title="base URI" 
href="REC-xquery-20070123.htm#dt-base-uri">base URI</A> 
in the <A title="static context" 
href="REC-xquery-20070123.htm#dt-static-context">static 
context</A>. If an orderspec specifies a collation that is not found in <A 
title="statically known collations" 
href="REC-xquery-20070123.htm#dt-static-collations">statically 
known collations</A>, an error is raised [<A title=err:XQST0076 
href="REC-xquery-20070123.htm#ERRXQST0076">err:XQST0076</A>].</P>
<P>The process of evaluating and comparing the orderspecs is based on the 
following rules:</P>
<UL>
  <LI>
  <P><A title=atomization 
  href="REC-xquery-20070123.htm#dt-atomization">Atomization</A> 
  is applied to the result of the expression in each orderspec. If the result of 
  atomization is neither a single atomic value nor an empty sequence, a <A 
  title="type error" 
  href="REC-xquery-20070123.htm#dt-type-error">type 
  error</A> is raised [<A title=err:XPTY0004 
  href="REC-xquery-20070123.htm#ERRXPTY0004">err:XPTY0004</A>].</P>
  <LI>
  <P>If the value of an orderspec has the <A title="dynamic type" 
  href="REC-xquery-20070123.htm#dt-dynamic-type">dynamic 
  type</A> <CODE>xs:untypedAtomic</CODE> (such as character data in a schemaless 
  document), it is cast to the type <CODE>xs:string</CODE>.</P>
  <DIV class=note>
  <P class=prefix><B>Note:</B></P>
  <P>Consistently treating untyped values as strings enables the sorting process 
  to begin without complete knowledge of the types of all the values to be 
  sorted.</P></DIV>
  <LI>
  <P>All the non-empty orderspec values must be convertible to a common type by 
  <A title="subtype substitution" 
  href="REC-xquery-20070123.htm#dt-subtype-substitution">subtype 
  substitution</A> and/or <A title="type promotion" 
  href="REC-xquery-20070123.htm#dt-type-promotion">type 
  promotion</A>. The ordering is performed in the least common type that has a 
  <CODE>gt</CODE> operator. If two or more non-empty orderspec values are not 
  convertible to a common type that has a <CODE>gt</CODE> operator, a <A 
  title="type error" 
  href="REC-xquery-20070123.htm#dt-type-error">type 
  error</A> is raised [<A title=err:XPTY0004 
  href="REC-xquery-20070123.htm#ERRXPTY0004">err:XPTY0004</A>].</P>
  <UL>
    <LI>
    <P>Example: The orderspec values include a value of type 
    <CODE>hatsize</CODE>, which is derived from <CODE>xs:integer</CODE>, and a 
    value of type <CODE>shoesize</CODE>, which is derived from 
    <CODE>xs:decimal</CODE>. The least common type reachable by subtype 
    substitution and type promotion is <CODE>xs:decimal</CODE>.</P>
    <LI>
    <P>Example: The orderspec values include a value of type 
    <CODE>xs:string</CODE> and a value of type <CODE>xs:anyURI</CODE>. The least 
    common type reachable by subtype substitution and type promotion is 
    <CODE>xs:string</CODE>.</P></LI></UL></LI></UL>
<P>When two orderspec values are compared to determine their relative position 
in the ordering sequence, the <EM>greater-than</EM> relationship is defined as 
follows:</P>
<UL>
  <LI>
  <P>When the orderspec specifies <CODE>empty least</CODE>, a value W is 
  considered to be <EM>greater-than</EM> a value V if one of the following is 
  true:</P>
  <UL>
    <LI>
    <P>V is an empty sequence and W is not an empty sequence.</P>
    <LI>
    <P>V is <CODE>NaN</CODE>, and W is neither <CODE>NaN</CODE> nor an empty 
    sequence.</P>
    <LI>
    <P>No collation is specified, and W <CODE>gt</CODE> V is true.</P>
    <LI>
    <P>A specific collation C is specified, and <CODE>fn:compare(V, W, C)</CODE> 
    is less than zero.</P></LI></UL>
  <LI>
  <P>When the orderspec specifies <CODE>empty greatest</CODE>, a value W is 
  considered to be <EM>greater-than</EM> a value V if one of the following is 
  true:</P>
  <UL>
    <LI>
    <P>W is an empty sequence and V is not an empty sequence.</P>
    <LI>
    <P>W is <CODE>NaN</CODE>, and V is neither <CODE>NaN</CODE> nor an empty 
    sequence.</P>
    <LI>
    <P>No collation is specified, and W <CODE>gt</CODE> V is true.</P>
    <LI>
    <P>A specific collation C is specified, and <CODE>fn:compare(V, W, C)</CODE> 
    is less than zero.</P></LI></UL>
  <LI>
  <P>When the orderspec specifies neither <CODE>empty least</CODE> nor 
  <CODE>empty greatest</CODE>, the <A title="default order for empty sequences" 
  href="REC-xquery-20070123.htm#dt-default-empty-order">default 
  order for empty sequences</A> in the <A title="static context" 
  href="REC-xquery-20070123.htm#dt-static-context">static 
  context</A> determines whether the rules for <CODE>empty least</CODE> or 
  <CODE>empty greatest</CODE> are used.</P></LI></UL>
<P>If T1 and T2 are two tuples in the tuple stream, and V1 and V2 are the first 
pair of values encountered when evaluating their orderspecs from left to right 
for which one value is <EM>greater-than</EM> the other (as defined above), 
then:</P>
<OL class=enumar>
  <LI>
  <P>If V1 is <EM>greater-than</EM> V2: If the orderspec specifies 
  <CODE>descending</CODE>, then T1 precedes T2 in the tuple stream; otherwise, 
  T2 precedes T1 in the tuple stream.</P>
  <LI>
  <P>If V2 is <EM>greater-than</EM> V1: If the orderspec specifies 
  <CODE>descending</CODE>, then T2 precedes T1 in the tuple stream; otherwise, 
  T1 precedes T2 in the tuple stream.</P></LI></OL>
<P>If neither V1 nor V2 is <EM>greater-than</EM> the other for any pair of 
orderspecs for tuples T1 and T2, the following rules apply.</P>
<OL class=enumar>
  <LI>
  <P>If <CODE>stable</CODE> is specified, the original order of T1 and T2 is 
  preserved in the tuple stream.</P>
  <LI>
  <P>If <CODE>stable</CODE> is not specified, the order of T1 and T2 in the 
  tuple stream is <A title="implementation dependent" 
  href="REC-xquery-20070123.htm#dt-implementation-dependent">implementation-dependent</A>.</P></LI></OL>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>If two orderspecs return the special floating-point values positive and 
negative zero, neither of these values is <EM>greater-than</EM> the other, since 
<CODE>+0.0 gt -0.0</CODE> and <CODE>-0.0 gt +0.0</CODE> are both 
<CODE>false</CODE>.</P></DIV>
<P>An <CODE>order by</CODE> clause makes it easy to sort the result of a FLWOR 
expression, even if the sort key is not included in the result of the 
expression. For example, the following expression returns employee names in 
descending order by salary, without returning the actual salaries:</P>
<DIV class=parse-test>
<DIV class=exampleInner><PRE><SPAN class=parse-test><SPAN class=parse-test>for $e in $employees 
order by $e/salary descending 
return $e/name</SPAN></SPAN>
</PRE></DIV></DIV>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>Since the <CODE>order by</CODE> clause in a FLWOR expression is the only 
facility provided by XQuery for specifying a value ordering, a FLWOR expression 
must be used in some queries where iteration would not otherwise be necessary. 
For example, a list of books with price less than 100 might be obtained by a 
simple <A title="path expression" 
href="REC-xquery-20070123.htm#dt-path-expression">path 
expression</A> such as <CODE>$books/book[price &lt; 100]</CODE>. But if these 
books are to be returned in alphabetic order by title, the query must be 
expressed as follows:</P>
<DIV class=parse-test>
<DIV class=exampleInner><PRE><SPAN class=parse-test><SPAN class=parse-test>for $b in $books/book[price &lt; 100]
order by $b/title
return $b</SPAN></SPAN>
</PRE></DIV></DIV></DIV>
<P>The following example illustrates an <CODE>order by</CODE> clause that uses 
several options. It causes a collection of books to be sorted in primary order 
by title, and in secondary descending order by price. A specific <A 
title=collation 
href="REC-xquery-20070123.htm#dt-collation">collation</A> 
is specified for the title ordering, and in the ordering by price, books with no 
price are specified to occur last (as though they have the least possible 
price). Whenever two books with the same title and price occur, the keyword 
<CODE>stable</CODE> indicates that their input order is preserved.</P>
<DIV class=parse-test>
<DIV class=exampleInner><PRE><SPAN class=parse-test><SPAN class=parse-test>for $b in $books/book
stable order by $b/title 
      collation "http://www.example.org/collations/fr-ca",
   $b/price descending empty least
return $b</SPAN></SPAN>
</PRE></DIV></DIV>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>Parentheses are helpful in <CODE>return</CODE> clauses that contain comma 
operators, since FLWOR expressions have a higher precedence than the comma 
operator. For instance, the following query raises an error because after the 
comma, <CODE>$j</CODE> is no longer within the FLWOR expression, and is an 
undefined variable:</P>
<DIV class=parse-test>
<DIV class=exampleInner><PRE>let $i := 5,
    $j := 20 * $i
return $i, $j
</PRE></DIV></DIV>
<P>Parentheses can be used to bring <CODE>$j</CODE> into the <CODE>return</CODE> 
clause of the FLWOR expression, as the programmer probably intended:</P>
<DIV class=parse-test>
<DIV class=exampleInner><PRE>let $i := 5,
    $j := 20 * $i
return ($i, $j)
</PRE></DIV></DIV></DIV></DIV>
<DIV class=div3>
<H4><A id=id-flwor-example name=id-flwor-example></A>3.8.4 Example</H4>
<P>The following example illustrates how FLWOR expressions can be nested, and 
how ordering can be specified at multiple levels of an element hierarchy. The 
example query inverts a document hierarchy to transform a bibliography into an 
author list. The input (bound to the variable <CODE>$bib</CODE>) is a 
<CODE>bib</CODE> element containing a list of books, each of which in turn 
contains a list of authors. The example is based on the following input:</P>
<DIV class=exampleInner><PRE>&lt;bib&gt;
  &lt;book&gt;
    &lt;title&gt;TCP/IP Illustrated&lt;/title&gt;
    &lt;author&gt;Stevens&lt;/author&gt;
    &lt;publisher&gt;Addison-Wesley&lt;/publisher&gt;
  &lt;/book&gt;
  &lt;book&gt;
    &lt;title&gt;Advanced Programming
           in the Unix Environment&lt;/title&gt;
    &lt;author&gt;Stevens&lt;/author&gt;
    &lt;publisher&gt;Addison-Wesley&lt;/publisher&gt;
  &lt;/book&gt;
  &lt;book&gt;
    &lt;title&gt;Data on the Web&lt;/title&gt;
    &lt;author&gt;Abiteboul&lt;/author&gt;
    &lt;author&gt;Buneman&lt;/author&gt;
    &lt;author&gt;Suciu&lt;/author&gt;
  &lt;/book&gt;
&lt;/bib&gt;
</PRE></DIV>
<P>The following query transforms the input document into a list in which each 
author's name appears only once, followed by a list of titles of books written 
by that author. The <CODE>fn:distinct-values</CODE> function is used to 
eliminate duplicates (by value) from a list of author nodes. The author list, 
and the lists of books published by each author, are returned in alphabetic 
order using the <A title="default collation" 
href="REC-xquery-20070123.htm#dt-def-collation">default 
collation</A>.</P>
<DIV class=parse-test>
<DIV class=exampleInner><PRE><SPAN class=parse-test><SPAN class=parse-test>&lt;authlist&gt;
 {
   for $a in fn:distinct-values($bib/book/author)
   order by $a
   return
     &lt;author&gt;
        &lt;name&gt; {$a} &lt;/name&gt;
        &lt;books&gt;
          {
            for $b in $bib/book[author = $a]
            order by $b/title
            return $b/title 
          }
        &lt;/books&gt;
     &lt;/author&gt;
 }
&lt;/authlist&gt;</SPAN></SPAN>
</PRE></DIV></DIV>
<P>The result of the above expression is as follows:</P>
<DIV class=exampleInner><PRE>&lt;authlist&gt;
   &lt;author&gt;
      &lt;name&gt;Abiteboul&lt;/name&gt;
      &lt;books&gt;
         &lt;title&gt;Data on the Web&lt;/title&gt;
      &lt;/books&gt;
   &lt;/author&gt;
   &lt;author&gt;
      &lt;name&gt;Buneman&lt;/name&gt;
      &lt;books&gt;
         &lt;title&gt;Data on the Web&lt;/title&gt;
      &lt;/books&gt;
   &lt;/author&gt;
   &lt;author&gt;
      &lt;name&gt;Stevens&lt;/name&gt;
      &lt;books&gt;
         &lt;title&gt;Advanced Programming
                in the Unix Environment&lt;/title&gt;
         &lt;title&gt;TCP/IP Illustrated&lt;/title&gt;
      &lt;/books&gt;
   &lt;/author&gt;
   &lt;author&gt;
      &lt;name&gt;Suciu&lt;/name&gt;
      &lt;books&gt;
         &lt;title&gt;Data on the Web&lt;/title&gt;
      &lt;/books&gt;
   &lt;/author&gt;
&lt;/authlist&gt;
</PRE></DIV></DIV></DIV></DIV>
<DIV class=xquery>
<DIV class=div2>
<H3><A id=id-unordered-expressions name=id-unordered-expressions></A>3.9 Ordered 
and Unordered Expressions</H3>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-OrderedExpr 
      name=doc-xquery-OrderedExpr></A>[91]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-OrderedExpr">OrderedExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"ordered" "{" <A 
      href="REC-xquery-20070123.htm#doc-xquery-Expr">Expr</A> 
      "}"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-UnorderedExpr 
      name=doc-xquery-UnorderedExpr></A>[92]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-UnorderedExpr">UnorderedExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"unordered" "{" <A 
      href="REC-xquery-20070123.htm#doc-xquery-Expr">Expr</A> 
      "}"</CODE></TD></TR></TBODY></TABLE>
<P>The purpose of <CODE>ordered</CODE> and <CODE>unordered</CODE> expressions is 
to set the <A title="ordering mode" 
href="REC-xquery-20070123.htm#dt-ordering-mode">ordering 
mode</A> in the <A title="static context" 
href="REC-xquery-20070123.htm#dt-static-context">static 
context</A> to <CODE>ordered</CODE> or <CODE>unordered</CODE> for a certain 
region in a query. The specified ordering mode applies to the expression nested 
inside the curly braces. For expressions where the ordering of the result is not 
significant, a performance advantage may be realized by setting the ordering 
mode to <CODE>unordered</CODE>, thereby granting the system flexibility to 
return the result in the order that it finds most efficient.</P>
<P><A title="ordering mode" 
href="REC-xquery-20070123.htm#dt-ordering-mode">Ordering 
mode</A> affects the behavior of <A title="path expression" 
href="REC-xquery-20070123.htm#dt-path-expression">path 
expressions</A> that include a "<CODE>/</CODE>" or "<CODE>//</CODE>" operator or 
an <A title="axis step" 
href="REC-xquery-20070123.htm#dt-axis-step">axis 
step</A>; <CODE>union</CODE>, <CODE>intersect</CODE>, and <CODE>except</CODE> 
expressions; the <CODE>fn:id</CODE> and <CODE>fn:idref</CODE> functions; and 
FLWOR expressions that have no <CODE>order by</CODE> clause. If ordering mode is 
<CODE>ordered</CODE>, node sequences returned by path expressions, 
<CODE>union</CODE>, <CODE>intersect</CODE>, and <CODE>except</CODE> expressions, 
and the <CODE>fn:id</CODE> and <CODE>fn:idref</CODE> functions are in <A 
title="document order" 
href="REC-xquery-20070123.htm#dt-document-order">document 
order</A>; otherwise the order of these return sequences is <A 
title="implementation dependent" 
href="REC-xquery-20070123.htm#dt-implementation-dependent">implementation-dependent</A>. 
The effect of ordering mode on FLWOR expressions is described in <A 
href="REC-xquery-20070123.htm#id-flwor-expressions"><B>3.8 
FLWOR Expressions</B></A>. Ordering mode has no effect on duplicate 
elimination.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>In a region of a query where ordering mode is <CODE>unordered</CODE>, the 
result of an expression may be nondeterministic if the expression invokes 
certain functions that are affected by the ordering of node sequences. These 
functions include <CODE>fn:position</CODE>, <CODE>fn:last</CODE>, 
<CODE>fn:index-of</CODE>, <CODE>fn:insert-before</CODE>, <CODE>fn:remove</CODE>, 
<CODE>fn:reverse</CODE>, and <CODE>fn:subsequence</CODE>. Also, within a <A 
title="path expression" 
href="REC-xquery-20070123.htm#dt-path-expression">path 
expression</A> in an unordered region, <A title="numeric predicate" 
href="REC-xquery-20070123.htm#dt-numeric-predicate">numeric 
predicates</A> are nondeterministic. For example, in an ordered region, the path 
expression <CODE>(//a/b)[5]</CODE> will return the fifth qualifying 
<CODE>b</CODE>-element in <A title="document order" 
href="REC-xquery-20070123.htm#dt-document-order">document 
order</A>. In an unordered region, the same expression will return an <A 
title="implementation dependent" 
href="REC-xquery-20070123.htm#dt-implementation-dependent">implementation-dependent</A> 
qualifying <CODE>b</CODE>-element.</P></DIV>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>The <CODE>fn:id</CODE> and <CODE>fn:idref</CODE> functions are described in 
<A 
href="REC-xquery-20070123.htm#FunctionsAndOperators">[XQuery 
1.0 and XPath 2.0 Functions and Operators]</A> as returning their results in <A 
title="document order" 
href="REC-xquery-20070123.htm#dt-document-order">document 
order</A>. Since ordering mode is a feature of XQuery, relaxation of the 
ordering requirement for function results when ordering mode is 
<CODE>unordered</CODE> is a feature of XQuery rather than of the functions 
themselves.</P></DIV>
<P>The use of an <CODE>unordered</CODE> expression is illustrated by the 
following example, which joins together two documents named 
<CODE>parts.xml</CODE> and <CODE>suppliers.xml</CODE>. The example returns the 
part numbers of red parts, paired with the supplier numbers of suppliers who 
supply these parts. If an <CODE>unordered</CODE> expression were not used, the 
resulting list of (part number, supplier number) pairs would be required to have 
an ordering that is controlled primarily by the <A title="document order" 
href="REC-xquery-20070123.htm#dt-document-order">document 
order</A> of <CODE>parts.xml</CODE> and secondarily by the <A 
title="document order" 
href="REC-xquery-20070123.htm#dt-document-order">document 
order</A> of <CODE>suppliers.xml</CODE>. However, this might not be the most 
efficient way to process the query if the ordering of the result is not 
important. An XQuery implementation might be able to process the query more 
efficiently by using an index to find the red parts, or by using 
<CODE>suppliers.xml</CODE> rather than <CODE>parts.xml</CODE> to control the 
primary ordering of the result. The <CODE>unordered</CODE> expression gives the 
query evaluator freedom to make these kinds of optimizations.</P>
<DIV class=parse-test>
<DIV class=exampleInner><PRE><SPAN class=parse-test><SPAN class=parse-test>unordered {
  for $p in fn:doc("parts.xml")/parts/part[color = "Red"],
      $s in fn:doc("suppliers.xml")/suppliers/supplier
  where $p/suppno = $s/suppno  
  return
    &lt;ps&gt;
       { $p/partno, $s/suppno }
    &lt;/ps&gt;
}</SPAN></SPAN>
</PRE></DIV></DIV>
<P>In addition to <CODE>ordered</CODE> and <CODE>unordered</CODE> expressions, 
XQuery provides a function named <CODE>fn:unordered</CODE> that operates on any 
sequence of items and returns the same sequence in a nondeterministic order. A 
call to the <CODE>fn:unordered</CODE> function may be thought of as giving 
permission for the argument expression to be materialized in whatever order the 
system finds most efficient. The <CODE>fn:unordered</CODE> function relaxes 
ordering only for the sequence that is its immediate operand, whereas an 
<CODE>unordered</CODE> expression sets the <A title="ordering mode" 
href="REC-xquery-20070123.htm#dt-ordering-mode">ordering 
mode</A> for its operand expression and all nested expressions.</P></DIV></DIV>
<DIV class=div2>
<H3><A id=id-conditionals name=id-conditionals></A>3.10 Conditional 
Expressions</H3>
<P>XQuery supports a conditional expression based on the keywords 
<CODE>if</CODE>, <CODE>then</CODE>, and <CODE>else</CODE>.</P>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-IfExpr 
    name=doc-xquery-IfExpr></A>[45]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-IfExpr">IfExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"if" "(" <A 
      href="REC-xquery-20070123.htm#doc-xquery-Expr">Expr</A> 
      ")" "then" <A 
      href="REC-xquery-20070123.htm#doc-xquery-ExprSingle">ExprSingle</A> 
      "else" <A 
      href="REC-xquery-20070123.htm#doc-xquery-ExprSingle">ExprSingle</A></CODE></TD></TR></TBODY></TABLE>
<P>The expression following the <CODE>if</CODE> keyword is called the <B>test 
expression</B>, and the expressions following the <CODE>then</CODE> and 
<CODE>else</CODE> keywords are called the <B>then-expression</B> and 
<B>else-expression</B>, respectively.</P>
<P>The first step in processing a conditional expression is to find the <A 
title="effective boolean value" 
href="REC-xquery-20070123.htm#dt-ebv">effective boolean 
value</A> of the test expression, as defined in <A 
href="REC-xquery-20070123.htm#id-ebv"><B>2.4.3 Effective 
Boolean Value</B></A>.</P>
<P>The value of a conditional expression is defined as follows: If the effective 
boolean value of the test expression is <CODE>true</CODE>, the value of the 
then-expression is returned. If the effective boolean value of the test 
expression is <CODE>false</CODE>, the value of the else-expression is 
returned.</P>
<P>Conditional expressions have a special rule for propagating <A 
title="dynamic error" 
href="REC-xquery-20070123.htm#dt-dynamic-error">dynamic 
errors</A>. If the effective value of the test expression is <CODE>true</CODE>, 
the conditional expression ignores (does not raise) any dynamic errors 
encountered in the else-expression. In this case, since the else-expression can 
have no observable effect, it need not be evaluated. Similarly, if the effective 
value of the test expression is <CODE>false</CODE>, the conditional expression 
ignores any <A title="dynamic error" 
href="REC-xquery-20070123.htm#dt-dynamic-error">dynamic 
errors</A> encountered in the then-expression, and the then-expression need not 
be evaluated.</P>
<P>Here are some examples of conditional expressions:</P>
<UL>
  <LI>
  <P>In this example, the test expression is a comparison expression:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>if ($widget1/unit-cost &lt; $widget2/unit-cost) 
  then $widget1
  else $widget2
</PRE></DIV></DIV>
  <LI>
  <P>In this example, the test expression tests for the existence of an 
  attribute named <CODE>discounted</CODE>, independently of its value:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>if ($part/@discounted) 
  then $part/wholesale 
  else $part/retail
</PRE></DIV></DIV></LI></UL></DIV>
<DIV class=div2>
<H3><A id=id-quantified-expressions name=id-quantified-expressions></A>3.11 
Quantified Expressions</H3>
<P>Quantified expressions support existential and universal quantification. The 
value of a quantified expression is always <CODE>true</CODE> or 
<CODE>false</CODE>.</P>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-QuantifiedExpr 
      name=doc-xquery-QuantifiedExpr></A>[42]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-QuantifiedExpr">QuantifiedExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>("some" | "every") "$" <A 
      href="REC-xquery-20070123.htm#doc-xquery-VarName">VarName</A> 
      <A 
      href="REC-xquery-20070123.htm#doc-xquery-TypeDeclaration">TypeDeclaration</A>? 
      "in" <A 
      href="REC-xquery-20070123.htm#doc-xquery-ExprSingle">ExprSingle</A> 
      ("," "$" <A 
      href="REC-xquery-20070123.htm#doc-xquery-VarName">VarName</A> 
      <A 
      href="REC-xquery-20070123.htm#doc-xquery-TypeDeclaration">TypeDeclaration</A>? 
      "in" <A 
      href="REC-xquery-20070123.htm#doc-xquery-ExprSingle">ExprSingle</A>)* 
      "satisfies" <A 
      href="REC-xquery-20070123.htm#doc-xquery-ExprSingle">ExprSingle</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=noid_N145FF.doc-xquery-TypeDeclaration 
      name=noid_N145FF.doc-xquery-TypeDeclaration></A>[118]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-TypeDeclaration">TypeDeclaration</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"as" <A 
      href="REC-xquery-20070123.htm#doc-xquery-SequenceType">SequenceType</A></CODE></TD></TR></TBODY></TABLE>
<P>A <B>quantified expression</B> begins with a <B>quantifier</B>, which is the 
keyword <CODE>some</CODE> or <CODE>every</CODE>, followed by one or more 
in-clauses that are used to bind variables, followed by the keyword 
<CODE>satisfies</CODE> and a test expression. Each in-clause associates a 
variable with an expression that returns a sequence of items, called the 
<B>binding sequence</B> for that variable. The in-clauses generate tuples of 
variable bindings, including a tuple for each combination of items in the 
binding sequences of the respective variables. Conceptually, the test expression 
is evaluated for each tuple of variable bindings. Results depend on the <A 
title="effective boolean value" 
href="REC-xquery-20070123.htm#dt-ebv">effective boolean 
value</A> of the test expressions, as defined in <A 
href="REC-xquery-20070123.htm#id-ebv"><B>2.4.3 Effective 
Boolean Value</B></A>. The value of the quantified expression is defined by the 
following rules:</P>
<OL class=enumar>
  <LI>
  <P>If the quantifier is <CODE>some</CODE>, the quantified expression is 
  <CODE>true</CODE> if at least one evaluation of the test expression has the <A 
  title="effective boolean value" 
  href="REC-xquery-20070123.htm#dt-ebv">effective boolean 
  value</A> <CODE>true</CODE>; otherwise the quantified expression is 
  <CODE>false</CODE>. This rule implies that, if the in-clauses generate zero 
  binding tuples, the value of the quantified expression is 
  <CODE>false</CODE>.</P>
  <LI>
  <P>If the quantifier is <CODE>every</CODE>, the quantified expression is 
  <CODE>true</CODE> if every evaluation of the test expression has the <A 
  title="effective boolean value" 
  href="REC-xquery-20070123.htm#dt-ebv">effective boolean 
  value</A> <CODE>true</CODE>; otherwise the quantified expression is 
  <CODE>false</CODE>. This rule implies that, if the in-clauses generate zero 
  binding tuples, the value of the quantified expression is 
  <CODE>true</CODE>.</P></LI></OL>
<P>The scope of a variable bound in a quantified expression comprises all 
subexpressions of the quantified expression that appear after the variable 
binding. The scope does not include the expression to which the variable is 
bound.</P>
<DIV class=xquery>
<P class=xquery>Each variable bound in an in-clause of a quantified expression 
may have an optional <A 
href="REC-xquery-20070123.htm#doc-xquery-TypeDeclaration">type 
declaration</A>. If the type of a value bound to the variable does not match the 
declared type according to the rules for <A title="SequenceType matching" 
href="REC-xquery-20070123.htm#dt-sequencetype-matching">SequenceType 
matching</A>, a <A title="type error" 
href="REC-xquery-20070123.htm#dt-type-error">type 
error</A> is raised [<A title=err:XPTY0004 
href="REC-xquery-20070123.htm#ERRXPTY0004">err:XPTY0004</A>].</P></DIV>
<P>The order in which test expressions are evaluated for the various binding 
tuples is <A title="implementation dependent" 
href="REC-xquery-20070123.htm#dt-implementation-dependent">implementation-dependent</A>. 
If the quantifier is <CODE>some</CODE>, an implementation may return 
<CODE>true</CODE> as soon as it finds one binding tuple for which the test 
expression has an <A title="effective boolean value" 
href="REC-xquery-20070123.htm#dt-ebv">effective boolean 
value</A> of <CODE>true</CODE>, and it may raise a <A title="dynamic error" 
href="REC-xquery-20070123.htm#dt-dynamic-error">dynamic 
error</A> as soon as it finds one binding tuple for which the test expression 
raises an error. Similarly, if the quantifier is <CODE>every</CODE>, an 
implementation may return <CODE>false</CODE> as soon as it finds one binding 
tuple for which the test expression has an <A title="effective boolean value" 
href="REC-xquery-20070123.htm#dt-ebv">effective boolean 
value</A> of <CODE>false</CODE>, and it may raise a <A title="dynamic error" 
href="REC-xquery-20070123.htm#dt-dynamic-error">dynamic 
error</A> as soon as it finds one binding tuple for which the test expression 
raises an error. As a result of these rules, the value of a quantified 
expression is not deterministic in the presence of errors, as illustrated in the 
examples below.</P>
<P>Here are some examples of quantified expressions:</P>
<UL>
  <LI>
  <P>This expression is <CODE>true</CODE> if every <CODE>part</CODE> element has 
  a <CODE>discounted</CODE> attribute (regardless of the values of these 
  attributes):</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>every $part in /parts/part satisfies $part/@discounted
</PRE></DIV></DIV>
  <LI>
  <P>This expression is <CODE>true</CODE> if at least one <CODE>employee</CODE> 
  element satisfies the given comparison expression:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>some $emp in /emps/employee satisfies 
     ($emp/bonus &gt; 0.25 * $emp/salary)
</PRE></DIV></DIV>
  <LI>
  <P>In the following examples, each quantified expression evaluates its test 
  expression over nine tuples of variable bindings, formed from the Cartesian 
  product of the sequences <CODE>(1, 2, 3)</CODE> and <CODE>(2, 3, 4)</CODE>. 
  The expression beginning with <CODE>some</CODE> evaluates to 
  <CODE>true</CODE>, and the expression beginning with <CODE>every</CODE> 
  evaluates to <CODE>false</CODE>.</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE><SPAN class=parse-test><SPAN class=parse-test>some $x in (1, 2, 3), $y in (2, 3, 4) 
     satisfies $x + $y = 4</SPAN></SPAN>
</PRE></DIV></DIV>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE><SPAN class=parse-test><SPAN class=parse-test>every $x in (1, 2, 3), $y in (2, 3, 4) 
     satisfies $x + $y = 4</SPAN></SPAN>
</PRE></DIV></DIV>
  <LI>
  <P>This quantified expression may either return <CODE>true</CODE> or raise a 
  <A title="type error" 
  href="REC-xquery-20070123.htm#dt-type-error">type 
  error</A>, since its test expression returns <CODE>true</CODE> for one 
  variable binding and raises a <A title="type error" 
  href="REC-xquery-20070123.htm#dt-type-error">type 
  error</A> for another:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>some $x in (1, 2, "cat") satisfies $x * 2 = 4
</PRE></DIV></DIV>
  <LI>
  <P>This quantified expression may either return <CODE>false</CODE> or raise a 
  <A title="type error" 
  href="REC-xquery-20070123.htm#dt-type-error">type 
  error</A>, since its test expression returns <CODE>false</CODE> for one 
  variable binding and raises a <A title="type error" 
  href="REC-xquery-20070123.htm#dt-type-error">type 
  error</A> for another:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>every $x in (1, 2, "cat") satisfies $x * 2 = 4
</PRE></DIV></DIV>
  <LI class=xquery>
  <P>This quantified expression contains a <A 
  href="REC-xquery-20070123.htm#doc-xquery-TypeDeclaration">type 
  declaration</A> that is not satisfied by every item in the test expression. If 
  the <A title="static typing feature" 
  href="REC-xquery-20070123.htm#dt-static-typing-feature">Static 
  Typing Feature</A> is implemented, this expression raises a <A 
  title="type error" 
  href="REC-xquery-20070123.htm#dt-type-error">type 
  error</A> during the <A title="static analysis phase" 
  href="REC-xquery-20070123.htm#dt-static-analysis">static 
  analysis phase</A>. Otherwise, the expression may either return 
  <CODE>true</CODE> or raise a <A title="type error" 
  href="REC-xquery-20070123.htm#dt-type-error">type 
  error</A> during the <A title="dynamic evaluation phase" 
  href="REC-xquery-20070123.htm#dt-dynamic-evaluation">dynamic 
  evaluation phase</A>.</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>some $x as xs:integer in (1, 2, "cat") satisfies $x * 2 = 4
</PRE></DIV></DIV></LI></UL></DIV>
<DIV class=div2>
<H3><A id=id-expressions-on-datatypes name=id-expressions-on-datatypes></A>3.12 
Expressions on SequenceTypes</H3>
<P><SPAN class=xquery><SPAN class=xquery>In addition to their use in function 
parameters and results,</SPAN></SPAN> <A title="sequence type" 
href="REC-xquery-20070123.htm#dt-sequence-type">sequence 
types</A> are used in <CODE>instance of</CODE>, <SPAN class=xquery><SPAN 
class=xquery><CODE>typeswitch</CODE>,</SPAN></SPAN> <CODE>cast</CODE>, 
<CODE>castable</CODE>, and <CODE>treat</CODE> expressions.</P>
<DIV class=div3>
<H4><A id=id-instance-of name=id-instance-of></A>3.12.1 Instance Of</H4>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-InstanceofExpr 
      name=doc-xquery-InstanceofExpr></A>[54]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-InstanceofExpr">InstanceofExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-TreatExpr">TreatExpr</A> 
      ( "instance" "of" <A 
      href="REC-xquery-20070123.htm#doc-xquery-SequenceType">SequenceType</A> 
      )?</CODE></TD></TR></TBODY></TABLE>
<P>The boolean operator <CODE>instance of</CODE> returns <CODE>true</CODE> if 
the value of its first operand matches the <A 
href="REC-xquery-20070123.htm#doc-xquery-SequenceType">SequenceType</A> 
in its second operand, according to the rules for <A 
title="SequenceType matching" 
href="REC-xquery-20070123.htm#dt-sequencetype-matching">SequenceType 
matching</A>; otherwise it returns <CODE>false</CODE>. For example:</P>
<UL>
  <LI>
  <P><CODE>5 instance of xs:integer</CODE></P>
  <P>This example returns <CODE>true</CODE> because the given value is an 
  instance of the given type.</P>
  <LI>
  <P><CODE>5 instance of xs:decimal</CODE></P>
  <P>This example returns <CODE>true</CODE> because the given value is an 
  integer literal, and <CODE>xs:integer</CODE> is derived by restriction from 
  <CODE>xs:decimal</CODE>.</P>
  <LI class=xquery>
  <P><CODE>&lt;a&gt;{5}&lt;/a&gt; instance of xs:integer</CODE></P>
  <P>This example returns <CODE>false</CODE> because the given value is an 
  element rather than an integer.</P>
  <LI>
  <P><CODE>(5, 6) instance of xs:integer+</CODE></P>
  <P>This example returns <CODE>true</CODE> because the given sequence contains 
  two integers, and is a valid instance of the specified type.</P>
  <LI>
  <P><CODE>. instance of element()</CODE></P>
  <P>This example returns <CODE>true</CODE> if the context item is an element 
  node or <CODE>false</CODE> if the context item is defined but is not an 
  element node. If the context item is undefined, a <A title="dynamic error" 
  href="REC-xquery-20070123.htm#dt-dynamic-error">dynamic 
  error</A> is raised [<A title=err:XPDY0002 
  href="REC-xquery-20070123.htm#ERRXPDY0002">err:XPDY0002</A>].</P></LI></UL></DIV>
<DIV class=xquery>
<DIV class=div3>
<H4><A id=id-typeswitch name=id-typeswitch></A>3.12.2 Typeswitch</H4>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-TypeswitchExpr 
      name=doc-xquery-TypeswitchExpr></A>[43]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-TypeswitchExpr">TypeswitchExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"typeswitch" "(" <A 
      href="REC-xquery-20070123.htm#doc-xquery-Expr">Expr</A> 
      ")" <A 
      href="REC-xquery-20070123.htm#doc-xquery-CaseClause">CaseClause</A>+ 
      "default" ("$" <A 
      href="REC-xquery-20070123.htm#doc-xquery-VarName">VarName</A>)? 
      "return" <A 
      href="REC-xquery-20070123.htm#doc-xquery-ExprSingle">ExprSingle</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-CaseClause 
      name=doc-xquery-CaseClause></A>[44]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-CaseClause">CaseClause</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"case" ("$" <A 
      href="REC-xquery-20070123.htm#doc-xquery-VarName">VarName</A> 
      "as")? <A 
      href="REC-xquery-20070123.htm#doc-xquery-SequenceType">SequenceType</A> 
      "return" <A 
      href="REC-xquery-20070123.htm#doc-xquery-ExprSingle">ExprSingle</A></CODE></TD></TR></TBODY></TABLE>
<DIV class=xquery>
<P class=xquery>The <B>typeswitch</B> expression chooses one of several 
expressions to evaluate based on the <A title="dynamic type" 
href="REC-xquery-20070123.htm#dt-dynamic-type">dynamic 
type</A> of an input value.</P></DIV>
<DIV class=xquery>
<P class=xquery>In a <CODE>typeswitch</CODE> expression, the 
<CODE>typeswitch</CODE> keyword is followed by an expression enclosed in 
parentheses, called the <B>operand expression</B>. This is the expression whose 
type is being tested. The remainder of the <CODE>typeswitch</CODE> expression 
consists of one or more <CODE>case</CODE> clauses and a <CODE>default</CODE> 
clause.</P></DIV>
<DIV class=xquery>
<P class=xquery>Each <CODE>case</CODE> clause specifies a <A 
href="REC-xquery-20070123.htm#doc-xquery-SequenceType">SequenceType</A> 
followed by a <CODE>return</CODE> expression. [<A id=dt-effective-case 
title="effective case" name=dt-effective-case>Definition</A>: The <B>effective 
case</B> in a <CODE>typeswitch</CODE> expression is the first <CODE>case</CODE> 
clause such that the value of the operand expression matches the <A 
href="REC-xquery-20070123.htm#doc-xquery-SequenceType">SequenceType</A> 
in the <CODE>case</CODE> clause, using the rules of <A 
title="SequenceType matching" 
href="REC-xquery-20070123.htm#dt-sequencetype-matching">SequenceType 
matching</A>.] The value of the <CODE>typeswitch</CODE> expression is the value 
of the <CODE>return</CODE> expression in the effective case. If the value of the 
operand expression does not match any <A 
href="REC-xquery-20070123.htm#doc-xquery-SequenceType">SequenceType</A> 
named in a <CODE>case</CODE> clause, the value of the <CODE>typeswitch</CODE> 
expression is the value of the <CODE>return</CODE> expression in the 
<CODE>default</CODE> clause.</P></DIV>
<P>In a <CODE>case</CODE> or <CODE>default</CODE> clause, if the value to be 
returned depends on the value of the operand expression, the clause must specify 
a variable name. Within the <CODE>return</CODE> expression of the 
<CODE>case</CODE> or <CODE>default</CODE> clause, this variable name is bound to 
the value of the operand expression. Inside a <CODE>case</CODE> clause, the <A 
title="static type" 
href="REC-xquery-20070123.htm#dt-static-type">static 
type</A> of the variable is the <A 
href="REC-xquery-20070123.htm#doc-xquery-SequenceType">SequenceType</A> 
named in the <CODE>case</CODE> clause. Inside a <CODE>default</CODE> clause, the 
static type of the variable is the same as the static type of the operand 
expression. If the value to be returned by a <CODE>case</CODE> or 
<CODE>default</CODE> clause does not depend on the value of the operand 
expression, the clause need not specify a variable.</P>
<P>The scope of a variable binding in a <CODE>case</CODE> or 
<CODE>default</CODE> clause comprises that clause. It is not an error for more 
than one <CODE>case</CODE> or <CODE>default</CODE> clause in the same 
<CODE>typeswitch</CODE> expression to bind variables with the same name.</P>
<P>A special rule applies to propagation of <A title="dynamic error" 
href="REC-xquery-20070123.htm#dt-dynamic-error">dynamic 
errors</A> by <CODE>typeswitch</CODE> expressions. A <CODE>typeswitch</CODE> 
expression ignores (does not raise) any dynamic errors encountered in 
<CODE>case</CODE> clauses other than the <A title="effective case" 
href="REC-xquery-20070123.htm#dt-effective-case">effective 
case</A>. Dynamic errors encountered in the <CODE>default</CODE> clause are 
raised only if there is no <A title="effective case" 
href="REC-xquery-20070123.htm#dt-effective-case">effective 
case</A>.</P>
<DIV class=xquery>
<P class=xquery>The following example shows how a <CODE>typeswitch</CODE> 
expression might be used to process an expression in a way that depends on its 
<A title="dynamic type" 
href="REC-xquery-20070123.htm#dt-dynamic-type">dynamic 
type</A>.</P></DIV>
<DIV class=xquery>
<DIV class=exampleInner><PRE><SPAN class=parse-test><SPAN class=parse-test>typeswitch($customer/billing-address)
   case $a as element(*, USAddress) return $a/state
   case $a as element(*, CanadaAddress) return $a/province
   case $a as element(*, JapanAddress) return $a/prefecture
   default return "unknown"</SPAN></SPAN>
</PRE></DIV></DIV></DIV></DIV>
<DIV class=div3>
<H4><A id=id-cast name=id-cast></A>3.12.3 Cast</H4>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-CastExpr 
      name=doc-xquery-CastExpr></A>[57]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-CastExpr">CastExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-UnaryExpr">UnaryExpr</A> 
      ( "cast" "as" <A 
      href="REC-xquery-20070123.htm#doc-xquery-SingleType">SingleType</A> 
      )?</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-SingleType 
      name=doc-xquery-SingleType></A>[117]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-SingleType">SingleType</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-AtomicType">AtomicType</A> 
      "?"?</CODE></TD></TR></TBODY></TABLE>
<P>Occasionally it is necessary to convert a value to a specific datatype. For 
this purpose, XQuery provides a <CODE>cast</CODE> expression that creates a new 
value of a specific type based on an existing value. A <CODE>cast</CODE> 
expression takes two operands: an <B>input expression</B> and a <B>target 
type</B>. The type of the input expression is called the <B>input type</B>. The 
target type must be an atomic type that is in the <A 
title="in-scope schema type" 
href="REC-xquery-20070123.htm#dt-is-types">in-scope 
schema types</A> [<A title=err:XPST0051 
href="REC-xquery-20070123.htm#ERRXPST0051">err:XPST0051</A>]. 
In addition, the target type cannot be <CODE>xs:NOTATION</CODE> or 
<CODE>xs:anyAtomicType</CODE> [<A title=err:XPST0080 
href="REC-xquery-20070123.htm#ERRXPST0080">err:XPST0080</A>]. 
The optional occurrence indicator "<CODE>?</CODE>" denotes that an empty 
sequence is permitted. If the target type has no namespace prefix, it is 
considered to be in the <A title="default element/type namespace" 
href="REC-xquery-20070123.htm#dt-def-elemtype-ns">default 
element/type namespace</A>. The semantics of the <CODE>cast</CODE> expression 
are as follows:</P>
<OL class=enumar>
  <LI>
  <P><A title=atomization 
  href="REC-xquery-20070123.htm#dt-atomization">Atomization</A> 
  is performed on the input expression.</P>
  <LI>
  <P>If the result of atomization is a sequence of more than one atomic value, a 
  <A title="type error" 
  href="REC-xquery-20070123.htm#dt-type-error">type 
  error</A> is raised [<A title=err:XPTY0004 
  href="REC-xquery-20070123.htm#ERRXPTY0004">err:XPTY0004</A>].</P>
  <LI>
  <P>If the result of atomization is an empty sequence:</P>
  <OL class=enumla>
    <LI>
    <P>If <CODE>?</CODE> is specified after the target type, the result of the 
    <CODE>cast</CODE> expression is an empty sequence.</P>
    <LI>
    <P>If <CODE>?</CODE> is not specified after the target type, a <A 
    title="type error" 
    href="REC-xquery-20070123.htm#dt-type-error">type 
    error</A> is raised [<A title=err:XPTY0004 
    href="REC-xquery-20070123.htm#ERRXPTY0004">err:XPTY0004</A>].</P></LI></OL>
  <LI>
  <P>If the result of atomization is a single atomic value, the result of the 
  cast expression depends on the input type and the target type. In general, the 
  cast expression attempts to create a new value of the target type based on the 
  input value. Only certain combinations of input type and target type are 
  supported. A summary of the rules are listed below— the normative definition 
  of these rules is given in <A 
  href="REC-xquery-20070123.htm#FunctionsAndOperators">[XQuery 
  1.0 and XPath 2.0 Functions and Operators]</A>. For the purpose of these 
  rules, an implementation may determine that one type is derived by restriction 
  from another type either by examining the <A 
  title="in-scope schema definitions" 
  href="REC-xquery-20070123.htm#dt-issd">in-scope schema 
  definitions</A> or by using an alternative, <A 
  title="implementation dependent" 
  href="REC-xquery-20070123.htm#dt-implementation-dependent">implementation-dependent</A> 
  mechanism such as a data dictionary.</P>
  <OL class=enumla>
    <LI>
    <P><CODE>cast</CODE> is supported for the combinations of input type and 
    target type listed in <A 
    href="http://www.w3.org/TR/xpath-functions/#casting-from-primitive-to-primitive">Section 
    17.1 Casting from primitive types to primitive 
    types</A><SUP><SMALL>FO</SMALL></SUP>. For each of these combinations, both 
    the input type and the target type are primitive <A title="schema type" 
    href="REC-xquery-20070123.htm#dt-schema-type">schema 
    types</A>. For example, a value of type <CODE>xs:string</CODE> can be cast 
    into the schema type <CODE>xs:decimal</CODE>. For each of these built-in 
    combinations, the semantics of casting are specified in <A 
    href="REC-xquery-20070123.htm#FunctionsAndOperators">[XQuery 
    1.0 and XPath 2.0 Functions and Operators]</A>.</P>
    <P>If the target type of a <CODE>cast</CODE> expression is 
    <CODE>xs:QName</CODE>, or is a type that is derived from 
    <CODE>xs:QName</CODE> or <CODE>xs:NOTATION</CODE>, and if the base type of 
    the input is not the same as the base type of the target type, then the 
    input expression must be a string literal [<A title=err:XPTY0004 
    href="REC-xquery-20070123.htm#ERRXPTY0004">err:XPTY0004</A>].</P>
    <DIV class=note>
    <P class=prefix><B>Note:</B></P>
    <P>The reason for this rule is that construction of an instance of one of 
    these target types from a string requires knowledge about namespace 
    bindings. If the input expression is a non-literal string, it might be 
    derived from an input document whose namespace bindings are different from 
    the <A title="statically known namespaces" 
    href="REC-xquery-20070123.htm#dt-static-namespaces">statically 
    known namespaces</A>.</P></DIV>
    <LI>
    <P><CODE>cast</CODE> is supported if the input type is a non-primitive 
    atomic type that is derived by restriction from the target type. In this 
    case, the input value is mapped into the value space of the target type, 
    unchanged except for its type. For example, if <CODE>shoesize</CODE> is 
    derived by restriction from <CODE>xs:integer</CODE>, a value of type 
    <CODE>shoesize</CODE> can be cast into the schema type 
    <CODE>xs:integer</CODE>.</P>
    <LI>
    <P><CODE>cast</CODE> is supported if the target type is a non-primitive 
    atomic type and the input type is <CODE>xs:string</CODE> or 
    <CODE>xs:untypedAtomic</CODE>. The input value is first converted to a value 
    in the lexical space of the target type by applying the whitespace 
    normalization rules for the target type (as defined in <A 
    href="REC-xquery-20070123.htm#XMLSchema">[XML 
    Schema]</A>); a <A title="dynamic error" 
    href="REC-xquery-20070123.htm#dt-dynamic-error">dynamic 
    error</A> [err:FORG0001] is raised if the resulting lexical value does not 
    satisfy the pattern facet of the target type. The lexical value is then 
    converted to the value space of the target type using the schema-defined 
    rules for the target type; a <A title="dynamic error" 
    href="REC-xquery-20070123.htm#dt-dynamic-error">dynamic 
    error</A> [err:FORG0001] is raised if the resulting value does not satisfy 
    all the facets of the target type.</P>
    <LI>
    <P><CODE>cast</CODE> is supported if the target type is a non-primitive 
    atomic type that is derived by restriction from the input type. The input 
    value must satisfy all the facets of the target type (in the case of the 
    pattern facet, this is checked by generating a string representation of the 
    input value, using the rules for casting to <CODE>xs:string</CODE>). The 
    resulting value is the same as the input value, but with a different <A 
    title="dynamic type" 
    href="REC-xquery-20070123.htm#dt-dynamic-type">dynamic 
    type</A>.</P>
    <LI>
    <P>If a primitive type P1 can be cast into a primitive type P2, then any 
    type derived by restriction from P1 can be cast into any type derived by 
    restriction from P2, provided that the facets of the target type are 
    satisfied. First the input value is cast to P1 using rule (b) above. Next, 
    the value of type P1 is cast to the type P2, using rule (a) above. Finally, 
    the value of type P2 is cast to the target type, using rule (d) above.</P>
    <LI>
    <P>For any combination of input type and target type that is not in the 
    above list, a <CODE>cast</CODE> expression raises a <A title="type error" 
    href="REC-xquery-20070123.htm#dt-type-error">type 
    error</A> [<A title=err:XPTY0004 
    href="REC-xquery-20070123.htm#ERRXPTY0004">err:XPTY0004</A>].</P></LI></OL></LI></OL>
<P>If casting from the input type to the target type is supported but 
nevertheless it is not possible to cast the input value into the value space of 
the target type, a <A title="dynamic error" 
href="REC-xquery-20070123.htm#dt-dynamic-error">dynamic 
error</A> is raised. [err:FORG0001] This includes the case when any facet of the 
target type is not satisfied. For example, the expression <CODE>"2003-02-31" 
cast as xs:date</CODE> would raise a <A title="dynamic error" 
href="REC-xquery-20070123.htm#dt-dynamic-error">dynamic 
error</A>.</P></DIV>
<DIV class=div3>
<H4><A id=id-castable name=id-castable></A>3.12.4 Castable</H4>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-CastableExpr 
      name=doc-xquery-CastableExpr></A>[56]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-CastableExpr">CastableExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-CastExpr">CastExpr</A> 
      ( "castable" "as" <A 
      href="REC-xquery-20070123.htm#doc-xquery-SingleType">SingleType</A> 
      )?</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=noid_N149AE.doc-xquery-SingleType 
      name=noid_N149AE.doc-xquery-SingleType></A>[117]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-SingleType">SingleType</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-AtomicType">AtomicType</A> 
      "?"?</CODE></TD></TR></TBODY></TABLE>
<P>XQuery provides an expression that tests whether a given value is castable 
into a given target type. The target type must be an atomic type that is in the 
<A title="in-scope schema type" 
href="REC-xquery-20070123.htm#dt-is-types">in-scope 
schema types</A> [<A title=err:XPST0051 
href="REC-xquery-20070123.htm#ERRXPST0051">err:XPST0051</A>]. 
In addition, the target type cannot be <CODE>xs:NOTATION</CODE> or 
<CODE>xs:anyAtomicType</CODE> [<A title=err:XPST0080 
href="REC-xquery-20070123.htm#ERRXPST0080">err:XPST0080</A>]. 
The optional occurrence indicator "<CODE>?</CODE>" denotes that an empty 
sequence is permitted.</P>
<P>The expression <CODE>V castable as T</CODE> returns <CODE>true</CODE> if the 
value <CODE>V</CODE> can be successfully cast into the target type 
<CODE>T</CODE> by using a <CODE>cast</CODE> expression; otherwise it returns 
<CODE>false</CODE>. The <CODE>castable</CODE> expression can be used as a <A 
title=predicate 
href="REC-xquery-20070123.htm#dt-predicate">predicate</A> 
to avoid errors at evaluation time. It can also be used to select an appropriate 
type for processing of a given value, as illustrated in the following 
example:</P>
<DIV class=parse-test>
<DIV class=exampleInner><PRE>if ($x castable as hatsize) 
   then $x cast as hatsize 
   else if ($x castable as IQ) 
   then $x cast as IQ 
   else $x cast as xs:string
</PRE></DIV></DIV>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>If the target type of a <CODE>castable</CODE> expression is 
<CODE>xs:QName</CODE>, or is a type that is derived from <CODE>xs:QName</CODE> 
or <CODE>xs:NOTATION</CODE>, and the input argument of the expression is of type 
<CODE>xs:string</CODE> but it is not a literal string, the result of the 
<CODE>castable</CODE> expression is <CODE>false</CODE>.</P></DIV></DIV>
<DIV class=div3>
<H4><A id=id-constructor-functions name=id-constructor-functions></A>3.12.5 
Constructor Functions</H4>
<P>For every atomic type in the <A title="in-scope schema type" 
href="REC-xquery-20070123.htm#dt-is-types">in-scope 
schema types</A> (except <CODE>xs:NOTATION</CODE> and 
<CODE>xs:anyAtomicType</CODE>, which are not instantiable), a <B>constructor 
function</B> is implicitly defined. In each case, the name of the constructor 
function is the same as the name of its target type (including namespace). The 
signature of the constructor function for type <EM>T</EM> is as follows:</P>
<DIV class=exampleInner><PRE><EM>T</EM>($arg as xs:anyAtomicType?) as <EM>T?</EM>
</PRE></DIV>
<P>[<A id=dt-constructor-function title="constructor function" 
name=dt-constructor-function>Definition</A>: The <B>constructor function</B> for 
a given type is used to convert instances of other atomic types into the given 
type. The semantics of the constructor function call <CODE>T($arg)</CODE> are 
defined to be equivalent to the expression <CODE>(($arg) cast as 
T?)</CODE>.]</P>
<P>The constructor functions for <CODE>xs:QName</CODE> and for types derived 
from <CODE>xs:QName</CODE> and <CODE>xs:NOTATION</CODE> require their arguments 
to be string literals or to have a base type that is the same as the base type 
of the target type; otherwise a type error [<A title=err:XPTY0004 
href="REC-xquery-20070123.htm#ERRXPTY0004">err:XPTY0004</A>] 
is raised. This rule is consistent with the semantics of <CODE>cast</CODE> 
expressions for these types, as defined in <A 
href="REC-xquery-20070123.htm#id-cast"><B>3.12.3 
Cast</B></A>.</P>
<P>The following examples illustrate the use of constructor functions:</P>
<UL>
  <LI>
  <P>This example is equivalent to <CODE>("2000-01-01" cast as 
  xs:date?)</CODE>.</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>xs:date("2000-01-01")
</PRE></DIV></DIV>
  <LI>
  <P>This example is equivalent to <CODE>(($floatvalue * 0.2E-5) cast as 
  xs:decimal?)</CODE>.</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>xs:decimal($floatvalue * 0.2E-5)
</PRE></DIV></DIV>
  <LI>
  <P>This example returns a <CODE>xs:dayTimeDuration</CODE> value equal to 21 
  days. It is equivalent to <CODE>("P21D" cast as 
  xs:dayTimeDuration?)</CODE>.</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>xs:dayTimeDuration("P21D")
</PRE></DIV></DIV>
  <LI>
  <P>If <CODE>usa:zipcode</CODE> is a user-defined atomic type in the <A 
  title="in-scope schema type" 
  href="REC-xquery-20070123.htm#dt-is-types">in-scope 
  schema types</A>, then the following expression is equivalent to the 
  expression <CODE>("12345" cast as usa:zipcode?)</CODE>.</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>usa:zipcode("12345")
</PRE></DIV></DIV></LI></UL>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>An instance of an atomic type that is not in a namespace can be constructed 
in either of the following ways:</P>
<UL>
  <LI>
  <P>By using a <CODE>cast</CODE> expression, if the <A 
  title="default element/type namespace" 
  href="REC-xquery-20070123.htm#dt-def-elemtype-ns">default 
  element/type namespace</A> is "none". <SPAN class=xquery><SPAN 
  class=xquery>(See <A 
  href="REC-xquery-20070123.htm#id-default-namespace"><B>4.13 
  Default Namespace Declaration</B></A> for how to undeclare the <A 
  title="default element/type namespace" 
  href="REC-xquery-20070123.htm#dt-def-elemtype-ns">default 
  element/type namespace</A>).</SPAN></SPAN></P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>17 cast as apple
</PRE></DIV></DIV>
  <LI>
  <P>By using a constructor function, if the <A 
  title="default function namespace" 
  href="REC-xquery-20070123.htm#dt-def-fn-ns">default 
  function namespace</A> is "none". <SPAN class=xquery><SPAN class=xquery>(See 
  <A 
  href="REC-xquery-20070123.htm#id-default-namespace"><B>4.13 
  Default Namespace Declaration</B></A> for how to undeclare the <A 
  title="default function namespace" 
  href="REC-xquery-20070123.htm#dt-def-fn-ns">default 
  function namespace</A>).</SPAN></SPAN></P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>apple(17)
</PRE></DIV></DIV></LI></UL></DIV></DIV>
<DIV class=div3>
<H4><A id=id-treat name=id-treat></A>3.12.6 Treat</H4>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-TreatExpr 
      name=doc-xquery-TreatExpr></A>[55]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-TreatExpr">TreatExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-CastableExpr">CastableExpr</A> 
      ( "treat" "as" <A 
      href="REC-xquery-20070123.htm#doc-xquery-SequenceType">SequenceType</A> 
      )?</CODE></TD></TR></TBODY></TABLE>
<P>XQuery provides an expression called <CODE>treat</CODE> that can be used to 
modify the <A title="static type" 
href="REC-xquery-20070123.htm#dt-static-type">static 
type</A> of its operand.</P>
<P>Like <CODE>cast</CODE>, the <CODE>treat</CODE> expression takes two operands: 
an expression and a <A 
href="REC-xquery-20070123.htm#doc-xquery-SequenceType">SequenceType</A>. 
Unlike <CODE>cast</CODE>, however, <CODE>treat</CODE> does not change the <A 
title="dynamic type" 
href="REC-xquery-20070123.htm#dt-dynamic-type">dynamic 
type</A> or value of its operand. Instead, the purpose of <CODE>treat</CODE> is 
to ensure that an expression has an expected dynamic type at evaluation 
time.</P>
<P>The semantics of <EM><CODE>expr1</CODE></EM> <CODE>treat as</CODE> 
<EM><CODE>type1</CODE></EM> are as follows:</P>
<UL>
  <LI>
  <P>During static analysis:</P>
  <P>The <A title="static type" 
  href="REC-xquery-20070123.htm#dt-static-type">static 
  type</A> of the <CODE>treat</CODE> expression is <EM><CODE>type1</CODE></EM>. 
  This enables the expression to be used as an argument of a function that 
  requires a parameter of <EM><CODE>type1</CODE></EM>.</P>
  <LI>
  <P>During expression evaluation:</P>
  <P>If <EM><CODE>expr1</CODE></EM> matches <EM><CODE>type1</CODE></EM>, using 
  the rules for <A title="SequenceType matching" 
  href="REC-xquery-20070123.htm#dt-sequencetype-matching">SequenceType 
  matching</A>, the <CODE>treat</CODE> expression returns the value of 
  <EM><CODE>expr1</CODE></EM>; otherwise, it raises a <A title="dynamic error" 
  href="REC-xquery-20070123.htm#dt-dynamic-error">dynamic 
  error</A> [<A title=err:XPDY0050 
  href="REC-xquery-20070123.htm#ERRXPDY0050">err:XPDY0050</A>]. 
  If the value of <EM><CODE>expr1</CODE></EM> is returned, its identity is 
  preserved. The <CODE>treat</CODE> expression ensures that the value of its 
  expression operand conforms to the expected type at run-time.</P>
  <LI>
  <P>Example:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>$myaddress treat as element(*, USAddress)
</PRE></DIV></DIV>
  <P>The <A title="static type" 
  href="REC-xquery-20070123.htm#dt-static-type">static 
  type</A> of <CODE>$myaddress</CODE> may be <CODE>element(*, Address)</CODE>, a 
  less specific type than <CODE>element(*, USAddress)</CODE>. However, at 
  run-time, the value of <CODE>$myaddress</CODE> must match the type 
  <CODE>element(*, USAddress)</CODE> using rules for <A 
  title="SequenceType matching" 
  href="REC-xquery-20070123.htm#dt-sequencetype-matching">SequenceType 
  matching</A>; otherwise a <A title="dynamic error" 
  href="REC-xquery-20070123.htm#dt-dynamic-error">dynamic 
  error</A> is raised [<A title=err:XPDY0050 
  href="REC-xquery-20070123.htm#ERRXPDY0050">err:XPDY0050</A>].</P></LI></UL></DIV></DIV>
<DIV class=xquery>
<DIV class=div2>
<H3><A id=id-validate name=id-validate></A>3.13 Validate Expressions</H3>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-ValidateExpr 
      name=doc-xquery-ValidateExpr></A>[63]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-ValidateExpr">ValidateExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"validate" <A 
      href="REC-xquery-20070123.htm#doc-xquery-ValidationMode">ValidationMode</A>? 
      "{" <A 
      href="REC-xquery-20070123.htm#doc-xquery-Expr">Expr</A> 
      "}"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-ValidationMode 
      name=doc-xquery-ValidationMode></A>[64]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-ValidationMode">ValidationMode</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"lax" | "strict"</CODE></TD></TR></TBODY></TABLE>
<P>A <CODE>validate</CODE> expression can be used to validate a document node or 
an element node with respect to the <A title="in-scope schema definitions" 
href="REC-xquery-20070123.htm#dt-issd">in-scope schema 
definitions</A>, using the schema validation process defined in <A 
href="REC-xquery-20070123.htm#XMLSchema">[XML 
Schema]</A>. If the operand of a <CODE>validate</CODE> expression does not 
evaluate to exactly one document or element node, a <A title="type error" 
href="REC-xquery-20070123.htm#dt-type-error">type 
error</A> is raised [<A title=err:XQTY0030 
href="REC-xquery-20070123.htm#ERRXQTY0030">err:XQTY0030</A>]. 
In this specification, the node that is the operand of a <CODE>validate</CODE> 
expression is called the <B>operand node</B>.</P>
<P>A <CODE>validate</CODE> expression returns a new node with its own identity 
and with no parent. The new node and its descendants are given <A 
title="type annotation" 
href="REC-xquery-20070123.htm#dt-type-annotation">type 
annotations</A> that are generated by applying a validation process to the 
operand node. In some cases, default values may also be generated by the 
validation process.</P>
<P>A <CODE>validate</CODE> expression may optionally specify a <A 
href="REC-xquery-20070123.htm#doc-xquery-ValidationMode">validation 
mode</A>. The default <A 
href="REC-xquery-20070123.htm#doc-xquery-ValidationMode">validation 
mode</A> is <CODE>strict</CODE>. The result of a <CODE>validate</CODE> 
expression is defined by the following rules.</P>
<OL class=enumar>
  <LI>
  <P>If the operand node is a document node, its children must consist of 
  exactly one element node and zero or more comment and processing instruction 
  nodes, in any order; otherwise, a <A title="dynamic error" 
  href="REC-xquery-20070123.htm#dt-dynamic-error">dynamic 
  error</A> [<A title=err:XQDY0061 
  href="REC-xquery-20070123.htm#ERRXQDY0061">err:XQDY0061</A>] 
  is raised.</P>
  <LI>
  <P>The operand node is converted to an XML Information Set (<A 
  href="REC-xquery-20070123.htm#XINFO">[XML Infoset]</A>) 
  according to the "Infoset Mapping" rules defined in <A 
  href="REC-xquery-20070123.htm#datamodel">[XQuery/XPath 
  Data Model (XDM)]</A>. Note that this process discards any existing <A 
  title="type annotation" 
  href="REC-xquery-20070123.htm#dt-type-annotation">type 
  annotations</A>.</P>
  <LI>
  <P>Validity assessment is carried out on the root element information item of 
  the resulting Infoset, using the <A title="in-scope schema definitions" 
  href="REC-xquery-20070123.htm#dt-issd">in-scope schema 
  definitions</A> as the effective schema. The process of validation applies 
  recursively to contained elements and attributes to the extent required by the 
  effective schema. During validity assessment, the following special rules are 
  in effect:</P>
  <OL class=enumla>
    <LI>
    <P>If <A 
    href="REC-xquery-20070123.htm#doc-xquery-ValidationMode">validation 
    mode</A> is <CODE>strict</CODE>, then there must be a top-level element 
    declaration in the <A title="in-scope element declarations" 
    href="REC-xquery-20070123.htm#dt-is-elems">in-scope 
    element declarations</A> that matches the root element information item in 
    the Infoset, and schema-validity assessment is carried out using that 
    declaration in accordance with item 2 of <A 
    href="REC-xquery-20070123.htm#XMLSchema">[XML 
    Schema]</A> Part 1, section 5.2, "Assessing Schema-Validity." If there is no 
    such element declaration, a <A title="dynamic error" 
    href="REC-xquery-20070123.htm#dt-dynamic-error">dynamic 
    error</A> is raised [<A title=err:XQDY0084 
    href="REC-xquery-20070123.htm#ERRXQDY0084">err:XQDY0084</A>].</P>
    <LI>
    <P>If <A 
    href="REC-xquery-20070123.htm#doc-xquery-ValidationMode">validation 
    mode</A> is <CODE>lax</CODE>, then schema-validity assessment is carried out 
    in accordance with item 3 of <A 
    href="REC-xquery-20070123.htm#XMLSchema">[XML 
    Schema]</A> Part 1, section 5.2, "Assessing Schema-Validity."</P>
    <P>If <A 
    href="REC-xquery-20070123.htm#doc-xquery-ValidationMode">validation 
    mode</A> is <CODE>lax</CODE> and the root element information item has 
    neither a top-level element declaration nor an <CODE>xsi:type</CODE> 
    attribute, <A 
    href="REC-xquery-20070123.htm#XMLSchema">[XML 
    Schema]</A> defines the recursive checking of children and attributes as 
    optional. During processing of an XQuery <CODE>validate</CODE> expression, 
    this recursive checking is required.</P>
    <LI>
    <P>If the operand node is an element node, the validation rules named 
    "Validation Root Valid (ID/IDREF)" and "Identity-constraint Satisfied" are 
    not applied. This means that document-level constraints relating to 
    uniqueness and referential integrity are not enforced.</P>
    <LI>
    <P>There is no check that the document contains unparsed entities whose 
    names match the values of nodes of type <CODE>xs:ENTITY</CODE> or 
    <CODE>xs:ENTITIES</CODE>.</P>
    <LI>
    <P>There is no check that the document contains notations whose names match 
    the values of nodes of type <CODE>xs:NOTATION</CODE>.</P></LI></OL>
  <DIV class=note>
  <P class=prefix><B>Note:</B></P>
  <P>Validity assessment is affected by the presence or absence of 
  <CODE>xsi:type</CODE> attributes on the elements being validated, and may 
  generate new information items such as default attributes.</P></DIV>
  <LI>
  <P>The next step depends on <A 
  href="REC-xquery-20070123.htm#doc-xquery-ValidationMode">validation 
  mode</A> and on the <CODE>validity</CODE> property of the root element 
  information item in the PSVI that results from the validation process.</P>
  <OL class=enumla>
    <LI>
    <P>If the <CODE>validity</CODE> property of the root element information 
    item is <CODE>valid</CODE> (for any <A 
    href="REC-xquery-20070123.htm#doc-xquery-ValidationMode">validation 
    mode</A>), or if <A 
    href="REC-xquery-20070123.htm#doc-xquery-ValidationMode">validation 
    mode</A> is <CODE>lax</CODE> and the <CODE>validity</CODE> property of the 
    root element information item is <CODE>notKnown</CODE>, the PSVI is 
    converted back into an <A title="XDM instance" 
    href="REC-xquery-20070123.htm#dt-data-model-instance">XDM 
    instance</A> as described in <A 
    href="REC-xquery-20070123.htm#datamodel">[XQuery/XPath 
    Data Model (XDM)]</A> Section 3.3, "Construction from a PSVI". The resulting 
    node (a new node of the same kind as the operand node) is returned as the 
    result of the <CODE>validate</CODE> expression.</P>
    <LI>
    <P>Otherwise, a <A title="dynamic error" 
    href="REC-xquery-20070123.htm#dt-dynamic-error">dynamic 
    error</A> is raised [<A title=err:XQDY0027 
    href="REC-xquery-20070123.htm#ERRXQDY0027">err:XQDY0027</A>].</P></LI></OL></LI></OL>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>The effect of these rules is as follows: If <A 
href="REC-xquery-20070123.htm#doc-xquery-ValidationMode">validation 
mode</A> is <CODE>strict</CODE>, the validated element must have a top-level 
element declaration in the effective schema, and must conform to this 
declaration. If <A 
href="REC-xquery-20070123.htm#doc-xquery-ValidationMode">validation 
mode</A> is <CODE>lax</CODE>, the validated element must conform to its 
top-level element declaration if such a declaration exists in the effective 
schema. If <A 
href="REC-xquery-20070123.htm#doc-xquery-ValidationMode">validation 
mode</A> is <CODE>lax</CODE> and there is no top-level element declaration for 
the element, and the element has an <CODE>xsi:type</CODE> attribute, then the 
<CODE>xsi:type</CODE> attribute must name a top-level type definition in the 
effective schema, and the element must conform to that type. The validated 
element corresponds either to the operand node or (if the operand node is a 
document node) to its element child.</P></DIV>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>During conversion of the PSVI into an <A title="XDM instance" 
href="REC-xquery-20070123.htm#dt-data-model-instance">XDM 
instance</A> after validation, any element information items whose validity 
property is <CODE>notKnown</CODE> are converted into element nodes with <A 
title="type annotation" 
href="REC-xquery-20070123.htm#dt-type-annotation">type 
annotation</A> <CODE>xs:anyType</CODE>, and any attribute information items 
whose validity property is <CODE>notKnown</CODE> are converted into attribute 
nodes with <A title="type annotation" 
href="REC-xquery-20070123.htm#dt-type-annotation">type 
annotation</A> <CODE>xs:untypedAtomic</CODE>, as described in <A 
href="http://www.w3.org/TR/xpath-datamodel/#PSVI2NodeTypes">Section 3.3.1.1 
Element and Attribute Node Type 
Names</A><SUP><SMALL>DM</SMALL></SUP>.</P></DIV></DIV></DIV>
<DIV class=xquery>
<DIV class=div2>
<H3><A id=id-extension-expressions name=id-extension-expressions></A>3.14 
Extension Expressions</H3>
<P>[<A id=dt-extension-expression title="extension expression" 
name=dt-extension-expression>Definition</A>: An <B>extension expression</B> is 
an expression whose semantics are <A title="implementation defined" 
href="REC-xquery-20070123.htm#dt-implementation-defined">implementation-defined</A>.] 
Typically a particular extension will be recognized by some implementations and 
not by others. The syntax is designed so that extension expressions can be 
successfully parsed by all implementations, and so that fallback behavior can be 
defined for implementations that do not recognize a particular extension.</P>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-ExtensionExpr 
      name=doc-xquery-ExtensionExpr></A>[65]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-ExtensionExpr">ExtensionExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-Pragma">Pragma</A>+ 
      "{" <A 
      href="REC-xquery-20070123.htm#doc-xquery-Expr">Expr</A>? 
      "}"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-Pragma 
    name=doc-xquery-Pragma></A>[66]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-Pragma">Pragma</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"(#" <A 
      href="REC-xquery-20070123.htm#prod-xquery-S">S</A>? 
      <A 
      href="REC-xquery-20070123.htm#prod-xquery-QName">QName</A> 
      (<A 
      href="REC-xquery-20070123.htm#prod-xquery-S">S</A> 
      <A 
      href="REC-xquery-20070123.htm#doc-xquery-PragmaContents">PragmaContents</A>)? 
      "#)"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-PragmaContents 
      name=doc-xquery-PragmaContents></A>[67]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-PragmaContents">PragmaContents</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>(<A 
      href="REC-xquery-20070123.htm#prod-xquery-Char">Char</A>* 
      - (Char* '#)' Char*))</CODE></TD></TR></TBODY></TABLE>
<P>An extension expression consists of one or more <B>pragmas</B>, followed by 
an expression enclosed in curly braces. [<A id=dt-pragma title=pragma 
name=dt-pragma>Definition</A>: A <B>pragma</B> is denoted by the delimiters 
<CODE>(#</CODE> and <CODE>#)</CODE>, and consists of an identifying QName 
followed by <A title="implementation defined" 
href="REC-xquery-20070123.htm#dt-implementation-defined">implementation-defined</A> 
content.] The content of a pragma may consist of any string of characters that 
does not contain the ending delimiter <CODE>#)</CODE>. The QName of a pragma 
must resolve to a namespace URI and local name, using the <A 
title="statically known namespaces" 
href="REC-xquery-20070123.htm#dt-static-namespaces">statically 
known namespaces</A> [<A title=err:XPST0081 
href="REC-xquery-20070123.htm#ERRXPST0081">err:XPST0081</A>].</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>Since there is no default namespace for pragmas, a pragma QName must include 
a namespace prefix.</P></DIV>
<P>Each implementation recognizes an <A title="implementation defined" 
href="REC-xquery-20070123.htm#dt-implementation-defined">implementation-defined</A> 
set of namespace URIs used to denote pragmas.</P>
<P>If the namespace part of a pragma QName is not recognized by the 
implementation as a pragma namespace, then the pragma is ignored. If all the 
pragmas in an <A 
href="REC-xquery-20070123.htm#doc-xquery-ExtensionExpr">ExtensionExpr</A> 
are ignored, then the value of the <A 
href="REC-xquery-20070123.htm#doc-xquery-ExtensionExpr">ExtensionExpr</A> 
is the value of the expression enclosed in curly braces; if this expression is 
absent, then a <A title="static error" 
href="REC-xquery-20070123.htm#dt-static-error">static 
error</A> is raised [<A title=err:XQST0079 
href="REC-xquery-20070123.htm#ERRXQST0079">err:XQST0079</A>].</P>
<P>If an implementation recognizes the namespace of one or more pragmas in an <A 
href="REC-xquery-20070123.htm#doc-xquery-ExtensionExpr">ExtensionExpr</A>, 
then the value of the <A 
href="REC-xquery-20070123.htm#doc-xquery-ExtensionExpr">ExtensionExpr</A>, 
including its error behavior, is <A title="implementation defined" 
href="REC-xquery-20070123.htm#dt-implementation-defined">implementation-defined</A>. 
For example, an implementation that recognizes the namespace of a pragma QName, 
but does not recognize the local part of the QName, might choose either to raise 
an error or to ignore the pragma.</P>
<P>It is a <A title="static error" 
href="REC-xquery-20070123.htm#dt-static-error">static 
error</A> [<A title=err:XQST0013 
href="REC-xquery-20070123.htm#ERRXQST0013">err:XQST0013</A>] 
if an implementation recognizes a pragma but determines that its content is 
invalid.</P>
<P>If an implementation recognizes a pragma, it must report any static errors in 
the following expression even if it will not evaluate that expression (however, 
static type errors are raised only if the <A title="static typing feature" 
href="REC-xquery-20070123.htm#dt-static-typing-feature">Static 
Typing Feature</A> is in effect.)</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>The following examples illustrate three ways in which extension expressions 
might be used.</P>
<UL>
  <LI>
  <P>A pragma can be used to furnish a hint for how to evaluate the following 
  expression, without actually changing the result. For example:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>declare namespace exq = "http://example.org/XQueryImplementation";
   (# exq:use-index #)
      { $bib/book/author[name='Berners-Lee'] }
</PRE></DIV></DIV>
  <P>An implementation that recognizes the <CODE>exq:use-index</CODE> pragma 
  might use an index to evaluate the expression that follows. An implementation 
  that does not recognize this pragma would evaluate the expression in its 
  normal way.</P>
  <LI>
  <P>A pragma might be used to modify the semantics of the following expression 
  in ways that would not (in the absence of the pragma) be conformant with this 
  specification. For example, a pragma might be used to permit comparison of 
  <CODE>xs:duration</CODE> values using implementation-defined semantics (this 
  would normally be an error). Such changes to the language semantics must be 
  scoped to the expression contained within the curly braces following the 
  pragma.</P>
  <LI>
  <P>A pragma might contain syntactic constructs that are evaluated in place of 
  the following expression. In this case, the following expression itself (if it 
  is present) provides a fallback for use by implementations that do not 
  recognize the pragma. For example:</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>declare namespace exq = "http://example.org/XQueryImplementation";
   for $x in
      (# exq:distinct //city by @country #)
      { //city[not(@country = preceding::city/@country)] }
   return f:show-city($x)
</PRE></DIV></DIV>
  <P>Here an implementation that recognizes the pragma will return the result of 
  evaluating the proprietary syntax <CODE>exq:distinct //city by 
  @country</CODE>, while an implementation that does not recognize the pragma 
  will instead return the result of the expression <CODE>//city[not(@country = 
  preceding::city/@country)]</CODE>. If no fallback expression is required, or 
  if none is feasible, then the expression between the curly braces may be 
  omitted, in which case implementations that do not recognize the pragma will 
  raise a <A title="static error" 
  href="REC-xquery-20070123.htm#dt-static-error">static 
  error</A>.</P></LI></UL></DIV></DIV></DIV></DIV>
<DIV class=xquery>
<DIV class=div1>
<DIV class=xquery>
<H2><A id=id-query-prolog name=id-query-prolog></A>4 Modules and 
Prologs</H2></DIV>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-Module 
    name=doc-xquery-Module></A>[1]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-Module">Module</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-VersionDecl">VersionDecl</A>? 
      (<A 
      href="REC-xquery-20070123.htm#doc-xquery-LibraryModule">LibraryModule</A> 
      | <A 
      href="REC-xquery-20070123.htm#doc-xquery-MainModule">MainModule</A>)</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-MainModule 
      name=doc-xquery-MainModule></A>[3]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-MainModule">MainModule</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-Prolog">Prolog</A> 
      <A 
      href="REC-xquery-20070123.htm#doc-xquery-QueryBody">QueryBody</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-LibraryModule 
      name=doc-xquery-LibraryModule></A>[4]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-LibraryModule">LibraryModule</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-ModuleDecl">ModuleDecl</A> 
      <A 
      href="REC-xquery-20070123.htm#doc-xquery-Prolog">Prolog</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-Prolog 
    name=doc-xquery-Prolog></A>[6]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-Prolog">Prolog</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>((<A 
      href="REC-xquery-20070123.htm#doc-xquery-DefaultNamespaceDecl">DefaultNamespaceDecl</A> 
      | <A 
      href="REC-xquery-20070123.htm#doc-xquery-Setter">Setter</A> 
      | <A 
      href="REC-xquery-20070123.htm#doc-xquery-NamespaceDecl">NamespaceDecl</A> 
      | <A 
      href="REC-xquery-20070123.htm#doc-xquery-Import">Import</A>) 
      <A 
      href="REC-xquery-20070123.htm#doc-xquery-Separator">Separator</A>)* 
      ((<A 
      href="REC-xquery-20070123.htm#doc-xquery-VarDecl">VarDecl</A> 
      | <A 
      href="REC-xquery-20070123.htm#doc-xquery-FunctionDecl">FunctionDecl</A> 
      | <A 
      href="REC-xquery-20070123.htm#doc-xquery-OptionDecl">OptionDecl</A>) 
      <A 
      href="REC-xquery-20070123.htm#doc-xquery-Separator">Separator</A>)*</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-Setter 
    name=doc-xquery-Setter></A>[7]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-Setter">Setter</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-BoundarySpaceDecl">BoundarySpaceDecl</A> 
      | <A 
      href="REC-xquery-20070123.htm#doc-xquery-DefaultCollationDecl">DefaultCollationDecl</A> 
      | <A 
      href="REC-xquery-20070123.htm#doc-xquery-BaseURIDecl">BaseURIDecl</A> 
      | <A 
      href="REC-xquery-20070123.htm#doc-xquery-ConstructionDecl">ConstructionDecl</A> 
      | <A 
      href="REC-xquery-20070123.htm#doc-xquery-OrderingModeDecl">OrderingModeDecl</A> 
      | <A 
      href="REC-xquery-20070123.htm#doc-xquery-EmptyOrderDecl">EmptyOrderDecl</A> 
      | <A 
      href="REC-xquery-20070123.htm#doc-xquery-CopyNamespacesDecl">CopyNamespacesDecl</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-Import 
    name=doc-xquery-Import></A>[8]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-Import">Import</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-SchemaImport">SchemaImport</A> 
      | <A 
      href="REC-xquery-20070123.htm#doc-xquery-ModuleImport">ModuleImport</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-Separator 
      name=doc-xquery-Separator></A>[9]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-Separator">Separator</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>";"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-QueryBody 
      name=doc-xquery-QueryBody></A>[30]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-QueryBody">QueryBody</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-Expr">Expr</A></CODE></TD></TR></TBODY></TABLE>
<P>A query can be assembled from one or more fragments called <B>modules</B>. 
[<A id=dt-module title=module name=dt-module>Definition</A>: A <B>module</B> is 
a fragment of XQuery code that conforms to the <A 
href="REC-xquery-20070123.htm#doc-xquery-Module">Module</A> 
grammar and can independently undergo the <A title="static analysis phase" 
href="REC-xquery-20070123.htm#dt-static-analysis">static 
analysis phase</A> described in <A 
href="REC-xquery-20070123.htm#id-expression-processing"><B>2.2.3 
Expression Processing</B></A>. Each module is either a <A title="main module" 
href="REC-xquery-20070123.htm#dt-main-module">main 
module</A> or a <A title="library module" 
href="REC-xquery-20070123.htm#dt-library-module">library 
module</A>.]</P>
<P>[<A id=dt-main-module title="main module" name=dt-main-module>Definition</A>: 
A <B>main module</B> consists of a <A title=Prolog 
href="REC-xquery-20070123.htm#dt-prolog">Prolog</A> 
followed by a <A title="query body" 
href="REC-xquery-20070123.htm#dt-queryBody">Query 
Body</A>.] A query has exactly one main module. In a main module, the <A 
title="query body" 
href="REC-xquery-20070123.htm#dt-queryBody">Query 
Body</A> can be evaluated, and its value is the result of the query.</P>
<P>[<A id=dt-library-module title="library module" 
name=dt-library-module>Definition</A>: A module that does not contain a <A 
title="query body" 
href="REC-xquery-20070123.htm#dt-queryBody">Query 
Body</A> is called a <B>library module</B>. A library module consists of a <A 
title="module declaration" 
href="REC-xquery-20070123.htm#dt-module-declaration">module 
declaration</A> followed by a <A title=Prolog 
href="REC-xquery-20070123.htm#dt-prolog">Prolog</A>.] A 
library module cannot be evaluated directly; instead, it provides function and 
variable declarations that can be imported into other modules.</P>
<P>The XQuery syntax does not allow a <A title=module 
href="REC-xquery-20070123.htm#dt-module">module</A> to 
contain both a <A title="module declaration" 
href="REC-xquery-20070123.htm#dt-module-declaration">module 
declaration</A> and a <A title="query body" 
href="REC-xquery-20070123.htm#dt-queryBody">Query 
Body</A>.</P>
<P>[<A id=dt-prolog title=Prolog name=dt-prolog>Definition</A>: A <B>Prolog</B> 
is a series of declarations and imports that define the processing environment 
for the <A title=module 
href="REC-xquery-20070123.htm#dt-module">module</A> that 
contains the Prolog.] Each declaration or import is followed by a semicolon. A 
Prolog is organized into two parts.</P>
<P>The first part of the Prolog consists of setters, imports, namespace 
declarations, and default namespace declarations. [<A id=dt-setter title=setter 
name=dt-setter>Definition</A>: <B>Setters</B> are declarations that set the 
value of some property that affects query processing, such as construction mode, 
ordering mode, or default collation.] Namespace declarations and default 
namespace declarations affect the interpretation of QNames within the query. 
Imports are used to import definitions from schemas and modules. [<A 
id=dt-target-namespace title="target namespace" 
name=dt-target-namespace>Definition</A>: Each imported schema or module is 
identified by its <B>target namespace</B>, which is the namespace of the objects 
(such as elements or functions) that are defined by the schema or module.]</P>
<P>The second part of the Prolog consists of declarations of variables, 
functions, and options. These declarations appear at the end of the Prolog 
because they may be affected by declarations and imports in the first part of 
the Prolog.</P>
<P>[<A id=dt-queryBody title="query body" name=dt-queryBody>Definition</A>: The 
<B>Query Body</B>, if present, consists of an expression that defines the result 
of the query.] Evaluation of expressions is described in <A 
href="REC-xquery-20070123.htm#id-expressions"><B>3 
Expressions</B></A>. A module can be evaluated only if it has a Query Body.</P>
<DIV class=div2>
<H3><A id=id-version-declaration name=id-version-declaration></A>4.1 Version 
Declaration</H3>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-VersionDecl 
      name=doc-xquery-VersionDecl></A>[2]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-VersionDecl">VersionDecl</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"xquery" "version" <A 
      href="REC-xquery-20070123.htm#doc-xquery-StringLiteral">StringLiteral</A> 
      ("encoding" <A 
      href="REC-xquery-20070123.htm#doc-xquery-StringLiteral">StringLiteral</A>)? 
      <A 
      href="REC-xquery-20070123.htm#doc-xquery-Separator">Separator</A></CODE></TD></TR></TBODY></TABLE>
<P>[<A id=dt-version-declaration title="version declaration" 
name=dt-version-declaration>Definition</A>: Any <A title=module 
href="REC-xquery-20070123.htm#dt-module">module</A> may 
contain a <B>version declaration</B>. If present, the version declaration occurs 
at the beginning of the <A title=module 
href="REC-xquery-20070123.htm#dt-module">module</A> and 
identifies the applicable XQuery syntax and semantics for the <A title=module 
href="REC-xquery-20070123.htm#dt-module">module</A>.] The 
version number "1.0" indicates a requirement that the <A title=module 
href="REC-xquery-20070123.htm#dt-module">module</A> must 
be processed by an implementation that supports XQuery Version 1.0. If the 
version declaration is not present, the version is presumed to be "1.0". An 
XQuery implementation must raise a <A title="static error" 
href="REC-xquery-20070123.htm#dt-static-error">static 
error</A> [<A title=err:XQST0031 
href="REC-xquery-20070123.htm#ERRXQST0031">err:XQST0031</A>] 
when processing a <A title=module 
href="REC-xquery-20070123.htm#dt-module">module</A> 
labeled with a version that the implementation does not support. It is the 
intent of the XQuery working group to give later versions of this specification 
numbers other than "1.0", but this intent does not indicate a commitment to 
produce any future versions of XQuery, nor if any are produced, to use any 
particular numbering scheme.</P>
<P>[<A id=dt-encoding-declaration title="encoding declaration" 
name=dt-encoding-declaration>Definition</A>: If present, a version declaration 
may optionally include an <B>encoding declaration</B>. The value of the string 
literal following the keyword <CODE>encoding</CODE> is an encoding name, and 
must conform to the definition of <CODE>EncName</CODE> specified in <A 
href="REC-xquery-20070123.htm#XML">[XML 1.0]</A>[<A 
title=err:XQST0087 
href="REC-xquery-20070123.htm#ERRXQST0087">err:XQST0087</A>]. 
The purpose of an encoding declaration is to allow the writer of a query to 
provide a string that indicates how the query is encoded, such as 
"<CODE>UTF-8</CODE>", "<CODE>UTF-16</CODE>", or "<CODE>US-ASCII</CODE>".] Since 
the encoding of a query may change as the query moves from one environment to 
another, there can be no guarantee that the encoding declaration is correct.</P>
<P>The handling of an encoding declaration is <A 
title="implementation dependent" 
href="REC-xquery-20070123.htm#dt-implementation-dependent">implementation-dependent</A>. 
If an implementation has <EM>a priori</EM> knowledge of the encoding of a query, 
it may use this knowledge and disregard the encoding declaration. The semantics 
of a query are not affected by the presence or absence of an encoding 
declaration.</P>
<P>If a version declaration is present, no <A 
href="REC-xquery-20070123.htm#doc-xquery-Comment">Comment</A> 
may occur before the end of the version declaration. If such a <A 
href="REC-xquery-20070123.htm#doc-xquery-Comment">Comment</A> 
is present, the result is <A title="implementation dependent" 
href="REC-xquery-20070123.htm#dt-implementation-dependent">implementation-dependent</A>.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>The effect of a Comment before the end of a version declaration is 
implementation-dependent because it may suppress query processing by interfering 
with detection of the encoding declaration.</P></DIV>
<P>The following examples illustrate version declarations:</P>
<DIV class=frag-prolog-parse-test>
<DIV class=exampleInner><PRE>xquery version "1.0";
</PRE></DIV></DIV>
<DIV class=frag-prolog-parse-test>
<DIV class=exampleInner><PRE>xquery version "1.0" encoding "utf-8";
</PRE></DIV></DIV></DIV>
<DIV class=div2>
<H3><A id=id-module-declaration name=id-module-declaration></A>4.2 Module 
Declaration</H3>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-ModuleDecl 
      name=doc-xquery-ModuleDecl></A>[5]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-ModuleDecl">ModuleDecl</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"module" "namespace" <A 
      href="REC-xquery-20070123.htm#prod-xquery-NCName">NCName</A> 
      "=" <A 
      href="REC-xquery-20070123.htm#doc-xquery-URILiteral">URILiteral</A> 
      <A 
      href="REC-xquery-20070123.htm#doc-xquery-Separator">Separator</A></CODE></TD></TR></TBODY></TABLE>
<P>[<A id=dt-module-declaration title="module declaration" 
name=dt-module-declaration>Definition</A>: A <B>module declaration</B> serves to 
identify a <A title=module 
href="REC-xquery-20070123.htm#dt-module">module</A> as a 
<A title="library module" 
href="REC-xquery-20070123.htm#dt-library-module">library 
module</A>. A module declaration begins with the keyword <CODE>module</CODE> and 
contains a namespace prefix and a <A 
href="REC-xquery-20070123.htm#doc-xquery-URILiteral">URILiteral</A>.] 
The URILiteral must be of nonzero length [<A title=err:XQST0088 
href="REC-xquery-20070123.htm#ERRXQST0088">err:XQST0088</A>]. 
The URILiteral identifies the <A title="target namespace" 
href="REC-xquery-20070123.htm#dt-target-namespace">target 
namespace</A> of the library module, which is the namespace for all variables 
and functions exported by the library module. The name of every variable and 
function declared in a library module must have a namespace URI that is the same 
as the target namespace of the module; otherwise a <A title="static error" 
href="REC-xquery-20070123.htm#dt-static-error">static 
error</A> is raised [<A title=err:XQST0048 
href="REC-xquery-20070123.htm#ERRXQST0048">err:XQST0048</A>]. 
In the <A title="statically known namespaces" 
href="REC-xquery-20070123.htm#dt-static-namespaces">statically 
known namespaces</A> of the library module, the namespace prefix specified in 
the module declaration is bound to the module's target namespace.</P>
<P>The namespace prefix specified in a module declaration must not be 
<CODE>xml</CODE> or <CODE>xmlns</CODE> [<A title=err:XQST0070 
href="REC-xquery-20070123.htm#ERRXQST0070">err:XQST0070</A>], 
and must not be the same as any namespace prefix bound in the same module by a 
<A title="schema import" 
href="REC-xquery-20070123.htm#dt-schema-import">schema 
import</A>, by a <A title="namespace declaration" 
href="REC-xquery-20070123.htm#dt-namespace-declaration">namespace 
declaration</A>, or by a <A title="module import" 
href="REC-xquery-20070123.htm#dt-module-import">module 
import</A> with a different target namespace [<A title=err:XQST0033 
href="REC-xquery-20070123.htm#ERRXQST0033">err:XQST0033</A>].</P>
<P>Any <A title=module 
href="REC-xquery-20070123.htm#dt-module">module</A> may 
import one or more library modules by means of a <A title="module import" 
href="REC-xquery-20070123.htm#dt-module-import">module 
import</A> that specifies the target namespace of the library modules to be 
imported. When a module imports one or more library modules, the variables and 
functions declared in the imported modules are added to the <A 
title="static context" 
href="REC-xquery-20070123.htm#dt-static-context">static 
context</A> and (where applicable) to the <A title="dynamic context" 
href="REC-xquery-20070123.htm#dt-dynamic-context">dynamic 
context</A> of the importing module.</P>
<P>The following is an example of a module declaration:</P>
<DIV class=frag-prolog-parse-test>
<DIV class=exampleInner><PRE>module namespace math = "http://example.org/math-functions";
</PRE></DIV></DIV></DIV>
<DIV class=div2>
<H3><A id=id-boundary-space-decls name=id-boundary-space-decls></A>4.3 
Boundary-space Declaration</H3>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-BoundarySpaceDecl 
      name=doc-xquery-BoundarySpaceDecl></A>[11]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-BoundarySpaceDecl">BoundarySpaceDecl</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"declare" "boundary-space" ("preserve" | 
  "strip")</CODE></TD></TR></TBODY></TABLE>
<P>[<A id=dt-boundary-space-decl title="boundary-space declaration" 
name=dt-boundary-space-decl>Definition</A>: A <B>boundary-space declaration</B> 
sets the <A title="boundary-space policy" 
href="REC-xquery-20070123.htm#dt-boundary-space-policy">boundary-space 
policy</A> in the <A title="static context" 
href="REC-xquery-20070123.htm#dt-static-context">static 
context</A>, overriding any implementation-defined default. Boundary-space 
policy controls whether <A title="boundary whitespace" 
href="REC-xquery-20070123.htm#dt-boundary-whitespace">boundary 
whitespace</A> is preserved by element constructors during processing of the 
query.] If boundary-space policy is <CODE>preserve</CODE>, boundary whitespace 
is preserved. If boundary-space policy is <CODE>strip</CODE>, boundary 
whitespace is stripped (deleted). A further discussion of whitespace in 
constructed elements can be found in <A 
href="REC-xquery-20070123.htm#id-whitespace"><B>3.7.1.4 
Boundary Whitespace</B></A>.</P>
<P>The following example illustrates a boundary-space declaration:</P>
<DIV class=frag-prolog-parse-test>
<DIV class=exampleInner><PRE>declare boundary-space preserve;
</PRE></DIV></DIV>
<P>If a Prolog contains more than one boundary-space declaration, a <A 
title="static error" 
href="REC-xquery-20070123.htm#dt-static-error">static 
error</A> is raised [<A title=err:XQST0068 
href="REC-xquery-20070123.htm#ERRXQST0068">err:XQST0068</A>].</P></DIV>
<DIV class=div2>
<H3><A id=id-default-collation-declaration 
name=id-default-collation-declaration></A>4.4 Default Collation Declaration</H3>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-DefaultCollationDecl 
      name=doc-xquery-DefaultCollationDecl></A>[19]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-DefaultCollationDecl">DefaultCollationDecl</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"declare" "default" "collation" <A 
      href="REC-xquery-20070123.htm#doc-xquery-URILiteral">URILiteral</A></CODE></TD></TR></TBODY></TABLE>
<P>[<A id=dt-default-collation-decl title="default collation declaration" 
name=dt-default-collation-decl>Definition</A>: A <B>default collation 
declaration</B> sets the value of the <A title="default collation" 
href="REC-xquery-20070123.htm#dt-def-collation">default 
collation</A> in the <A title="static context" 
href="REC-xquery-20070123.htm#dt-static-context">static 
context</A>, overriding any implementation-defined default.] The default 
collation is the collation that is used by functions and operators that require 
a collation if no other collation is specified. For example, the <CODE>gt</CODE> 
operator on strings is defined by a call to the <CODE>fn:compare</CODE> 
function, which takes an optional collation parameter. Since the <CODE>gt</CODE> 
operator does not specify a collation, the <CODE>fn:compare</CODE> function 
implements <CODE>gt</CODE> by using the default collation.</P>
<P>If neither the implementation nor the Prolog specifies a default collation, 
the Unicode codepoint collation 
(<CODE>http://www.w3.org/2005/xpath-functions/collation/codepoint</CODE>) is 
used.</P>
<P>The following example illustrates a default collation declaration:</P>
<DIV class=frag-prolog-parse-test>
<DIV class=exampleInner><PRE>declare default collation
         "http://example.org/languages/Icelandic";
</PRE></DIV></DIV>
<P>If a default collation declaration specifies a collation by a relative URI, 
that relative URI is resolved to an absolute URI using the <A title="base URI" 
href="REC-xquery-20070123.htm#dt-base-uri">base URI</A> 
in the <A title="static context" 
href="REC-xquery-20070123.htm#dt-static-context">static 
context</A>. If a Prolog contains more than one default collation declaration, 
or the value specified by a default collation declaration (after resolution of a 
relative URI, if necessary) is not present in <A 
title="statically known collations" 
href="REC-xquery-20070123.htm#dt-static-collations">statically 
known collations</A>, a <A title="static error" 
href="REC-xquery-20070123.htm#dt-static-error">static 
error</A> is raised [<A title=err:XQST0038 
href="REC-xquery-20070123.htm#ERRXQST0038">err:XQST0038</A>].</P></DIV>
<DIV class=div2>
<H3><A id=id-base-uri-decl name=id-base-uri-decl></A>4.5 Base URI 
Declaration</H3>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-BaseURIDecl 
      name=doc-xquery-BaseURIDecl></A>[20]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-BaseURIDecl">BaseURIDecl</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"declare" "base-uri" <A 
      href="REC-xquery-20070123.htm#doc-xquery-URILiteral">URILiteral</A></CODE></TD></TR></TBODY></TABLE>
<P>[<A id=dt-base-uri-decl title="base URI declaration" 
name=dt-base-uri-decl>Definition</A>: A <B>base URI declaration</B> specifies 
the <A title="base URI" 
href="REC-xquery-20070123.htm#dt-base-uri">base URI</A> 
property of the <A title="static context" 
href="REC-xquery-20070123.htm#dt-static-context">static 
context</A>. The <A title="base URI" 
href="REC-xquery-20070123.htm#dt-base-uri">base URI</A> 
property is used when resolving relative URIs within a <A title=module 
href="REC-xquery-20070123.htm#dt-module">module</A>.] For 
example, the <CODE>fn:doc</CODE> function resolves a relative URI using the base 
URI of the calling module.</P>
<P>The following is an example of a base URI declaration:</P>
<DIV class=frag-prolog-parse-test>
<DIV class=exampleInner><PRE>declare base-uri "http://example.org";
</PRE></DIV></DIV>
<P>If a Prolog contains more than one base URI declaration, a <A 
title="static error" 
href="REC-xquery-20070123.htm#dt-static-error">static 
error</A> is raised [<A title=err:XQST0032 
href="REC-xquery-20070123.htm#ERRXQST0032">err:XQST0032</A>].</P>
<P>In the terminology of <A 
href="REC-xquery-20070123.htm#RFC3986">[RFC3986]</A> 
Section 5.1, the URILiteral of the base URI declaration is considered to be a 
"base URI embedded in content". If no base URI declaration is present, the <A 
title="base URI" 
href="REC-xquery-20070123.htm#dt-base-uri">base URI</A> 
in the <A title="static context" 
href="REC-xquery-20070123.htm#dt-static-context">static 
context</A> is established according to the principles outlined in <A 
href="REC-xquery-20070123.htm#RFC3986">[RFC3986]</A> 
Section 5.1—that is, it defaults first to the base URI of the encapsulating 
entity, then to the URI used to retrieve the entity, and finally to an 
implementation-defined default. If the URILiteral in the base URI declaration is 
a relative URI, then it is made absolute by resolving it with respect to this 
same hierarchy. For example, if the URILiteral in the base URI declaration is 
<CODE>../data/</CODE>, and the query is contained in a file whose URI is 
<CODE>file:///C:/temp/queries/query.xq</CODE>, then the <A title="base URI" 
href="REC-xquery-20070123.htm#dt-base-uri">base URI</A> 
in the <A title="static context" 
href="REC-xquery-20070123.htm#dt-static-context">static 
context</A> is <CODE>file:///C:/temp/data/</CODE>.</P>
<P>It is not intrinsically an error if this process fails to establish an 
absolute base URI; however, the <A title="base URI" 
href="REC-xquery-20070123.htm#dt-base-uri">base URI</A> 
in the <A title="static context" 
href="REC-xquery-20070123.htm#dt-static-context">static 
context</A> is then undefined, and any attempt to use its value may result in an 
error [<A title=err:XPST0001 
href="REC-xquery-20070123.htm#ERRXPST0001">err:XPST0001</A>].</P></DIV>
<DIV class=div2>
<H3><A id=id-construction-declaration name=id-construction-declaration></A>4.6 
Construction Declaration</H3>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-ConstructionDecl 
      name=doc-xquery-ConstructionDecl></A>[25]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-ConstructionDecl">ConstructionDecl</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"declare" "construction" ("strip" | 
  "preserve")</CODE></TD></TR></TBODY></TABLE>
<P>[<A id=dt-construction-decl title="construction declaration" 
name=dt-construction-decl>Definition</A>: A <B>construction declaration</B> sets 
the <A title="construction mode" 
href="REC-xquery-20070123.htm#dt-construction-mode">construction 
mode</A> in the <A title="static context" 
href="REC-xquery-20070123.htm#dt-static-context">static 
context</A>, overriding any implementation-defined default.] The construction 
mode governs the behavior of element and document node constructors. If 
construction mode is <CODE>preserve</CODE>, the type of a constructed element 
node is <CODE>xs:anyType</CODE>, and all attribute and element nodes copied 
during node construction retain their original types. If construction mode is 
<CODE>strip</CODE>, the type of a constructed element node is 
<CODE>xs:untyped</CODE>; all element nodes copied during node construction 
receive the type <CODE>xs:untyped</CODE>, and all attribute nodes copied during 
node construction receive the type <CODE>xs:untypedAtomic</CODE>.</P>
<P>The following example illustrates a construction declaration:</P>
<DIV class=frag-prolog-parse-test>
<DIV class=exampleInner><PRE>declare construction strip;
</PRE></DIV></DIV>
<P>If a Prolog specifies more than one construction declaration, a <A 
title="static error" 
href="REC-xquery-20070123.htm#dt-static-error">static 
error</A> is raised [<A title=err:XQST0067 
href="REC-xquery-20070123.htm#ERRXQST0067">err:XQST0067</A>].</P></DIV>
<DIV class=div2>
<H3><A id=id-default-ordering-decl name=id-default-ordering-decl></A>4.7 
Ordering Mode Declaration</H3>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-OrderingModeDecl 
      name=doc-xquery-OrderingModeDecl></A>[14]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-OrderingModeDecl">OrderingModeDecl</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"declare" "ordering" ("ordered" | 
  "unordered")</CODE></TD></TR></TBODY></TABLE>
<P>[<A id=dt-ordering-mode-decl title="ordering mode declaration" 
name=dt-ordering-mode-decl>Definition</A>: An <B>ordering mode declaration</B> 
sets the <A title="ordering mode" 
href="REC-xquery-20070123.htm#dt-ordering-mode">ordering 
mode</A> in the <A title="static context" 
href="REC-xquery-20070123.htm#dt-static-context">static 
context</A>, overriding any implementation-defined default.] This ordering mode 
applies to all expressions in a <A title=module 
href="REC-xquery-20070123.htm#dt-module">module</A> 
(including both the <A title=Prolog 
href="REC-xquery-20070123.htm#dt-prolog">Prolog</A> and 
the <A title="query body" 
href="REC-xquery-20070123.htm#dt-queryBody">Query 
Body</A>, if any), unless overridden by an <CODE>ordered</CODE> or 
<CODE>unordered</CODE> expression.</P>
<P><A title="ordering mode" 
href="REC-xquery-20070123.htm#dt-ordering-mode">Ordering 
mode</A> affects the behavior of <A title="path expression" 
href="REC-xquery-20070123.htm#dt-path-expression">path 
expressions</A> that include a "<CODE>/</CODE>" or "<CODE>//</CODE>" operator or 
an <A title="axis step" 
href="REC-xquery-20070123.htm#dt-axis-step">axis 
step</A>; <CODE>union</CODE>, <CODE>intersect</CODE>, and <CODE>except</CODE> 
expressions; and FLWOR expressions that have no <CODE>order by</CODE> clause. If 
ordering mode is <CODE>ordered</CODE>, node sequences returned by path, 
<CODE>union</CODE>, <CODE>intersect</CODE>, and <CODE>except</CODE> expressions 
are in <A title="document order" 
href="REC-xquery-20070123.htm#dt-document-order">document 
order</A>; otherwise the order of these return sequences is <A 
title="implementation dependent" 
href="REC-xquery-20070123.htm#dt-implementation-dependent">implementation-dependent</A>. 
The effect of ordering mode on FLWOR expressions is described in <A 
href="REC-xquery-20070123.htm#id-flwor-expressions"><B>3.8 
FLWOR Expressions</B></A>.</P>
<P>The following example illustrates an ordering mode declaration:</P>
<DIV class=frag-prolog-parse-test>
<DIV class=exampleInner><PRE>declare ordering unordered;
</PRE></DIV></DIV>
<P>If a Prolog contains more than one ordering mode declaration, a <A 
title="static error" 
href="REC-xquery-20070123.htm#dt-static-error">static 
error</A> is raised [<A title=err:XQST0065 
href="REC-xquery-20070123.htm#ERRXQST0065">err:XQST0065</A>].</P></DIV>
<DIV class=div2>
<H3><A id=id-empty-order-decl name=id-empty-order-decl></A>4.8 Empty Order 
Declaration</H3>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-EmptyOrderDecl 
      name=doc-xquery-EmptyOrderDecl></A>[15]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-EmptyOrderDecl">EmptyOrderDecl</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"declare" "default" "order" "empty" ("greatest" | 
    "least")</CODE></TD></TR></TBODY></TABLE>
<P>[<A id=dt-empty-order-decl title="empty order declaration" 
name=dt-empty-order-decl>Definition</A>: An <B>empty order declaration</B> sets 
the <A title="default order for empty sequences" 
href="REC-xquery-20070123.htm#dt-default-empty-order">default 
order for empty sequences</A> in the <A title="static context" 
href="REC-xquery-20070123.htm#dt-static-context">static 
context,</A> overriding any implementation-defined default. This declaration 
controls the processing of empty sequences and <CODE>NaN</CODE> values as 
ordering keys in an <CODE>order by</CODE> clause in a FLWOR expression.] An 
individual <CODE>order by</CODE> clause may override the default order for empty 
sequences by specifying <CODE>empty greatest</CODE> or <CODE>empty 
least</CODE>.</P>
<P>The following example illustrates an empty order declaration:</P>
<DIV class=frag-prolog-parse-test>
<DIV class=exampleInner><PRE>declare default order empty least;
</PRE></DIV></DIV>
<P>If a Prolog contains more than one empty order declaration, a <A 
title="static error" 
href="REC-xquery-20070123.htm#dt-static-error">static 
error</A> is raised [<A title=err:XQST0069 
href="REC-xquery-20070123.htm#ERRXQST0069">err:XQST0069</A>].</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>It is important to distinguish an <A title="empty order declaration" 
href="REC-xquery-20070123.htm#dt-empty-order-decl">empty 
order declaration</A> from an <A title="ordering mode declaration" 
href="REC-xquery-20070123.htm#dt-ordering-mode-decl">ordering 
mode declaration</A>. An <A title="empty order declaration" 
href="REC-xquery-20070123.htm#dt-empty-order-decl">empty 
order declaration</A> applies only when an <CODE>order by</CODE> clause is 
present, and specifies how empty sequences are treated by the <CODE>order 
by</CODE> clause (unless overridden). An <A title="ordering mode declaration" 
href="REC-xquery-20070123.htm#dt-ordering-mode-decl">ordering 
mode declaration</A>, on the other hand, applies only in the absence of an 
<CODE>order by</CODE> clause.</P></DIV></DIV>
<DIV class=div2>
<H3><A id=id-copy-namespaces-decl name=id-copy-namespaces-decl></A>4.9 
Copy-Namespaces Declaration</H3>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-CopyNamespacesDecl 
      name=doc-xquery-CopyNamespacesDecl></A>[16]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-CopyNamespacesDecl">CopyNamespacesDecl</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"declare" "copy-namespaces" <A 
      href="REC-xquery-20070123.htm#doc-xquery-PreserveMode">PreserveMode</A> 
      "," <A 
      href="REC-xquery-20070123.htm#doc-xquery-InheritMode">InheritMode</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-PreserveMode 
      name=doc-xquery-PreserveMode></A>[17]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-PreserveMode">PreserveMode</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"preserve" | "no-preserve"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-InheritMode 
      name=doc-xquery-InheritMode></A>[18]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-InheritMode">InheritMode</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"inherit" | "no-inherit"</CODE></TD></TR></TBODY></TABLE>
<P>[<A id=dt-copy-namespaces-decl title="copy-namespaces declaration" 
name=dt-copy-namespaces-decl>Definition</A>: A <B>copy-namespaces 
declaration</B> sets the value of <A title="copy-namespaces mode" 
href="REC-xquery-20070123.htm#dt-copy-namespaces-mode">copy-namespaces 
mode</A> in the <A title="static context" 
href="REC-xquery-20070123.htm#dt-static-context">static 
context</A>, overriding any implementation-defined default. Copy-namespaces mode 
controls the namespace bindings that are assigned when an existing element node 
is copied by an element constructor or document constructor.] Handling of 
namespace bindings by element constructors is described in <A 
href="REC-xquery-20070123.htm#id-element-constructor"><B>3.7.1 
Direct Element Constructors</B></A>.</P>
<P>The following example illustrates a copy-namespaces declaration:</P>
<DIV class=frag-prolog-parse-test>
<DIV class=exampleInner><PRE>declare copy-namespaces preserve, no-inherit;
</PRE></DIV></DIV>
<P>If a Prolog contains more than one copy-namespaces declaration, a <A 
title="static error" 
href="REC-xquery-20070123.htm#dt-static-error">static 
error</A> is raised [<A title=err:XQST0055 
href="REC-xquery-20070123.htm#ERRXQST0055">err:XQST0055</A>].</P></DIV>
<DIV class=div2>
<H3><A id=id-schema-import name=id-schema-import></A>4.10 Schema Import</H3>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-SchemaImport 
      name=doc-xquery-SchemaImport></A>[21]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-SchemaImport">SchemaImport</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"import" "schema" <A 
      href="REC-xquery-20070123.htm#doc-xquery-SchemaPrefix">SchemaPrefix</A>? 
      <A 
      href="REC-xquery-20070123.htm#doc-xquery-URILiteral">URILiteral</A> 
      ("at" <A 
      href="REC-xquery-20070123.htm#doc-xquery-URILiteral">URILiteral</A> 
      ("," <A 
      href="REC-xquery-20070123.htm#doc-xquery-URILiteral">URILiteral</A>)*)?</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-SchemaPrefix 
      name=doc-xquery-SchemaPrefix></A>[22]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-SchemaPrefix">SchemaPrefix</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>("namespace" <A 
      href="REC-xquery-20070123.htm#prod-xquery-NCName">NCName</A> 
      "=") | ("default" "element" "namespace")</CODE></TD></TR></TBODY></TABLE>
<P>[<A id=dt-schema-import title="schema import" 
name=dt-schema-import>Definition</A>: A <B>schema import</B> imports the element 
declarations, attribute declarations, and type definitions from a schema into 
the <A title="in-scope schema definitions" 
href="REC-xquery-20070123.htm#dt-issd">in-scope schema 
definitions</A>.] The schema to be imported is identified by its <A 
title="target namespace" 
href="REC-xquery-20070123.htm#dt-target-namespace">target 
namespace</A>. The schema import may bind a namespace prefix to the target 
namespace of the imported schema, or may declare that target namespace to be the 
<A title="default element/type namespace" 
href="REC-xquery-20070123.htm#dt-def-elemtype-ns">default 
element/type namespace</A>. The schema import may also provide optional hints 
for locating the schema.</P>
<P>The namespace prefix specified in a schema import must not be 
<CODE>xml</CODE> or <CODE>xmlns</CODE> [<A title=err:XQST0070 
href="REC-xquery-20070123.htm#ERRXQST0070">err:XQST0070</A>], 
and must not be the same as any namespace prefix bound in the same module by 
another schema import, a <A title="module import" 
href="REC-xquery-20070123.htm#dt-module-import">module 
import</A>, a <A title="namespace declaration" 
href="REC-xquery-20070123.htm#dt-namespace-declaration">namespace 
declaration</A>, or a <A title="module import" 
href="REC-xquery-20070123.htm#dt-module-import">module 
declaration</A> [<A title=err:XQST0033 
href="REC-xquery-20070123.htm#ERRXQST0033">err:XQST0033</A>].</P>
<P>The first <A 
href="REC-xquery-20070123.htm#doc-xquery-URILiteral">URILiteral</A> 
in a schema import specifies the target namespace of the schema to be imported. 
The URILiterals that follow the <CODE>at</CODE> keyword are optional location 
hints, and can be interpreted or disregarded in an implementation-dependent way. 
Multiple location hints might be used to indicate more than one possible place 
to look for the schema or multiple physical resources to be assembled to form 
the schema.</P>
<P>A schema import that specifies a zero-length string as target namespace is 
considered to import a schema that has no target namespace. Such a schema import 
may not bind a namespace prefix [<A title=err:XQST0057 
href="REC-xquery-20070123.htm#ERRXQST0057">err:XQST0057</A>], 
but it may set the default element/type namespace to a zero-length string 
(representing "no namespace"), thus enabling the definitions in the imported 
namespace to be referenced. If the default element/type namespace is not set to 
"no namespace", there is no way to reference the definitions in an imported 
schema that has no target namespace.</P>
<P>It is a <A title="static error" 
href="REC-xquery-20070123.htm#dt-static-error">static 
error</A> [<A title=err:XQST0058 
href="REC-xquery-20070123.htm#ERRXQST0058">err:XQST0058</A>] 
if more than one schema import in the same <A title=Prolog 
href="REC-xquery-20070123.htm#dt-prolog">Prolog</A> 
specifies the same target namespace. It is a <A title="static error" 
href="REC-xquery-20070123.htm#dt-static-error">static 
error</A> [<A title=err:XQST0059 
href="REC-xquery-20070123.htm#ERRXQST0059">err:XQST0059</A>] 
if the implementation is not able to process a schema import by finding a valid 
schema with the specified target namespace. It is a <A title="static error" 
href="REC-xquery-20070123.htm#dt-static-error">static 
error</A> [<A title=err:XQST0035 
href="REC-xquery-20070123.htm#ERRXQST0035">err:XQST0035</A>] 
if multiple imported schemas, or multiple physical resources within one schema, 
contain definitions for the same name in the same symbol space (for example, two 
definitions for the same element name, even if the definitions are consistent). 
However, it is not an error to import the schema with target namespace 
<CODE>http://www.w3.org/2001/XMLSchema</CODE> (predeclared prefix 
<CODE>xs</CODE>), even though the built-in types defined in this schema are 
implicitly included in the <A title="in-scope schema type" 
href="REC-xquery-20070123.htm#dt-is-types">in-scope 
schema types.</A></P>
<P>It is a <A title="static error" 
href="REC-xquery-20070123.htm#dt-static-error">static 
error</A> [<A title=err:XQST0012 
href="REC-xquery-20070123.htm#ERRXQST0012">err:XQST0012</A>] 
if the set of definitions contained in all schemas imported by a Prolog do not 
satisfy the conditions for schema validity specified in Sections 3 and 5 of <A 
href="REC-xquery-20070123.htm#XMLSchema">[XML Schema]</A> 
Part 1--i.e., each definition must be valid, complete, and unique.</P>
<P>The following example imports a schema, specifying both its target namespace 
and its location, and binding the prefix <CODE>soap</CODE> to the target 
namespace:</P>
<DIV class=frag-prolog-parse-test>
<DIV class=exampleInner><PRE>import schema namespace soap="http://www.w3.org/2003/05/soap-envelope"
at "http://www.w3.org/2003/05/soap-envelope/";
</PRE></DIV></DIV>
<P>The following example imports a schema by specifying only its target 
namespace, and makes it the default element/type namespace:</P>
<DIV class=frag-prolog-parse-test>
<DIV class=exampleInner><PRE>import schema default element namespace "http://example.org/abc";
</PRE></DIV></DIV>
<P>The following example imports a schema that has no target namespace, 
providing a location hint, and sets the default element/type namespace to "no 
namespace" so that the definitions in the imported schema can be referenced:</P>
<DIV class=frag-prolog-parse-test>
<DIV class=exampleInner><PRE>import schema default element namespace "" 
at "http://example.org/xyz.xsd";
</PRE></DIV></DIV>
<P>The following example imports a schema that has no target namespace and sets 
the default element/type namespace to "no namespace". Since no location hint is 
provided, it is up to the implementation to find the schema to be imported.</P>
<DIV class=frag-prolog-parse-test>
<DIV class=exampleInner><PRE>import schema default element namespace "";
</PRE></DIV></DIV></DIV>
<DIV class=div2>
<H3><A id=id-module-import name=id-module-import></A>4.11 Module Import</H3>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-ModuleImport 
      name=doc-xquery-ModuleImport></A>[23]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-ModuleImport">ModuleImport</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"import" "module" ("namespace" <A 
      href="REC-xquery-20070123.htm#prod-xquery-NCName">NCName</A> 
      "=")? <A 
      href="REC-xquery-20070123.htm#doc-xquery-URILiteral">URILiteral</A> 
      ("at" <A 
      href="REC-xquery-20070123.htm#doc-xquery-URILiteral">URILiteral</A> 
      ("," <A 
      href="REC-xquery-20070123.htm#doc-xquery-URILiteral">URILiteral</A>)*)?</CODE></TD></TR></TBODY></TABLE>
<P>[<A id=dt-module-import title="module import" 
name=dt-module-import>Definition</A>: A <B>module import</B> imports the 
function declarations and variable declarations from one or more <A 
title="library module" 
href="REC-xquery-20070123.htm#dt-library-module">library 
modules</A> into the <A title="function signature" 
href="REC-xquery-20070123.htm#dt-function-signature">function 
signatures</A> and <A title="in-scope variables" 
href="REC-xquery-20070123.htm#dt-in-scope-variables">in-scope 
variables</A> of the importing <A title=module 
href="REC-xquery-20070123.htm#dt-module">module</A>.] 
Each module import names a <A title="target namespace" 
href="REC-xquery-20070123.htm#dt-target-namespace">target 
namespace</A> and imports an <A title="implementation defined" 
href="REC-xquery-20070123.htm#dt-implementation-defined">implementation-defined</A> 
set of modules that share this target namespace. The module import may bind a 
namespace prefix to the target namespace, and it may provide optional hints for 
locating the modules to be imported.</P>
<P>The namespace prefix specified in a module import must not be 
<CODE>xml</CODE> or <CODE>xmlns</CODE> [<A title=err:XQST0070 
href="REC-xquery-20070123.htm#ERRXQST0070">err:XQST0070</A>], 
and must not be the same as any namespace prefix bound in the same module by 
another module import, a <A title="schema import" 
href="REC-xquery-20070123.htm#dt-schema-import">schema 
import</A>, a <A title="namespace declaration" 
href="REC-xquery-20070123.htm#dt-namespace-declaration">namespace 
declaration</A>, or a <A title="module declaration" 
href="REC-xquery-20070123.htm#dt-module-declaration">module 
declaration</A> with a different target namespace [<A title=err:XQST0033 
href="REC-xquery-20070123.htm#ERRXQST0033">err:XQST0033</A>].</P>
<P>The first <A 
href="REC-xquery-20070123.htm#doc-xquery-URILiteral">URILiteral</A> 
in a module import must be of nonzero length [<A title=err:XQST0088 
href="REC-xquery-20070123.htm#ERRXQST0088">err:XQST0088</A>], 
and specifies the target namespace of the modules to be imported. The 
URILiterals that follow the <CODE>at</CODE> keyword are optional location hints, 
and can be interpreted or disregarded in an <A title="implementation defined" 
href="REC-xquery-20070123.htm#dt-implementation-defined">implementation-defined</A> 
way.</P>
<P>It is a <A title="static error" 
href="REC-xquery-20070123.htm#dt-static-error">static 
error</A> [<A title=err:XQST0047 
href="REC-xquery-20070123.htm#ERRXQST0047">err:XQST0047</A>] 
if more than one module import in a <A title=Prolog 
href="REC-xquery-20070123.htm#dt-prolog">Prolog</A> 
specifies the same target namespace. It is a <A title="static error" 
href="REC-xquery-20070123.htm#dt-static-error">static 
error</A> [<A title=err:XQST0059 
href="REC-xquery-20070123.htm#ERRXQST0059">err:XQST0059</A>] 
if the implementation is not able to process a module import by finding a valid 
module definition with the specified target namespace. It is a <A 
title="static error" 
href="REC-xquery-20070123.htm#dt-static-error">static 
error</A> if the <A title="expanded QName" 
href="REC-xquery-20070123.htm#dt-expanded-qname">expanded 
QName</A> and arity of a function declared in an imported module are 
respectively equal to the <A title="expanded QName" 
href="REC-xquery-20070123.htm#dt-expanded-qname">expanded 
QName</A> and arity of a function declared in the importing module or in another 
imported module (even if the declarations are consistent) [<A title=err:XQST0034 
href="REC-xquery-20070123.htm#ERRXQST0034">err:XQST0034</A>]. 
It is a <A title="static error" 
href="REC-xquery-20070123.htm#dt-static-error">static 
error</A> if the <A title="expanded QName" 
href="REC-xquery-20070123.htm#dt-expanded-qname">expanded 
QName</A> of a variable declared in an imported module is equal (as defined by 
the <CODE>eq</CODE> operator) to the <A title="expanded QName" 
href="REC-xquery-20070123.htm#dt-expanded-qname">expanded 
QName</A> of a variable declared in the importing module or in another imported 
module (even if the declarations are consistent) [<A title=err:XQST0049 
href="REC-xquery-20070123.htm#ERRXQST0049">err:XQST0049</A>].</P>
<P>Each <A title=module 
href="REC-xquery-20070123.htm#dt-module">module</A> has 
its own <A title="static context" 
href="REC-xquery-20070123.htm#dt-static-context">static 
context</A>. A <A title="module import" 
href="REC-xquery-20070123.htm#dt-module-import">module 
import</A> imports only functions and variable declarations; it does not import 
other objects from the imported modules, such as <A 
title="in-scope schema definitions" 
href="REC-xquery-20070123.htm#dt-issd">in-scope schema 
definitions</A> or <A title="statically known namespaces" 
href="REC-xquery-20070123.htm#dt-static-namespaces">statically 
known namespaces</A>. Module imports are not transitive—that is, importing a 
module provides access only to function and variable declarations contained 
directly in the imported module. For example, if module A imports module B, and 
module B imports module C, module A does not have access to the functions and 
variables declared in module C.</P>
<P>A module may import its own target namespace (this is interpreted as 
importing an <A title="implementation defined" 
href="REC-xquery-20070123.htm#dt-implementation-defined">implementation-defined</A> 
set of other modules that share its target namespace.) However, it is a <A 
title="static error" 
href="REC-xquery-20070123.htm#dt-static-error">static 
error</A> [<A title=err:XQST0073 
href="REC-xquery-20070123.htm#ERRXQST0073">err:XQST0073</A>] 
if the graph of module imports contains a cycle (that is, if there exists a 
sequence of modules M<SUB>1</SUB> ... M<SUB>n</SUB> such that each M<SUB>i</SUB> 
imports M<SUB>i+1</SUB> and M<SUB>n</SUB> imports M<SUB>1</SUB>), unless all the 
modules in the cycle share a common namespace.</P>
<P>It is a <A title="static error" 
href="REC-xquery-20070123.htm#dt-static-error">static 
error</A> [<A title=err:XQST0036 
href="REC-xquery-20070123.htm#ERRXQST0036">err:XQST0036</A>] 
to import a module if the importing module's <A title="in-scope schema type" 
href="REC-xquery-20070123.htm#dt-is-types">in-scope 
schema types</A> do not include definitions for the schema type names that 
appear in the declarations of variables and functions (whether in an argument 
type or return type) that are present in the imported module and are referenced 
in the importing module.</P>
<P>To illustrate the above rules, suppose that a certain schema defines a type 
named <CODE>triangle</CODE>. Suppose that a library module imports the schema, 
binds its target namespace to the prefix <CODE>geometry</CODE>, and declares a 
function with the following <A title="function signature" 
href="REC-xquery-20070123.htm#dt-function-signature">function 
signature</A>: <CODE>math:area($t as geometry:triangle) as xs:double</CODE>. If 
a query wishes to use this function, it must import <EM>both</EM> the library 
module and the schema on which it is based. Importing the library module alone 
would not provide access to the definition of the type 
<CODE>geometry:triangle</CODE> used in the signature of the <CODE>area</CODE> 
function.</P>
<P>[<A id=dt-module-directly-depends title="module directly depends" 
name=dt-module-directly-depends>Definition</A>: A module M<SUB>1</SUB> 
<B>directly depends</B> on another module M<SUB>2</SUB> (different from 
M<SUB>1</SUB>) if a variable or function declared in M<SUB>1</SUB> <A 
title="variable depends" 
href="REC-xquery-20070123.htm#dt-variable-depends">depends</A> 
on a variable or function declared in M<SUB>2</SUB>.] It is a <A 
title="static error" 
href="REC-xquery-20070123.htm#dt-static-error">static 
error</A> [<A title=err:XQST0093 
href="REC-xquery-20070123.htm#ERRXQST0093">err:XQST0093</A>] 
to import a module M<SUB>1</SUB> if there exists a sequence of modules 
M<SUB>1</SUB> ... M<SUB>i</SUB> ... M<SUB>1</SUB> such that each module <A 
title="module directly depends" 
href="REC-xquery-20070123.htm#dt-module-directly-depends">directly 
depends</A> on the next module in the sequence (informally, if M<SUB>1</SUB> 
depends on itself through some chain of module dependencies.)</P>
<P>The following example illustrates a module import:</P>
<DIV class=frag-prolog-parse-test>
<DIV class=exampleInner><PRE>import module namespace math = "http://example.org/math-functions";
</PRE></DIV></DIV></DIV>
<DIV class=div2>
<H3><A id=id-namespace-declaration name=id-namespace-declaration></A>4.12 
Namespace Declaration</H3>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-NamespaceDecl 
      name=doc-xquery-NamespaceDecl></A>[10]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-NamespaceDecl">NamespaceDecl</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"declare" "namespace" <A 
      href="REC-xquery-20070123.htm#prod-xquery-NCName">NCName</A> 
      "=" <A 
      href="REC-xquery-20070123.htm#doc-xquery-URILiteral">URILiteral</A></CODE></TD></TR></TBODY></TABLE>
<P>[<A id=dt-namespace-declaration title="namespace declaration" 
name=dt-namespace-declaration>Definition</A>: A <B>namespace declaration</B> 
declares a namespace prefix and associates it with a namespace URI, adding the 
(prefix, URI) pair to the set of <A title="statically known namespaces" 
href="REC-xquery-20070123.htm#dt-static-namespaces">statically 
known namespaces</A>.] The namespace declaration is in scope throughout the 
query in which it is declared, unless it is overridden by a <A 
title="namespace declaration attribute" 
href="REC-xquery-20070123.htm#dt-namespace-decl-attr">namespace 
declaration attribute</A> in a <A title="direct element constructor" 
href="REC-xquery-20070123.htm#dt-direct-elem-const">direct 
element constructor</A>.</P>
<P>If the URILiteral part of a namespace declaration is a zero-length string, 
any existing namespace binding for the given prefix is removed from the <A 
title="statically known namespaces" 
href="REC-xquery-20070123.htm#dt-static-namespaces">statically 
known namespaces</A>. This feature provides a way to remove predeclared 
namespace prefixes such as <CODE>local</CODE>.</P>
<P>The following query illustrates a namespace declaration:</P>
<DIV class=parse-test>
<DIV class=exampleInner><PRE>declare namespace foo = "http://example.org";
&lt;foo:bar&gt; Lentils &lt;/foo:bar&gt;
</PRE></DIV></DIV>
<P>In the query result, the newly created node is in the namespace associated 
with the namespace URI <CODE>http://example.org</CODE>.</P>
<P>The namespace prefix specified in a namespace declaration must not be 
<CODE>xml</CODE> or <CODE>xmlns</CODE> [<A title=err:XQST0070 
href="REC-xquery-20070123.htm#ERRXQST0070">err:XQST0070</A>], 
and must not be the same as any namespace prefix bound in the same module by a 
<A title="module import" 
href="REC-xquery-20070123.htm#dt-module-import">module 
import</A>, <A title="schema import" 
href="REC-xquery-20070123.htm#dt-schema-import">schema 
import</A>, <A title="module import" 
href="REC-xquery-20070123.htm#dt-module-import">module 
declaration</A>, or another namespace declaration [<A title=err:XQST0033 
href="REC-xquery-20070123.htm#ERRXQST0033">err:XQST0033</A>].</P>
<P>It is a <A title="static error" 
href="REC-xquery-20070123.htm#dt-static-error">static 
error</A> [<A title=err:XPST0081 
href="REC-xquery-20070123.htm#ERRXPST0081">err:XPST0081</A>] 
if an expression contains a QName with a namespace prefix that is not in the <A 
title="statically known namespaces" 
href="REC-xquery-20070123.htm#dt-static-namespaces">statically 
known namespaces</A>.</P>
<P>XQuery has several predeclared namespace prefixes that are present in the <A 
title="statically known namespaces" 
href="REC-xquery-20070123.htm#dt-static-namespaces">statically 
known namespaces</A> before each query is processed. These prefixes may be used 
without an explicit declaration. They may be overridden by <A 
title="namespace declaration" 
href="REC-xquery-20070123.htm#dt-namespace-declaration">namespace 
declarations</A> in a <A title=Prolog 
href="REC-xquery-20070123.htm#dt-prolog">Prolog</A> or by 
<A title="namespace declaration attribute" 
href="REC-xquery-20070123.htm#dt-namespace-decl-attr">namespace 
declaration attributes</A> on constructed elements (however, the prefix 
<CODE>xml</CODE> may not be redeclared, and no other prefix may be bound to the 
namespace URI associated with the prefix <CODE>xml</CODE> [<A title=err:XQST0070 
href="REC-xquery-20070123.htm#ERRXQST0070">err:XQST0070</A>]). 
The predeclared namespace prefixes are as follows:</P>
<UL>
  <LI>
  <P><CODE>xml = http://www.w3.org/XML/1998/namespace</CODE></P>
  <LI>
  <P><CODE>xs = http://www.w3.org/2001/XMLSchema</CODE></P>
  <LI>
  <P><CODE>xsi = http://www.w3.org/2001/XMLSchema-instance</CODE></P>
  <LI>
  <P><CODE>fn = http://www.w3.org/2005/xpath-functions</CODE></P>
  <LI>
  <P><CODE>local = http://www.w3.org/2005/xquery-local-functions</CODE> (see <A 
  href="REC-xquery-20070123.htm#FunctionDeclns"><B>4.15 
  Function Declaration</B></A>.)</P></LI></UL>
<P>Additional predeclared namespace prefixes may be added to the <A 
title="statically known namespaces" 
href="REC-xquery-20070123.htm#dt-static-namespaces">statically 
known namespaces</A> by an implementation.</P>
<P>When element or attribute names are compared, they are considered identical 
if the local parts and namespace URIs match on a codepoint basis. Namespace 
prefixes need not be identical for two names to match, as illustrated by the 
following example:</P>
<DIV class=parse-test>
<DIV class=exampleInner><PRE>declare namespace xx = "http://example.org";

let $i := &lt;foo:bar xmlns:foo = "http://example.org"&gt;
              &lt;foo:bing&gt; Lentils &lt;/foo:bing&gt;
          &lt;/foo:bar&gt;
return $i/xx:bing
</PRE></DIV></DIV>
<P>Although the namespace prefixes <CODE>xx</CODE> and <CODE>foo</CODE> differ, 
both are bound to the namespace URI <CODE>"http://example.org"</CODE>. Since 
<CODE>xx:bing</CODE> and <CODE>foo:bing</CODE> have the same local name and the 
same namespace URI, they match. The output of the above query is as follows.</P>
<DIV class=parse-test>
<DIV class=exampleInner><PRE>&lt;foo:bing xmlns:foo = "http://example.org"&gt; Lentils &lt;/foo:bing&gt;
</PRE></DIV></DIV></DIV>
<DIV class=div2>
<H3><A id=id-default-namespace name=id-default-namespace></A>4.13 Default 
Namespace Declaration</H3>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-DefaultNamespaceDecl 
      name=doc-xquery-DefaultNamespaceDecl></A>[12]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-DefaultNamespaceDecl">DefaultNamespaceDecl</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"declare" "default" ("element" | "function") "namespace" <A 
      href="REC-xquery-20070123.htm#doc-xquery-URILiteral">URILiteral</A></CODE></TD></TR></TBODY></TABLE>
<P><B>Default namespace declarations</B> can be used in a <A title=Prolog 
href="REC-xquery-20070123.htm#dt-prolog">Prolog</A> to 
facilitate the use of unprefixed QNames. The following kinds of default 
namespace declarations are supported:</P>
<UL>
  <LI>
  <P>A <B>default element/type namespace declaration</B> declares a namespace 
  URI that is associated with unprefixed names of elements and types. This 
  declaration is recorded as the <A title="default element/type namespace" 
  href="REC-xquery-20070123.htm#dt-def-elemtype-ns">default 
  element/type namespace</A> in the <A title="static context" 
  href="REC-xquery-20070123.htm#dt-static-context">static 
  context</A>. A <A title=Prolog 
  href="REC-xquery-20070123.htm#dt-prolog">Prolog</A> may 
  contain at most one default element/type namespace declaration [<A 
  title=err:XQST0066 
  href="REC-xquery-20070123.htm#ERRXQST0066">err:XQST0066</A>]. 
  If the <A 
  href="REC-xquery-20070123.htm#doc-xquery-URILiteral">URILiteral</A> 
  in a default element/type namespace declaration is a zero-length string, the 
  <A title="default element/type namespace" 
  href="REC-xquery-20070123.htm#dt-def-elemtype-ns">default 
  element/type namespace</A> is undeclared (set to "none"), and unprefixed names 
  of elements and types are considered to be in no namespace. The following 
  example illustrates the declaration of a default namespace for elements and 
  types:</P>
  <DIV class=frag-prolog-parse-test>
  <DIV class=exampleInner><PRE>declare default element namespace "http://example.org/names";
</PRE></DIV></DIV>
  <P>A default element/type namespace declaration may be overridden by a <A 
  title="namespace declaration attribute" 
  href="REC-xquery-20070123.htm#dt-namespace-decl-attr">namespace 
  declaration attribute</A> in a <A title="direct element constructor" 
  href="REC-xquery-20070123.htm#dt-direct-elem-const">direct 
  element constructor</A>.</P>
  <P>If no default element/type namespace declaration is present, unprefixed 
  element and type names are in no namespace (however, an implementation may 
  define a different default as specified in <A 
  href="REC-xquery-20070123.htm#id-xq-static-context-components"><B>C.1 
  Static Context Components</B></A>.)</P>
  <LI>
  <P>A <B>default function namespace declaration</B> declares a namespace URI 
  that is associated with unprefixed function names in function calls and 
  function declarations. This declaration is recorded as the <A 
  title="default function namespace" 
  href="REC-xquery-20070123.htm#dt-def-fn-ns">default 
  function namespace</A> in the <A title="static context" 
  href="REC-xquery-20070123.htm#dt-static-context">static 
  context</A>. A <A title=Prolog 
  href="REC-xquery-20070123.htm#dt-prolog">Prolog</A> may 
  contain at most one default function namespace declaration [<A 
  title=err:XQST0066 
  href="REC-xquery-20070123.htm#ERRXQST0066">err:XQST0066</A>]. 
  If the StringLiteral in a default function namespace declaration is a 
  zero-length string, the default function namespace is undeclared (set to 
  "none"). In that case, any functions that are associated with a namespace can 
  be called only by using an explicit namespace prefix.</P>
  <P>If no default function namespace declaration is present, the default 
  function namespace is the namespace of XPath/XQuery functions, 
  <CODE>http://www.w3.org/2005/xpath-functions</CODE> (however, an 
  implementation may define a different default as specified in <A 
  href="REC-xquery-20070123.htm#id-xq-static-context-components"><B>C.1 
  Static Context Components</B></A>.)</P>
  <P>The following example illustrates the declaration of a default function 
  namespace:</P>
  <DIV class=frag-prolog-parse-test>
  <DIV class=exampleInner><PRE>declare default function namespace 
     "http://example.org/math-functions";
</PRE></DIV></DIV>
  <P>The effect of declaring a default function namespace is that all functions 
  in the default function namespace, including implicitly-declared <A 
  title="constructor function" 
  href="REC-xquery-20070123.htm#dt-constructor-function">constructor 
  functions</A>, can be invoked without specifying a namespace prefix. When a 
  function call uses a function name with no prefix, the local name of the 
  function must match a function (including implicitly-declared <A 
  title="constructor function" 
  href="REC-xquery-20070123.htm#dt-constructor-function">constructor 
  functions</A>) in the default function namespace [<A title=err:XPST0017 
  href="REC-xquery-20070123.htm#ERRXPST0017">err:XPST0017</A>].</P>
  <DIV class=note>
  <P class=prefix><B>Note:</B></P>
  <P>Only <A title="constructor function" 
  href="REC-xquery-20070123.htm#dt-constructor-function">constructor 
  functions</A> can be in no namespace.</P></DIV></LI></UL>
<P>Unprefixed attribute names and variable names are in no namespace.</P></DIV>
<DIV class=div2>
<H3><A id=id-variable-declarations name=id-variable-declarations></A>4.14 
Variable Declaration</H3>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-VarDecl 
    name=doc-xquery-VarDecl></A>[24]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-VarDecl">VarDecl</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"declare" "variable" "$" <A 
      href="REC-xquery-20070123.htm#prod-xquery-QName">QName</A> 
      <A 
      href="REC-xquery-20070123.htm#doc-xquery-TypeDeclaration">TypeDeclaration</A>? 
      ((":=" <A 
      href="REC-xquery-20070123.htm#doc-xquery-ExprSingle">ExprSingle</A>) 
      | "external")</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=noid_N1543E.doc-xquery-VarName 
      name=noid_N1543E.doc-xquery-VarName></A>[88]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-VarName">VarName</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-QName">QName</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=noid_N15440.doc-xquery-TypeDeclaration 
      name=noid_N15440.doc-xquery-TypeDeclaration></A>[118]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-TypeDeclaration">TypeDeclaration</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"as" <A 
      href="REC-xquery-20070123.htm#doc-xquery-SequenceType">SequenceType</A></CODE></TD></TR></TBODY></TABLE>
<P>A <B>variable declaration</B> adds the <A title="static type" 
href="REC-xquery-20070123.htm#dt-static-type">static 
type</A> of a variable to the <A title="in-scope variables" 
href="REC-xquery-20070123.htm#dt-in-scope-variables">in-scope 
variables</A>, and may also add a value for the variable to the <A 
title="variable values" 
href="REC-xquery-20070123.htm#dt-variable-values">variable 
values</A>. If the <A title="expanded QName" 
href="REC-xquery-20070123.htm#dt-expanded-qname">expanded 
QName</A> of the variable is equal (as defined by the <CODE>eq</CODE> operator) 
to the name of another variable in <A title="in-scope variables" 
href="REC-xquery-20070123.htm#dt-in-scope-variables">in-scope 
variables</A>, a <A title="static error" 
href="REC-xquery-20070123.htm#dt-static-error">static 
error</A> is raised [<A title=err:XQST0049 
href="REC-xquery-20070123.htm#ERRXQST0049">err:XQST0049</A>].</P>
<P>If a variable declaration includes a type, that type is added to the <A 
title="static context" 
href="REC-xquery-20070123.htm#dt-static-context">static 
context</A> as the type of the variable. If a variable declaration includes an 
expression but not an explicit type, the type of the variable is inferred from 
static analysis of the expression and is added to the <A title="static context" 
href="REC-xquery-20070123.htm#dt-static-context">static 
context</A>. If a variable declaration includes both a type and an expression, 
the value returned by the expression must match the declared type according to 
the rules for <A title="SequenceType matching" 
href="REC-xquery-20070123.htm#dt-sequencetype-matching">SequenceType 
matching</A>; otherwise a <A title="type error" 
href="REC-xquery-20070123.htm#dt-type-error">type 
error</A> is raised [<A title=err:XPTY0004 
href="REC-xquery-20070123.htm#ERRXPTY0004">err:XPTY0004</A>].</P>
<P>[<A id=dt-initializing-expression title="initializing expression" 
name=dt-initializing-expression>Definition</A>: If a variable declaration 
includes an expression, the expression is called an <B>initializing 
expression</B>.] The initializing expression for a given variable must be 
evaluated before the evaluation of any expression that references the variable. 
The <A title="static context" 
href="REC-xquery-20070123.htm#dt-static-context">static 
context</A> for an initializing expression includes all functions that are 
declared or imported anywhere in the <A title=Prolog 
href="REC-xquery-20070123.htm#dt-prolog">Prolog</A>, but 
it includes only those variables and namespaces that are declared or imported 
earlier in the Prolog than the variable that is being initialized.</P>
<P>[<A id=dt-variable-depends title="variable depends" 
name=dt-variable-depends>Definition</A>: A variable <CODE>$x</CODE> 
<B>depends</B> on a variable <CODE>$y</CODE> or a function <CODE>f2</CODE> if a 
reference to <CODE>$y</CODE> or <CODE>f2</CODE> appears in the initializing 
expression of <CODE>$x</CODE>, or if there exists a variable <CODE>$z</CODE> or 
a function <CODE>f3</CODE> such that <CODE>$x</CODE> <A title="variable depends" 
href="REC-xquery-20070123.htm#dt-variable-depends">depends</A> 
on <CODE>$z</CODE> or <CODE>f3</CODE> and <CODE>$z</CODE> or <CODE>f3</CODE> <A 
title="function depends" 
href="REC-xquery-20070123.htm#dt-function-depends">depends</A> 
on <CODE>$y</CODE> or <CODE>f2</CODE>.]</P>
<P>[<A id=dt-function-depends title="function depends" 
name=dt-function-depends>Definition</A>: A function <CODE>f1</CODE> 
<B>depends</B> on a variable <CODE>$y</CODE> or a function <CODE>f2</CODE> if a 
reference to <CODE>$y</CODE> or <CODE>f2</CODE> appears in the body of 
<CODE>f1</CODE>, or if there exists a variable <CODE>$z</CODE> or a function 
<CODE>f3</CODE> such that <CODE>f1</CODE> <A title="function depends" 
href="REC-xquery-20070123.htm#dt-function-depends">depends</A> 
on <CODE>$z</CODE> or <CODE>f3</CODE> and <CODE>$z</CODE> or <CODE>f3</CODE> <A 
title="variable depends" 
href="REC-xquery-20070123.htm#dt-variable-depends">depends</A> 
on <CODE>$y</CODE> or <CODE>f2</CODE>.]</P>
<P>If a variable <A title="variable depends" 
href="REC-xquery-20070123.htm#dt-variable-depends">depends</A> 
on itself, a <A title="static error" 
href="REC-xquery-20070123.htm#dt-static-error">static 
error</A> is raised [<A title=err:XQST0054 
href="REC-xquery-20070123.htm#ERRXQST0054">err:XQST0054</A>].</P>
<P>If the variable declaration includes the keyword <CODE>external</CODE>, a 
value must be provided for the variable by the external environment before the 
query can be evaluated. If an external variable declaration also includes a 
declared type, the value provided by the external environment must match the 
declared type according to the rules for <A title="SequenceType matching" 
href="REC-xquery-20070123.htm#dt-sequencetype-matching">SequenceType 
matching</A> (see <A 
href="REC-xquery-20070123.htm#id-consistency-constraints"><B>2.2.5 
Consistency Constraints</B></A>). If an external variable declaration does not 
include a declared type, the type and a matching value must be provided by the 
external environment at evaluation time. The <A title="static type" 
href="REC-xquery-20070123.htm#dt-static-type">static 
type</A> of such a variable is considered to be <CODE>item()*</CODE>. Any 
reference to a variable that was declared <CODE>external</CODE>, but was not 
bound to a value by the external environment, raises a dynamic error [<A 
title=err:XPDY0002 
href="REC-xquery-20070123.htm#ERRXPDY0002">err:XPDY0002</A>].</P>
<P>All variable names declared in a <A title="library module" 
href="REC-xquery-20070123.htm#dt-library-module">library 
module</A> must (when expanded) be in the <A title="target namespace" 
href="REC-xquery-20070123.htm#dt-target-namespace">target 
namespace</A> of the library module [<A title=err:XQST0048 
href="REC-xquery-20070123.htm#ERRXQST0048">err:XQST0048</A>]. 
When a library module is imported, variables declared in the imported module are 
added to the <A title="in-scope variables" 
href="REC-xquery-20070123.htm#dt-in-scope-variables">in-scope 
variables</A> of the importing module.</P>
<P>Variable names that have no namespace prefix are in no namespace. Variable 
declarations that have no namespace prefix may appear only in a main module.</P>
<P>The term <B>variable declaration</B> always refers to a declaration of a 
variable in a <A title=Prolog 
href="REC-xquery-20070123.htm#dt-prolog">Prolog</A>. The 
binding of a variable to a value in a query expression, such as a FLWOR 
expression, is known as a <B>variable binding</B>, and does not make the 
variable visible to an importing module.</P>
<P>Here are some examples of variable declarations:</P>
<UL>
  <LI>
  <P>The following declaration specifies both the type and the value of a 
  variable. This declaration causes the type <CODE>xs:integer</CODE> to be 
  associated with variable <CODE>$x</CODE> in the <A title="static context" 
  href="REC-xquery-20070123.htm#dt-static-context">static 
  context</A>, and the value <CODE>7</CODE> to be associated with variable 
  <CODE>$x</CODE> in the <A title="dynamic context" 
  href="REC-xquery-20070123.htm#dt-dynamic-context">dynamic 
  context</A>.</P>
  <DIV class=frag-prolog-parse-test>
  <DIV class=exampleInner><PRE>declare variable $x as xs:integer := 7;
</PRE></DIV></DIV>
  <LI>
  <P>The following declaration specifies a value but not a type. The <A 
  title="static type" 
  href="REC-xquery-20070123.htm#dt-static-type">static 
  type</A> of the variable is inferred from the static type of its value. In 
  this case, the variable <CODE>$x</CODE> has a static type of 
  <CODE>xs:decimal</CODE>, inferred from its value which is 7.5.</P>
  <DIV class=frag-prolog-parse-test>
  <DIV class=exampleInner><PRE>declare variable $x := 7.5;
</PRE></DIV></DIV>
  <LI>
  <P>The following declaration specifies a type but not a value. The keyword 
  <CODE>external</CODE> indicates that the value of the variable will be 
  provided by the external environment. At evaluation time, if the variable 
  <CODE>$x</CODE> in the <A title="dynamic context" 
  href="REC-xquery-20070123.htm#dt-dynamic-context">dynamic 
  context</A> does not have a value of type <CODE>xs:integer</CODE>, a type 
  error is raised.</P>
  <DIV class=frag-prolog-parse-test>
  <DIV class=exampleInner><PRE>declare variable $x as xs:integer external;
</PRE></DIV></DIV>
  <LI>
  <P>The following declaration specifies neither a type nor a value. It simply 
  declares that the query depends on the existence of a variable named 
  <CODE>$x</CODE>, whose type and value will be provided by the external 
  environment. During query analysis, the type of <CODE>$x</CODE> is considered 
  to be <CODE>item()*</CODE>. During query evaluation, the <A 
  title="dynamic context" 
  href="REC-xquery-20070123.htm#dt-dynamic-context">dynamic 
  context</A> must include a type and a value for <CODE>$x</CODE>, and its value 
  must be compatible with its type.</P>
  <DIV class=frag-prolog-parse-test>
  <DIV class=exampleInner><PRE>declare variable $x external;
</PRE></DIV></DIV>
  <LI>
  <P>The following declaration, which might appear in a library module, declares 
  a variable whose name includes a namespace prefix:</P>
  <DIV class=frag-prolog-parse-test>
  <DIV class=exampleInner><PRE>declare variable $math:pi as xs:double := 3.14159E0;
</PRE></DIV></DIV></LI></UL></DIV>
<DIV class=div2>
<H3><A id=FunctionDeclns name=FunctionDeclns></A>4.15 Function Declaration</H3>
<P>In addition to the built-in functions described in <A 
href="REC-xquery-20070123.htm#FunctionsAndOperators">[XQuery 
1.0 and XPath 2.0 Functions and Operators]</A>, XQuery allows users to declare 
functions of their own. A function declaration specifies the name of the 
function, the names and datatypes of the parameters, and the datatype of the 
result. All datatypes are specified using the syntax described in <A 
href="REC-xquery-20070123.htm#id-types"><B>2.5 
Types</B></A>. A function declaration causes the declared function to be added 
to the <A title="function signature" 
href="REC-xquery-20070123.htm#dt-function-signature">function 
signatures</A> of the <A title=module 
href="REC-xquery-20070123.htm#dt-module">module</A> in 
which it appears.</P>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-FunctionDecl 
      name=doc-xquery-FunctionDecl></A>[26]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-FunctionDecl">FunctionDecl</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"declare" "function" <A 
      href="REC-xquery-20070123.htm#prod-xquery-QName">QName</A> 
      "(" <A 
      href="REC-xquery-20070123.htm#doc-xquery-ParamList">ParamList</A>? 
      ")" ("as" <A 
      href="REC-xquery-20070123.htm#doc-xquery-SequenceType">SequenceType</A>)? 
      (<A 
      href="REC-xquery-20070123.htm#doc-xquery-EnclosedExpr">EnclosedExpr</A> 
      | "external")</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-ParamList 
      name=doc-xquery-ParamList></A>[27]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-ParamList">ParamList</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-Param">Param</A> 
      ("," <A 
      href="REC-xquery-20070123.htm#doc-xquery-Param">Param</A>)*</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-Param 
    name=doc-xquery-Param></A>[28]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-Param">Param</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"$" <A 
      href="REC-xquery-20070123.htm#prod-xquery-QName">QName</A> 
      <A 
      href="REC-xquery-20070123.htm#doc-xquery-TypeDeclaration">TypeDeclaration</A>?</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=noid_N155D9.doc-xquery-TypeDeclaration 
      name=noid_N155D9.doc-xquery-TypeDeclaration></A>[118]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-TypeDeclaration">TypeDeclaration</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"as" <A 
      href="REC-xquery-20070123.htm#doc-xquery-SequenceType">SequenceType</A></CODE></TD></TR></TBODY></TABLE>
<P>A function declaration specifies whether a function is <A 
title="user-defined function" 
href="REC-xquery-20070123.htm#dt-udf">user-defined</A> or 
<A title="external function" 
href="REC-xquery-20070123.htm#dt-external-function">external</A>. 
[<A id=dt-udf title="user-defined function" name=dt-udf>Definition</A>: For a 
<B>user-defined function</B>, the function declaration includes an expression 
called the <B>function body</B> that defines how the result of the function is 
computed from its parameters.]. The <A title="static context" 
href="REC-xquery-20070123.htm#dt-static-context">static 
context</A> for a function body includes all functions that are declared or 
imported anywhere in the <A title=Prolog 
href="REC-xquery-20070123.htm#dt-prolog">Prolog</A>, but 
it includes only those variables and namespaces that are declared or imported 
earlier in the Prolog than the function that is being defined.</P>
<P>[<A id=dt-external-function title="external function" 
name=dt-external-function>Definition</A>: <B>External functions</B> are 
functions that are implemented outside the query environment.] For example, an 
XQuery implementation might provide a set of external functions in addition to 
the core function library described in <A 
href="REC-xquery-20070123.htm#FunctionsAndOperators">[XQuery 
1.0 and XPath 2.0 Functions and Operators]</A>. External functions are 
identified by the keyword <CODE>external</CODE>. The purpose of a function 
declaration for an external function is to declare the datatypes of the function 
parameters and result, for use in type checking of the query that contains or 
imports the function declaration.</P>
<P>An XQuery implementation may provide a facility whereby external functions 
can be implemented using a host programming language, but it is not required to 
do so. If such a facility is provided, the protocols by which parameters are 
passed to an external function, and the result of the function is returned to 
the invoking query, are <A title="implementation defined" 
href="REC-xquery-20070123.htm#dt-implementation-defined">implementation-defined</A>. 
An XQuery implementation may augment the type system of <A 
href="REC-xquery-20070123.htm#datamodel">[XQuery/XPath 
Data Model (XDM)]</A> with additional types that are designed to facilitate 
exchange of data with host programming languages, or it may provide mechanisms 
for the user to define such types. For example, a type might be provided that 
encapsulates an object returned by an external function, such as an SQL database 
connection. These additional types, if defined, are considered to be derived by 
restriction from <CODE>xs:anyAtomicType</CODE>.</P>
<P>Every user-defined function must be in a namespace--that is, every declared 
function name must (when expanded) have a non-null namespace URI [<A 
title=err:XQST0060 
href="REC-xquery-20070123.htm#ERRXQST0060">err:XQST0060</A>]. 
If the function name in a function declaration has no namespace prefix, it is 
considered to be in the <A title="default function namespace" 
href="REC-xquery-20070123.htm#dt-def-fn-ns">default 
function namespace</A>. Every function name declared in a <A 
title="library module" 
href="REC-xquery-20070123.htm#dt-library-module">library 
module</A> must (when expanded) be in the <A title="target namespace" 
href="REC-xquery-20070123.htm#dt-target-namespace">target 
namespace</A> of the library module [<A title=err:XQST0048 
href="REC-xquery-20070123.htm#ERRXQST0048">err:XQST0048</A>]. 
It is a <A title="static error" 
href="REC-xquery-20070123.htm#dt-static-error">static 
error</A> [<A title=err:XQST0045 
href="REC-xquery-20070123.htm#ERRXQST0045">err:XQST0045</A>] 
if the function name in a function declaration (when expanded) is in any of the 
following namespaces:</P>
<UL>
  <LI>
  <P><CODE>http://www.w3.org/XML/1998/namespace</CODE></P>
  <LI>
  <P><CODE>http://www.w3.org/2001/XMLSchema</CODE></P>
  <LI>
  <P><CODE>http://www.w3.org/2001/XMLSchema-instance</CODE></P>
  <LI>
  <P><CODE>http://www.w3.org/2005/xpath-functions</CODE></P></LI></UL>
<P>It is a <A title="static error" 
href="REC-xquery-20070123.htm#dt-static-error">static 
error</A> [<A title=err:XQST0034 
href="REC-xquery-20070123.htm#ERRXQST0034">err:XQST0034</A>] 
if the <A title="expanded QName" 
href="REC-xquery-20070123.htm#dt-expanded-qname">expanded 
QName</A> and arity (number of arguments) of the declared function are equal (as 
defined by the <CODE>eq</CODE> operator) to the <A title="expanded QName" 
href="REC-xquery-20070123.htm#dt-expanded-qname">expanded 
QName</A> and arity of another function in <A title="function signature" 
href="REC-xquery-20070123.htm#dt-function-signature">function 
signatures</A>.</P>
<P>In order to allow main modules to declare functions for local use within the 
module without defining a new namespace, XQuery predefines the namespace prefix 
<CODE>local</CODE> to the namespace 
<CODE>http://www.w3.org/2005/xquery-local-functions</CODE>. It is suggested (but 
not required) that this namespace be used for defining local functions.</P>
<P>If a function parameter is declared using a name but no type, its default 
type is <CODE>item()*</CODE>. If the result type is omitted from a function 
declaration, its default result type is <CODE>item()*</CODE>.</P>
<P>The parameters of a function declaration are considered to be variables whose 
scope is the function body. It is an <A title="static error" 
href="REC-xquery-20070123.htm#dt-static-error">static 
error</A> [<A title=err:XQST0039 
href="REC-xquery-20070123.htm#ERRXQST0039">err:XQST0039</A>] 
for a function declaration to have more than one parameter with the same name. 
The type of a function parameter can be any type that can be expressed as a <A 
title="sequence type" 
href="REC-xquery-20070123.htm#dt-sequence-type">sequence 
type</A>.</P>
<P>The following example illustrates the declaration and use of a local function 
that accepts a sequence of <CODE>employee</CODE> elements, summarizes them by 
department, and returns a sequence of <CODE>dept</CODE> elements.</P>
<UL>
  <LI>
  <P>Using a function, prepare a summary of employees that are located in 
  Denver.</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>declare function local:summary($emps as element(employee)*) 
   as element(dept)*
{
   for $d in fn:distinct-values($emps/deptno)
   let $e := $emps[deptno = $d]
   return
      &lt;dept&gt;
         &lt;deptno&gt;{$d}&lt;/deptno&gt;
         &lt;headcount&gt; {fn:count($e)} &lt;/headcount&gt;
         &lt;payroll&gt; {fn:sum($e/salary)} &lt;/payroll&gt;
      &lt;/dept&gt;
};

local:summary(fn:doc("acme_corp.xml")//employee[location = "Denver"])
</PRE></DIV></DIV></LI></UL>
<P>Rules for converting function arguments to their declared parameter types, 
and for converting the result of a function to its declared result type, are 
described in <A 
href="REC-xquery-20070123.htm#id-function-calls"><B>3.1.5 
Function Calls</B></A>.</P>
<P>A function declaration may be recursive—that is, it may reference itself. 
Mutually recursive functions, whose bodies reference each other, are also 
allowed. The following example declares a recursive function that computes the 
maximum depth of a node hierarchy, and calls the function to find the maximum 
depth of a particular document. In its declaration, the user-declared function 
<CODE>local:depth</CODE> calls the built-in functions <CODE>empty</CODE> and 
<CODE>max</CODE>, which are in the default function namespace.</P>
<UL>
  <LI>
  <P>Find the maximum depth of the document named <CODE>partlist.xml</CODE>.</P>
  <DIV class=parse-test>
  <DIV class=exampleInner><PRE>declare function local:depth($e as node()) as xs:integer
{
   (: A node with no children has depth 1 :)
   (: Otherwise, add 1 to max depth of children :)
   if (fn:empty($e/*)) then 1
   else fn:max(for $c in $e/* return local:depth($c)) + 1
};

local:depth(fn:doc("partlist.xml"))
</PRE></DIV></DIV></LI></UL>
<P>Since a <A title="constructor function" 
href="REC-xquery-20070123.htm#dt-constructor-function">constructor 
function</A> is effectively declared for every user-defined atomic type in the 
<A title="in-scope schema type" 
href="REC-xquery-20070123.htm#dt-is-types">in-scope 
schema types</A>, a <A title="static error" 
href="REC-xquery-20070123.htm#dt-static-error">static 
error</A> [<A title=err:XQST0034 
href="REC-xquery-20070123.htm#ERRXQST0034">err:XQST0034</A>] 
is raised if the Prolog attempts to declare a single-parameter function with the 
same <A title="expanded QName" 
href="REC-xquery-20070123.htm#dt-expanded-qname">expanded 
QName</A> as any of these types.</P></DIV>
<DIV class=div2>
<H3><A id=id-option-declaration name=id-option-declaration></A>4.16 Option 
Declaration</H3>
<P>[<A id=dt-option-declaration title="option declaration" 
name=dt-option-declaration>Definition</A>: An <B>option declaration</B> declares 
an option that affects the behavior of a particular implementation. Each option 
consists of an identifying QName and a StringLiteral.]</P>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=doc-xquery-OptionDecl 
      name=doc-xquery-OptionDecl></A>[13]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A class=xquery 
      href="REC-xquery-20070123.htm#prod-xquery-OptionDecl">OptionDecl</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"declare" "option" <A 
      href="REC-xquery-20070123.htm#prod-xquery-QName">QName</A> 
      <A 
      href="REC-xquery-20070123.htm#doc-xquery-StringLiteral">StringLiteral</A></CODE></TD></TR></TBODY></TABLE>
<P>Typically, a particular option will be recognized by some implementations and 
not by others. The syntax is designed so that option declarations can be 
successfully parsed by all implementations.</P>
<P>The QName of an option must resolve to a namespace URI and local name, using 
the <A title="statically known namespaces" 
href="REC-xquery-20070123.htm#dt-static-namespaces">statically 
known namespaces</A> [<A title=err:XPST0081 
href="REC-xquery-20070123.htm#ERRXPST0081">err:XPST0081</A>].</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>There is no default namespace for options.</P></DIV>
<P>Each implementation recognizes an <A title="implementation defined" 
href="REC-xquery-20070123.htm#dt-implementation-defined">implementation-defined</A> 
set of namespace URIs used to denote option declarations.</P>
<P>If the namespace part of the QName is not a namespace recognized by the 
implementation as one used to denote option declarations, then the option 
declaration is ignored.</P>
<P>Otherwise, the effect of the option declaration, including its error 
behavior, is <A title="implementation defined" 
href="REC-xquery-20070123.htm#dt-implementation-defined">implementation-defined</A>. 
For example, if the local part of the QName is not recognized, or if the 
StringLiteral does not conform to the rules defined by the implementation for 
the particular option declaration, the implementation may choose whether to 
report an error, ignore the option declaration, or take some other action.</P>
<P>Implementations may impose rules on where particular option declarations may 
appear relative to variable declarations and function declarations, and the 
interpretation of an option declaration may depend on its position.</P>
<P>An option declaration must not be used to change the syntax accepted by the 
processor, or to suppress the detection of static errors. However, it may be 
used without restriction to modify the semantics of the query. The scope of the 
option declaration is <A title="implementation defined" 
href="REC-xquery-20070123.htm#dt-implementation-defined">implementation-defined</A>—for 
example, an option declaration might apply to the whole query, to the current 
module, or to the immediately following function declaration.</P>
<P>The following examples illustrate several possible uses for option 
declarations:</P>
<UL>
  <LI>
  <P>This option declaration might be used to set a serialization parameter:</P>
  <DIV class=frag-prolog-parse-test>
  <DIV class=exampleInner><PRE>declare namespace exq = "http://example.org/XQueryImplementation";
declare option exq:output "encoding = iso-8859-1";
</PRE></DIV></DIV>
  <LI>
  <P>This option declaration might be used to specify how comments in source 
  documents returned by the <CODE>fn:doc()</CODE> function should be 
handled:</P>
  <DIV class=frag-prolog-parse-test>
  <DIV class=exampleInner><PRE>declare option exq:strip-comments "true";
</PRE></DIV></DIV>
  <LI>
  <P>This option declaration might be used to associate a namespace used in 
  function names with a Java class:</P>
  <DIV class=frag-prolog-parse-test>
  <DIV class=exampleInner><PRE>declare namespace math = "http://example.org/MathLibrary";
declare option exq:java-class "math = java.lang.Math";
</PRE></DIV></DIV></LI></UL></DIV></DIV></DIV>
<DIV class=xquery>
<DIV class=div1>
<H2><A id=id-xquery-conformance name=id-xquery-conformance></A>5 
Conformance</H2>
<P>This section defines the conformance criteria for an XQuery processor. In 
this section, the following terms are used to indicate the requirement levels 
defined in <A href="REC-xquery-20070123.htm#RFC2119">[RFC 
2119]</A>. [<A id=must title=must name=must>Definition</A>: <B>MUST</B> means 
that the item is an absolute requirement of the specification.] [<A id=may 
title=may name=may>Definition</A>: <B>MAY</B> means that an item is truly 
optional.] [<A id=should title=should name=should>Definition</A>: <B>SHOULD</B> 
means that there may exist valid reasons in particular circumstances to ignore a 
particular item, but the full implications must be understood and carefully 
weighed before choosing a different course.]</P>
<P>An XQuery processor that claims to conform to this specification <A 
title=must href="REC-xquery-20070123.htm#must">MUST</A> 
include a claim of Minimal Conformance as defined in <A 
href="REC-xquery-20070123.htm#id-minimal-conformance"><B>5.1 
Minimal Conformance</B></A>. In addition to a claim of Minimal Conformance, it 
<A title=may href="REC-xquery-20070123.htm#may">MAY</A> 
claim conformance to one or more optional features defined in <A 
href="REC-xquery-20070123.htm#id-conform-optional-features"><B>5.2 
Optional Features</B></A>.</P>
<DIV class=div2>
<H3><A id=id-minimal-conformance name=id-minimal-conformance></A>5.1 Minimal 
Conformance</H3>
<P>Minimal Conformance to this specification <A title=must 
href="REC-xquery-20070123.htm#must">MUST</A> include all 
of the following items:</P>
<OL class=enumar>
  <LI>
  <P>Support for everything specified in this document except those features 
  specified in <A 
  href="REC-xquery-20070123.htm#id-conform-optional-features"><B>5.2 
  Optional Features</B></A> to be optional. If an implementation does not 
  provide a given optional feature, it <A title=must 
  href="REC-xquery-20070123.htm#must">MUST</A> implement 
  any requirements specified in <A 
  href="REC-xquery-20070123.htm#id-conform-optional-features"><B>5.2 
  Optional Features</B></A> for implementations that do not provide that 
  feature.</P>
  <LI>
  <P>A definition of every item specified to be <A 
  title="implementation defined" 
  href="REC-xquery-20070123.htm#dt-implementation-defined">implementation-defined</A>, 
  unless that item is part of an optional feature that is not supported by the 
  implementation. A list of <A title="implementation defined" 
  href="REC-xquery-20070123.htm#dt-implementation-defined">implementation-defined</A> 
  items can be found in <A 
  href="REC-xquery-20070123.htm#id-impl-defined-items"><B>D 
  Implementation-Defined Items</B></A>.</P>
  <DIV class=note>
  <P class=prefix><B>Note:</B></P>
  <P>Implementations are not required to define items specified to be <A 
  title="implementation dependent" 
  href="REC-xquery-20070123.htm#dt-implementation-dependent">implementation-dependent</A>.</P></DIV>
  <LI>
  <P>Support for <A 
  href="REC-xquery-20070123.htm#datamodel">[XQuery/XPath 
  Data Model (XDM)]</A>, as specified in <A 
  href="REC-xquery-20070123.htm#id-data-model-conformance"><B>5.3 
  Data Model Conformance</B></A>.</P>
  <LI>
  <P>Support for all functions defined in <A 
  href="REC-xquery-20070123.htm#FunctionsAndOperators">[XQuery 
  1.0 and XPath 2.0 Functions and Operators]</A>.</P></LI></OL></DIV>
<DIV class=div2>
<H3><A id=id-conform-optional-features name=id-conform-optional-features></A>5.2 
Optional Features</H3>
<DIV class=div3>
<H4><A id=id-schema-import-feature name=id-schema-import-feature></A>5.2.1 
Schema Import Feature</H4>
<P>[<A id=dt-schema-import-feature title="schema import feature" 
name=dt-schema-import-feature>Definition</A>: The <B>Schema Import Feature</B> 
permits the query Prolog to contain a <A title="schema import" 
href="REC-xquery-20070123.htm#dt-schema-import">schema 
import</A>.]</P>
<P>If an XQuery implementation does not support the Schema Import Feature, it <A 
title=must href="REC-xquery-20070123.htm#must">MUST</A> 
raise a static error [<A title=err:XQST0009 
href="REC-xquery-20070123.htm#ERRXQST0009">err:XQST0009</A>] 
if it encounters a schema import.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>If an implementation does not support the Schema Import Feature, the <A 
title="in-scope schema type" 
href="REC-xquery-20070123.htm#dt-is-types">in-scope 
schema types</A> consist only of built-in and <A title="implementation defined" 
href="REC-xquery-20070123.htm#dt-implementation-defined">implementation-defined</A> 
schema type definitions, as described in <A 
href="REC-xquery-20070123.htm#id-xq-static-context-components"><B>C.1 
Static Context Components</B></A>.</P></DIV></DIV>
<DIV class=div3>
<H4><A id=id-schema-validation-feature 
name=id-schema-validation-feature></A>5.2.2 Schema Validation Feature</H4>
<P>[<A id=dt-schema-validation-feature title="schema validation feature" 
name=dt-schema-validation-feature>Definition</A>: The <B>Schema Validation 
Feature</B> permits a query to contain a <CODE>validate</CODE> expression (see 
<A href="REC-xquery-20070123.htm#id-validate"><B>3.13 
Validate Expressions</B></A>.)]</P>
<P>If an XQuery implementation does not support the Schema Validation Feature, 
it <A title=must 
href="REC-xquery-20070123.htm#must">MUST</A> raise a 
static error [<A title=err:XQST0075 
href="REC-xquery-20070123.htm#ERRXQST0075">err:XQST0075</A>] 
if it encounters a <CODE>validate</CODE> expression.</P></DIV>
<DIV class=div3>
<H4><A id=id-static-typing-feature name=id-static-typing-feature></A>5.2.3 
Static Typing Feature</H4>
<P>[<A id=dt-static-typing-feature title="static typing feature" 
name=dt-static-typing-feature>Definition</A>: The <B>Static Typing Feature</B> 
provides support for the static semantics defined in <A 
href="REC-xquery-20070123.htm#XQueryFormalSemantics">[XQuery 
1.0 and XPath 2.0 Formal Semantics]</A>, and requires implementations to detect 
and report <A title="type error" 
href="REC-xquery-20070123.htm#dt-type-error">type 
errors</A> during the <A title="static analysis phase" 
href="REC-xquery-20070123.htm#dt-static-analysis">static 
analysis phase</A>.]</P>
<P>If an implementation does not support the <A title="static typing feature" 
href="REC-xquery-20070123.htm#dt-static-typing-feature">Static 
Typing Feature</A>, but can nevertheless determine during the static analysis 
phase that an expression, if evaluated, will necessarily raise a type error at 
run time, the implementation <A title=may 
href="REC-xquery-20070123.htm#may">MAY</A> raise that 
error during the static analysis phase. The choice of whether to raise such an 
error at analysis time is <A title="implementation dependent" 
href="REC-xquery-20070123.htm#dt-implementation-dependent">implementation 
dependent</A>.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>An implementation that does not support the <A title="static typing feature" 
href="REC-xquery-20070123.htm#dt-static-typing-feature">Static 
Typing Feature</A> is not required to raise type errors during the static 
analysis phase; however, it <A title=must 
href="REC-xquery-20070123.htm#must">MUST</A> detect and 
raise non-type-related static errors during the static analysis phase.</P></DIV>
<DIV class=xquery>
<DIV class=div4>
<H5><A id=id-static-extensions name=id-static-extensions></A>5.2.3.1 Static 
Typing Extensions</H5>
<P>In some cases, the static typing rules defined in <A 
href="REC-xquery-20070123.htm#XQueryFormalSemantics">[XQuery 
1.0 and XPath 2.0 Formal Semantics]</A> are not very precise (see, for example, 
the type inference rules for the ancestor axes—parent, ancestor, and 
ancestor-or-self—and for the function <CODE>fn:root</CODE>). Some 
implementations may wish to support more precise static typing rules.</P>
<P>A conforming implementation that implements the <A 
title="static typing feature" 
href="REC-xquery-20070123.htm#dt-static-typing-feature">Static 
Typing Feature</A> <A title=may 
href="REC-xquery-20070123.htm#may">MAY</A> also provide 
one or more <B>static typing extensions</B>. [<A id=dt-static-typing-extension 
title="static typing extension" name=dt-static-typing-extension>Definition</A>: 
A <B>static typing extension</B> is an <A title="implementation defined" 
href="REC-xquery-20070123.htm#dt-implementation-defined">implementation-defined</A> 
type inference rule that infers a more precise static type than that inferred by 
the type inference rules in <A 
href="REC-xquery-20070123.htm#XQueryFormalSemantics">[XQuery 
1.0 and XPath 2.0 Formal Semantics]</A>.] See <A 
href="http://www.w3.org/TR/xquery-semantics/#id-static-extensions">Section 6.1.1 
Static Typing Extensions</A><SUP><SMALL>FS</SMALL></SUP> for a formal definition 
of the constraints on static typing extensions.</P></DIV></DIV></DIV>
<DIV class=div3>
<H4><A id=id-full-axis-feature name=id-full-axis-feature></A>5.2.4 Full Axis 
Feature</H4>
<P>[<A id=dt-optional-axis title="optional axis" 
name=dt-optional-axis>Definition</A>: The following axes are designated as 
<B>optional axes</B>: <CODE>ancestor</CODE>, <CODE>ancestor-or-self</CODE>, 
<CODE>following</CODE>, <CODE>following-sibling</CODE>, <CODE>preceding</CODE>, 
and <CODE>preceding-sibling</CODE>.]</P>
<P>[<A id=dt-full-axis-feature title="Full Axis Feature" 
name=dt-full-axis-feature>Definition</A>: A conforming XQuery implementation 
that supports the <B>Full Axis Feature</B> <A title=must 
href="REC-xquery-20070123.htm#must">MUST</A> support all 
the <A title="optional axis" 
href="REC-xquery-20070123.htm#dt-optional-axis">optional 
axes</A>.]</P>
<P>Conforming XQuery implementations that do not support the Full Axis Feature 
<A title=may href="REC-xquery-20070123.htm#may">MAY</A> 
support one or more optional axes; it is <A title="implementation defined" 
href="REC-xquery-20070123.htm#dt-implementation-defined">implementation-defined</A> 
which optional axes are supported by such implementations. A conforming 
implementation that encounters a reference to an optional axis that it does not 
support <A title=must 
href="REC-xquery-20070123.htm#must">MUST</A> raise a <A 
title="static error" 
href="REC-xquery-20070123.htm#dt-static-error">static 
error</A> [<A title=err:XPST0010 
href="REC-xquery-20070123.htm#ERRXPST0010">err:XPST0010</A>].</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>XQuery does not recognize the <CODE>namespace</CODE> axis (defined by XPath 
1.0 and deprecated by XPath 2.0).</P></DIV></DIV>
<DIV class=div3>
<H4><A id=id-module-feature name=id-module-feature></A>5.2.5 Module Feature</H4>
<P>[<A id=dt-module-feature title="module feature" 
name=dt-module-feature>Definition</A>: A conforming XQuery implementation that 
supports the <B>Module Feature</B> allows a query Prolog to contain a <B>Module 
Import</B> and allows <B>library modules</B> to be created.]</P>
<P>A conforming implementation that does not support the Module Feature <A 
title=must href="REC-xquery-20070123.htm#must">MUST</A> 
raise a <A title="static error" 
href="REC-xquery-20070123.htm#dt-static-error">static 
error</A> [<A title=err:XQST0016 
href="REC-xquery-20070123.htm#ERRXQST0016">err:XQST0016</A>] 
if it encounters a <A title="module declaration" 
href="REC-xquery-20070123.htm#dt-module-declaration">module 
declaration</A> or a <A title="module import" 
href="REC-xquery-20070123.htm#dt-module-import">module 
import</A>. Since a <A title="module declaration" 
href="REC-xquery-20070123.htm#dt-module-declaration">module 
declaration</A> is required in a <A title="library module" 
href="REC-xquery-20070123.htm#dt-library-module">library 
module</A>, the Module Feature is required in order to create a <A 
title="library module" 
href="REC-xquery-20070123.htm#dt-library-module">library 
module</A>.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>In the absence of the Module Feature, each query consists of a single <A 
title="main module" 
href="REC-xquery-20070123.htm#dt-main-module">main 
module</A>.</P></DIV></DIV>
<DIV class=div3>
<H4><A id=id-serialization-feature name=id-serialization-feature></A>5.2.6 
Serialization Feature</H4>
<P>[<A id=dt-serialization-feature title="serialization feature" 
name=dt-serialization-feature>Definition</A>: A conforming XQuery implementation 
that supports the <B>Serialization Feature</B> <A title=must 
href="REC-xquery-20070123.htm#must">MUST</A> provide 
means for serializing the result of a query, as specified in <A 
href="REC-xquery-20070123.htm#id-serialization"><B>2.2.4 
Serialization</B></A>.]</P>
<P>A conforming XQuery implementation that supports the Serialization Feature <A 
title=must href="REC-xquery-20070123.htm#must">MUST</A> 
conform to <A 
href="REC-xquery-20070123.htm#id-xq-serialization-parameters"><B>C.3 
Serialization Parameters</B></A>. The means by which serialization is invoked is 
<A title="implementation defined" 
href="REC-xquery-20070123.htm#dt-implementation-defined">implementation-defined</A>.</P>
<P>If an error is raised during the serialization process as specified in <A 
href="REC-xquery-20070123.htm#serialization">[XSLT 2.0 
and XQuery 1.0 Serialization]</A>, an conforming XQuery implementation <A 
title=must href="REC-xquery-20070123.htm#must">MUST</A> 
report the error to the calling environment.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>Not all implementations need to serialize. For instance, an implementation 
might provide results via an XML API instead of producing a textual 
representation.</P></DIV></DIV></DIV>
<DIV class=div2>
<H3><A id=id-data-model-conformance name=id-data-model-conformance></A>5.3 Data 
Model Conformance</H3>
<P>All XQuery implementations process data represented in the <A 
title="data model" 
href="REC-xquery-20070123.htm#dt-datamodel">data 
model</A> as specified in <A 
href="REC-xquery-20070123.htm#datamodel">[XQuery/XPath 
Data Model (XDM)]</A>. The data model specification relies on languages such as 
XQuery to specify conformance criteria for the data model in their respective 
environments, and suggests that the following issues should be considered:</P>
<OL class=enumar>
  <LI>
  <P><EM>Support for normative construction from an infoset.</EM> A conforming 
  implementation <A title=may 
  href="REC-xquery-20070123.htm#may">MAY</A> choose to 
  claim conformance to <A 
  href="http://www.w3.org/TR/xpath-datamodel/#const-infoset">Section 3.2 
  Construction from an Infoset</A><SUP><SMALL>DM</SMALL></SUP>, which defines a 
  normative way to construct an <A title="XDM instance" 
  href="REC-xquery-20070123.htm#dt-data-model-instance">XDM 
  instance</A> from an XML document that is merely well-formed or is governed by 
  a DTD.</P>
  <LI>
  <P><EM>Support for normative construction from a PSVI.</EM> A conforming 
  implementation <A title=may 
  href="REC-xquery-20070123.htm#may">MAY</A> choose to 
  claim conformance to <A 
  href="http://www.w3.org/TR/xpath-datamodel/#const-psvi">Section 3.3 
  Construction from a PSVI</A><SUP><SMALL>DM</SMALL></SUP>, which defines a 
  normative way to construct an <A title="XDM instance" 
  href="REC-xquery-20070123.htm#dt-data-model-instance">XDM 
  instance</A> from an XML document that is governed by a W3C XML Schema.</P>
  <LI>
  <P><EM>Support for XML 1.0 and XML 1.1.</EM> The <A 
  href="REC-xquery-20070123.htm#datamodel">[XQuery/XPath 
  Data Model (XDM)]</A> supports either <A 
  href="REC-xquery-20070123.htm#XML">[XML 1.0]</A> or <A 
  href="REC-xquery-20070123.htm#XML1.1">[XML 1.1]</A>. In 
  XQuery, the choice of which XML version to support is <A 
  title="implementation defined" 
  href="REC-xquery-20070123.htm#dt-implementation-defined">implementation-defined</A>.</P>
  <P>At the time of writing there is no published version of XML Schema that 
  references the XML 1.1 specifications. This means that datatypes such as 
  <CODE>xs:NCName</CODE> and <CODE>xs:ID</CODE> are constrained by the XML 1.0 
  rules. It is recommended that an XQuery 1.0 processor should implement the 
  rules defined by later versions of XML Schema as they become available.</P>
  <DIV class=note>
  <P class=prefix><B>Note:</B></P>
  <P>For suggestions on processing XML 1.1 documents, see <A 
  href="REC-xquery-20070123.htm#xml11schema10">[XML 1.1 
  and Schema 1.0]</A>.</P></DIV>
  <LI>
  <P><EM>Ranges of data values.</EM> In XQuery, the following limits are <A 
  title="implementation defined" 
  href="REC-xquery-20070123.htm#dt-implementation-defined">implementation-defined</A>:</P>
  <OL class=enumla>
    <LI>
    <P>For the <CODE>xs:decimal</CODE> type, the maximum number of decimal 
    digits (<CODE>totalDigits</CODE> facet) (must be at least 18).</P>
    <LI>
    <P>For the types <CODE>xs:date</CODE>, <CODE>xs:time</CODE>, 
    <CODE>xs:dateTime</CODE>, <CODE>xs:gYear</CODE>, and 
    <CODE>xs:gYearMonth</CODE>: the maximum value of the year component and the 
    maximum number of fractional second digits (must be at least 3).</P>
    <LI>
    <P>For the <CODE>xs:duration type</CODE>: the maximum absolute values of the 
    years, months, days, hours, minutes, and seconds components.</P>
    <LI>
    <P>For the <CODE>xs:yearMonthDuration</CODE> type: the maximum absolute 
    value, expressed as an integer number of months.</P>
    <LI>
    <P>For the <CODE>xs:dayTimeDuration</CODE> type: the maximum absolute value, 
    expressed as a decimal number of seconds.</P>
    <LI>
    <P>For the types <CODE>xs:string</CODE>, <CODE>xs:hexBinary</CODE>, 
    <CODE>xs:base64Binary</CODE>, <CODE>xs:QName</CODE>, <CODE>xs:anyURI</CODE>, 
    <CODE>xs:NOTATION</CODE>, and types derived from them: limitations (if any) 
    imposed by the implementation on lengths of values.</P></LI></OL>
  <P>The limits listed above need not be fixed, but may depend on environmental 
  factors such as system resources. For example, the length of a value of type 
  <CODE>xs:string</CODE> may be limited by available 
memory.</P></LI></OL></DIV></DIV></DIV></DIV>
<DIV class=back>
<DIV class=div1>
<H2><A id=nt-bnf name=nt-bnf></A>A XQuery Grammar</H2>
<DIV class=div2>
<H3><A id=id-grammar name=id-grammar></A>A.1 EBNF</H3>
<P>The grammar of XQuery uses the same simple Extended Backus-Naur Form (EBNF) 
notation as <A href="REC-xquery-20070123.htm#XML">[XML 
1.0]</A> with the following minor differences.</P>
<UL>
  <LI>
  <P>All named symbols have a name that begins with an uppercase letter.</P>
  <LI>
  <P>It adds a notation for referring to productions in external specs.</P>
  <LI>
  <P>Comments or extra-grammatical constraints on grammar productions are 
  between '/*' and '*/' symbols.</P>
  <UL>
    <LI>
    <P>A 'xgc:' prefix is an extra-grammatical constraint, the details of which 
    are explained in <A 
    href="REC-xquery-20070123.htm#extra-grammatical-constraints"><B>A.1.2 
    Extra-grammatical Constraints</B></A></P>
    <LI>
    <P>A 'ws:' prefix explains the whitespace rules for the production, the 
    details of which are explained in <A 
    href="REC-xquery-20070123.htm#whitespace-rules"><B>A.2.4 
    Whitespace Rules</B></A></P>
    <LI>
    <P>A 'gn:' prefix means a 'Grammar Note', and is meant as a clarification 
    for parsing rules, and is explained in <A 
    href="REC-xquery-20070123.htm#notes-on-parsing"><B>A.1.3 
    Grammar Notes</B></A>. These notes are not normative.</P></LI></UL></LI></UL>
<P>The terminal symbols for this grammar include the quoted strings used in the 
production rules below, and the terminal symbols defined in section <A 
href="REC-xquery-20070123.htm#terminal-symbols"><B>A.2.1 
Terminal Symbols</B></A>.</P>
<P>The EBNF notation is described in more detail in <A 
href="REC-xquery-20070123.htm#EBNFNotation"><B>A.1.1 
Notation</B></A>.</P>
<P>To increase readability, the EBNF in the main body of this document omits 
some of these notational features. This appendix is the normative version of the 
EBNF.</P>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-Module 
    name=prod-xquery-Module></A>[1]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-Module">Module</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-VersionDecl">VersionDecl</A>? 
      (<A 
      href="REC-xquery-20070123.htm#prod-xquery-LibraryModule">LibraryModule</A> 
      | <A 
      href="REC-xquery-20070123.htm#prod-xquery-MainModule">MainModule</A>)</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-VersionDecl 
      name=prod-xquery-VersionDecl></A>[2]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-VersionDecl">VersionDecl</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"xquery" "version" <A 
      href="REC-xquery-20070123.htm#prod-xquery-StringLiteral">StringLiteral</A> 
      ("encoding" <A 
      href="REC-xquery-20070123.htm#prod-xquery-StringLiteral">StringLiteral</A>)? 
      <A 
      href="REC-xquery-20070123.htm#prod-xquery-Separator">Separator</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-MainModule 
      name=prod-xquery-MainModule></A>[3]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-MainModule">MainModule</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-Prolog">Prolog</A> 
      <A 
      href="REC-xquery-20070123.htm#prod-xquery-QueryBody">QueryBody</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-LibraryModule 
      name=prod-xquery-LibraryModule></A>[4]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-LibraryModule">LibraryModule</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-ModuleDecl">ModuleDecl</A> 
      <A 
      href="REC-xquery-20070123.htm#prod-xquery-Prolog">Prolog</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-ModuleDecl 
      name=prod-xquery-ModuleDecl></A>[5]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-ModuleDecl">ModuleDecl</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"module" "namespace" <A 
      href="REC-xquery-20070123.htm#prod-xquery-NCName">NCName</A> 
      "=" <A 
      href="REC-xquery-20070123.htm#prod-xquery-URILiteral">URILiteral</A> 
      <A 
      href="REC-xquery-20070123.htm#prod-xquery-Separator">Separator</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-Prolog 
    name=prod-xquery-Prolog></A>[6]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-Prolog">Prolog</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>((<A 
      href="REC-xquery-20070123.htm#prod-xquery-DefaultNamespaceDecl">DefaultNamespaceDecl</A> 
      | <A 
      href="REC-xquery-20070123.htm#prod-xquery-Setter">Setter</A> 
      | <A 
      href="REC-xquery-20070123.htm#prod-xquery-NamespaceDecl">NamespaceDecl</A> 
      | <A 
      href="REC-xquery-20070123.htm#prod-xquery-Import">Import</A>) 
      <A 
      href="REC-xquery-20070123.htm#prod-xquery-Separator">Separator</A>)* 
      ((<A 
      href="REC-xquery-20070123.htm#prod-xquery-VarDecl">VarDecl</A> 
      | <A 
      href="REC-xquery-20070123.htm#prod-xquery-FunctionDecl">FunctionDecl</A> 
      | <A 
      href="REC-xquery-20070123.htm#prod-xquery-OptionDecl">OptionDecl</A>) 
      <A 
      href="REC-xquery-20070123.htm#prod-xquery-Separator">Separator</A>)*</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-Setter 
    name=prod-xquery-Setter></A>[7]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-Setter">Setter</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-BoundarySpaceDecl">BoundarySpaceDecl</A> 
      | <A 
      href="REC-xquery-20070123.htm#prod-xquery-DefaultCollationDecl">DefaultCollationDecl</A> 
      | <A 
      href="REC-xquery-20070123.htm#prod-xquery-BaseURIDecl">BaseURIDecl</A> 
      | <A 
      href="REC-xquery-20070123.htm#prod-xquery-ConstructionDecl">ConstructionDecl</A> 
      | <A 
      href="REC-xquery-20070123.htm#prod-xquery-OrderingModeDecl">OrderingModeDecl</A> 
      | <A 
      href="REC-xquery-20070123.htm#prod-xquery-EmptyOrderDecl">EmptyOrderDecl</A> 
      | <A 
      href="REC-xquery-20070123.htm#prod-xquery-CopyNamespacesDecl">CopyNamespacesDecl</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-Import 
    name=prod-xquery-Import></A>[8]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-Import">Import</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-SchemaImport">SchemaImport</A> 
      | <A 
      href="REC-xquery-20070123.htm#prod-xquery-ModuleImport">ModuleImport</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-Separator 
      name=prod-xquery-Separator></A>[9]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-Separator">Separator</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>";"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-NamespaceDecl 
      name=prod-xquery-NamespaceDecl></A>[10]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-NamespaceDecl">NamespaceDecl</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"declare" "namespace" <A 
      href="REC-xquery-20070123.htm#prod-xquery-NCName">NCName</A> 
      "=" <A 
      href="REC-xquery-20070123.htm#prod-xquery-URILiteral">URILiteral</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-BoundarySpaceDecl 
      name=prod-xquery-BoundarySpaceDecl></A>[11]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-BoundarySpaceDecl">BoundarySpaceDecl</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"declare" "boundary-space" ("preserve" | 
  "strip")</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-DefaultNamespaceDecl 
      name=prod-xquery-DefaultNamespaceDecl></A>[12]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-DefaultNamespaceDecl">DefaultNamespaceDecl</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"declare" "default" ("element" | "function") "namespace" <A 
      href="REC-xquery-20070123.htm#prod-xquery-URILiteral">URILiteral</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-OptionDecl 
      name=prod-xquery-OptionDecl></A>[13]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-OptionDecl">OptionDecl</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"declare" "option" <A 
      href="REC-xquery-20070123.htm#prod-xquery-QName">QName</A> 
      <A 
      href="REC-xquery-20070123.htm#prod-xquery-StringLiteral">StringLiteral</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-OrderingModeDecl 
      name=prod-xquery-OrderingModeDecl></A>[14]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-OrderingModeDecl">OrderingModeDecl</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"declare" "ordering" ("ordered" | 
  "unordered")</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-EmptyOrderDecl 
      name=prod-xquery-EmptyOrderDecl></A>[15]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-EmptyOrderDecl">EmptyOrderDecl</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"declare" "default" "order" "empty" ("greatest" | 
    "least")</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-CopyNamespacesDecl 
      name=prod-xquery-CopyNamespacesDecl></A>[16]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-CopyNamespacesDecl">CopyNamespacesDecl</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"declare" "copy-namespaces" <A 
      href="REC-xquery-20070123.htm#prod-xquery-PreserveMode">PreserveMode</A> 
      "," <A 
      href="REC-xquery-20070123.htm#prod-xquery-InheritMode">InheritMode</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-PreserveMode 
      name=prod-xquery-PreserveMode></A>[17]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-PreserveMode">PreserveMode</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"preserve" | "no-preserve"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-InheritMode 
      name=prod-xquery-InheritMode></A>[18]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-InheritMode">InheritMode</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"inherit" | "no-inherit"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-DefaultCollationDecl 
      name=prod-xquery-DefaultCollationDecl></A>[19]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-DefaultCollationDecl">DefaultCollationDecl</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"declare" "default" "collation" <A 
      href="REC-xquery-20070123.htm#prod-xquery-URILiteral">URILiteral</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-BaseURIDecl 
      name=prod-xquery-BaseURIDecl></A>[20]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-BaseURIDecl">BaseURIDecl</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"declare" "base-uri" <A 
      href="REC-xquery-20070123.htm#prod-xquery-URILiteral">URILiteral</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-SchemaImport 
      name=prod-xquery-SchemaImport></A>[21]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-SchemaImport">SchemaImport</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"import" "schema" <A 
      href="REC-xquery-20070123.htm#prod-xquery-SchemaPrefix">SchemaPrefix</A>? 
      <A 
      href="REC-xquery-20070123.htm#prod-xquery-URILiteral">URILiteral</A> 
      ("at" <A 
      href="REC-xquery-20070123.htm#prod-xquery-URILiteral">URILiteral</A> 
      ("," <A 
      href="REC-xquery-20070123.htm#prod-xquery-URILiteral">URILiteral</A>)*)?</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-SchemaPrefix 
      name=prod-xquery-SchemaPrefix></A>[22]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-SchemaPrefix">SchemaPrefix</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>("namespace" <A 
      href="REC-xquery-20070123.htm#prod-xquery-NCName">NCName</A> 
      "=") | ("default" "element" "namespace")</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-ModuleImport 
      name=prod-xquery-ModuleImport></A>[23]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-ModuleImport">ModuleImport</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"import" "module" ("namespace" <A 
      href="REC-xquery-20070123.htm#prod-xquery-NCName">NCName</A> 
      "=")? <A 
      href="REC-xquery-20070123.htm#prod-xquery-URILiteral">URILiteral</A> 
      ("at" <A 
      href="REC-xquery-20070123.htm#prod-xquery-URILiteral">URILiteral</A> 
      ("," <A 
      href="REC-xquery-20070123.htm#prod-xquery-URILiteral">URILiteral</A>)*)?</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-VarDecl 
      name=prod-xquery-VarDecl></A>[24]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-VarDecl">VarDecl</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"declare" "variable" "$" <A 
      href="REC-xquery-20070123.htm#prod-xquery-QName">QName</A> 
      <A 
      href="REC-xquery-20070123.htm#prod-xquery-TypeDeclaration">TypeDeclaration</A>? 
      ((":=" <A 
      href="REC-xquery-20070123.htm#prod-xquery-ExprSingle">ExprSingle</A>) 
      | "external")</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-ConstructionDecl 
      name=prod-xquery-ConstructionDecl></A>[25]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-ConstructionDecl">ConstructionDecl</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"declare" "construction" ("strip" | 
  "preserve")</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-FunctionDecl 
      name=prod-xquery-FunctionDecl></A>[26]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-FunctionDecl">FunctionDecl</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"declare" "function" <A 
      href="REC-xquery-20070123.htm#prod-xquery-QName">QName</A> 
      "(" <A 
      href="REC-xquery-20070123.htm#prod-xquery-ParamList">ParamList</A>? 
      ")" ("as" <A 
      href="REC-xquery-20070123.htm#prod-xquery-SequenceType">SequenceType</A>)? 
      (<A 
      href="REC-xquery-20070123.htm#prod-xquery-EnclosedExpr">EnclosedExpr</A> 
      | "external")</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-ParamList 
      name=prod-xquery-ParamList></A>[27]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-ParamList">ParamList</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-Param">Param</A> 
      ("," <A 
      href="REC-xquery-20070123.htm#prod-xquery-Param">Param</A>)*</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-Param 
    name=prod-xquery-Param></A>[28]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-Param">Param</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"$" <A 
      href="REC-xquery-20070123.htm#prod-xquery-QName">QName</A> 
      <A 
      href="REC-xquery-20070123.htm#prod-xquery-TypeDeclaration">TypeDeclaration</A>?</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-EnclosedExpr 
      name=prod-xquery-EnclosedExpr></A>[29]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-EnclosedExpr">EnclosedExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"{" <A 
      href="REC-xquery-20070123.htm#prod-xquery-Expr">Expr</A> 
      "}"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-QueryBody 
      name=prod-xquery-QueryBody></A>[30]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-QueryBody">QueryBody</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-Expr">Expr</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-Expr 
    name=prod-xquery-Expr></A>[31]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-Expr">Expr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-ExprSingle">ExprSingle</A> 
      ("," <A 
      href="REC-xquery-20070123.htm#prod-xquery-ExprSingle">ExprSingle</A>)*</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-ExprSingle 
      name=prod-xquery-ExprSingle></A>[32]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-ExprSingle">ExprSingle</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-FLWORExpr">FLWORExpr</A><BR>| 
      <A 
      href="REC-xquery-20070123.htm#prod-xquery-QuantifiedExpr">QuantifiedExpr</A><BR>| 
      <A 
      href="REC-xquery-20070123.htm#prod-xquery-TypeswitchExpr">TypeswitchExpr</A><BR>| 
      <A 
      href="REC-xquery-20070123.htm#prod-xquery-IfExpr">IfExpr</A><BR>| 
      <A 
      href="REC-xquery-20070123.htm#prod-xquery-OrExpr">OrExpr</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-FLWORExpr 
      name=prod-xquery-FLWORExpr></A>[33]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-FLWORExpr">FLWORExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>(<A 
      href="REC-xquery-20070123.htm#prod-xquery-ForClause">ForClause</A> 
      | <A 
      href="REC-xquery-20070123.htm#prod-xquery-LetClause">LetClause</A>)+ 
      <A 
      href="REC-xquery-20070123.htm#prod-xquery-WhereClause">WhereClause</A>? 
      <A 
      href="REC-xquery-20070123.htm#prod-xquery-OrderByClause">OrderByClause</A>? 
      "return" <A 
      href="REC-xquery-20070123.htm#prod-xquery-ExprSingle">ExprSingle</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-ForClause 
      name=prod-xquery-ForClause></A>[34]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-ForClause">ForClause</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"for" "$" <A 
      href="REC-xquery-20070123.htm#prod-xquery-VarName">VarName</A> 
      <A 
      href="REC-xquery-20070123.htm#prod-xquery-TypeDeclaration">TypeDeclaration</A>? 
      <A 
      href="REC-xquery-20070123.htm#prod-xquery-PositionalVar">PositionalVar</A>? 
      "in" <A 
      href="REC-xquery-20070123.htm#prod-xquery-ExprSingle">ExprSingle</A> 
      ("," "$" <A 
      href="REC-xquery-20070123.htm#prod-xquery-VarName">VarName</A> 
      <A 
      href="REC-xquery-20070123.htm#prod-xquery-TypeDeclaration">TypeDeclaration</A>? 
      <A 
      href="REC-xquery-20070123.htm#prod-xquery-PositionalVar">PositionalVar</A>? 
      "in" <A 
      href="REC-xquery-20070123.htm#prod-xquery-ExprSingle">ExprSingle</A>)*</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-PositionalVar 
      name=prod-xquery-PositionalVar></A>[35]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-PositionalVar">PositionalVar</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"at" "$" <A 
      href="REC-xquery-20070123.htm#prod-xquery-VarName">VarName</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-LetClause 
      name=prod-xquery-LetClause></A>[36]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-LetClause">LetClause</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"let" "$" <A 
      href="REC-xquery-20070123.htm#prod-xquery-VarName">VarName</A> 
      <A 
      href="REC-xquery-20070123.htm#prod-xquery-TypeDeclaration">TypeDeclaration</A>? 
      ":=" <A 
      href="REC-xquery-20070123.htm#prod-xquery-ExprSingle">ExprSingle</A> 
      ("," "$" <A 
      href="REC-xquery-20070123.htm#prod-xquery-VarName">VarName</A> 
      <A 
      href="REC-xquery-20070123.htm#prod-xquery-TypeDeclaration">TypeDeclaration</A>? 
      ":=" <A 
      href="REC-xquery-20070123.htm#prod-xquery-ExprSingle">ExprSingle</A>)*</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-WhereClause 
      name=prod-xquery-WhereClause></A>[37]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-WhereClause">WhereClause</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"where" <A 
      href="REC-xquery-20070123.htm#prod-xquery-ExprSingle">ExprSingle</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-OrderByClause 
      name=prod-xquery-OrderByClause></A>[38]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-OrderByClause">OrderByClause</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>(("order" "by") | ("stable" "order" "by")) <A 
      href="REC-xquery-20070123.htm#prod-xquery-OrderSpecList">OrderSpecList</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-OrderSpecList 
      name=prod-xquery-OrderSpecList></A>[39]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-OrderSpecList">OrderSpecList</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-OrderSpec">OrderSpec</A> 
      ("," <A 
      href="REC-xquery-20070123.htm#prod-xquery-OrderSpec">OrderSpec</A>)*</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-OrderSpec 
      name=prod-xquery-OrderSpec></A>[40]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-OrderSpec">OrderSpec</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-ExprSingle">ExprSingle</A> 
      <A 
      href="REC-xquery-20070123.htm#prod-xquery-OrderModifier">OrderModifier</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-OrderModifier 
      name=prod-xquery-OrderModifier></A>[41]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-OrderModifier">OrderModifier</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>("ascending" | "descending")? ("empty" ("greatest" | "least"))? 
      ("collation" <A 
      href="REC-xquery-20070123.htm#prod-xquery-URILiteral">URILiteral</A>)?</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-QuantifiedExpr 
      name=prod-xquery-QuantifiedExpr></A>[42]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-QuantifiedExpr">QuantifiedExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>("some" | "every") "$" <A 
      href="REC-xquery-20070123.htm#prod-xquery-VarName">VarName</A> 
      <A 
      href="REC-xquery-20070123.htm#prod-xquery-TypeDeclaration">TypeDeclaration</A>? 
      "in" <A 
      href="REC-xquery-20070123.htm#prod-xquery-ExprSingle">ExprSingle</A> 
      ("," "$" <A 
      href="REC-xquery-20070123.htm#prod-xquery-VarName">VarName</A> 
      <A 
      href="REC-xquery-20070123.htm#prod-xquery-TypeDeclaration">TypeDeclaration</A>? 
      "in" <A 
      href="REC-xquery-20070123.htm#prod-xquery-ExprSingle">ExprSingle</A>)* 
      "satisfies" <A 
      href="REC-xquery-20070123.htm#prod-xquery-ExprSingle">ExprSingle</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-TypeswitchExpr 
      name=prod-xquery-TypeswitchExpr></A>[43]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-TypeswitchExpr">TypeswitchExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"typeswitch" "(" <A 
      href="REC-xquery-20070123.htm#prod-xquery-Expr">Expr</A> 
      ")" <A 
      href="REC-xquery-20070123.htm#prod-xquery-CaseClause">CaseClause</A>+ 
      "default" ("$" <A 
      href="REC-xquery-20070123.htm#prod-xquery-VarName">VarName</A>)? 
      "return" <A 
      href="REC-xquery-20070123.htm#prod-xquery-ExprSingle">ExprSingle</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-CaseClause 
      name=prod-xquery-CaseClause></A>[44]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-CaseClause">CaseClause</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"case" ("$" <A 
      href="REC-xquery-20070123.htm#prod-xquery-VarName">VarName</A> 
      "as")? <A 
      href="REC-xquery-20070123.htm#prod-xquery-SequenceType">SequenceType</A> 
      "return" <A 
      href="REC-xquery-20070123.htm#prod-xquery-ExprSingle">ExprSingle</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-IfExpr 
    name=prod-xquery-IfExpr></A>[45]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-IfExpr">IfExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"if" "(" <A 
      href="REC-xquery-20070123.htm#prod-xquery-Expr">Expr</A> 
      ")" "then" <A 
      href="REC-xquery-20070123.htm#prod-xquery-ExprSingle">ExprSingle</A> 
      "else" <A 
      href="REC-xquery-20070123.htm#prod-xquery-ExprSingle">ExprSingle</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-OrExpr 
    name=prod-xquery-OrExpr></A>[46]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-OrExpr">OrExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-AndExpr">AndExpr</A> 
      ( "or" <A 
      href="REC-xquery-20070123.htm#prod-xquery-AndExpr">AndExpr</A> 
      )*</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-AndExpr 
      name=prod-xquery-AndExpr></A>[47]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-AndExpr">AndExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-ComparisonExpr">ComparisonExpr</A> 
      ( "and" <A 
      href="REC-xquery-20070123.htm#prod-xquery-ComparisonExpr">ComparisonExpr</A> 
      )*</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-ComparisonExpr 
      name=prod-xquery-ComparisonExpr></A>[48]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-ComparisonExpr">ComparisonExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-RangeExpr">RangeExpr</A> 
      ( (<A 
      href="REC-xquery-20070123.htm#prod-xquery-ValueComp">ValueComp</A><BR>| 
      <A 
      href="REC-xquery-20070123.htm#prod-xquery-GeneralComp">GeneralComp</A><BR>| 
      <A 
      href="REC-xquery-20070123.htm#prod-xquery-NodeComp">NodeComp</A>) 
      <A 
      href="REC-xquery-20070123.htm#prod-xquery-RangeExpr">RangeExpr</A> 
      )?</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-RangeExpr 
      name=prod-xquery-RangeExpr></A>[49]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-RangeExpr">RangeExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-AdditiveExpr">AdditiveExpr</A> 
      ( "to" <A 
      href="REC-xquery-20070123.htm#prod-xquery-AdditiveExpr">AdditiveExpr</A> 
      )?</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-AdditiveExpr 
      name=prod-xquery-AdditiveExpr></A>[50]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-AdditiveExpr">AdditiveExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-MultiplicativeExpr">MultiplicativeExpr</A> 
      ( ("+" | "-") <A 
      href="REC-xquery-20070123.htm#prod-xquery-MultiplicativeExpr">MultiplicativeExpr</A> 
      )*</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-MultiplicativeExpr 
      name=prod-xquery-MultiplicativeExpr></A>[51]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-MultiplicativeExpr">MultiplicativeExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-UnionExpr">UnionExpr</A> 
      ( ("*" | "div" | "idiv" | "mod") <A 
      href="REC-xquery-20070123.htm#prod-xquery-UnionExpr">UnionExpr</A> 
      )*</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-UnionExpr 
      name=prod-xquery-UnionExpr></A>[52]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-UnionExpr">UnionExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-IntersectExceptExpr">IntersectExceptExpr</A> 
      ( ("union" | "|") <A 
      href="REC-xquery-20070123.htm#prod-xquery-IntersectExceptExpr">IntersectExceptExpr</A> 
      )*</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-IntersectExceptExpr 
      name=prod-xquery-IntersectExceptExpr></A>[53]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-IntersectExceptExpr">IntersectExceptExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-InstanceofExpr">InstanceofExpr</A> 
      ( ("intersect" | "except") <A 
      href="REC-xquery-20070123.htm#prod-xquery-InstanceofExpr">InstanceofExpr</A> 
      )*</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-InstanceofExpr 
      name=prod-xquery-InstanceofExpr></A>[54]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-InstanceofExpr">InstanceofExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-TreatExpr">TreatExpr</A> 
      ( "instance" "of" <A 
      href="REC-xquery-20070123.htm#prod-xquery-SequenceType">SequenceType</A> 
      )?</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-TreatExpr 
      name=prod-xquery-TreatExpr></A>[55]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-TreatExpr">TreatExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-CastableExpr">CastableExpr</A> 
      ( "treat" "as" <A 
      href="REC-xquery-20070123.htm#prod-xquery-SequenceType">SequenceType</A> 
      )?</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-CastableExpr 
      name=prod-xquery-CastableExpr></A>[56]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-CastableExpr">CastableExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-CastExpr">CastExpr</A> 
      ( "castable" "as" <A 
      href="REC-xquery-20070123.htm#prod-xquery-SingleType">SingleType</A> 
      )?</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-CastExpr 
      name=prod-xquery-CastExpr></A>[57]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-CastExpr">CastExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-UnaryExpr">UnaryExpr</A> 
      ( "cast" "as" <A 
      href="REC-xquery-20070123.htm#prod-xquery-SingleType">SingleType</A> 
      )?</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-UnaryExpr 
      name=prod-xquery-UnaryExpr></A>[58]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-UnaryExpr">UnaryExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>("-" | "+")* <A 
      href="REC-xquery-20070123.htm#prod-xquery-ValueExpr">ValueExpr</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-ValueExpr 
      name=prod-xquery-ValueExpr></A>[59]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-ValueExpr">ValueExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-ValidateExpr">ValidateExpr</A> 
      | <A 
      href="REC-xquery-20070123.htm#prod-xquery-PathExpr">PathExpr</A> 
      | <A 
      href="REC-xquery-20070123.htm#prod-xquery-ExtensionExpr">ExtensionExpr</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-GeneralComp 
      name=prod-xquery-GeneralComp></A>[60]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-GeneralComp">GeneralComp</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"=" | "!=" | "&lt;" | "&lt;=" | "&gt;" | 
  "&gt;="</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-ValueComp 
      name=prod-xquery-ValueComp></A>[61]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-ValueComp">ValueComp</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"eq" | "ne" | "lt" | "le" | "gt" | "ge"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-NodeComp 
      name=prod-xquery-NodeComp></A>[62]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-NodeComp">NodeComp</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"is" | "&lt;&lt;" | "&gt;&gt;"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-ValidateExpr 
      name=prod-xquery-ValidateExpr></A>[63]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-ValidateExpr">ValidateExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"validate" <A 
      href="REC-xquery-20070123.htm#prod-xquery-ValidationMode">ValidationMode</A>? 
      "{" <A 
      href="REC-xquery-20070123.htm#prod-xquery-Expr">Expr</A> 
      "}"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-ValidationMode 
      name=prod-xquery-ValidationMode></A>[64]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-ValidationMode">ValidationMode</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"lax" | "strict"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-ExtensionExpr 
      name=prod-xquery-ExtensionExpr></A>[65]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-ExtensionExpr">ExtensionExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-Pragma">Pragma</A>+ 
      "{" <A 
      href="REC-xquery-20070123.htm#prod-xquery-Expr">Expr</A>? 
      "}"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-Pragma 
    name=prod-xquery-Pragma></A>[66]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-Pragma">Pragma</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"(#" <A 
      href="REC-xquery-20070123.htm#prod-xquery-S">S</A>? 
      <A 
      href="REC-xquery-20070123.htm#prod-xquery-QName">QName</A> 
      (<A 
      href="REC-xquery-20070123.htm#prod-xquery-S">S</A> 
      <A 
      href="REC-xquery-20070123.htm#prod-xquery-PragmaContents">PragmaContents</A>)? 
      "#)"</CODE></TD>
    <TD><I>/* <A 
      href="REC-xquery-20070123.htm#ws-explicit">ws: 
      explicit</A> */</I></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-PragmaContents 
      name=prod-xquery-PragmaContents></A>[67]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-PragmaContents">PragmaContents</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>(<A 
      href="REC-xquery-20070123.htm#prod-xquery-Char">Char</A>* 
      - (Char* '#)' Char*))</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-PathExpr 
      name=prod-xquery-PathExpr></A>[68]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-PathExpr">PathExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>("/" <A 
      href="REC-xquery-20070123.htm#prod-xquery-RelativePathExpr">RelativePathExpr</A>?)<BR>| 
      ("//" <A 
      href="REC-xquery-20070123.htm#prod-xquery-RelativePathExpr">RelativePathExpr</A>)<BR>| 
      <A 
      href="REC-xquery-20070123.htm#prod-xquery-RelativePathExpr">RelativePathExpr</A></CODE></TD>
    <TD><I>/* <A 
      href="REC-xquery-20070123.htm#parse-note-leading-lone-slash">xgs: 
      leading-lone-slash</A> */</I></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-RelativePathExpr 
      name=prod-xquery-RelativePathExpr></A>[69]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-RelativePathExpr">RelativePathExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-StepExpr">StepExpr</A> 
      (("/" | "//") <A 
      href="REC-xquery-20070123.htm#prod-xquery-StepExpr">StepExpr</A>)*</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-StepExpr 
      name=prod-xquery-StepExpr></A>[70]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-StepExpr">StepExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-FilterExpr">FilterExpr</A> 
      | <A 
      href="REC-xquery-20070123.htm#prod-xquery-AxisStep">AxisStep</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-AxisStep 
      name=prod-xquery-AxisStep></A>[71]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-AxisStep">AxisStep</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>(<A 
      href="REC-xquery-20070123.htm#prod-xquery-ReverseStep">ReverseStep</A> 
      | <A 
      href="REC-xquery-20070123.htm#prod-xquery-ForwardStep">ForwardStep</A>) 
      <A 
      href="REC-xquery-20070123.htm#prod-xquery-PredicateList">PredicateList</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-ForwardStep 
      name=prod-xquery-ForwardStep></A>[72]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-ForwardStep">ForwardStep</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>(<A 
      href="REC-xquery-20070123.htm#prod-xquery-ForwardAxis">ForwardAxis</A> 
      <A 
      href="REC-xquery-20070123.htm#prod-xquery-NodeTest">NodeTest</A>) 
      | <A 
      href="REC-xquery-20070123.htm#prod-xquery-AbbrevForwardStep">AbbrevForwardStep</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-ForwardAxis 
      name=prod-xquery-ForwardAxis></A>[73]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-ForwardAxis">ForwardAxis</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>("child" "::")<BR>| ("descendant" "::")<BR>| ("attribute" 
      "::")<BR>| ("self" "::")<BR>| ("descendant-or-self" "::")<BR>| 
      ("following-sibling" "::")<BR>| ("following" "::")</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-AbbrevForwardStep 
      name=prod-xquery-AbbrevForwardStep></A>[74]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-AbbrevForwardStep">AbbrevForwardStep</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"@"? <A 
      href="REC-xquery-20070123.htm#prod-xquery-NodeTest">NodeTest</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-ReverseStep 
      name=prod-xquery-ReverseStep></A>[75]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-ReverseStep">ReverseStep</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>(<A 
      href="REC-xquery-20070123.htm#prod-xquery-ReverseAxis">ReverseAxis</A> 
      <A 
      href="REC-xquery-20070123.htm#prod-xquery-NodeTest">NodeTest</A>) 
      | <A 
      href="REC-xquery-20070123.htm#prod-xquery-AbbrevReverseStep">AbbrevReverseStep</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-ReverseAxis 
      name=prod-xquery-ReverseAxis></A>[76]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-ReverseAxis">ReverseAxis</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>("parent" "::")<BR>| ("ancestor" "::")<BR>| ("preceding-sibling" 
      "::")<BR>| ("preceding" "::")<BR>| ("ancestor-or-self" 
  "::")</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-AbbrevReverseStep 
      name=prod-xquery-AbbrevReverseStep></A>[77]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-AbbrevReverseStep">AbbrevReverseStep</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>".."</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-NodeTest 
      name=prod-xquery-NodeTest></A>[78]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-NodeTest">NodeTest</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-KindTest">KindTest</A> 
      | <A 
      href="REC-xquery-20070123.htm#prod-xquery-NameTest">NameTest</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-NameTest 
      name=prod-xquery-NameTest></A>[79]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-NameTest">NameTest</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-QName">QName</A> 
      | <A 
      href="REC-xquery-20070123.htm#prod-xquery-Wildcard">Wildcard</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-Wildcard 
      name=prod-xquery-Wildcard></A>[80]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-Wildcard">Wildcard</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"*"<BR>| (<A 
      href="REC-xquery-20070123.htm#prod-xquery-NCName">NCName</A> 
      ":" "*")<BR>| ("*" ":" <A 
      href="REC-xquery-20070123.htm#prod-xquery-NCName">NCName</A>)</CODE></TD>
    <TD><I>/* <A 
      href="REC-xquery-20070123.htm#ws-explicit">ws: 
      explicit</A> */</I></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-FilterExpr 
      name=prod-xquery-FilterExpr></A>[81]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-FilterExpr">FilterExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-PrimaryExpr">PrimaryExpr</A> 
      <A 
      href="REC-xquery-20070123.htm#prod-xquery-PredicateList">PredicateList</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-PredicateList 
      name=prod-xquery-PredicateList></A>[82]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-PredicateList">PredicateList</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-Predicate">Predicate</A>*</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-Predicate 
      name=prod-xquery-Predicate></A>[83]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-Predicate">Predicate</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"[" <A 
      href="REC-xquery-20070123.htm#prod-xquery-Expr">Expr</A> 
      "]"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-PrimaryExpr 
      name=prod-xquery-PrimaryExpr></A>[84]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-PrimaryExpr">PrimaryExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-Literal">Literal</A> 
      | <A 
      href="REC-xquery-20070123.htm#prod-xquery-VarRef">VarRef</A> 
      | <A 
      href="REC-xquery-20070123.htm#prod-xquery-ParenthesizedExpr">ParenthesizedExpr</A> 
      | <A 
      href="REC-xquery-20070123.htm#prod-xquery-ContextItemExpr">ContextItemExpr</A> 
      | <A 
      href="REC-xquery-20070123.htm#prod-xquery-FunctionCall">FunctionCall</A> 
      | <A 
      href="REC-xquery-20070123.htm#prod-xquery-OrderedExpr">OrderedExpr</A> 
      | <A 
      href="REC-xquery-20070123.htm#prod-xquery-UnorderedExpr">UnorderedExpr</A> 
      | <A 
      href="REC-xquery-20070123.htm#prod-xquery-Constructor">Constructor</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-Literal 
      name=prod-xquery-Literal></A>[85]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-Literal">Literal</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-NumericLiteral">NumericLiteral</A> 
      | <A 
      href="REC-xquery-20070123.htm#prod-xquery-StringLiteral">StringLiteral</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-NumericLiteral 
      name=prod-xquery-NumericLiteral></A>[86]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-NumericLiteral">NumericLiteral</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-IntegerLiteral">IntegerLiteral</A> 
      | <A 
      href="REC-xquery-20070123.htm#prod-xquery-DecimalLiteral">DecimalLiteral</A> 
      | <A 
      href="REC-xquery-20070123.htm#prod-xquery-DoubleLiteral">DoubleLiteral</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-VarRef 
    name=prod-xquery-VarRef></A>[87]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-VarRef">VarRef</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"$" <A 
      href="REC-xquery-20070123.htm#prod-xquery-VarName">VarName</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-VarName 
      name=prod-xquery-VarName></A>[88]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-VarName">VarName</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-QName">QName</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-ParenthesizedExpr 
      name=prod-xquery-ParenthesizedExpr></A>[89]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-ParenthesizedExpr">ParenthesizedExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"(" <A 
      href="REC-xquery-20070123.htm#prod-xquery-Expr">Expr</A>? 
      ")"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-ContextItemExpr 
      name=prod-xquery-ContextItemExpr></A>[90]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-ContextItemExpr">ContextItemExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"."</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-OrderedExpr 
      name=prod-xquery-OrderedExpr></A>[91]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-OrderedExpr">OrderedExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"ordered" "{" <A 
      href="REC-xquery-20070123.htm#prod-xquery-Expr">Expr</A> 
      "}"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-UnorderedExpr 
      name=prod-xquery-UnorderedExpr></A>[92]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-UnorderedExpr">UnorderedExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"unordered" "{" <A 
      href="REC-xquery-20070123.htm#prod-xquery-Expr">Expr</A> 
      "}"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-FunctionCall 
      name=prod-xquery-FunctionCall></A>[93]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-FunctionCall">FunctionCall</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-QName">QName</A> 
      "(" (<A 
      href="REC-xquery-20070123.htm#prod-xquery-ExprSingle">ExprSingle</A> 
      ("," <A 
      href="REC-xquery-20070123.htm#prod-xquery-ExprSingle">ExprSingle</A>)*)? 
      ")"</CODE></TD>
    <TD><I>/* <A 
      href="REC-xquery-20070123.htm#parse-note-reserved-function-names">xgs: 
      reserved-function-names</A> */</I></TD></TR>
  <TR vAlign=baseline>
    <TD></TD>
    <TD></TD>
    <TD></TD>
    <TD></TD>
    <TD><I>/* <A 
      href="REC-xquery-20070123.htm#parse-note-parens">gn: 
      parens</A> */</I></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-Constructor 
      name=prod-xquery-Constructor></A>[94]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-Constructor">Constructor</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-DirectConstructor">DirectConstructor</A><BR>| 
      <A 
      href="REC-xquery-20070123.htm#prod-xquery-ComputedConstructor">ComputedConstructor</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-DirectConstructor 
      name=prod-xquery-DirectConstructor></A>[95]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-DirectConstructor">DirectConstructor</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-DirElemConstructor">DirElemConstructor</A><BR>| 
      <A 
      href="REC-xquery-20070123.htm#prod-xquery-DirCommentConstructor">DirCommentConstructor</A><BR>| 
      <A 
      href="REC-xquery-20070123.htm#prod-xquery-DirPIConstructor">DirPIConstructor</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-DirElemConstructor 
      name=prod-xquery-DirElemConstructor></A>[96]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-DirElemConstructor">DirElemConstructor</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"&lt;" <A 
      href="REC-xquery-20070123.htm#prod-xquery-QName">QName</A> 
      <A 
      href="REC-xquery-20070123.htm#prod-xquery-DirAttributeList">DirAttributeList</A> 
      ("/&gt;" | ("&gt;" <A 
      href="REC-xquery-20070123.htm#prod-xquery-DirElemContent">DirElemContent</A>* 
      "&lt;/" <A 
      href="REC-xquery-20070123.htm#prod-xquery-QName">QName</A> 
      <A 
      href="REC-xquery-20070123.htm#prod-xquery-S">S</A>? 
      "&gt;"))</CODE></TD>
    <TD><I>/* <A 
      href="REC-xquery-20070123.htm#ws-explicit">ws: 
      explicit</A> */</I></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-DirAttributeList 
      name=prod-xquery-DirAttributeList></A>[97]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-DirAttributeList">DirAttributeList</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>(<A 
      href="REC-xquery-20070123.htm#prod-xquery-S">S</A> 
      (<A 
      href="REC-xquery-20070123.htm#prod-xquery-QName">QName</A> 
      <A 
      href="REC-xquery-20070123.htm#prod-xquery-S">S</A>? 
      "=" <A 
      href="REC-xquery-20070123.htm#prod-xquery-S">S</A>? 
      <A 
      href="REC-xquery-20070123.htm#prod-xquery-DirAttributeValue">DirAttributeValue</A>)?)*</CODE></TD>
    <TD><I>/* <A 
      href="REC-xquery-20070123.htm#ws-explicit">ws: 
      explicit</A> */</I></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-DirAttributeValue 
      name=prod-xquery-DirAttributeValue></A>[98]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-DirAttributeValue">DirAttributeValue</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>('"' (<A 
      href="REC-xquery-20070123.htm#prod-xquery-EscapeQuot">EscapeQuot</A> 
      | <A 
      href="REC-xquery-20070123.htm#prod-xquery-QuotAttrValueContent">QuotAttrValueContent</A>)* 
      '"')<BR>| ("'" (<A 
      href="REC-xquery-20070123.htm#prod-xquery-EscapeApos">EscapeApos</A> 
      | <A 
      href="REC-xquery-20070123.htm#prod-xquery-AposAttrValueContent">AposAttrValueContent</A>)* 
      "'")</CODE></TD>
    <TD><I>/* <A 
      href="REC-xquery-20070123.htm#ws-explicit">ws: 
      explicit</A> */</I></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-QuotAttrValueContent 
      name=prod-xquery-QuotAttrValueContent></A>[99]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-QuotAttrValueContent">QuotAttrValueContent</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-QuotAttrContentChar">QuotAttrContentChar</A><BR>| 
      <A 
      href="REC-xquery-20070123.htm#prod-xquery-CommonContent">CommonContent</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-AposAttrValueContent 
      name=prod-xquery-AposAttrValueContent></A>[100]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-AposAttrValueContent">AposAttrValueContent</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-AposAttrContentChar">AposAttrContentChar</A><BR>| 
      <A 
      href="REC-xquery-20070123.htm#prod-xquery-CommonContent">CommonContent</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-DirElemContent 
      name=prod-xquery-DirElemContent></A>[101]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-DirElemContent">DirElemContent</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-DirectConstructor">DirectConstructor</A><BR>| 
      <A 
      href="REC-xquery-20070123.htm#prod-xquery-CDataSection">CDataSection</A><BR>| 
      <A 
      href="REC-xquery-20070123.htm#prod-xquery-CommonContent">CommonContent</A><BR>| 
      <A 
      href="REC-xquery-20070123.htm#prod-xquery-ElementContentChar">ElementContentChar</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-CommonContent 
      name=prod-xquery-CommonContent></A>[102]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-CommonContent">CommonContent</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-PredefinedEntityRef">PredefinedEntityRef</A> 
      | <A 
      href="REC-xquery-20070123.htm#prod-xquery-CharRef">CharRef</A> 
      | "{{" | "}}" | <A 
      href="REC-xquery-20070123.htm#prod-xquery-EnclosedExpr">EnclosedExpr</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-DirCommentConstructor 
      name=prod-xquery-DirCommentConstructor></A>[103]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-DirCommentConstructor">DirCommentConstructor</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"&lt;!--" <A 
      href="REC-xquery-20070123.htm#prod-xquery-DirCommentContents">DirCommentContents</A> 
      "--&gt;"</CODE></TD>
    <TD><I>/* <A 
      href="REC-xquery-20070123.htm#ws-explicit">ws: 
      explicit</A> */</I></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-DirCommentContents 
      name=prod-xquery-DirCommentContents></A>[104]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-DirCommentContents">DirCommentContents</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>((<A 
      href="REC-xquery-20070123.htm#prod-xquery-Char">Char</A> 
      - '-') | ('-' (<A 
      href="REC-xquery-20070123.htm#prod-xquery-Char">Char</A> 
      - '-')))*</CODE></TD>
    <TD><I>/* <A 
      href="REC-xquery-20070123.htm#ws-explicit">ws: 
      explicit</A> */</I></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-DirPIConstructor 
      name=prod-xquery-DirPIConstructor></A>[105]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-DirPIConstructor">DirPIConstructor</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"&lt;?" <A 
      href="REC-xquery-20070123.htm#prod-xquery-PITarget">PITarget</A> 
      (<A 
      href="REC-xquery-20070123.htm#prod-xquery-S">S</A> 
      <A 
      href="REC-xquery-20070123.htm#prod-xquery-DirPIContents">DirPIContents</A>)? 
      "?&gt;"</CODE></TD>
    <TD><I>/* <A 
      href="REC-xquery-20070123.htm#ws-explicit">ws: 
      explicit</A> */</I></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-DirPIContents 
      name=prod-xquery-DirPIContents></A>[106]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-DirPIContents">DirPIContents</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>(<A 
      href="REC-xquery-20070123.htm#prod-xquery-Char">Char</A>* 
      - (Char* '?&gt;' Char*))</CODE></TD>
    <TD><I>/* <A 
      href="REC-xquery-20070123.htm#ws-explicit">ws: 
      explicit</A> */</I></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-CDataSection 
      name=prod-xquery-CDataSection></A>[107]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-CDataSection">CDataSection</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"&lt;![CDATA[" <A 
      href="REC-xquery-20070123.htm#prod-xquery-CDataSectionContents">CDataSectionContents</A> 
      "]]&gt;"</CODE></TD>
    <TD><I>/* <A 
      href="REC-xquery-20070123.htm#ws-explicit">ws: 
      explicit</A> */</I></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-CDataSectionContents 
      name=prod-xquery-CDataSectionContents></A>[108]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-CDataSectionContents">CDataSectionContents</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>(<A 
      href="REC-xquery-20070123.htm#prod-xquery-Char">Char</A>* 
      - (Char* ']]&gt;' Char*))</CODE></TD>
    <TD><I>/* <A 
      href="REC-xquery-20070123.htm#ws-explicit">ws: 
      explicit</A> */</I></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-ComputedConstructor 
      name=prod-xquery-ComputedConstructor></A>[109]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-ComputedConstructor">ComputedConstructor</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-CompDocConstructor">CompDocConstructor</A><BR>| 
      <A 
      href="REC-xquery-20070123.htm#prod-xquery-CompElemConstructor">CompElemConstructor</A><BR>| 
      <A 
      href="REC-xquery-20070123.htm#prod-xquery-CompAttrConstructor">CompAttrConstructor</A><BR>| 
      <A 
      href="REC-xquery-20070123.htm#prod-xquery-CompTextConstructor">CompTextConstructor</A><BR>| 
      <A 
      href="REC-xquery-20070123.htm#prod-xquery-CompCommentConstructor">CompCommentConstructor</A><BR>| 
      <A 
      href="REC-xquery-20070123.htm#prod-xquery-CompPIConstructor">CompPIConstructor</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-CompDocConstructor 
      name=prod-xquery-CompDocConstructor></A>[110]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-CompDocConstructor">CompDocConstructor</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"document" "{" <A 
      href="REC-xquery-20070123.htm#prod-xquery-Expr">Expr</A> 
      "}"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-CompElemConstructor 
      name=prod-xquery-CompElemConstructor></A>[111]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-CompElemConstructor">CompElemConstructor</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"element" (<A 
      href="REC-xquery-20070123.htm#prod-xquery-QName">QName</A> 
      | ("{" <A 
      href="REC-xquery-20070123.htm#prod-xquery-Expr">Expr</A> 
      "}")) "{" <A 
      href="REC-xquery-20070123.htm#prod-xquery-ContentExpr">ContentExpr</A>? 
      "}"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-ContentExpr 
      name=prod-xquery-ContentExpr></A>[112]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-ContentExpr">ContentExpr</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-Expr">Expr</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-CompAttrConstructor 
      name=prod-xquery-CompAttrConstructor></A>[113]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-CompAttrConstructor">CompAttrConstructor</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"attribute" (<A 
      href="REC-xquery-20070123.htm#prod-xquery-QName">QName</A> 
      | ("{" <A 
      href="REC-xquery-20070123.htm#prod-xquery-Expr">Expr</A> 
      "}")) "{" <A 
      href="REC-xquery-20070123.htm#prod-xquery-Expr">Expr</A>? 
      "}"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-CompTextConstructor 
      name=prod-xquery-CompTextConstructor></A>[114]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-CompTextConstructor">CompTextConstructor</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"text" "{" <A 
      href="REC-xquery-20070123.htm#prod-xquery-Expr">Expr</A> 
      "}"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-CompCommentConstructor 
      name=prod-xquery-CompCommentConstructor></A>[115]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-CompCommentConstructor">CompCommentConstructor</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"comment" "{" <A 
      href="REC-xquery-20070123.htm#prod-xquery-Expr">Expr</A> 
      "}"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-CompPIConstructor 
      name=prod-xquery-CompPIConstructor></A>[116]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-CompPIConstructor">CompPIConstructor</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"processing-instruction" (<A 
      href="REC-xquery-20070123.htm#prod-xquery-NCName">NCName</A> 
      | ("{" <A 
      href="REC-xquery-20070123.htm#prod-xquery-Expr">Expr</A> 
      "}")) "{" <A 
      href="REC-xquery-20070123.htm#prod-xquery-Expr">Expr</A>? 
      "}"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-SingleType 
      name=prod-xquery-SingleType></A>[117]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-SingleType">SingleType</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-AtomicType">AtomicType</A> 
      "?"?</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-TypeDeclaration 
      name=prod-xquery-TypeDeclaration></A>[118]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-TypeDeclaration">TypeDeclaration</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"as" <A 
      href="REC-xquery-20070123.htm#prod-xquery-SequenceType">SequenceType</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-SequenceType 
      name=prod-xquery-SequenceType></A>[119]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-SequenceType">SequenceType</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>("empty-sequence" "(" ")")<BR>| (<A 
      href="REC-xquery-20070123.htm#prod-xquery-ItemType">ItemType</A> 
      <A 
      href="REC-xquery-20070123.htm#prod-xquery-OccurrenceIndicator">OccurrenceIndicator</A>?)</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-OccurrenceIndicator 
      name=prod-xquery-OccurrenceIndicator></A>[120]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-OccurrenceIndicator">OccurrenceIndicator</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"?" | "*" | "+"</CODE></TD>
    <TD><I>/* <A 
      href="REC-xquery-20070123.htm#parse-note-occurrence-indicators">xgs: 
      occurrence-indicators</A> */</I></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-ItemType 
      name=prod-xquery-ItemType></A>[121]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-ItemType">ItemType</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-KindTest">KindTest</A> 
      | ("item" "(" ")") | <A 
      href="REC-xquery-20070123.htm#prod-xquery-AtomicType">AtomicType</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-AtomicType 
      name=prod-xquery-AtomicType></A>[122]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-AtomicType">AtomicType</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-QName">QName</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-KindTest 
      name=prod-xquery-KindTest></A>[123]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-KindTest">KindTest</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-DocumentTest">DocumentTest</A><BR>| 
      <A 
      href="REC-xquery-20070123.htm#prod-xquery-ElementTest">ElementTest</A><BR>| 
      <A 
      href="REC-xquery-20070123.htm#prod-xquery-AttributeTest">AttributeTest</A><BR>| 
      <A 
      href="REC-xquery-20070123.htm#prod-xquery-SchemaElementTest">SchemaElementTest</A><BR>| 
      <A 
      href="REC-xquery-20070123.htm#prod-xquery-SchemaAttributeTest">SchemaAttributeTest</A><BR>| 
      <A 
      href="REC-xquery-20070123.htm#prod-xquery-PITest">PITest</A><BR>| 
      <A 
      href="REC-xquery-20070123.htm#prod-xquery-CommentTest">CommentTest</A><BR>| 
      <A 
      href="REC-xquery-20070123.htm#prod-xquery-TextTest">TextTest</A><BR>| 
      <A 
      href="REC-xquery-20070123.htm#prod-xquery-AnyKindTest">AnyKindTest</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-AnyKindTest 
      name=prod-xquery-AnyKindTest></A>[124]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-AnyKindTest">AnyKindTest</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"node" "(" ")"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-DocumentTest 
      name=prod-xquery-DocumentTest></A>[125]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-DocumentTest">DocumentTest</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"document-node" "(" (<A 
      href="REC-xquery-20070123.htm#prod-xquery-ElementTest">ElementTest</A> 
      | <A 
      href="REC-xquery-20070123.htm#prod-xquery-SchemaElementTest">SchemaElementTest</A>)? 
      ")"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-TextTest 
      name=prod-xquery-TextTest></A>[126]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-TextTest">TextTest</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"text" "(" ")"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-CommentTest 
      name=prod-xquery-CommentTest></A>[127]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-CommentTest">CommentTest</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"comment" "(" ")"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-PITest 
    name=prod-xquery-PITest></A>[128]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-PITest">PITest</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"processing-instruction" "(" (<A 
      href="REC-xquery-20070123.htm#prod-xquery-NCName">NCName</A> 
      | <A 
      href="REC-xquery-20070123.htm#prod-xquery-StringLiteral">StringLiteral</A>)? 
      ")"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-AttributeTest 
      name=prod-xquery-AttributeTest></A>[129]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-AttributeTest">AttributeTest</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"attribute" "(" (<A 
      href="REC-xquery-20070123.htm#prod-xquery-AttribNameOrWildcard">AttribNameOrWildcard</A> 
      ("," <A 
      href="REC-xquery-20070123.htm#prod-xquery-TypeName">TypeName</A>)?)? 
      ")"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-AttribNameOrWildcard 
      name=prod-xquery-AttribNameOrWildcard></A>[130]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-AttribNameOrWildcard">AttribNameOrWildcard</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-AttributeName">AttributeName</A> 
      | "*"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-SchemaAttributeTest 
      name=prod-xquery-SchemaAttributeTest></A>[131]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-SchemaAttributeTest">SchemaAttributeTest</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"schema-attribute" "(" <A 
      href="REC-xquery-20070123.htm#prod-xquery-AttributeDeclaration">AttributeDeclaration</A> 
      ")"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-AttributeDeclaration 
      name=prod-xquery-AttributeDeclaration></A>[132]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-AttributeDeclaration">AttributeDeclaration</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-AttributeName">AttributeName</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-ElementTest 
      name=prod-xquery-ElementTest></A>[133]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-ElementTest">ElementTest</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"element" "(" (<A 
      href="REC-xquery-20070123.htm#prod-xquery-ElementNameOrWildcard">ElementNameOrWildcard</A> 
      ("," <A 
      href="REC-xquery-20070123.htm#prod-xquery-TypeName">TypeName</A> 
      "?"?)?)? ")"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-ElementNameOrWildcard 
      name=prod-xquery-ElementNameOrWildcard></A>[134]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-ElementNameOrWildcard">ElementNameOrWildcard</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-ElementName">ElementName</A> 
      | "*"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-SchemaElementTest 
      name=prod-xquery-SchemaElementTest></A>[135]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-SchemaElementTest">SchemaElementTest</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"schema-element" "(" <A 
      href="REC-xquery-20070123.htm#prod-xquery-ElementDeclaration">ElementDeclaration</A> 
      ")"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-ElementDeclaration 
      name=prod-xquery-ElementDeclaration></A>[136]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-ElementDeclaration">ElementDeclaration</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-ElementName">ElementName</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-AttributeName 
      name=prod-xquery-AttributeName></A>[137]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-AttributeName">AttributeName</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-QName">QName</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-ElementName 
      name=prod-xquery-ElementName></A>[138]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-ElementName">ElementName</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-QName">QName</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-TypeName 
      name=prod-xquery-TypeName></A>[139]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-TypeName">TypeName</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-QName">QName</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-URILiteral 
      name=prod-xquery-URILiteral></A>[140]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-URILiteral">URILiteral</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-StringLiteral">StringLiteral</A></CODE></TD></TR></TBODY></TABLE>
<DIV class=div3>
<H4><A id=EBNFNotation name=EBNFNotation></A>A.1.1 Notation</H4>
<P>The following definitions will be helpful in defining precisely this 
exposition.</P>
<P>[<A id=symbol title=symbol name=symbol>Definition</A>: Each rule in the 
grammar defines one <B>symbol</B>, using the following format:</P>
<DIV class=exampleInner><PRE>symbol ::= expression
</PRE></DIV>
<P>]</P>
<P>[<A id=terminal title=terminal name=terminal>Definition</A>: A 
<B>terminal</B> is a symbol or string or pattern that can appear in the 
right-hand side of a rule, but never appears on the left hand side in the main 
grammar, although it may appear on the left-hand side of a rule in the grammar 
for terminals.] The following constructs are used to match strings of one or 
more characters in a terminal:</P>
<DL>
  <DT class=label>[a-zA-Z] 
  <DD>
  <P>matches any <A 
  href="REC-xquery-20070123.htm#prod-xquery-Char">Char</A> 
  with a value in the range(s) indicated (inclusive).</P>
  <DT class=label>[abc] 
  <DD>
  <P>matches any <A 
  href="REC-xquery-20070123.htm#prod-xquery-Char">Char</A> 
  with a value among the characters enumerated.</P>
  <DT class=label>[^abc] 
  <DD>
  <P>matches any <A 
  href="REC-xquery-20070123.htm#prod-xquery-Char">Char</A> 
  with a value not among the characters given.</P>
  <DT class=label>"string" 
  <DD>
  <P>matches the sequence of characters that appear inside the double 
quotes.</P>
  <DT class=label>'string' 
  <DD>
  <P>matches the sequence of characters that appear inside the single 
quotes.</P>
  <DT class=label>[http://www.w3.org/TR/REC-example/#NT-Example] 
  <DD>
  <P>matches any string matched by the production defined in the external 
  specification as per the provided reference.</P></DD></DL>
<P>Patterns (including the above constructs) can be combined with grammatical 
operators to form more complex patterns, matching more complex sets of character 
strings. In the examples that follow, A and B represent (sub-)patterns.</P>
<DL>
  <DT class=label>(A) 
  <DD>
  <P><CODE>A</CODE> is treated as a unit and may be combined as described in 
  this list.</P>
  <DT class=label>A? 
  <DD>
  <P>matches <CODE>A</CODE> or nothing; optional <CODE>A</CODE>.</P>
  <DT class=label>A B 
  <DD>
  <P>matches <CODE>A</CODE> followed by <CODE>B</CODE>. This operator has higher 
  precedence than alternation; thus <CODE>A B | C D</CODE> is identical to 
  <CODE>(A B) | (C D)</CODE>.</P>
  <DT class=label>A | B 
  <DD>
  <P>matches <CODE>A</CODE> or <CODE>B</CODE> but not both.</P>
  <DT class=label>A - B 
  <DD>
  <P>matches any string that matches <CODE>A</CODE> but does not match 
  <CODE>B</CODE>.</P>
  <DT class=label>A+ 
  <DD>
  <P>matches one or more occurrences of <CODE>A</CODE>. Concatenation has higher 
  precedence than alternation; thus <CODE>A+ | B+</CODE> is identical to 
  <CODE>(A+) | (B+)</CODE>.</P></DD></DL>
<DL>
  <DT class=label>A* 
  <DD>
  <P>matches zero or more occurrences of <CODE>A</CODE>. Concatenation has 
  higher precedence than alternation; thus <CODE>A* | B*</CODE> is identical to 
  <CODE>(A*) | (B*)</CODE></P></DD></DL></DIV>
<DIV class=div3>
<H4><A id=extra-grammatical-constraints 
name=extra-grammatical-constraints></A>A.1.2 Extra-grammatical Constraints</H4>
<P>This section contains constraints on the EBNF productions, which are required 
to parse legal sentences. The notes below are referenced from the right side of 
the production, with the notation: <EM>/* xgc: &lt;id&gt; */</EM>.</P>
<DIV class=constraint>
<P class=prefix><A id=parse-note-leading-lone-slash 
name=parse-note-leading-lone-slash></A><B>Constraint: leading-lone-slash</B></P>
<P>A single slash may appear either as a complete path expression or as the 
first part of a path expression in which it is followed by a <A 
href="REC-xquery-20070123.htm#doc-xquery-RelativePathExpr">RelativePathExpr</A>, 
which can take the form of a <A 
href="REC-xquery-20070123.htm#doc-xquery-NameTest">NameTest</A> 
("*" or a QName). In contexts where operators like "*", "union", etc., can 
occur, parsers may have difficulty distinguishing operators from NameTests. For 
example, without lookahead the first part of the expression "/ * 5", for example 
is easily taken to be a complete expression, "/ *", which has a very different 
interpretation (the child nodes of "/").</P>
<P>To reduce the need for lookahead, therefore, if the token immediately 
following a slash is "*" or a keyword, then the slash must be the beginning, but 
not the entirety, of a <A 
href="REC-xquery-20070123.htm#doc-xquery-PathExpr">PathExpr</A> 
(and the following token must be a <A 
href="REC-xquery-20070123.htm#doc-xquery-NameTest">NameTest</A>, 
not an operator).</P>
<P>A single slash may be used as the left-hand argument of an operator by 
parenthesizing it: <CODE>(/) * 5</CODE>. The expression <CODE>5 * /</CODE>, on 
the other hand, is legal without parentheses.</P></DIV>
<DIV class=constraint>
<P class=prefix><A id=parse-note-xml-version 
name=parse-note-xml-version></A><B>Constraint: xml-version</B></P>
<P>An implementation's choice to support the <A 
href="REC-xquery-20070123.htm#XML">[XML 1.0]</A> and <A 
href="REC-xquery-20070123.htm#XMLNAMES">[XML Names]</A>, 
or <A href="REC-xquery-20070123.htm#XML1.1">[XML 1.1]</A> 
and <A href="REC-xquery-20070123.htm#XMLNAMES11">[XML 
Names 1.1]</A> lexical specification determines the external document from which 
to obtain the definition for this production. The EBNF only has references to 
the 1.0 versions. In some cases, the XML 1.0 and XML 1.1 definitions may be 
exactly the same. Also please note that these external productions follow the 
whitespace rules of their respective specifications, and not the rules of this 
specification, in particular <A 
href="REC-xquery-20070123.htm#DefaultWhitespaceHandling"><B>A.2.4.1 
Default Whitespace Handling</B></A>. Thus <CODE>prefix : localname</CODE> is not 
a valid QName for purposes of this specification, just as it is not permitted in 
a XML document. Also, comments are not permissible on either side of the colon. 
Also extra-grammatical constraints such as well-formedness constraints must be 
taken into account.</P></DIV>
<DIV class=constraint>
<P class=prefix><A id=parse-note-reserved-function-names 
name=parse-note-reserved-function-names></A><B>Constraint: 
reserved-function-names</B></P>
<P>Unprefixed function names spelled the same way as language keywords could 
make the language harder to recognize. For instance, <CODE>if(foo)</CODE> could 
be taken either as a <A 
href="REC-xquery-20070123.htm#doc-xquery-FunctionCall">FunctionCall</A> 
or as the beginning of an <A 
href="REC-xquery-20070123.htm#doc-xquery-IfExpr">IfExpr</A>. 
Therefore it is not legal syntax for a user to invoke functions with unprefixed 
names which match any of the names in <A 
href="REC-xquery-20070123.htm#id-reserved-fn-names"><B>A.3 
Reserved Function Names</B></A>.</P>
<P>A function named "if" can be called by binding its namespace to a prefix and 
using the prefixed form: "library:if(foo)" instead of "if(foo)".</P></DIV>
<DIV class=constraint>
<P class=prefix><A id=parse-note-occurrence-indicators 
name=parse-note-occurrence-indicators></A><B>Constraint: 
occurrence-indicators</B></P>
<P>As written, the grammar in <A 
href="REC-xquery-20070123.htm#nt-bnf"><B>A XQuery 
Grammar</B></A> is ambiguous for some forms using the '+' and '*' Kleene 
operators. The ambiguity is resolved as follows: these operators are tightly 
bound to the <A 
href="REC-xquery-20070123.htm#doc-xquery-SequenceType">SequenceType</A> 
expression, and have higher precedence than other uses of these symbols. Any 
occurrence of '+' and '*', as well as '?', following a sequence type is assumed 
to be an occurrence indicator. That is, a "+", "*", or "?" immediately following 
an <A 
href="REC-xquery-20070123.htm#doc-xquery-ItemType">ItemType</A> 
must be an <A 
href="REC-xquery-20070123.htm#doc-xquery-OccurrenceIndicator">OccurrenceIndicator</A>. 
Thus, <CODE>4 treat as item() + - 5</CODE> must be interpreted as <CODE>(4 treat 
as item()+) - 5</CODE>, taking the '+' as an OccurrenceIndicator and the '-' as 
a subtraction operator. To force the interpretation of "+" as an addition 
operator (and the corresponding interpretation of the "-" as a unary minus), 
parentheses may be used: the form <CODE>(4 treat as item()) + -5</CODE> 
surrounds the <A 
href="REC-xquery-20070123.htm#doc-xquery-SequenceType">SequenceType</A> 
expression with parentheses and leads to the desired interpretation.</P>
<P>This rule has as a consequence that certain forms which would otherwise be 
legal and unambiguous are not recognized: in "4 treat as item() + 5", the "+" is 
taken as an <A 
href="REC-xquery-20070123.htm#doc-xquery-OccurrenceIndicator">OccurrenceIndicator</A>, 
and not as an operator, which means this is not a legal 
expression.</P></DIV></DIV>
<DIV class=div3>
<H4><A id=notes-on-parsing name=notes-on-parsing></A>A.1.3 Grammar Notes</H4>
<P>This section contains general notes on the EBNF productions, which may be 
helpful in understanding how to interpret and implement the EBNF. These notes 
are not normative. The notes below are referenced from the right side of the 
production, with the notation: <EM>/* gn: &lt;id&gt; */</EM>.</P>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<DL>
  <DT class=label><A id=parse-note-parens 
  name=parse-note-parens></A>grammar-note: parens 
  <DD>
  <P>Look-ahead is required to distinguish <A 
  href="REC-xquery-20070123.htm#doc-xquery-FunctionCall">FunctionCall</A> 
  from a QName or keyword followed by a <SPAN class=xquery><SPAN class=xquery><A 
  href="REC-xquery-20070123.htm#doc-xquery-Pragma">Pragma</A> 
  or</SPAN></SPAN> <A 
  href="REC-xquery-20070123.htm#doc-xquery-Comment">Comment</A>. 
  For example: <CODE>address (: this may be empty :)</CODE> may be mistaken for 
  a call to a function named "address" unless this lookahead is employed. 
  Another example is <CODE>for (: whom the bell :) $tolls in 3 return 
  $tolls</CODE>, where the keyword "for" must not be mistaken for a function 
  name.</P>
  <DT class=label><A id=parse-note-comments 
  name=parse-note-comments></A>grammar-note: comments 
  <DD>
  <P>Comments are allowed everywhere that <A title="ignorable whitespace" 
  href="REC-xquery-20070123.htm#IgnorableWhitespace">ignorable 
  whitespace</A> is allowed, and the <A 
  href="REC-xquery-20070123.htm#doc-xquery-Comment">Comment</A> 
  symbol does not explicity appear on the right-hand side of the grammar (except 
  in its own production). See <A 
  href="REC-xquery-20070123.htm#DefaultWhitespaceHandling"><B>A.2.4.1 
  Default Whitespace Handling</B></A>. <SPAN class=xquery><SPAN 
  class=xquery>Note that comments are not allowed in direct constructor content, 
  though they are allowed in nested <A 
  href="REC-xquery-20070123.htm#doc-xquery-EnclosedExpr">EnclosedExprs</A>.</SPAN></SPAN></P>
  <P>A comment can contain nested comments, as long as all "(:" and ":)" 
  patterns are balanced, no matter where they occur within the outer 
comment.</P>
  <DIV class=note>
  <P class=prefix><B>Note:</B></P>
  <P>Lexical analysis may typically handle nested comments by incrementing a 
  counter for each "(:" pattern, and decrementing the counter for each ":)" 
  pattern. The comment does not terminate until the counter is back to 
  zero.</P></DIV>
  <P>Some illustrative examples:</P>
  <UL>
    <LI>
    <P><CODE>(: commenting out a (: comment :) may be confusing, but often 
    helpful :)</CODE> is a legal Comment, since balanced nesting of comments is 
    allowed.</P>
    <LI>
    <P><CODE>"this is just a string :)"</CODE> is a legal expression. However, 
    <CODE>(: "this is just a string :)" :)</CODE> will cause a syntax error. 
    Likewise, <CODE>"this is another string (:"</CODE> is a legal expression, 
    but <CODE>(: "this is another string (:" :)</CODE> will cause a syntax 
    error. It is a limitation of nested comments that literal content can cause 
    unbalanced nesting of comments.</P>
    <LI>
    <P><CODE>for (: set up loop :) $i in $x return $i</CODE> is syntactically 
    legal, ignoring the comment.</P>
    <LI>
    <P><CODE>5 instance (: strange place for a comment :) of xs:integer</CODE> 
    is also syntactically legal.</P>
    <LI class=xquery>
    <P><CODE>&lt;eg (: an example:)&gt;{$i//title}&lt;/eg&gt;</CODE> is not 
    syntactically legal.</P>
    <LI class=xquery>
    <P><CODE>&lt;eg&gt; (: an example:) &lt;/eg&gt;</CODE> is syntactically 
    legal, but the characters that look like a comment are in fact literal 
    element content.</P></LI></UL></DD></DL></DIV></DIV></DIV>
<DIV class=div2>
<H3><A id=lexical-structure name=lexical-structure></A>A.2 Lexical 
structure</H3>
<P>The terminal symbols assumed by the grammar above are described in this 
section.</P>
<P>Quoted strings appearing in production rules are terminal symbols.</P>
<P>Other terminal symbols are defined in <A 
href="REC-xquery-20070123.htm#terminal-symbols"><B>A.2.1 
Terminal Symbols</B></A>.</P>
<DIV class=xquery>
<P class=xquery>It is <A title="implementation defined" 
href="REC-xquery-20070123.htm#dt-implementation-defined">implementation-defined</A> 
whether the lexical rules of <A 
href="REC-xquery-20070123.htm#XML">[XML 1.0]</A> and <A 
href="REC-xquery-20070123.htm#XMLNAMES">[XML Names]</A> 
are followed, or alternatively, the lexical rules of <A 
href="REC-xquery-20070123.htm#XML1.1">[XML 1.1]</A> and 
<A href="REC-xquery-20070123.htm#XMLNAMES11">[XML Names 
1.1]</A> are followed. Implementations that support the full <A 
href="REC-xquery-20070123.htm#XML1.1">[XML 1.1]</A> 
character set <A title=should 
href="REC-xquery-20070123.htm#should">SHOULD</A>, for 
purposes of interoperability, provide a mode that follows only the <A 
href="REC-xquery-20070123.htm#XML">[XML 1.0]</A> and <A 
href="REC-xquery-20070123.htm#XMLNAMES">[XML Names]</A> 
lexical rules.</P></DIV>
<P>When tokenizing, the longest possible match that is valid in the current 
context is used.</P>
<P>All keywords are case sensitive. Keywords are not reserved—that is, any QName 
may duplicate a keyword except as noted in <A 
href="REC-xquery-20070123.htm#id-reserved-fn-names"><B>A.3 
Reserved Function Names</B></A>.</P>
<DIV class=div3>
<H4><A id=terminal-symbols name=terminal-symbols></A>A.2.1 Terminal Symbols</H4>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-IntegerLiteral 
      name=prod-xquery-IntegerLiteral></A>[141]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-IntegerLiteral">IntegerLiteral</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-Digits">Digits</A></CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-DecimalLiteral 
      name=prod-xquery-DecimalLiteral></A>[142]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-DecimalLiteral">DecimalLiteral</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>("." <A 
      href="REC-xquery-20070123.htm#prod-xquery-Digits">Digits</A>) 
      | (<A 
      href="REC-xquery-20070123.htm#prod-xquery-Digits">Digits</A> 
      "." [0-9]*)</CODE></TD>
    <TD><I>/* <A 
      href="REC-xquery-20070123.htm#ws-explicit">ws: 
      explicit</A> */</I></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-DoubleLiteral 
      name=prod-xquery-DoubleLiteral></A>[143]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-DoubleLiteral">DoubleLiteral</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>(("." <A 
      href="REC-xquery-20070123.htm#prod-xquery-Digits">Digits</A>) 
      | (<A 
      href="REC-xquery-20070123.htm#prod-xquery-Digits">Digits</A> 
      ("." [0-9]*)?)) [eE] [+-]? <A 
      href="REC-xquery-20070123.htm#prod-xquery-Digits">Digits</A></CODE></TD>
    <TD><I>/* <A 
      href="REC-xquery-20070123.htm#ws-explicit">ws: 
      explicit</A> */</I></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-StringLiteral 
      name=prod-xquery-StringLiteral></A>[144]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-StringLiteral">StringLiteral</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>('"' (<A 
      href="REC-xquery-20070123.htm#prod-xquery-PredefinedEntityRef">PredefinedEntityRef</A> 
      | <A 
      href="REC-xquery-20070123.htm#prod-xquery-CharRef">CharRef</A> 
      | <A 
      href="REC-xquery-20070123.htm#prod-xquery-EscapeQuot">EscapeQuot</A> 
      | [^"&amp;])* '"') | ("'" (<A 
      href="REC-xquery-20070123.htm#prod-xquery-PredefinedEntityRef">PredefinedEntityRef</A> 
      | <A 
      href="REC-xquery-20070123.htm#prod-xquery-CharRef">CharRef</A> 
      | <A 
      href="REC-xquery-20070123.htm#prod-xquery-EscapeApos">EscapeApos</A> 
      | [^'&amp;])* "'")</CODE></TD>
    <TD><I>/* <A 
      href="REC-xquery-20070123.htm#ws-explicit">ws: 
      explicit</A> */</I></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-PredefinedEntityRef 
      name=prod-xquery-PredefinedEntityRef></A>[145]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-PredefinedEntityRef">PredefinedEntityRef</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"&amp;" ("lt" | "gt" | "amp" | "quot" | "apos") ";"</CODE></TD>
    <TD><I>/* <A 
      href="REC-xquery-20070123.htm#ws-explicit">ws: 
      explicit</A> */</I></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-EscapeQuot 
      name=prod-xquery-EscapeQuot></A>[146]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-EscapeQuot">EscapeQuot</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>'""'</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-EscapeApos 
      name=prod-xquery-EscapeApos></A>[147]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-EscapeApos">EscapeApos</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"''"</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-ElementContentChar 
      name=prod-xquery-ElementContentChar></A>[148]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-ElementContentChar">ElementContentChar</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-Char">Char</A> 
      - [{}&lt;&amp;]</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-QuotAttrContentChar 
      name=prod-xquery-QuotAttrContentChar></A>[149]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-QuotAttrContentChar">QuotAttrContentChar</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-Char">Char</A> 
      - ["{}&lt;&amp;]</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-AposAttrContentChar 
      name=prod-xquery-AposAttrContentChar></A>[150]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-AposAttrContentChar">AposAttrContentChar</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#prod-xquery-Char">Char</A> 
      - ['{}&lt;&amp;]</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-Comment 
      name=prod-xquery-Comment></A>[151]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-Comment">Comment</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>"(:" (<A 
      href="REC-xquery-20070123.htm#prod-xquery-CommentContents">CommentContents</A> 
      | <A 
      href="REC-xquery-20070123.htm#prod-xquery-Comment">Comment</A>)* 
      ":)"</CODE></TD>
    <TD><I>/* <A 
      href="REC-xquery-20070123.htm#ws-explicit">ws: 
      explicit</A> */</I></TD></TR>
  <TR vAlign=baseline>
    <TD></TD>
    <TD></TD>
    <TD></TD>
    <TD></TD>
    <TD><I>/* <A 
      href="REC-xquery-20070123.htm#parse-note-comments">gn: 
      comments</A> */</I></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-PITarget 
      name=prod-xquery-PITarget></A>[152]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>PITarget</CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="http://www.w3.org/TR/REC-xml/#NT-PITarget">[http://www.w3.org/TR/REC-xml#NT-PITarget]</A><SUP> 
      <SMALL>XML</SMALL></SUP></CODE></TD>
    <TD><I>/* <A 
      href="REC-xquery-20070123.htm#parse-note-xml-version">xgs: 
      xml-version</A> */</I></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-CharRef 
      name=prod-xquery-CharRef></A>[153]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>CharRef</CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="http://www.w3.org/TR/REC-xml/#NT-CharRef">[http://www.w3.org/TR/REC-xml#NT-CharRef]</A><SUP> 
      <SMALL>XML</SMALL></SUP></CODE></TD>
    <TD><I>/* <A 
      href="REC-xquery-20070123.htm#parse-note-xml-version">xgs: 
      xml-version</A> */</I></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-QName 
    name=prod-xquery-QName></A>[154]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>QName</CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="http://www.w3.org/TR/REC-xml-names/#NT-QName">[http://www.w3.org/TR/REC-xml-names/#NT-QName]</A><SUP> 
      <SMALL>Names</SMALL></SUP></CODE></TD>
    <TD><I>/* <A 
      href="REC-xquery-20070123.htm#parse-note-xml-version">xgs: 
      xml-version</A> */</I></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-NCName 
    name=prod-xquery-NCName></A>[155]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>NCName</CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="http://www.w3.org/TR/REC-xml-names/#NT-NCName">[http://www.w3.org/TR/REC-xml-names/#NT-NCName]</A><SUP> 
      <SMALL>Names</SMALL></SUP></CODE></TD>
    <TD><I>/* <A 
      href="REC-xquery-20070123.htm#parse-note-xml-version">xgs: 
      xml-version</A> */</I></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-S name=prod-xquery-S></A>[156]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>S</CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="http://www.w3.org/TR/REC-xml/#NT-S">[http://www.w3.org/TR/REC-xml#NT-S]</A><SUP> 
      <SMALL>XML</SMALL></SUP></CODE></TD>
    <TD><I>/* <A 
      href="REC-xquery-20070123.htm#parse-note-xml-version">xgs: 
      xml-version</A> */</I></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-Char 
    name=prod-xquery-Char></A>[157]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>Char</CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="http://www.w3.org/TR/REC-xml/#NT-Char">[http://www.w3.org/TR/REC-xml#NT-Char]</A><SUP> 
      <SMALL>XML</SMALL></SUP></CODE></TD>
    <TD><I>/* <A 
      href="REC-xquery-20070123.htm#parse-note-xml-version">xgs: 
      xml-version</A> */</I></TD></TR></TBODY></TABLE>
<P>The following symbols are used only in the definition of terminal symbols; 
they are not terminal symbols in the grammar of <A 
href="REC-xquery-20070123.htm#id-grammar"><B>A.1 
EBNF</B></A>.</P>
<TABLE class=scrap summary=Scrap>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-Digits 
    name=prod-xquery-Digits></A>[158]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-Digits">Digits</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>[0-9]+</CODE></TD></TR></TBODY>
  <TBODY>
  <TR vAlign=baseline>
    <TD><A id=prod-xquery-CommentContents 
      name=prod-xquery-CommentContents></A>[159]&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE><A 
      href="REC-xquery-20070123.htm#doc-xquery-CommentContents">CommentContents</A></CODE></TD>
    <TD>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</TD>
    <TD><CODE>(<A 
      href="REC-xquery-20070123.htm#prod-xquery-Char">Char</A>+ 
      - (Char* ('(:' | ':)') Char*))</CODE></TD></TR></TBODY></TABLE></DIV>
<DIV class=div3>
<H4><A id=id-terminal-delimitation name=id-terminal-delimitation></A>A.2.2 
Terminal Delimitation</H4>
<P>XQuery 1.0 expressions consist of <A 
href="REC-xquery-20070123.htm#terminal-symbols">terminal 
symbols</A> and <A title="symbol separators" 
href="REC-xquery-20070123.htm#symbolseparators">symbol 
separators</A>.</P>
<P>Terminal symbols that are not used exclusively in <A 
href="REC-xquery-20070123.htm#ws-explicit">/* ws: 
explicit */</A> productions are of two kinds: delimiting and non-delimiting.</P>
<P>[<A id=delimiting-token title="delimiting terminal symbol" 
name=delimiting-token>Definition</A>: The <B>delimiting terminal symbols</B> 
are: <A 
href="REC-xquery-20070123.htm#prod-xquery-S">S</A>, "-", 
(comma), (semi-colon), (colon), "::", ":=", "!=", "?", "?&gt;", "/", "//", 
"/&gt;", (dot), "..", <A 
href="REC-xquery-20070123.htm#prod-xquery-StringLiteral">StringLiteral</A>, 
"(", "(#", ")", "[", "]", "]]&gt;", "{", "}", "@", "$", "*", "#)", "+", "&lt;", 
"&lt;!--", "&lt;![CDATA[", "&lt;?", "&lt;/", "&lt;&lt;", "&lt;=", "=", "&gt;", 
"--&gt;", "&gt;=", "&gt;&gt;", "|"]</P>
<P>[<A id=non-delimiting-token title="non-delimiting terminal symbol" 
name=non-delimiting-token>Definition</A>: The <B>non-delimiting terminal 
symbols</B> are: <A 
href="REC-xquery-20070123.htm#prod-xquery-IntegerLiteral">IntegerLiteral</A>, 
<A 
href="REC-xquery-20070123.htm#prod-xquery-NCName">NCName</A>, 
<A 
href="REC-xquery-20070123.htm#prod-xquery-QName">QName</A>, 
<A 
href="REC-xquery-20070123.htm#prod-xquery-DecimalLiteral">DecimalLiteral</A>, 
<A 
href="REC-xquery-20070123.htm#prod-xquery-DoubleLiteral">DoubleLiteral</A>, 
"ancestor", "ancestor-or-self", "and", "as", "ascending", "at", "attribute", 
"base-uri", "boundary-space", "by", "case", "cast", "castable", "child", 
"collation", "comment", "construction", "copy-namespaces", "declare", "default", 
"descendant", "descendant-or-self", "descending", "div", "document", 
"document-node", "element", "else", "empty", "empty-sequence", "encoding", "eq", 
"every", "except", "external", "following", "following-sibling", "for", 
"function", "ge", "greatest", "gt", "idiv", "if", "import", "in", "inherit", 
"instance", "intersect", "is", "item", "lax", "le", "least", "let", "lt", "mod", 
"module", "namespace", "ne", "node", "no-inherit", "no-preserve", "of", 
"option", "or", "order", "ordered", "ordering", "parent", "preceding", 
"preceding-sibling", "preserve", "processing-instruction", "return", 
"satisfies", "schema", "schema-attribute", "schema-element", "self", "some", 
"stable", "strict", "strip", "text", "then", "to", "treat", "typeswitch", 
"union", "unordered", "validate", "variable", "version", "where", "xquery"]</P>
<P>[<A id=symbolseparators title="symbol separators" 
name=symbolseparators>Definition</A>: <A title=whitespace 
href="REC-xquery-20070123.htm#Whitespace">Whitespace</A> 
and <A 
href="REC-xquery-20070123.htm#doc-xquery-Comment">Comments</A> 
function as <B>symbol separators</B>. For the most part, they are not mentioned 
in the grammar, and may occur between any two terminal symbols mentioned in the 
grammar, except where that is forbidden by the <A 
href="REC-xquery-20070123.htm#ws-explicit">/* ws: 
explicit */</A> annotation in the EBNF, or by the <A 
href="REC-xquery-20070123.htm#parse-note-xml-version">/* 
xgs: xml-version */</A> annotation. ]</P>
<P>It is customary to separate consecutive terminal symbols by <A 
title=whitespace 
href="REC-xquery-20070123.htm#Whitespace">whitespace</A> 
and <A 
href="REC-xquery-20070123.htm#doc-xquery-Comment">Comments</A>, 
but this is required only when otherwise two non-delimiting symbols would be 
adjacent to each other. There are two exceptions to this, that of "." and "-", 
which do require a <A title="symbol separators" 
href="REC-xquery-20070123.htm#symbolseparators">symbol 
separator</A> if they follow a QName or NCName. Also, "." requires a separator 
if it precedes or follows a numeric literal.</P></DIV>
<DIV class=div3>
<H4><A id=id-eol-handling name=id-eol-handling></A>A.2.3 End-of-Line 
Handling</H4>
<P>The XQuery processor must behave as if it normalized all line breaks on 
input, before parsing. The normalization should be done according to the choice 
to support either <A 
href="REC-xquery-20070123.htm#XML">[XML 1.0]</A> or <A 
href="REC-xquery-20070123.htm#XML1.1">[XML 1.1]</A> 
lexical processing.</P>
<DIV class=div4>
<H5><A id=id-xml10-eol-handling name=id-xml10-eol-handling></A>A.2.3.1 XML 1.0 
End-of-Line Handling</H5>
<P>For <A href="REC-xquery-20070123.htm#XML">[XML 
1.0]</A> processing, all of the following must be translated to a single #xA 
character:</P>
<OL class=enumar>
  <LI>
  <P>the two-character sequence #xD #xA</P>
  <LI>
  <P>any #xD character that is not immediately followed by 
#xA.</P></LI></OL></DIV>
<DIV class=div4>
<H5><A id=id-xml11-eol-handling name=id-xml11-eol-handling></A>A.2.3.2 XML 1.1 
End-of-Line Handling</H5>
<P>For <A href="REC-xquery-20070123.htm#XML1.1">[XML 
1.1]</A> processing, all of the following must be translated to a single #xA 
character:</P>
<OL class=enumar>
  <LI>
  <P>the two-character sequence #xD #xA</P>
  <LI>
  <P>the two-character sequence #xD #x85</P>
  <LI>
  <P>the single character #x85</P>
  <LI>
  <P>the single character #x2028</P>
  <LI>
  <P>any #xD character that is not immediately followed by #xA or 
#x85.</P></LI></OL>
<DIV class=xquery>
<P class=xquery>The characters #x85 and #x2028 cannot be reliably recognized and 
translated until the <A 
href="REC-xquery-20070123.htm#doc-xquery-VersionDecl">VersionDecl</A> 
declaration (if present) has been read.</P></DIV></DIV></DIV>
<DIV class=div3>
<H4><A id=whitespace-rules name=whitespace-rules></A>A.2.4 Whitespace Rules</H4>
<DIV class=div4>
<H5><A id=DefaultWhitespaceHandling name=DefaultWhitespaceHandling></A>A.2.4.1 
Default Whitespace Handling</H5>
<P>[<A id=Whitespace title=whitespace name=Whitespace>Definition</A>: A 
<B>whitespace</B> character is any of the characters defined by <A 
href="http://www.w3.org/TR/REC-xml#NT-S">[http://www.w3.org/TR/REC-xml#NT-S]</A>.]</P>
<P>[<A id=IgnorableWhitespace title="ignorable whitespace" 
name=IgnorableWhitespace>Definition</A>: <B>Ignorable whitespace</B> consists of 
any <A title=whitespace 
href="REC-xquery-20070123.htm#Whitespace">whitespace</A> 
characters that may occur between <A title=terminal 
href="REC-xquery-20070123.htm#terminal">terminals</A>, 
unless these characters occur in the context of a production marked with a <A 
href="REC-xquery-20070123.htm#ExplicitWhitespaceHandling">ws:explicit</A> 
annotation, in which case they can occur only where explicitly specified (see <A 
href="REC-xquery-20070123.htm#ExplicitWhitespaceHandling"><B>A.2.4.2 
Explicit Whitespace Handling</B></A>).] Ignorable whitespace characters are not 
significant to the semantics of an expression. Whitespace is allowed before the 
first terminal and after the last terminal of a module. Whitespace is allowed 
between any two <A title=terminal 
href="REC-xquery-20070123.htm#terminal">terminals</A>. <A 
href="REC-xquery-20070123.htm#doc-xquery-Comment">Comments</A> 
may also act as "whitespace" to prevent two adjacent terminals from being 
recognized as one. Some illustrative examples are as follows:</P>
<UL>
  <LI>
  <P><CODE>foo- foo</CODE> results in a syntax error. "foo-" would be recognized 
  as a QName.</P>
  <LI>
  <P><CODE>foo -foo</CODE> is syntactically equivalent to <CODE>foo - 
  foo</CODE>, two QNames separated by a subtraction operator.</P>
  <LI>
  <P><CODE>foo(: This is a comment :)- foo</CODE> is syntactically equivalent to 
  <CODE>foo - foo</CODE>. This is because the comment prevents the two adjacent 
  terminals from being recognized as one.</P>
  <LI>
  <P><CODE>foo-foo</CODE> is syntactically equivalent to single QName. This is 
  because "-" is a valid character in a QName. When used as an operator after 
  the characters of a name, the "-" must be separated from the name, e.g. by 
  using whitespace or parentheses.</P>
  <LI>
  <P><CODE>10div 3</CODE> results in a syntax error.</P>
  <LI>
  <P><CODE>10 div3</CODE> also results in a syntax error.</P>
  <LI>
  <P><CODE>10div3</CODE> also results in a syntax error.</P></LI></UL></DIV>
<DIV class=div4>
<H5><A id=ExplicitWhitespaceHandling name=ExplicitWhitespaceHandling></A>A.2.4.2 
Explicit Whitespace Handling</H5>
<P>Explicit whitespace notation is specified with the EBNF productions, when it 
is different from the default rules, using the notation shown below. This 
notation is not inherited. In other words, if an EBNF rule is marked as /* ws: 
explicit */, the notation does not automatically apply to all the 'child' EBNF 
productions of that rule.</P>
<DL>
  <DT class=label><A id=ws-explicit name=ws-explicit></A>ws: explicit 
  <DD>
  <P>/* ws: explicit */ means that the EBNF notation explicitly notates, with 
  <CODE>S</CODE> or otherwise, where <A title=whitespace 
  href="REC-xquery-20070123.htm#Whitespace">whitespace 
  characters</A> are allowed. In productions with the /* ws: explicit */ 
  annotation, <A 
  href="REC-xquery-20070123.htm#DefaultWhitespaceHandling"><B>A.2.4.1 
  Default Whitespace Handling</B></A> does not apply. <A 
  href="REC-xquery-20070123.htm#doc-xquery-Comment">Comments</A> 
  are also not allowed in these productions.</P></DD></DL>
<DIV class=xquery>
<P class=xquery id=ws-explicit-lex-states>For example, whitespace is not freely 
allowed by the direct constructor productions, but is specified explicitly in 
the grammar, in order to be more consistent with 
XML.</P></DIV></DIV></DIV></DIV>
<DIV class=div2>
<H3><A id=id-reserved-fn-names name=id-reserved-fn-names></A>A.3 Reserved 
Function Names</H3>
<P>The following names are not allowed as function names in an unprefixed form 
because expression syntax takes precedence.</P>
<UL>
  <LI>
  <P><CODE>attribute</CODE></P>
  <LI>
  <P><CODE>comment</CODE></P>
  <LI>
  <P><CODE>document-node</CODE></P>
  <LI>
  <P><CODE>element</CODE></P>
  <LI>
  <P><CODE>empty-sequence</CODE></P>
  <LI>
  <P><CODE>if</CODE></P>
  <LI>
  <P><CODE>item</CODE></P>
  <LI>
  <P><CODE>node</CODE></P>
  <LI>
  <P><CODE>processing-instruction</CODE></P>
  <LI>
  <P><CODE>schema-attribute</CODE></P>
  <LI>
  <P><CODE>schema-element</CODE></P>
  <LI>
  <P><CODE>text</CODE></P>
  <LI>
  <P><CODE>typeswitch</CODE></P></LI></UL></DIV>
<DIV class=div2>
<H3><A id=id-precedence-order name=id-precedence-order></A>A.4 Precedence 
Order</H3>
<P>The grammar in <A 
href="REC-xquery-20070123.htm#id-grammar"><B>A.1 
EBNF</B></A> normatively defines built-in precedence among the operators of 
XQuery. These operators are summarized here to make clear the order of their 
precedence from lowest to highest. Operators that have a lower precedence number 
cannot be contained by operators with a higher precedence number. The 
associativity column indicates the order in which operators of equal precedence 
in an expression are applied.</P>
<TABLE border=1>
  <TBODY>
  <TR>
    <TH>#</TH>
    <TH>Operator</TH>
    <TH>Associativity</TH></TR>
  <TR>
    <TD>1</TD>
    <TD>, (comma)</TD>
    <TD>left-to-right</TD></TR>
  <TR class=xquery>
    <TD>2</TD>
    <TD>:= (assignment)</TD>
    <TD>right-to-left</TD></TR>
  <TR>
    <TD>3</TD>
    <TD><SPAN class=xquery><SPAN class=xquery><A 
      href="REC-xquery-20070123.htm#doc-xquery-FLWORExpr">for</A>,</SPAN></SPAN> 
      <A 
      href="REC-xquery-20070123.htm#doc-xquery-QuantifiedExpr">some, 
      every</A>, <SPAN class=xquery><SPAN class=xquery><A 
      href="REC-xquery-20070123.htm#doc-xquery-TypeswitchExpr">typeswitch</A>,</SPAN></SPAN> 
      <A 
      href="REC-xquery-20070123.htm#doc-xquery-IfExpr">if</A></TD>
    <TD>left-to-right</TD></TR>
  <TR>
    <TD>4</TD>
    <TD><A 
      href="REC-xquery-20070123.htm#doc-xquery-OrExpr">or</A></TD>
    <TD>left-to-right</TD></TR>
  <TR>
    <TD>5</TD>
    <TD><A 
      href="REC-xquery-20070123.htm#doc-xquery-AndExpr">and</A></TD>
    <TD>left-to-right</TD></TR>
  <TR>
    <TD>6</TD>
    <TD><A 
      href="REC-xquery-20070123.htm#doc-xquery-ValueComp">eq, 
      ne, lt, le, gt, ge</A>, <A 
      href="REC-xquery-20070123.htm#doc-xquery-GeneralComp">=, 
      !=, &lt;, &lt;=, &gt;, &gt;=</A>, <A 
      href="REC-xquery-20070123.htm#doc-xquery-NodeComp">is</A>, 
      <A 
      href="REC-xquery-20070123.htm#doc-xquery-NodeComp">&lt;&lt;, 
      &gt;&gt;</A></TD>
    <TD>left-to-right</TD></TR>
  <TR>
    <TD>7</TD>
    <TD><A 
      href="REC-xquery-20070123.htm#doc-xquery-RangeExpr">to</A></TD>
    <TD>left-to-right</TD></TR>
  <TR>
    <TD>8</TD>
    <TD><A 
      href="REC-xquery-20070123.htm#doc-xquery-AdditiveExpr">+, 
      -</A></TD>
    <TD>left-to-right</TD></TR>
  <TR>
    <TD>9</TD>
    <TD><A 
      href="REC-xquery-20070123.htm#doc-xquery-MultiplicativeExpr">*, 
      div, idiv, mod</A></TD>
    <TD>left-to-right</TD></TR>
  <TR>
    <TD>10</TD>
    <TD><A 
      href="REC-xquery-20070123.htm#doc-xquery-UnionExpr">union, 
      |</A></TD>
    <TD>left-to-right</TD></TR>
  <TR>
    <TD>11</TD>
    <TD><A 
      href="REC-xquery-20070123.htm#doc-xquery-IntersectExceptExpr">intersect, 
      except</A></TD>
    <TD>left-to-right</TD></TR>
  <TR>
    <TD>12</TD>
    <TD><A 
      href="REC-xquery-20070123.htm#doc-xquery-InstanceofExpr">instance 
      of</A></TD>
    <TD>left-to-right</TD></TR>
  <TR>
    <TD>13</TD>
    <TD><A 
      href="REC-xquery-20070123.htm#doc-xquery-TreatExpr">treat</A></TD>
    <TD>left-to-right</TD></TR>
  <TR>
    <TD>14</TD>
    <TD><A 
      href="REC-xquery-20070123.htm#doc-xquery-CastableExpr">castable</A></TD>
    <TD>left-to-right</TD></TR>
  <TR>
    <TD>15</TD>
    <TD><A 
      href="REC-xquery-20070123.htm#doc-xquery-CastExpr">cast</A></TD>
    <TD>left-to-right</TD></TR>
  <TR>
    <TD>16</TD>
    <TD><A 
      href="REC-xquery-20070123.htm#doc-xquery-UnaryExpr">-(unary), 
      +(unary)</A></TD>
    <TD>right-to-left</TD></TR>
  <TR>
    <TD>17</TD>
    <TD><A 
      href="REC-xquery-20070123.htm#doc-xquery-OccurrenceIndicator">?, 
      *(OccurrenceIndicator), +(OccurrenceIndicator)</A></TD>
    <TD>left-to-right</TD></TR>
  <TR>
    <TD>18</TD>
    <TD><A 
      href="REC-xquery-20070123.htm#doc-xquery-PathExpr">/, 
      //</A></TD>
    <TD>left-to-right</TD></TR>
  <TR>
    <TD>19</TD>
    <TD><A 
      href="REC-xquery-20070123.htm#doc-xquery-Predicate">[ 
      ]</A>, <A 
      href="REC-xquery-20070123.htm#doc-xquery-ParenthesizedExpr">( 
      )</A>, {}</TD>
    <TD>left-to-right</TD></TR></TBODY></TABLE></DIV></DIV>
<DIV class=div1>
<H2><A id=id-type-promotion-and-operator-mapping 
name=id-type-promotion-and-operator-mapping></A>B Type Promotion and Operator 
Mapping</H2>
<DIV class=div2>
<H3><A id=promotion name=promotion></A>B.1 Type Promotion</H3>
<P>[<A id=dt-type-promotion title="type promotion" 
name=dt-type-promotion>Definition</A>: Under certain circumstances, an atomic 
value can be promoted from one type to another. <B>Type promotion</B> is used in 
evaluating function calls (see <A 
href="REC-xquery-20070123.htm#id-function-calls"><B>3.1.5 
Function Calls</B></A>)<SPAN class=xquery><SPAN class=xquery>, <CODE>order 
by</CODE> clauses (see <A 
href="REC-xquery-20070123.htm#id-orderby-return"><B>3.8.3 
Order By and Return Clauses</B></A>),</SPAN></SPAN> and operators that accept 
numeric or string operands (see <A 
href="REC-xquery-20070123.htm#mapping"><B>B.2 Operator 
Mapping</B></A>).] The following type promotions are permitted:</P>
<OL class=enumar>
  <LI>
  <P>Numeric type promotion:</P>
  <OL class=enumla>
    <LI>
    <P>A value of type <CODE>xs:float</CODE> (or any type derived by restriction 
    from <CODE>xs:float</CODE>) can be promoted to the type 
    <CODE>xs:double</CODE>. The result is the <CODE>xs:double</CODE> value that 
    is the same as the original value.</P>
    <LI>
    <P>A value of type <CODE>xs:decimal</CODE> (or any type derived by 
    restriction from <CODE>xs:decimal</CODE>) can be promoted to either of the 
    types <CODE>xs:float</CODE> or <CODE>xs:double</CODE>. The result of this 
    promotion is created by casting the original value to the required type. 
    This kind of promotion may cause loss of precision.</P></LI></OL>
  <LI>
  <P>URI type promotion: A value of type <CODE>xs:anyURI</CODE> (or any type 
  derived by restriction from <CODE>xs:anyURI</CODE>) can be promoted to the 
  type <CODE>xs:string</CODE>. The result of this promotion is created by 
  casting the original value to the type <CODE>xs:string</CODE>.</P>
  <DIV class=note>
  <P class=prefix><B>Note:</B></P>
  <P>Since <CODE>xs:anyURI</CODE> values can be promoted to 
  <CODE>xs:string</CODE>, functions and operators that compare strings using the 
  <A title="default collation" 
  href="REC-xquery-20070123.htm#dt-def-collation">default 
  collation</A> also compare <CODE>xs:anyURI</CODE> values using the <A 
  title="default collation" 
  href="REC-xquery-20070123.htm#dt-def-collation">default 
  collation</A>. This ensures that orderings that include strings, 
  <CODE>xs:anyURI</CODE> values, or any combination of the two types are 
  consistent and well-defined.</P></DIV></LI></OL>
<P>Note that <A title="type promotion" 
href="REC-xquery-20070123.htm#dt-type-promotion">type 
promotion</A> is different from <A title="subtype substitution" 
href="REC-xquery-20070123.htm#dt-subtype-substitution">subtype 
substitution</A>. For example:</P>
<UL>
  <LI>
  <P>A function that expects a parameter <CODE>$p</CODE> of type 
  <CODE>xs:float</CODE> can be invoked with a value of type 
  <CODE>xs:decimal</CODE>. This is an example of <A title="type promotion" 
  href="REC-xquery-20070123.htm#dt-type-promotion">type 
  promotion</A>. The value is actually converted to the expected type. Within 
  the body of the function, <CODE>$p instance of xs:decimal</CODE> returns 
  <CODE>false</CODE>.</P>
  <LI>
  <P>A function that expects a parameter <CODE>$p</CODE> of type 
  <CODE>xs:decimal</CODE> can be invoked with a value of type 
  <CODE>xs:integer</CODE>. This is an example of <A title="subtype substitution" 
  href="REC-xquery-20070123.htm#dt-subtype-substitution">subtype 
  substitution</A>. The value retains its original type. Within the body of the 
  function, <CODE>$p instance of xs:integer</CODE> returns 
  <CODE>true</CODE>.</P></LI></UL></DIV>
<DIV class=div2>
<H3><A id=mapping name=mapping></A>B.2 Operator Mapping</H3>
<P>The operator mapping tables in this section list the combinations of types 
for which the various operators of XQuery are defined. [<A 
id=dt-operator-function title="operator function" 
name=dt-operator-function>Definition</A>: For each operator and valid 
combination of operand types, the operator mapping tables specify a result type 
and an <B>operator function</B> that implements the semantics of the operator 
for the given types.] The definitions of the operator functions are given in <A 
href="REC-xquery-20070123.htm#FunctionsAndOperators">[XQuery 
1.0 and XPath 2.0 Functions and Operators]</A>. The result of an operator may be 
the raising of an error by its operator function, as defined in <A 
href="REC-xquery-20070123.htm#FunctionsAndOperators">[XQuery 
1.0 and XPath 2.0 Functions and Operators]</A>. In some cases, the operator 
function does not implement the full semantics of a given operator. For the 
definition of each operator (including its behavior for empty sequences or 
sequences of length greater than one), see the descriptive material in the main 
part of this document.</P>
<P>The <CODE>and</CODE> and <CODE>or</CODE> operators are defined directly in 
the main body of this document, and do not occur in the operator mapping 
tables.</P>
<P>If an operator in the operator mapping tables expects an operand of type 
<EM>ET</EM>, that operator can be applied to an operand of type <EM>AT</EM> if 
type <EM>AT</EM> can be converted to type <EM>ET</EM> by a combination of <A 
title="type promotion" 
href="REC-xquery-20070123.htm#dt-type-promotion">type 
promotion</A> and <A title="subtype substitution" 
href="REC-xquery-20070123.htm#dt-subtype-substitution">subtype 
substitution</A>. For example, a table entry indicates that the <CODE>gt</CODE> 
operator may be applied to two <CODE>xs:date</CODE> operands, returning 
<CODE>xs:boolean</CODE>. Therefore, the <CODE>gt</CODE> operator may also be 
applied to two (possibly different) subtypes of <CODE>xs:date</CODE>, also 
returning <CODE>xs:boolean</CODE>.</P>
<P>[<A id=dt-numeric title=numeric name=dt-numeric>Definition</A>: When 
referring to a type, the term <B>numeric</B> denotes the types 
<CODE>xs:integer</CODE>, <CODE>xs:decimal</CODE>, <CODE>xs:float</CODE>, and 
<CODE>xs:double</CODE>.] An operator whose operands and result are designated as 
<A title=numeric 
href="REC-xquery-20070123.htm#dt-numeric">numeric</A> 
might be thought of as representing four operators, one for each of the numeric 
types. For example, the numeric <CODE>+</CODE> operator might be thought of as 
representing the following four operators:</P>
<TABLE width="80%" summary=Operators border=1>
  <TBODY>
  <TR>
    <TD align=middle>Operator</TD>
    <TD align=middle>First operand type</TD>
    <TD align=middle>Second operand type</TD>
    <TD align=middle>Result type</TD></TR>
  <TR>
    <TD align=middle><CODE>+</CODE></TD>
    <TD align=middle><CODE>xs:integer</CODE></TD>
    <TD align=middle><CODE>xs:integer</CODE></TD>
    <TD align=middle><CODE>xs:integer</CODE></TD></TR>
  <TR>
    <TD align=middle><CODE>+</CODE></TD>
    <TD align=middle><CODE>xs:decimal</CODE></TD>
    <TD align=middle><CODE>xs:decimal</CODE></TD>
    <TD align=middle><CODE>xs:decimal</CODE></TD></TR>
  <TR>
    <TD align=middle><CODE>+</CODE></TD>
    <TD align=middle><CODE>xs:float</CODE></TD>
    <TD align=middle><CODE>xs:float</CODE></TD>
    <TD align=middle><CODE>xs:float</CODE></TD></TR>
  <TR>
    <TD align=middle><CODE>+</CODE></TD>
    <TD align=middle><CODE>xs:double</CODE></TD>
    <TD align=middle><CODE>xs:double</CODE></TD>
    <TD align=middle><CODE>xs:double</CODE></TD></TR></TBODY></TABLE>
<P>A numeric operator may be validly applied to an operand of type <EM>AT</EM> 
if type <EM>AT</EM> can be converted to any of the four numeric types by a 
combination of <A title="type promotion" 
href="REC-xquery-20070123.htm#dt-type-promotion">type 
promotion</A> and <A title="subtype substitution" 
href="REC-xquery-20070123.htm#dt-subtype-substitution">subtype 
substitution</A>. If the result type of an operator is listed as numeric, it 
means "the first type in the ordered list <CODE>(xs:integer, xs:decimal, 
xs:float, xs:double)</CODE> into which all operands can be converted by <A 
title="subtype substitution" 
href="REC-xquery-20070123.htm#dt-subtype-substitution">subtype 
substitution</A> and <A title="type promotion" 
href="REC-xquery-20070123.htm#dt-type-promotion">type 
promotion</A>." As an example, suppose that the type <CODE>hatsize</CODE> is 
derived from <CODE>xs:integer</CODE> and the type <CODE>shoesize</CODE> is 
derived from <CODE>xs:float</CODE>. Then if the <CODE>+</CODE> operator is 
invoked with operands of type <CODE>hatsize</CODE> and <CODE>shoesize</CODE>, it 
returns a result of type <CODE>xs:float</CODE>. Similarly, if <CODE>+</CODE> is 
invoked with two operands of type <CODE>hatsize</CODE> it returns a result of 
type <CODE>xs:integer</CODE>.</P>
<P>[<A id=dt-gregorian title=Gregorian name=dt-gregorian>Definition</A>: In the 
operator mapping tables, the term <B>Gregorian</B> refers to the types 
<CODE>xs:gYearMonth</CODE>, <CODE>xs:gYear</CODE>, <CODE>xs:gMonthDay</CODE>, 
<CODE>xs:gDay</CODE>, and <CODE>xs:gMonth</CODE>.] For binary operators that 
accept two Gregorian-type operands, both operands must have the same type (for 
example, if one operand is of type <CODE>xs:gDay</CODE>, the other operand must 
be of type <CODE>xs:gDay</CODE>.)</P>
<DIV class=small>
<TABLE class=small summary="Binary operators" border=1>
  <CAPTION>Binary Operators</CAPTION>
  <TBODY>
  <TR>
    <TH>Operator</TH>
    <TH>Type(A)</TH>
    <TH>Type(B)</TH>
    <TH>Function</TH>
    <TH>Result type</TH></TR>
  <TR>
    <TD>A + B</TD>
    <TD>numeric</TD>
    <TD>numeric</TD>
    <TD>op:numeric-add(A, B)</TD>
    <TD>numeric</TD></TR>
  <TR>
    <TD>A + B</TD>
    <TD>xs:date</TD>
    <TD>xs:yearMonthDuration</TD>
    <TD>op:add-yearMonthDuration-to-date(A, B)</TD>
    <TD>xs:date</TD></TR>
  <TR>
    <TD>A + B</TD>
    <TD>xs:yearMonthDuration</TD>
    <TD>xs:date</TD>
    <TD>op:add-yearMonthDuration-to-date(B, A)</TD>
    <TD>xs:date</TD></TR>
  <TR>
    <TD>A + B</TD>
    <TD>xs:date</TD>
    <TD>xs:dayTimeDuration</TD>
    <TD>op:add-dayTimeDuration-to-date(A, B)</TD>
    <TD>xs:date</TD></TR>
  <TR>
    <TD>A + B</TD>
    <TD>xs:dayTimeDuration</TD>
    <TD>xs:date</TD>
    <TD>op:add-dayTimeDuration-to-date(B, A)</TD>
    <TD>xs:date</TD></TR>
  <TR>
    <TD>A + B</TD>
    <TD>xs:time</TD>
    <TD>xs:dayTimeDuration</TD>
    <TD>op:add-dayTimeDuration-to-time(A, B)</TD>
    <TD>xs:time</TD></TR>
  <TR>
    <TD>A + B</TD>
    <TD>xs:dayTimeDuration</TD>
    <TD>xs:time</TD>
    <TD>op:add-dayTimeDuration-to-time(B, A)</TD>
    <TD>xs:time</TD></TR>
  <TR>
    <TD>A + B</TD>
    <TD>xs:dateTime</TD>
    <TD>xs:yearMonthDuration</TD>
    <TD>op:add-yearMonthDuration-to-dateTime(A, B)</TD>
    <TD>xs:dateTime</TD></TR>
  <TR>
    <TD>A + B</TD>
    <TD>xs:yearMonthDuration</TD>
    <TD>xs:dateTime</TD>
    <TD>op:add-yearMonthDuration-to-dateTime(B, A)</TD>
    <TD>xs:dateTime</TD></TR>
  <TR>
    <TD>A + B</TD>
    <TD>xs:dateTime</TD>
    <TD>xs:dayTimeDuration</TD>
    <TD>op:add-dayTimeDuration-to-dateTime(A, B)</TD>
    <TD>xs:dateTime</TD></TR>
  <TR>
    <TD>A + B</TD>
    <TD>xs:dayTimeDuration</TD>
    <TD>xs:dateTime</TD>
    <TD>op:add-dayTimeDuration-to-dateTime(B, A)</TD>
    <TD>xs:dateTime</TD></TR>
  <TR>
    <TD>A + B</TD>
    <TD>xs:yearMonthDuration</TD>
    <TD>xs:yearMonthDuration</TD>
    <TD>op:add-yearMonthDurations(A, B)</TD>
    <TD>xs:yearMonthDuration</TD></TR>
  <TR>
    <TD>A + B</TD>
    <TD>xs:dayTimeDuration</TD>
    <TD>xs:dayTimeDuration</TD>
    <TD>op:add-dayTimeDurations(A, B)</TD>
    <TD>xs:dayTimeDuration</TD></TR>
  <TR>
    <TD>A - B</TD>
    <TD>numeric</TD>
    <TD>numeric</TD>
    <TD>op:numeric-subtract(A, B)</TD>
    <TD>numeric</TD></TR>
  <TR>
    <TD>A - B</TD>
    <TD>xs:date</TD>
    <TD>xs:date</TD>
    <TD>op:subtract-dates(A, B)</TD>
    <TD>xs:dayTimeDuration</TD></TR>
  <TR>
    <TD>A - B</TD>
    <TD>xs:date</TD>
    <TD>xs:yearMonthDuration</TD>
    <TD>op:subtract-yearMonthDuration-from-date(A, B)</TD>
    <TD>xs:date</TD></TR>
  <TR>
    <TD>A - B</TD>
    <TD>xs:date</TD>
    <TD>xs:dayTimeDuration</TD>
    <TD>op:subtract-dayTimeDuration-from-date(A, B)</TD>
    <TD>xs:date</TD></TR>
  <TR>
    <TD>A - B</TD>
    <TD>xs:time</TD>
    <TD>xs:time</TD>
    <TD>op:subtract-times(A, B)</TD>
    <TD>xs:dayTimeDuration</TD></TR>
  <TR>
    <TD>A - B</TD>
    <TD>xs:time</TD>
    <TD>xs:dayTimeDuration</TD>
    <TD>op:subtract-dayTimeDuration-from-time(A, B)</TD>
    <TD>xs:time</TD></TR>
  <TR>
    <TD>A - B</TD>
    <TD>xs:dateTime</TD>
    <TD>xs:dateTime</TD>
    <TD>op:subtract-dateTimes(A, B)</TD>
    <TD>xs:dayTimeDuration</TD></TR>
  <TR>
    <TD>A - B</TD>
    <TD>xs:dateTime</TD>
    <TD>xs:yearMonthDuration</TD>
    <TD>op:subtract-yearMonthDuration-from-dateTime(A, B)</TD>
    <TD>xs:dateTime</TD></TR>
  <TR>
    <TD>A - B</TD>
    <TD>xs:dateTime</TD>
    <TD>xs:dayTimeDuration</TD>
    <TD>op:subtract-dayTimeDuration-from-dateTime(A, B)</TD>
    <TD>xs:dateTime</TD></TR>
  <TR>
    <TD>A - B</TD>
    <TD>xs:yearMonthDuration</TD>
    <TD>xs:yearMonthDuration</TD>
    <TD>op:subtract-yearMonthDurations(A, B)</TD>
    <TD>xs:yearMonthDuration</TD></TR>
  <TR>
    <TD>A - B</TD>
    <TD>xs:dayTimeDuration</TD>
    <TD>xs:dayTimeDuration</TD>
    <TD>op:subtract-dayTimeDurations(A, B)</TD>
    <TD>xs:dayTimeDuration</TD></TR>
  <TR>
    <TD>A * B</TD>
    <TD>numeric</TD>
    <TD>numeric</TD>
    <TD>op:numeric-multiply(A, B)</TD>
    <TD>numeric</TD></TR>
  <TR>
    <TD>A * B</TD>
    <TD>xs:yearMonthDuration</TD>
    <TD>numeric</TD>
    <TD>op:multiply-yearMonthDuration(A, B)</TD>
    <TD>xs:yearMonthDuration</TD></TR>
  <TR>
    <TD>A * B</TD>
    <TD>numeric</TD>
    <TD>xs:yearMonthDuration</TD>
    <TD>op:multiply-yearMonthDuration(B, A)</TD>
    <TD>xs:yearMonthDuration</TD></TR>
  <TR>
    <TD>A * B</TD>
    <TD>xs:dayTimeDuration</TD>
    <TD>numeric</TD>
    <TD>op:multiply-dayTimeDuration(A, B)</TD>
    <TD>xs:dayTimeDuration</TD></TR>
  <TR>
    <TD>A * B</TD>
    <TD>numeric</TD>
    <TD>xs:dayTimeDuration</TD>
    <TD>op:multiply-dayTimeDuration(B, A)</TD>
    <TD>xs:dayTimeDuration</TD></TR>
  <TR>
    <TD>A idiv B</TD>
    <TD>numeric</TD>
    <TD>numeric</TD>
    <TD>op:numeric-integer-divide(A, B)</TD>
    <TD>xs:integer</TD></TR>
  <TR>
    <TD>A div B</TD>
    <TD>numeric</TD>
    <TD>numeric</TD>
    <TD>op:numeric-divide(A, B)</TD>
    <TD>numeric; but xs:decimal if both operands are xs:integer</TD></TR>
  <TR>
    <TD>A div B</TD>
    <TD>xs:yearMonthDuration</TD>
    <TD>numeric</TD>
    <TD>op:divide-yearMonthDuration(A, B)</TD>
    <TD>xs:yearMonthDuration</TD></TR>
  <TR>
    <TD>A div B</TD>
    <TD>xs:dayTimeDuration</TD>
    <TD>numeric</TD>
    <TD>op:divide-dayTimeDuration(A, B)</TD>
    <TD>xs:dayTimeDuration</TD></TR>
  <TR>
    <TD>A div B</TD>
    <TD>xs:yearMonthDuration</TD>
    <TD>xs:yearMonthDuration</TD>
    <TD>op:divide-yearMonthDuration-by-yearMonthDuration (A, B)</TD>
    <TD>xs:decimal</TD></TR>
  <TR>
    <TD>A div B</TD>
    <TD>xs:dayTimeDuration</TD>
    <TD>xs:dayTimeDuration</TD>
    <TD>op:divide-dayTimeDuration-by-dayTimeDuration (A, B)</TD>
    <TD>xs:decimal</TD></TR>
  <TR>
    <TD>A mod B</TD>
    <TD>numeric</TD>
    <TD>numeric</TD>
    <TD>op:numeric-mod(A, B)</TD>
    <TD>numeric</TD></TR>
  <TR>
    <TD>A eq B</TD>
    <TD>numeric</TD>
    <TD>numeric</TD>
    <TD>op:numeric-equal(A, B)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A eq B</TD>
    <TD>xs:boolean</TD>
    <TD>xs:boolean</TD>
    <TD>op:boolean-equal(A, B)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A eq B</TD>
    <TD>xs:string</TD>
    <TD>xs:string</TD>
    <TD>op:numeric-equal(fn:compare(A, B), 0)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A eq B</TD>
    <TD>xs:date</TD>
    <TD>xs:date</TD>
    <TD>op:date-equal(A, B)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A eq B</TD>
    <TD>xs:time</TD>
    <TD>xs:time</TD>
    <TD>op:time-equal(A, B)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A eq B</TD>
    <TD>xs:dateTime</TD>
    <TD>xs:dateTime</TD>
    <TD>op:dateTime-equal(A, B)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A eq B</TD>
    <TD>xs:duration</TD>
    <TD>xs:duration</TD>
    <TD>op:duration-equal(A, B)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A eq B</TD>
    <TD>Gregorian</TD>
    <TD>Gregorian</TD>
    <TD>op:gYear-equal(A, B) etc.</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A eq B</TD>
    <TD>xs:hexBinary</TD>
    <TD>xs:hexBinary</TD>
    <TD>op:hex-binary-equal(A, B)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A eq B</TD>
    <TD>xs:base64Binary</TD>
    <TD>xs:base64Binary</TD>
    <TD>op:base64-binary-equal(A, B)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A eq B</TD>
    <TD>xs:anyURI</TD>
    <TD>xs:anyURI</TD>
    <TD>op:numeric-equal(fn:compare(A, B), 0)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A eq B</TD>
    <TD>xs:QName</TD>
    <TD>xs:QName</TD>
    <TD>op:QName-equal(A, B)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A eq B</TD>
    <TD>xs:NOTATION</TD>
    <TD>xs:NOTATION</TD>
    <TD>op:NOTATION-equal(A, B)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A ne B</TD>
    <TD>numeric</TD>
    <TD>numeric</TD>
    <TD>fn:not(op:numeric-equal(A, B))</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A ne B</TD>
    <TD>xs:boolean</TD>
    <TD>xs:boolean</TD>
    <TD>fn:not(op:boolean-equal(A, B))</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A ne B</TD>
    <TD>xs:string</TD>
    <TD>xs:string</TD>
    <TD>fn:not(op:numeric-equal(fn:compare(A, B), 0))</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A ne B</TD>
    <TD>xs:date</TD>
    <TD>xs:date</TD>
    <TD>fn:not(op:date-equal(A, B))</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A ne B</TD>
    <TD>xs:time</TD>
    <TD>xs:time</TD>
    <TD>fn:not(op:time-equal(A, B))</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A ne B</TD>
    <TD>xs:dateTime</TD>
    <TD>xs:dateTime</TD>
    <TD>fn:not(op:dateTime-equal(A, B))</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A ne B</TD>
    <TD>xs:duration</TD>
    <TD>xs:duration</TD>
    <TD>fn:not(op:duration-equal(A, B))</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A ne B</TD>
    <TD>Gregorian</TD>
    <TD>Gregorian</TD>
    <TD>fn:not(op:gYear-equal(A, B)) etc.</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A ne B</TD>
    <TD>xs:hexBinary</TD>
    <TD>xs:hexBinary</TD>
    <TD>fn:not(op:hex-binary-equal(A, B))</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A ne B</TD>
    <TD>xs:base64Binary</TD>
    <TD>xs:base64Binary</TD>
    <TD>fn:not(op:base64-binary-equal(A, B))</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A ne B</TD>
    <TD>xs:anyURI</TD>
    <TD>xs:anyURI</TD>
    <TD>fn:not(op:numeric-equal(fn:compare(A, B), 0))</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A ne B</TD>
    <TD>xs:QName</TD>
    <TD>xs:QName</TD>
    <TD>fn:not(op:QName-equal(A, B))</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A ne B</TD>
    <TD>xs:NOTATION</TD>
    <TD>xs:NOTATION</TD>
    <TD>fn:not(op:NOTATION-equal(A, B))</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A gt B</TD>
    <TD>numeric</TD>
    <TD>numeric</TD>
    <TD>op:numeric-greater-than(A, B)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A gt B</TD>
    <TD>xs:boolean</TD>
    <TD>xs:boolean</TD>
    <TD>op:boolean-greater-than(A, B)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A gt B</TD>
    <TD>xs:string</TD>
    <TD>xs:string</TD>
    <TD>op:numeric-greater-than(fn:compare(A, B), 0)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A gt B</TD>
    <TD>xs:date</TD>
    <TD>xs:date</TD>
    <TD>op:date-greater-than(A, B)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A gt B</TD>
    <TD>xs:time</TD>
    <TD>xs:time</TD>
    <TD>op:time-greater-than(A, B)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A gt B</TD>
    <TD>xs:dateTime</TD>
    <TD>xs:dateTime</TD>
    <TD>op:dateTime-greater-than(A, B)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A gt B</TD>
    <TD>xs:yearMonthDuration</TD>
    <TD>xs:yearMonthDuration</TD>
    <TD>op:yearMonthDuration-greater-than(A, B)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A gt B</TD>
    <TD>xs:dayTimeDuration</TD>
    <TD>xs:dayTimeDuration</TD>
    <TD>op:dayTimeDuration-greater-than(A, B)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A gt B</TD>
    <TD>xs:anyURI</TD>
    <TD>xs:anyURI</TD>
    <TD>op:numeric-greater-than(fn:compare(A, B), 0)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A lt B</TD>
    <TD>numeric</TD>
    <TD>numeric</TD>
    <TD>op:numeric-less-than(A, B)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A lt B</TD>
    <TD>xs:boolean</TD>
    <TD>xs:boolean</TD>
    <TD>op:boolean-less-than(A, B)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A lt B</TD>
    <TD>xs:string</TD>
    <TD>xs:string</TD>
    <TD>op:numeric-less-than(fn:compare(A, B), 0)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A lt B</TD>
    <TD>xs:date</TD>
    <TD>xs:date</TD>
    <TD>op:date-less-than(A, B)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A lt B</TD>
    <TD>xs:time</TD>
    <TD>xs:time</TD>
    <TD>op:time-less-than(A, B)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A lt B</TD>
    <TD>xs:dateTime</TD>
    <TD>xs:dateTime</TD>
    <TD>op:dateTime-less-than(A, B)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A lt B</TD>
    <TD>xs:yearMonthDuration</TD>
    <TD>xs:yearMonthDuration</TD>
    <TD>op:yearMonthDuration-less-than(A, B)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A lt B</TD>
    <TD>xs:dayTimeDuration</TD>
    <TD>xs:dayTimeDuration</TD>
    <TD>op:dayTimeDuration-less-than(A, B)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A lt B</TD>
    <TD>xs:anyURI</TD>
    <TD>xs:anyURI</TD>
    <TD>op:numeric-less-than(fn:compare(A, B), 0)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A ge B</TD>
    <TD>numeric</TD>
    <TD>numeric</TD>
    <TD>op:numeric-greater-than(A, B) or op:numeric-equal(A, B)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A ge B</TD>
    <TD>xs:boolean</TD>
    <TD>xs:boolean</TD>
    <TD>fn:not(op:boolean-less-than(A, B))</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A ge B</TD>
    <TD>xs:string</TD>
    <TD>xs:string</TD>
    <TD>op:numeric-greater-than(fn:compare(A, B), -1)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A ge B</TD>
    <TD>xs:date</TD>
    <TD>xs:date</TD>
    <TD>fn:not(op:date-less-than(A, B))</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A ge B</TD>
    <TD>xs:time</TD>
    <TD>xs:time</TD>
    <TD>fn:not(op:time-less-than(A, B))</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A ge B</TD>
    <TD>xs:dateTime</TD>
    <TD>xs:dateTime</TD>
    <TD>fn:not(op:dateTime-less-than(A, B))</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A ge B</TD>
    <TD>xs:yearMonthDuration</TD>
    <TD>xs:yearMonthDuration</TD>
    <TD>fn:not(op:yearMonthDuration-less-than(A, B))</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A ge B</TD>
    <TD>xs:dayTimeDuration</TD>
    <TD>xs:dayTimeDuration</TD>
    <TD>fn:not(op:dayTimeDuration-less-than(A, B))</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A ge B</TD>
    <TD>xs:anyURI</TD>
    <TD>xs:anyURI</TD>
    <TD>op:numeric-greater-than(fn:compare(A, B), -1)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A le B</TD>
    <TD>numeric</TD>
    <TD>numeric</TD>
    <TD>op:numeric-less-than(A, B) or op:numeric-equal(A, B)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A le B</TD>
    <TD>xs:boolean</TD>
    <TD>xs:boolean</TD>
    <TD>fn:not(op:boolean-greater-than(A, B))</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A le B</TD>
    <TD>xs:string</TD>
    <TD>xs:string</TD>
    <TD>op:numeric-less-than(fn:compare(A, B), 1)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A le B</TD>
    <TD>xs:date</TD>
    <TD>xs:date</TD>
    <TD>fn:not(op:date-greater-than(A, B))</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A le B</TD>
    <TD>xs:time</TD>
    <TD>xs:time</TD>
    <TD>fn:not(op:time-greater-than(A, B))</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A le B</TD>
    <TD>xs:dateTime</TD>
    <TD>xs:dateTime</TD>
    <TD>fn:not(op:dateTime-greater-than(A, B))</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A le B</TD>
    <TD>xs:yearMonthDuration</TD>
    <TD>xs:yearMonthDuration</TD>
    <TD>fn:not(op:yearMonthDuration-greater-than(A, B))</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A le B</TD>
    <TD>xs:dayTimeDuration</TD>
    <TD>xs:dayTimeDuration</TD>
    <TD>fn:not(op:dayTimeDuration-greater-than(A, B))</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A le B</TD>
    <TD>xs:anyURI</TD>
    <TD>xs:anyURI</TD>
    <TD>op:numeric-less-than(fn:compare(A, B), 1)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A is B</TD>
    <TD>node()</TD>
    <TD>node()</TD>
    <TD>op:is-same-node(A, B)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A &lt;&lt; B</TD>
    <TD>node()</TD>
    <TD>node()</TD>
    <TD>op:node-before(A, B)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A &gt;&gt; B</TD>
    <TD>node()</TD>
    <TD>node()</TD>
    <TD>op:node-after(A, B)</TD>
    <TD>xs:boolean</TD></TR>
  <TR>
    <TD>A union B</TD>
    <TD>node()*</TD>
    <TD>node()*</TD>
    <TD>op:union(A, B)</TD>
    <TD>node()*</TD></TR>
  <TR>
    <TD>A | B</TD>
    <TD>node()*</TD>
    <TD>node()*</TD>
    <TD>op:union(A, B)</TD>
    <TD>node()*</TD></TR>
  <TR>
    <TD>A intersect B</TD>
    <TD>node()*</TD>
    <TD>node()*</TD>
    <TD>op:intersect(A, B)</TD>
    <TD>node()*</TD></TR>
  <TR>
    <TD>A except B</TD>
    <TD>node()*</TD>
    <TD>node()*</TD>
    <TD>op:except(A, B)</TD>
    <TD>node()*</TD></TR>
  <TR>
    <TD>A to B</TD>
    <TD>xs:integer</TD>
    <TD>xs:integer</TD>
    <TD>op:to(A, B)</TD>
    <TD>xs:integer*</TD></TR>
  <TR>
    <TD>A , B</TD>
    <TD>item()*</TD>
    <TD>item()*</TD>
    <TD>op:concatenate(A, B)</TD>
    <TD>item()*</TD></TR></TBODY></TABLE></DIV>
<DIV class=small>
<TABLE class=small summary="Unary operators" border=1>
  <CAPTION>Unary Operators</CAPTION>
  <TBODY>
  <TR>
    <TH>Operator</TH>
    <TH>Operand type</TH>
    <TH>Function</TH>
    <TH>Result type</TH></TR>
  <TR>
    <TD>+ A</TD>
    <TD>numeric</TD>
    <TD>op:numeric-unary-plus(A)</TD>
    <TD>numeric</TD></TR>
  <TR>
    <TD>- A</TD>
    <TD>numeric</TD>
    <TD>op:numeric-unary-minus(A)</TD>
    <TD>numeric</TD></TR></TBODY></TABLE></DIV></DIV></DIV>
<DIV class=xquery>
<DIV class=div1>
<H2><A id=id-xq-context-components name=id-xq-context-components></A>C Context 
Components</H2>
<P>The tables in this section describe how values are assigned to the various 
components of the static context and dynamic context, and to the parameters that 
control the serialization process.</P>
<DIV class=div2>
<H3><A id=id-xq-static-context-components 
name=id-xq-static-context-components></A>C.1 Static Context Components</H3>
<P>The following table describes the components of the <B>static context</B>. 
The following aspects of each component are described:</P>
<UL>
  <LI>
  <P><EM>Default initial value:</EM> This is the initial value of the component 
  if it is not overridden or augmented by the implementation or by a query.</P>
  <LI>
  <P><EM>Can be overwritten or augmented by implementation:</EM> Indicates 
  whether an XQuery implementation is allowed to replace the default initial 
  value of the component by a different, <A title="implementation defined" 
  href="REC-xquery-20070123.htm#dt-implementation-defined">implementation-defined</A> 
  value and/or to augment the default initial value by additional <A 
  title="implementation defined" 
  href="REC-xquery-20070123.htm#dt-implementation-defined">implementation-defined</A> 
  values.</P>
  <LI>
  <P><EM>Can be overwritten or augmented by a query:</EM> Indicates whether a 
  query is allowed to replace and/or augment the initial value provided by 
  default or by the implementation. If so, indicates how this is accomplished 
  (for example, by a declaration in the prolog).</P>
  <LI>
  <P><EM>Scope:</EM> Indicates where the component is applicable. "Global" 
  indicates that the component applies globally, throughout all the modules used 
  in a query. "Module" indicates that the component applies throughout a <A 
  title=module 
  href="REC-xquery-20070123.htm#dt-module">module</A>. 
  "Lexical" indicates that the component applies within the expression in which 
  it is defined (equivalent to "module" if the component is declared in a <A 
  title=Prolog 
  href="REC-xquery-20070123.htm#dt-prolog">Prolog</A>.)</P>
  <LI>
  <P><EM>Consistency Rules:</EM> Indicates rules that must be observed in 
  assigning values to the component. Additional consistency rules may be found 
  in <A 
  href="REC-xquery-20070123.htm#id-consistency-constraints"><B>2.2.5 
  Consistency Constraints</B></A>.</P></LI></UL>
<DIV class=small>
<TABLE class=small width="100%" summary="Static Context" border=1>
  <CAPTION>Static Context Components</CAPTION>
  <TBODY>
  <TR>
    <TH>Component</TH>
    <TH>Default initial value</TH>
    <TH>Can be overwritten or augmented by implementation?</TH>
    <TH>Can be overwritten or augmented by a query?</TH>
    <TH>Scope</TH>
    <TH>Consistency rules</TH></TR>
  <TR>
    <TD>XPath 1.0 Compatibility Mode</TD>
    <TD><CODE>false</CODE></TD>
    <TD>no</TD>
    <TD>no</TD>
    <TD>global</TD>
    <TD>Must be <CODE>false</CODE>.</TD></TR>
  <TR>
    <TD>Statically known namespaces</TD>
    <TD><CODE>fn</CODE>, <CODE>xml</CODE>, <CODE>xs</CODE>, <CODE>xsi</CODE>, 
      <CODE>local</CODE></TD>
    <TD>overwriteable and augmentable (except for <CODE>xml</CODE>)</TD>
    <TD>overwriteable and augmentable by prolog or element constructor</TD>
    <TD>lexical</TD>
    <TD>Only one namespace can be assigned to a given prefix per lexical 
    scope.</TD></TR>
  <TR>
    <TD>Default element/type namespace</TD>
    <TD>no namespace</TD>
    <TD>overwriteable</TD>
    <TD>overwriteable by prolog or element constructor</TD>
    <TD>lexical</TD>
    <TD>Only one default namespace per lexical scope.</TD></TR>
  <TR>
    <TD>Default function namespace</TD>
    <TD><CODE>fn</CODE></TD>
    <TD>overwriteable (not recommended)</TD>
    <TD>overwriteable by prolog</TD>
    <TD>module</TD>
    <TD>None.</TD></TR>
  <TR>
    <TD>In-scope schema types</TD>
    <TD>built-in types in <CODE>xs</CODE></TD>
    <TD>augmentable</TD>
    <TD>augmentable by schema import in prolog</TD>
    <TD>module</TD>
    <TD>Only one definition per global or local type.</TD></TR>
  <TR>
    <TD>In-scope element declarations</TD>
    <TD>none</TD>
    <TD>augmentable</TD>
    <TD>augmentable by schema import in prolog</TD>
    <TD>module</TD>
    <TD>Only one definition per global or local element name.</TD></TR>
  <TR>
    <TD>In-scope attribute declarations</TD>
    <TD>none</TD>
    <TD>augmentable</TD>
    <TD>augmentable by schema import in prolog</TD>
    <TD>module</TD>
    <TD>Only one definition per global or local attribute name.</TD></TR>
  <TR>
    <TD>In-scope variables</TD>
    <TD>none</TD>
    <TD>augmentable</TD>
    <TD>overwriteable and augmentable by prolog and by variable-binding 
      expressions</TD>
    <TD>lexical</TD>
    <TD>Only one definition per variable per lexical scope.</TD></TR>
  <TR>
    <TD>Context item static type</TD>
    <TD><CODE>none</CODE> (raises error on access)</TD>
    <TD>overwriteable</TD>
    <TD>not explicitly, but can be influenced by expressions</TD>
    <TD>lexical</TD>
    <TD>None.</TD></TR>
  <TR>
    <TD>Function signatures</TD>
    <TD>functions in <CODE>fn</CODE> namespace, and constructors for built-in 
      atomic types</TD>
    <TD>augmentable</TD>
    <TD>augmentable by module import and by function declaration in prolog</TD>
    <TD>module</TD>
    <TD>Each function must have a unique expanded QName and number of 
      arguments.</TD></TR>
  <TR>
    <TD>Statically known collations</TD>
    <TD>only the default collation</TD>
    <TD>augmentable</TD>
    <TD>no</TD>
    <TD>module</TD>
    <TD>Each URI uniquely identifies a collation.</TD></TR>
  <TR>
    <TD>Default collation</TD>
    <TD>Unicode codepoint collation</TD>
    <TD>overwriteable</TD>
    <TD>overwriteable by prolog</TD>
    <TD>module</TD>
    <TD>None.</TD></TR>
  <TR>
    <TD>Construction mode</TD>
    <TD><CODE>preserve</CODE></TD>
    <TD>overwriteable</TD>
    <TD>overwriteable by prolog</TD>
    <TD>module</TD>
    <TD>Value must be <CODE>preserve</CODE> or <CODE>strip</CODE>.</TD></TR>
  <TR>
    <TD>Ordering mode</TD>
    <TD><CODE>ordered</CODE></TD>
    <TD>overwriteable</TD>
    <TD>overwriteable by prolog or expression</TD>
    <TD>lexical</TD>
    <TD>Value must be <CODE>ordered</CODE> or <CODE>unordered</CODE>.</TD></TR>
  <TR>
    <TD>Default order for empty sequences</TD>
    <TD>implementation-defined</TD>
    <TD>overwriteable</TD>
    <TD>overwriteable by prolog</TD>
    <TD>module</TD>
    <TD>Value must be <CODE>greatest</CODE> or <CODE>least</CODE>.</TD></TR>
  <TR>
    <TD>Boundary-space policy</TD>
    <TD><CODE>strip</CODE></TD>
    <TD>overwriteable</TD>
    <TD>overwriteable by prolog</TD>
    <TD>module</TD>
    <TD>Value must be <CODE>preserve</CODE> or <CODE>strip</CODE>.</TD></TR>
  <TR>
    <TD>Copy-namespaces mode</TD>
    <TD><CODE>inherit, preserve</CODE></TD>
    <TD>overwriteable</TD>
    <TD>overwriteable by prolog</TD>
    <TD>module</TD>
    <TD>Value consists of <CODE>inherit</CODE> or <CODE>no-inherit</CODE>, and 
      <CODE>preserve</CODE> or <CODE>no-preserve</CODE>.</TD></TR>
  <TR>
    <TD>Base URI</TD>
    <TD>See rules in <A 
      href="REC-xquery-20070123.htm#id-base-uri-decl"><B>4.5 
      Base URI Declaration</B></A></TD>
    <TD>overwriteable</TD>
    <TD>overwriteable by prolog</TD>
    <TD>module</TD>
    <TD>Value must be a valid lexical representation of the type 
  xs:anyURI.</TD></TR>
  <TR>
    <TD>Statically known documents</TD>
    <TD>none</TD>
    <TD>augmentable</TD>
    <TD>no</TD>
    <TD>module</TD>
    <TD>None.</TD></TR>
  <TR>
    <TD>Statically known collections</TD>
    <TD>none</TD>
    <TD>augmentable</TD>
    <TD>no</TD>
    <TD>module</TD>
    <TD>None.</TD></TR>
  <TR>
    <TD>Statically known default collection type</TD>
    <TD><CODE>node()*</CODE></TD>
    <TD>overwriteable</TD>
    <TD>no</TD>
    <TD>module</TD>
    <TD>None.</TD></TR></TBODY></TABLE></DIV></DIV>
<DIV class=div2>
<H3><A id=id-xq-evaluation-context-components 
name=id-xq-evaluation-context-components></A>C.2 Dynamic Context Components</H3>
<P>The following table describes the components of the <B>dynamic context</B>. 
The following aspects of each component are described:</P>
<UL>
  <LI>
  <P><EM>Default initial value:</EM> This is the initial value of the component 
  if it is not overridden or augmented by the implementation or by a query.</P>
  <LI>
  <P><EM>Can be overwritten or augmented by implementation:</EM> Indicates 
  whether an XQuery implementation is allowed to replace the default initial 
  value of the component by a different <A title="implementation defined" 
  href="REC-xquery-20070123.htm#dt-implementation-defined">implementation-defined</A> 
  value and/or to augment the default initial value by additional <A 
  title="implementation defined" 
  href="REC-xquery-20070123.htm#dt-implementation-defined">implementation-defined</A> 
  values.</P>
  <LI>
  <P><EM>Can be overwritten or augmented by a query:</EM> Indicates whether a 
  query is allowed to replace and/or augment the initial value provided by 
  default or by the implementation. If so, indicates how this is 
  accomplished.</P>
  <LI>
  <P><EM>Scope:</EM> Indicates where the component is applicable. "Global" 
  indicates that the component applies globally, throughout all the modules used 
  in a query, and remains constant during evaluation of a query. "Dynamic" 
  indicates that evalation of an expression may influence the value of the 
  component for that expression and for nested expressions.</P>
  <LI>
  <P><EM>Consistency Rules:</EM> Indicates rules that must be observed in 
  assigning values to the component. Additional consistency rules may be found 
  in <A 
  href="REC-xquery-20070123.htm#id-consistency-constraints"><B>2.2.5 
  Consistency Constraints</B></A>.</P></LI></UL>
<DIV class=small>
<TABLE class=small width="100%" summary="Static Context" border=1>
  <CAPTION>Dynamic Context Components</CAPTION>
  <TBODY>
  <TR>
    <TH>Component</TH>
    <TH>Default initial value</TH>
    <TH>Can be overwritten or augmented by implementation?</TH>
    <TH>Can be overwritten or augmented by a query?</TH>
    <TH>Scope</TH>
    <TH>Consistency rules</TH></TR>
  <TR>
    <TD>Context item</TD>
    <TD>none</TD>
    <TD>overwriteable</TD>
    <TD>overwritten during evaluation of path expressions and predicates</TD>
    <TD>dynamic</TD>
    <TD>None</TD></TR>
  <TR>
    <TD>Context position</TD>
    <TD>none</TD>
    <TD>overwriteable</TD>
    <TD>overwritten during evaluation of path expressions and predicates</TD>
    <TD>dynamic</TD>
    <TD>If context item is defined, context position must be &gt;0 and &lt;= 
      context size; else context position is undefined.</TD></TR>
  <TR>
    <TD>Context size</TD>
    <TD>none</TD>
    <TD>overwriteable</TD>
    <TD>overwritten during evaluation of path expressions and predicates</TD>
    <TD>dynamic</TD>
    <TD>If context item is defined, context size must be &gt;0; else context 
      size is undefined.</TD></TR>
  <TR>
    <TD>Variable values</TD>
    <TD>none</TD>
    <TD>augmentable</TD>
    <TD>overwriteable and augmentable by prolog and by variable-binding 
      expressions</TD>
    <TD>dynamic</TD>
    <TD>Names and values must be consistent with in-scope variables.</TD></TR>
  <TR>
    <TD>Function implementations</TD>
    <TD>functions in <CODE>fn</CODE> namespace, and constructors for built-in 
      atomic types</TD>
    <TD>augmentable</TD>
    <TD>augmentable by module import and by function declaration in prolog</TD>
    <TD>global</TD>
    <TD>Must be consistent with function signatures</TD></TR>
  <TR>
    <TD>Current dateTime</TD>
    <TD>none</TD>
    <TD>must be initialized by implementation</TD>
    <TD>no</TD>
    <TD>global</TD>
    <TD>Must include a timezone. Remains constant during evaluation of a 
    query.</TD></TR>
  <TR>
    <TD>Implicit timezone</TD>
    <TD>none</TD>
    <TD>must be initialized by implementation</TD>
    <TD>no</TD>
    <TD>global</TD>
    <TD>Remains constant during evaluation of a query.</TD></TR>
  <TR>
    <TD>Available documents</TD>
    <TD>none</TD>
    <TD>must be initialized by implementation</TD>
    <TD>no</TD>
    <TD>global</TD>
    <TD>None</TD></TR>
  <TR>
    <TD>Available collections</TD>
    <TD>none</TD>
    <TD>must be initialized by implementation</TD>
    <TD>no</TD>
    <TD>global</TD>
    <TD>None</TD></TR>
  <TR>
    <TD>Default collection</TD>
    <TD>none</TD>
    <TD>overwriteable</TD>
    <TD>no</TD>
    <TD>global</TD>
    <TD>None</TD></TR></TBODY></TABLE></DIV></DIV>
<DIV class=div2>
<H3><A id=id-xq-serialization-parameters 
name=id-xq-serialization-parameters></A>C.3 Serialization Parameters</H3>
<P>The following table specifies default values for the parameters that control 
the process of serializing an <A title="XDM instance" 
href="REC-xquery-20070123.htm#dt-data-model-instance">XDM 
instance</A> into XML notation (<CODE>method = "xml"</CODE>). The meanings of 
the various parameters are defined in <A 
href="REC-xquery-20070123.htm#serialization">[XSLT 2.0 
and XQuery 1.0 Serialization]</A>. For each parameter, an XQuery implementation 
may (but is not required to) provide a means whereby a user can override the 
default value.</P>
<DIV class=small>
<TABLE class=small width="60%" summary="Unary operators" border=1>
  <CAPTION>Serialization Parameters</CAPTION>
  <TBODY>
  <TR>
    <TH>Parameter</TH>
    <TH>Default Value</TH></TR>
  <TR>
    <TD>byte-order-mark</TD>
    <TD>implementation-defined</TD></TR>
  <TR>
    <TD>cdata-section-elements</TD>
    <TD>empty</TD></TR>
  <TR>
    <TD>doctype-public</TD>
    <TD>(none)</TD></TR>
  <TR>
    <TD>doctype-system</TD>
    <TD>(none)</TD></TR>
  <TR>
    <TD>encoding</TD>
    <TD>implementation-defined choice between "utf-8" and "utf-16"</TD></TR>
  <TR>
    <TD>escape-uri-attributes</TD>
    <TD>(not applicable when method = xml)</TD></TR>
  <TR>
    <TD>include-content-type</TD>
    <TD>(not applicable when method = xml)</TD></TR>
  <TR>
    <TD>indent</TD>
    <TD>no</TD></TR>
  <TR>
    <TD>media-type</TD>
    <TD>implementation-defined</TD></TR>
  <TR>
    <TD>method</TD>
    <TD>xml</TD></TR>
  <TR>
    <TD>normalization-form</TD>
    <TD>implementation-defined</TD></TR>
  <TR>
    <TD>omit-xml-declaration</TD>
    <TD>implementation-defined</TD></TR>
  <TR>
    <TD>standalone</TD>
    <TD>implementation-defined</TD></TR>
  <TR>
    <TD>undeclare-prefixes</TD>
    <TD>no</TD></TR>
  <TR>
    <TD>use-character-maps</TD>
    <TD>empty</TD></TR>
  <TR>
    <TD>version</TD>
    <TD>implementation-defined</TD></TR></TBODY></TABLE></DIV></DIV></DIV></DIV>
<DIV class=div1>
<H2><A id=id-impl-defined-items name=id-impl-defined-items></A>D 
Implementation-Defined Items</H2>
<P>The following items in this specification are <A 
title="implementation defined" 
href="REC-xquery-20070123.htm#dt-implementation-defined">implementation-defined</A>:</P>
<OL class=enumar>
  <LI>
  <P>The version of Unicode that is used to construct expressions.</P>
  <LI>
  <P>The <A title="statically known collations" 
  href="REC-xquery-20070123.htm#dt-static-collations">statically-known 
  collations</A>.</P>
  <LI>
  <P>The <A title="implicit timezone" 
  href="REC-xquery-20070123.htm#dt-timezone">implicit 
  timezone</A>.</P>
  <LI>
  <P>The circumstances in which <A title=warning 
  href="REC-xquery-20070123.htm#dt-warning">warnings</A> 
  are raised, and the ways in which warnings are handled.</P>
  <LI>
  <P>The method by which errors are reported to the external processing 
  environment.</P>
  <LI>
  <P>Whether the implementation is based on the rules of <A 
  href="REC-xquery-20070123.htm#XML">[XML 1.0]</A> and <A 
  href="REC-xquery-20070123.htm#XMLNAMES">[XML Names]</A> 
  or the rules of <A 
  href="REC-xquery-20070123.htm#XML1.1">[XML 1.1]</A> and 
  <A href="REC-xquery-20070123.htm#XMLNAMES11">[XML Names 
  1.1]</A>. One of these sets of rules must be applied consistently by all 
  aspects of the implementation.</P>
  <LI class=xquery>
  <P>Any components of the <A title="static context" 
  href="REC-xquery-20070123.htm#dt-static-context">static 
  context</A> or <A title="dynamic context" 
  href="REC-xquery-20070123.htm#dt-dynamic-context">dynamic 
  context</A> that are overwritten or augmented by the implementation.</P>
  <LI class=xquery>
  <P>Which of the <A title="optional axis" 
  href="REC-xquery-20070123.htm#dt-optional-axis">optional 
  axes</A> are supported by the implementation, if the <A 
  title="Full Axis Feature" 
  href="REC-xquery-20070123.htm#dt-full-axis-feature">Full-Axis 
  Feature</A> is not supported.</P>
  <LI class=xquery>
  <P>The default handling of empty sequences returned by an ordering key 
  (sortspec) in an <CODE>order by</CODE> clause (<CODE>empty least</CODE> or 
  <CODE>empty greatest</CODE>).</P>
  <LI class=xquery>
  <P>The names and semantics of any <A title="extension expression" 
  href="REC-xquery-20070123.htm#dt-extension-expression">extension 
  expressions</A> (<A title=pragma 
  href="REC-xquery-20070123.htm#dt-pragma">pragmas</A>) 
  recognized by the implementation.</P>
  <LI class=xquery>
  <P>The names and semantics of any <A title="option declaration" 
  href="REC-xquery-20070123.htm#dt-option-declaration">option 
  declarations</A> recognized by the implementation.</P>
  <LI class=xquery>
  <P>Protocols (if any) by which parameters can be passed to an external 
  function, and the result of the function can returned to the invoking 
  query.</P>
  <LI class=xquery>
  <P>The process by which the specific modules to be imported by a <A 
  title="module import" 
  href="REC-xquery-20070123.htm#dt-module-import">module 
  import</A> are identified, if the <A title="module feature" 
  href="REC-xquery-20070123.htm#dt-module-feature">Module 
  Feature</A> is supported (includes processing of location hints, if any.)</P>
  <LI class=xquery>
  <P>Any <A title="static typing extension" 
  href="REC-xquery-20070123.htm#dt-static-typing-extension">static 
  typing extensions</A> supported by the implementation, if the <A 
  title="static typing feature" 
  href="REC-xquery-20070123.htm#dt-static-typing-feature">Static 
  Typing Feature</A> is supported.</P>
  <LI class=xquery>
  <P>The means by which serialization is invoked, if the <A 
  title="serialization feature" 
  href="REC-xquery-20070123.htm#dt-serialization-feature">Serialization 
  Feature</A> is supported.</P>
  <LI class=xquery>
  <P>The default values for the <CODE>byte-order-mark</CODE>, 
  <CODE>encoding</CODE>, <CODE>media-type</CODE>, 
  <CODE>normalization-form</CODE>, <CODE>omit-xml-declaration</CODE>, 
  <CODE>standalone</CODE>, and <CODE>version</CODE> parameters, if the <A 
  title="serialization feature" 
  href="REC-xquery-20070123.htm#dt-serialization-feature">Serialization 
  Feature</A> is supported.</P>
  <LI class=xquery>
  <P>The result of an unsuccessful call to an external function (for example, if 
  the function implementation cannot be found or does not return a value of the 
  declared type).</P>
  <LI class=xquery>
  <P>Limits on ranges of values for various data types, as enumerated in <A 
  href="REC-xquery-20070123.htm#id-data-model-conformance"><B>5.3 
  Data Model Conformance</B></A>.</P></LI></OL>
<DIV class=note>
<P class=prefix><B>Note:</B></P>
<P>Additional <A title="implementation defined" 
href="REC-xquery-20070123.htm#dt-implementation-defined">implementation-defined</A> 
items are listed in <A 
href="REC-xquery-20070123.htm#datamodel">[XQuery/XPath 
Data Model (XDM)]</A> and <A 
href="REC-xquery-20070123.htm#FunctionsAndOperators">[XQuery 
1.0 and XPath 2.0 Functions and Operators]</A>.</P></DIV></DIV>
<DIV class=div1>
<H2><A id=id-references name=id-references></A>E References</H2>
<DIV class=div2>
<H3><A id=id-normative-references name=id-normative-references></A>E.1 Normative 
References</H3>
<DL>
  <DT class=label><SPAN><A id=RFC2119 name=RFC2119></A>RFC 2119</SPAN> 
  <DD>
  <DIV>S. Bradner. <EM>Key Words for use in RFCs to Indicate Requirement 
  Levels.</EM> IETF RFC 2119. See <A 
  href="http://rfc.net/rfc2119.html">http://rfc.net/rfc2119.html</A>.</DIV>
  <DT class=label><SPAN><A id=RFC2396 name=RFC2396></A>RFC2396</SPAN> 
  <DD>
  <DIV>T. Berners-Lee, R. Fielding, and L. Masinter. <EM>Uniform Resource 
  Identifiers (URI): Generic Syntax</EM>. IETF RFC 2396. See <A 
  href="http://www.ietf.org/rfc/rfc2396.txt">http://www.ietf.org/rfc/rfc2396.txt</A>.</DIV>
  <DT class=label><SPAN><A id=RFC3986 name=RFC3986></A>RFC3986</SPAN> 
  <DD>
  <DIV>T. Berners-Lee, R. Fielding, and L. Masinter. <EM>Uniform Resource 
  Identifiers (URI): Generic Syntax</EM>. IETF RFC 3986. See <A 
  href="http://www.ietf.org/rfc/rfc3986.txt">http://www.ietf.org/rfc/rfc3986.txt</A>.</DIV>
  <DT class=label><SPAN><A id=RFC3987 name=RFC3987></A>RFC3987</SPAN> 
  <DD>
  <DIV>M. Duerst and M. Suignard. <EM>Internationalized Resource Identifiers 
  (IRIs)</EM>. IETF RFC 3987. See <A 
  href="http://www.ietf.org/rfc/rfc3987.txt">http://www.ietf.org/rfc/rfc3987.txt</A>.</DIV>
  <DT class=label><SPAN><A id=ISO10646 name=ISO10646></A>ISO/IEC 10646</SPAN> 
  <DD>
  <DIV>ISO (International Organization for Standardization). <EM>ISO/IEC 
  10646:2003. Information technology—Universal Multiple-Octet Coded Character 
  Set (UCS)</EM>, as, from time to time, amended, replaced by a new edition, or 
  expanded by the addition of new parts. [Geneva]: International Organization 
  for Standardization. (See <A 
  href="http://www.iso.org/">http://www.iso.org/</A> for the latest 
  version.)</DIV>
  <DT class=label><SPAN><A id=Unicode name=Unicode></A>Unicode</SPAN> 
  <DD>
  <DIV>The Unicode Consortium. <EM>The Unicode Standard</EM> Reading, Mass.: 
  Addison-Wesley, 2003, as updated from time to time by the publication of new 
  versions. See <A 
  href="http://www.unicode.org/unicode/standard/versions">http://www.unicode.org/unicode/standard/versions</A> 
  for the latest version and additional information on versions of the standard 
  and of the Unicode Character Database. The version of Unicode to be used is <A 
  title="implementation defined" 
  href="REC-xquery-20070123.htm#dt-implementation-defined">implementation-defined</A>, 
  but implementations are recommended to use the latest Unicode version.</DIV>
  <DT class=label><SPAN><A id=XML name=XML></A>XML 1.0</SPAN> 
  <DD>
  <DIV>World Wide Web Consortium. <EM>Extensible Markup Language (XML) 1.0. 
  (Third Edition)</EM> W3C Recommendation. See <A 
  href="http://www.w3.org/TR/REC-xml">http://www.w3.org/TR/REC-xml</A></DIV>
  <DT class=label><SPAN><A id=XML1.1 name=XML1.1></A>XML 1.1</SPAN> 
  <DD>
  <DIV>World Wide Web Consortium. <EM>Extensible Markup Language (XML) 1.1.</EM> 
  W3C Recommendation. See <A 
  href="http://www.w3.org/TR/xml11/">http://www.w3.org/TR/xml11/</A></DIV>
  <DT class=label><SPAN><A id=XMLBASE name=XMLBASE></A>XML Base</SPAN> 
  <DD>
  <DIV>World Wide Web Consortium. <EM>XML Base.</EM> W3C Recommendation. See <A 
  href="http://www.w3.org/TR/xmlbase/">http://www.w3.org/TR/xmlbase/</A></DIV>
  <DT class=label><SPAN><A id=XMLNAMES name=XMLNAMES></A>XML Names</SPAN> 
  <DD>
  <DIV>World Wide Web Consortium. <EM>Namespaces in XML.</EM> W3C 
  Recommendation. See <A 
  href="http://www.w3.org/TR/REC-xml-names/">http://www.w3.org/TR/REC-xml-names/</A></DIV>
  <DT class=label><SPAN><A id=XMLNAMES11 name=XMLNAMES11></A>XML Names 
  1.1</SPAN> 
  <DD>
  <DIV>World Wide Web Consortium. <EM>Namespaces in XML 1.1.</EM> W3C 
  Recommendation. See <A 
  href="http://www.w3.org/TR/xml-names11/">http://www.w3.org/TR/xml-names11/</A></DIV>
  <DT class=label><SPAN><A id=XMLID name=XMLID></A>XML ID</SPAN> 
  <DD>
  <DIV>World Wide Web Consortium. <EM>xml:id Version 1.0.</EM> W3C 
  Recommendation. See <A 
  href="http://www.w3.org/TR/xml-id/">http://www.w3.org/TR/xml-id/</A></DIV>
  <DT class=label><SPAN><A id=XMLSchema name=XMLSchema></A>XML Schema</SPAN> 
  <DD>
  <DIV>World Wide Web Consortium. <EM>XML Schema, Parts 0, 1, and 2 (Second 
  Edition)</EM>. W3C Recommendation, 28 October 2004. See <A 
  href="http://www.w3.org/TR/xmlschema-0/">http://www.w3.org/TR/xmlschema-0/</A>, 
  <A 
  href="http://www.w3.org/TR/xmlschema-1/">http://www.w3.org/TR/xmlschema-1/</A>, 
  and <A 
  href="http://www.w3.org/TR/xmlschema-2/">http://www.w3.org/TR/xmlschema-2/</A>.</DIV>
  <DT class=label><SPAN><A id=datamodel name=datamodel></A>XQuery/XPath Data 
  Model (XDM)</SPAN> 
  <DD>
  <DIV>World Wide Web Consortium. <EM>XQuery 1.0 and XPath 2.0 Data Model 
  (XDM)</EM>. W3C Recommendation, 23 Jan. 2007. See <A 
  href="http://www.w3.org/TR/xpath-datamodel/">http://www.w3.org/TR/xpath-datamodel/</A>.</DIV>
  <DT class=label><SPAN><A id=XQueryFormalSemantics 
  name=XQueryFormalSemantics></A>XQuery 1.0 and XPath 2.0 Formal 
  Semantics</SPAN> 
  <DD>
  <DIV>World Wide Web Consortium. <EM>XQuery 1.0 and XPath 2.0 Formal 
  Semantics</EM>. W3C Recommendation, 23 Jan. 2007. See <A 
  href="http://www.w3.org/TR/xquery-semantics/">http://www.w3.org/TR/xquery-semantics/</A>.</DIV>
  <DT class=label><SPAN><A id=FunctionsAndOperators 
  name=FunctionsAndOperators></A>XQuery 1.0 and XPath 2.0 Functions and 
  Operators</SPAN> 
  <DD>
  <DIV>World Wide Web Consortium. <EM>XQuery 1.0 and XPath 2.0 Functions and 
  Operators</EM> W3C Recommendation, 23 Jan. 2007. See <A 
  href="http://www.w3.org/TR/xquery-operators/">http://www.w3.org/TR/xquery-operators/</A>.</DIV>
  <DT class=label><SPAN><A id=serialization name=serialization></A>XSLT 2.0 and 
  XQuery 1.0 Serialization</SPAN> 
  <DD>
  <DIV>World Wide Web Consortium. <EM>XSLT 2.0 and XQuery 1.0 
  Serialization</EM>. W3C Recommendation, 23 Jan. 2007. See <A 
  href="http://www.w3.org/TR/xslt-xquery-serialization/">http://www.w3.org/TR/xslt-xquery-serialization/</A>.</DIV></DD></DL></DIV>
<DIV class=div2>
<H3><A id=id-non-normative-references name=id-non-normative-references></A>E.2 
Non-normative References</H3>
<DL>
  <DT class=label><SPAN class=xquery><A id=Requirements 
  name=Requirements></A>XML Query 1.0 Requirements</SPAN> 
  <DD>
  <DIV class=xquery>World Wide Web Consortium. <EM>XML Query 1.0 
  Requirements</EM>. W3C Working Draft, 14 Nov 2003. See <A 
  href="http://www.w3.org/TR/xquery-requirements/">http://www.w3.org/TR/xquery-requirements/</A>.</DIV>
  <DT class=label><SPAN class=xquery><A id=XPath20 name=XPath20></A>XPath 
  2.0</SPAN> 
  <DD>
  <DIV class=xquery>World Wide Web Consortium. <EM>XML Path Language (XPath) 
  Version 2.0</EM>. W3C Recommendation, 23 Jan. 2007. See <A 
  href="http://www.w3.org/TR/xpath20/">http://www.w3.org/TR/xpath20/</A>.</DIV>
  <DT class=label><SPAN class=xquery><A id=XQueryX name=XQueryX></A>XQueryX 
  1.0</SPAN> 
  <DD>
  <DIV class=xquery>World Wide Web Consortium. <EM>XQueryX, Version 1.0</EM>. 
  W3C Recommendation, 23 Jan. 2007. See <A 
  href="http://www.w3.org/TR/xqueryx/">http://www.w3.org/TR/xqueryx/</A>.</DIV>
  <DT class=label><SPAN><A id=XSLT name=XSLT></A>XSLT 2.0</SPAN> 
  <DD>
  <DIV>World Wide Web Consortium. <EM>XSL Transformations (XSLT) 2.0.</EM> W3C 
  Recommendation, 23 Jan. 2007. See <A 
  href="http://www.w3.org/TR/xslt20/">http://www.w3.org/TR/xslt20/</A></DIV>
  <DT class=label><SPAN><A id=DOM name=DOM></A>Document Object Model</SPAN> 
  <DD>
  <DIV>World Wide Web Consortium. <EM>Document Object Model (DOM) Level 3 Core 
  Specification.</EM> W3C Recommendation, April 7, 2004. See <A 
  href="http://www.w3.org/TR/DOM-Level-3-Core/">http://www.w3.org/TR/DOM-Level-3-Core/</A>.</DIV>
  <DT class=label><SPAN><A id=XINFO name=XINFO></A>XML Infoset</SPAN> 
  <DD>
  <DIV>World Wide Web Consortium. <EM>XML Information Set.</EM> W3C 
  Recommendation 24 October 2001. See <A 
  href="http://www.w3.org/TR/xml-infoset/">http://www.w3.org/TR/xml-infoset/</A></DIV>
  <DT class=label><SPAN><A id=XPath name=XPath></A>XPath 1.0</SPAN> 
  <DD>
  <DIV>World Wide Web Consortium. <EM>XML Path Language (XPath) Version 
  1.0</EM>. W3C Recommendation, Nov. 16, 1999. See <A 
  href="http://www.w3.org/TR/xpath.html">http://www.w3.org/TR/xpath.html</A></DIV>
  <DT class=label><SPAN><A id=XPTR name=XPTR></A>XPointer</SPAN> 
  <DD>
  <DIV>World Wide Web Consortium. <EM>XML Pointer Language (XPointer).</EM> W3C 
  Last Call Working Draft 8 January 2001. See <A 
  href="http://www.w3.org/TR/WD-xptr">http://www.w3.org/TR/WD-xptr</A></DIV>
  <DT class=label><SPAN class=xquery><A id=UseCases name=UseCases></A>XML Query 
  Use Cases</SPAN> 
  <DD>
  <DIV class=xquery>World Wide Web Consortium. <EM>XML Query Use Cases</EM>. W3C 
  Working Draft, 8 June 2006. See <A 
  href="http://www.w3.org/TR/xquery-use-cases/">http://www.w3.org/TR/xquery-use-cases/</A>.</DIV>
  <DT class=label><SPAN class=xquery><A id=xml11schema10 
  name=xml11schema10></A>XML 1.1 and Schema 1.0</SPAN> 
  <DD>
  <DIV class=xquery>World Wide Web Consortium. <EM>Processing XML 1.0 Documents 
  with XML Schema 1.0 Processors</EM>. W3C Working Group Note, 11 May 2005. See 
  <A 
  href="http://www.w3.org/TR/xml11schema10/">http://www.w3.org/TR/xml11schema10/</A>.</DIV>
  <DT class=label><SPAN class=xquery><A id=RFC1738 name=RFC1738></A>Uniform 
  Resource Locators (URL)</SPAN> 
  <DD>
  <DIV class=xquery>Internet Engineering Task Force (IETF). <EM>Uniform Resource 
  Locators (URL)</EM>. Request For Comment No. 1738, Dec. 1994. See <A 
  href="http://www.ietf.org/rfc/rfc1738.txt">http://www.ietf.org/rfc/rfc1738.txt</A>.</DIV>
  <DT class=label><SPAN class=xquery><A id=ODMG name=ODMG></A>ODMG</SPAN> 
  <DD>
  <DIV class=xquery>Rick Cattell et al. <EM>The Object Database Standard: 
  ODMG-93, Release 1.2</EM>. Morgan Kaufmann Publishers, San Francisco, 
  1996.</DIV>
  <DT class=label><SPAN class=xquery><A id=Quilt name=Quilt></A>Quilt</SPAN> 
  <DD>
  <DIV class=xquery>Don Chamberlin, Jonathan Robie, and Daniela Florescu. 
  <EM>Quilt: an XML Query Language for Heterogeneous Data Sources</EM>. In 
  <EM>Lecture Notes in Computer Science</EM>, Springer-Verlag, Dec. 2000. Also 
  available at <A 
  href="http://www.almaden.ibm.com/cs/people/chamberlin/quilt_lncs.pdf">http://www.almaden.ibm.com/cs/people/chamberlin/quilt_lncs.pdf</A>. 
  See also <A 
  href="http://www.almaden.ibm.com/cs/people/chamberlin/quilt.html">http://www.almaden.ibm.com/cs/people/chamberlin/quilt.html</A>.</DIV>
  <DT class=label><SPAN class=xquery><A id=XML-QL name=XML-QL></A>XML-QL</SPAN> 
  <DD>
  <DIV class=xquery>Alin Deutsch, Mary Fernandez, Daniela Florescu, Alon Levy, 
  and Dan Suciu. <EM>A Query Language for XML</EM>.</DIV>
  <DT class=label><SPAN class=xquery><A id=SQL name=SQL></A>SQL</SPAN> 
  <DD>
  <DIV class=xquery>International Organization for Standardization (ISO). 
  <EM>Information Technology-Database Language SQL</EM>. Standard No. ISO/IEC 
  9075:2003. (Available from American National Standards Institute, New York, NY 
  10036, (212) 642-4900.)</DIV>
  <DT class=label><SPAN class=xquery><A id=XQL name=XQL></A>XQL</SPAN> 
  <DD>
  <DIV class=xquery>J. Robie, J. Lapp, D. Schach. <EM>XML Query Language 
  (XQL)</EM>. See <A 
  href="http://www.w3.org/TandS/QL/QL98/pp/xql.html">http://www.w3.org/TandS/QL/QL98/pp/xql.html</A>.</DIV></DD></DL></DIV>
<DIV class=div2>
<H3><A id=id-background-material name=id-background-material></A>E.3 Background 
Material</H3>
<DL>
  <DT class=label><SPAN><A id=CHARMOD name=CHARMOD></A>Character Model</SPAN> 
  <DD>
  <DIV>World Wide Web Consortium. <EM>Character Model for the World Wide 
  Web.</EM> W3C Working Draft. See <A 
  href="http://www.w3.org/TR/charmod/">http://www.w3.org/TR/charmod/</A>.</DIV>
  <DT class=label><SPAN><A id=XSLT1 name=XSLT1></A>XSLT 1.0</SPAN> 
  <DD>
  <DIV>World Wide Web Consortium. <EM>XSL Transformations (XSLT) 1.0.</EM> W3C 
  Recommendation. See <A 
  href="http://www.w3.org/TR/xslt">http://www.w3.org/TR/xslt</A></DIV>
  <DT class=label><SPAN class=xquery><A id=UseCaseQueries 
  name=UseCaseQueries></A>Use Case Sample Queries</SPAN> 
  <DD>
  <DIV class=xquery>Queries from the XQuery 1.0 Use Cases, presented in a single 
  file. See <A 
  href="http://www.w3.org/TR/xquery-use-cases/xquery-use-case-queries.txt">http://www.w3.org/TR/xquery-use-cases/xquery-use-case-queries.txt</A>.</DIV>
  <DT class=label><SPAN class=xquery><A id=XQueryQueries 
  name=XQueryQueries></A>XQuery Sample Queries</SPAN> 
  <DD>
  <DIV class=xquery>Queries from this document, presented in a single file. See 
  <A 
  href="http://www.w3.org/TR/xquery-use-cases/xquery-wd-queries.txt">http://www.w3.org/TR/xquery-use-cases/xquery-wd-queries.txt</A>.</DIV></DD></DL></DIV></DIV>
<DIV class=div1>
<H2><A id=id-errors name=id-errors></A>F Error Conditions</H2>
<DL>
  <DT><A id=ERRXPST0001 name=ERRXPST0001></A>err:XPST0001 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xquery-20070123.htm#dt-static-error">static 
  error</A> if analysis of an expression relies on some component of the <A 
  title="static context" 
  href="REC-xquery-20070123.htm#dt-static-context">static 
  context</A> that has not been assigned a value.</P>
  <DT><A id=ERRXPDY0002 name=ERRXPDY0002></A>err:XPDY0002 
  <DD>
  <P>It is a <A title="dynamic error" 
  href="REC-xquery-20070123.htm#dt-dynamic-error">dynamic 
  error</A> if evaluation of an expression relies on some part of the <A 
  title="dynamic context" 
  href="REC-xquery-20070123.htm#dt-dynamic-context">dynamic 
  context</A> that has not been assigned a value.</P>
  <DT><A id=ERRXPST0003 name=ERRXPST0003></A>err:XPST0003 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xquery-20070123.htm#dt-static-error">static 
  error</A> if an expression is not a valid instance of the grammar defined in 
  <A href="REC-xquery-20070123.htm#id-grammar"><B>A.1 
  EBNF</B></A>.</P>
  <DT><A id=ERRXPTY0004 name=ERRXPTY0004></A>err:XPTY0004 
  <DD>
  <P>It is a <A title="type error" 
  href="REC-xquery-20070123.htm#dt-type-error">type 
  error</A> if, during the <A title="static analysis phase" 
  href="REC-xquery-20070123.htm#dt-static-analysis">static 
  analysis phase</A>, an expression is found to have a <A title="static type" 
  href="REC-xquery-20070123.htm#dt-static-type">static 
  type</A> that is not appropriate for the context in which the expression 
  occurs, or during the <A title="dynamic evaluation phase" 
  href="REC-xquery-20070123.htm#dt-dynamic-evaluation">dynamic 
  evaluation phase</A>, the <A title="dynamic type" 
  href="REC-xquery-20070123.htm#dt-dynamic-type">dynamic 
  type</A> of a value does not match a required type as specified by the 
  matching rules in <A 
  href="REC-xquery-20070123.htm#id-sequencetype-matching"><B>2.5.4 
  SequenceType Matching</B></A>.</P>
  <DT><A id=ERRXPST0005 name=ERRXPST0005></A>err:XPST0005 
  <DD>
  <P>During the analysis phase, it is a <A title="static error" 
  href="REC-xquery-20070123.htm#dt-static-error">static 
  error</A> if the <A title="static type" 
  href="REC-xquery-20070123.htm#dt-static-type">static 
  type</A> assigned to an expression other than the expression <CODE>()</CODE> 
  or <CODE>data(())</CODE> is <CODE>empty-sequence()</CODE>.</P>
  <DT><A id=ERRXPTY0006 name=ERRXPTY0006></A>err:XPTY0006 
  <DD>
  <P>(Not currently used.)</P>
  <DT><A id=ERRXPTY0007 name=ERRXPTY0007></A>err:XPTY0007 
  <DD>
  <P>(Not currently used.)</P>
  <DT><A id=ERRXPST0008 name=ERRXPST0008></A>err:XPST0008 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xquery-20070123.htm#dt-static-error">static 
  error</A> if an expression refers to an element name, attribute name, schema 
  type name, namespace prefix, or variable name that is not defined in the <A 
  title="static context" 
  href="REC-xquery-20070123.htm#dt-static-context">static 
  context</A>, except for an ElementName in an <A 
  href="REC-xquery-20070123.htm#doc-xquery-ElementTest">ElementTest</A> 
  or an AttributeName in an <A 
  href="REC-xquery-20070123.htm#doc-xquery-AttributeTest">AttributeTest</A>.</P>
  <DT><A id=ERRXQST0009 name=ERRXQST0009></A>err:XQST0009 
  <DD>
  <P>An implementation that does not support the Schema Import Feature must 
  raise a <A title="static error" 
  href="REC-xquery-20070123.htm#dt-static-error">static 
  error</A> if a Prolog contains a schema import.</P>
  <DT><A id=ERRXPST0010 name=ERRXPST0010></A>err:XPST0010 
  <DD>
  <P>An implementation must raise a <A title="static error" 
  href="REC-xquery-20070123.htm#dt-static-error">static 
  error</A> if it encounters a reference to an axis that it does not 
support.</P>
  <DT><A id=ERRXQST0012 name=ERRXQST0012></A>err:XQST0012 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xquery-20070123.htm#dt-static-error">static 
  error</A> if the set of definitions contained in all schemas imported by a 
  Prolog do not satisfy the conditions for schema validity specified in Sections 
  3 and 5 of <A 
  href="REC-xquery-20070123.htm#XMLSchema">[XML 
  Schema]</A> Part 1--i.e., each definition must be valid, complete, and 
  unique.</P>
  <DT><A id=ERRXQST0013 name=ERRXQST0013></A>err:XQST0013 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xquery-20070123.htm#dt-static-error">static 
  error</A> if an implementation recognizes a pragma but determines that its 
  content is invalid.</P>
  <DT><A id=ERRXQST0014 name=ERRXQST0014></A>err:XQST0014 
  <DD>
  <P>(Not currently used.)</P>
  <DT><A id=ERRXQST0015 name=ERRXQST0015></A>err:XQST0015 
  <DD>
  <P>(Not currently used.)</P>
  <DT><A id=ERRXQST0016 name=ERRXQST0016></A>err:XQST0016 
  <DD>
  <P>An implementation that does not support the Module Feature raises a <A 
  title="static error" 
  href="REC-xquery-20070123.htm#dt-static-error">static 
  error</A> if it encounters a <A title="module declaration" 
  href="REC-xquery-20070123.htm#dt-module-declaration">module 
  declaration</A> or a <A title="module import" 
  href="REC-xquery-20070123.htm#dt-module-import">module 
  import</A>.</P>
  <DT><A id=ERRXPST0017 name=ERRXPST0017></A>err:XPST0017 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xquery-20070123.htm#dt-static-error">static 
  error</A> if the expanded QName and number of arguments in a function call do 
  not match the name and arity of a <A title="function signature" 
  href="REC-xquery-20070123.htm#dt-function-signature">function 
  signature</A> in the <A title="static context" 
  href="REC-xquery-20070123.htm#dt-static-context">static 
  context</A>.</P>
  <DT><A id=ERRXPTY0018 name=ERRXPTY0018></A>err:XPTY0018 
  <DD>
  <P>It is a <A title="type error" 
  href="REC-xquery-20070123.htm#dt-type-error">type 
  error</A> if the result of the last step in a path expression contains both 
  nodes and atomic values.</P>
  <DT><A id=ERRXPTY0019 name=ERRXPTY0019></A>err:XPTY0019 
  <DD>
  <P>It is a <A title="type error" 
  href="REC-xquery-20070123.htm#dt-type-error">type 
  error</A> if the result of a step (other than the last step) in a path 
  expression contains an atomic value.</P>
  <DT><A id=ERRXPTY0020 name=ERRXPTY0020></A>err:XPTY0020 
  <DD>
  <P>It is a <A title="type error" 
  href="REC-xquery-20070123.htm#dt-type-error">type 
  error</A> if, in an axis step, the context item is not a node.</P>
  <DT><A id=ERRXPDY0021 name=ERRXPDY0021></A>err:XPDY0021 
  <DD>
  <P>(Not currently used.)</P>
  <DT><A id=ERRXQST0022 name=ERRXQST0022></A>err:XQST0022 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xquery-20070123.htm#dt-static-error">static 
  error</A> if the value of a <A title="namespace declaration attribute" 
  href="REC-xquery-20070123.htm#dt-namespace-decl-attr">namespace 
  declaration attribute</A> is not a <A 
  href="REC-xquery-20070123.htm#doc-xquery-URILiteral">URILiteral</A>.</P>
  <DT><A id=ERRXQTY0023 name=ERRXQTY0023></A>err:XQTY0023 
  <DD>
  <P>(Not currently used.)</P>
  <DT><A id=ERRXQTY0024 name=ERRXQTY0024></A>err:XQTY0024 
  <DD>
  <P>It is a <A title="type error" 
  href="REC-xquery-20070123.htm#dt-type-error">type 
  error</A> if the content sequence in an element constructor contains an 
  attribute node following a node that is not an attribute node.</P>
  <DT><A id=ERRXQDY0025 name=ERRXQDY0025></A>err:XQDY0025 
  <DD>
  <P>It is a <A title="dynamic error" 
  href="REC-xquery-20070123.htm#dt-dynamic-error">dynamic 
  error</A> if any attribute of a constructed element does not have a name that 
  is distinct from the names of all other attributes of the constructed 
  element.</P>
  <DT><A id=ERRXQDY0026 name=ERRXQDY0026></A>err:XQDY0026 
  <DD>
  <P>It is a <A title="dynamic error" 
  href="REC-xquery-20070123.htm#dt-dynamic-error">dynamic 
  error</A> if the result of the content expression of a computed processing 
  instruction constructor contains the string "<CODE>?&gt;</CODE>".</P>
  <DT><A id=ERRXQDY0027 name=ERRXQDY0027></A>err:XQDY0027 
  <DD>
  <P>In a validate expression, it is a <A title="dynamic error" 
  href="REC-xquery-20070123.htm#dt-dynamic-error">dynamic 
  error</A> if the root element information item in the PSVI resulting from 
  validation does not have the expected validity property: <CODE>valid</CODE> if 
  validation mode is <CODE>strict</CODE>, or either <CODE>valid</CODE> or 
  <CODE>notKnown</CODE> if validation mode is <CODE>lax</CODE>.</P>
  <DT><A id=ERRXQTY0028 name=ERRXQTY0028></A>err:XQTY0028 
  <DD>
  <P>(Not currently used.)</P>
  <DT><A id=ERRXQDY0029 name=ERRXQDY0029></A>err:XQDY0029 
  <DD>
  <P>(Not currently used.)</P>
  <DT><A id=ERRXQTY0030 name=ERRXQTY0030></A>err:XQTY0030 
  <DD>
  <P>It is a <A title="type error" 
  href="REC-xquery-20070123.htm#dt-type-error">type 
  error</A> if the argument of a <CODE>validate</CODE> expression does not 
  evaluate to exactly one document or element node.</P>
  <DT><A id=ERRXQST0031 name=ERRXQST0031></A>err:XQST0031 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xquery-20070123.htm#dt-static-error">static 
  error</A> if the version number specified in a version declaration is not 
  supported by the implementation.</P>
  <DT><A id=ERRXQST0032 name=ERRXQST0032></A>err:XQST0032 
  <DD>
  <P>A <A title="static error" 
  href="REC-xquery-20070123.htm#dt-static-error">static 
  error</A> is raised if a Prolog contains more than one <A 
  title="base URI declaration" 
  href="REC-xquery-20070123.htm#dt-base-uri-decl">base 
  URI declaration</A>.</P>
  <DT><A id=ERRXQST0033 name=ERRXQST0033></A>err:XQST0033 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xquery-20070123.htm#dt-static-error">static 
  error</A> if a module contains multiple bindings for the same namespace 
  prefix.</P>
  <DT><A id=ERRXQST0034 name=ERRXQST0034></A>err:XQST0034 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xquery-20070123.htm#dt-static-error">static 
  error</A> if multiple functions declared or imported by a <A title=module 
  href="REC-xquery-20070123.htm#dt-module">module</A> 
  have the number of arguments and their expanded QNames are equal (as defined 
  by the <CODE>eq</CODE> operator).</P>
  <DT><A id=ERRXQST0035 name=ERRXQST0035></A>err:XQST0035 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xquery-20070123.htm#dt-static-error">static 
  error</A> to import two schema components that both define the same name in 
  the same symbol space and in the same scope.</P>
  <DT><A id=ERRXQST0036 name=ERRXQST0036></A>err:XQST0036 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xquery-20070123.htm#dt-static-error">static 
  error</A> to import a module if the importing module's <A 
  title="in-scope schema type" 
  href="REC-xquery-20070123.htm#dt-is-types">in-scope 
  schema types</A> do not include definitions for the schema type names that 
  appear in the declarations of variables and functions (whether in an argument 
  type or return type) that are present in the imported module and are 
  referenced in the importing module.</P>
  <DT><A id=ERRXQST0037 name=ERRXQST0037></A>err:XQST0037 
  <DD>
  <P>(Not currently used.)</P>
  <DT><A id=ERRXQST0038 name=ERRXQST0038></A>err:XQST0038 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xquery-20070123.htm#dt-static-error">static 
  error</A> if a Prolog contains more than one <A 
  title="default collation declaration" 
  href="REC-xquery-20070123.htm#dt-default-collation-decl">default 
  collation declaration</A>, or the value specified by a default collation 
  declaration is not present in <A title="statically known collations" 
  href="REC-xquery-20070123.htm#dt-static-collations">statically 
  known collations</A>.</P>
  <DT><A id=ERRXQST0039 name=ERRXQST0039></A>err:XQST0039 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xquery-20070123.htm#dt-static-error">static 
  error</A> for a function declaration to have more than one parameter with the 
  same name.</P>
  <DT><A id=ERRXQST0040 name=ERRXQST0040></A>err:XQST0040 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xquery-20070123.htm#dt-static-error">static 
  error</A> if the attributes specified by a direct element constructor do not 
  have distinct expanded QNames.</P>
  <DT><A id=ERRXQDY0041 name=ERRXQDY0041></A>err:XQDY0041 
  <DD>
  <P>It is a <A title="dynamic error" 
  href="REC-xquery-20070123.htm#dt-dynamic-error">dynamic 
  error</A> if the value of the name expression in a computed processing 
  instruction constructor cannot be cast to the type <CODE>xs:NCName</CODE>.</P>
  <DT><A id=ERRXQST0042 name=ERRXQST0042></A>err:XQST0042 
  <DD>
  <P>(Not currently used.)</P>
  <DT><A id=ERRXQST0043 name=ERRXQST0043></A>err:XQST0043 
  <DD>
  <P>(Not currently used.)</P>
  <DT><A id=ERRXQDY0044 name=ERRXQDY0044></A>err:XQDY0044 
  <DD>
  <P>It is a <A title="dynamic error" 
  href="REC-xquery-20070123.htm#dt-dynamic-error">dynamic 
  error</A> if the <CODE>node-name</CODE> property of the node constructed by a 
  computed attribute constructor is in the namespace 
  <CODE>http://www.w3.org/2000/xmlns/</CODE> (corresponding to namespace prefix 
  <CODE>xmlns</CODE>), or is in no namespace and has local name 
  <CODE>xmlns</CODE>.</P>
  <DT><A id=ERRXQST0045 name=ERRXQST0045></A>err:XQST0045 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xquery-20070123.htm#dt-static-error">static 
  error</A> if the function name in a function declaration is in one of the 
  following namespaces: <CODE>http://www.w3.org/XML/1998/namespace, 
  http://www.w3.org/2001/XMLSchema, http://www.w3.org/2001/XMLSchema-instance, 
  http://www.w3.org/2005/xpath-functions</CODE>.</P>
  <DT><A id=ERRXQST0046 name=ERRXQST0046></A>err:XQST0046 
  <DD>
  <P>An implementation <A title=may 
  href="REC-xquery-20070123.htm#may">MAY</A> raise a <A 
  title="static error" 
  href="REC-xquery-20070123.htm#dt-static-error">static 
  error</A> if the value of a <A 
  href="REC-xquery-20070123.htm#doc-xquery-URILiteral">URILiteral</A> 
  is of nonzero length and is not in the lexical space of 
  <CODE>xs:anyURI</CODE>.</P>
  <DT><A id=ERRXQST0047 name=ERRXQST0047></A>err:XQST0047 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xquery-20070123.htm#dt-static-error">static 
  error</A> if multiple module imports in the same Prolog specify the same 
  target namespace.</P>
  <DT><A id=ERRXQST0048 name=ERRXQST0048></A>err:XQST0048 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xquery-20070123.htm#dt-static-error">static 
  error</A> if a function or variable declared in a library module is not in the 
  target namespace of the library module.</P>
  <DT><A id=ERRXQST0049 name=ERRXQST0049></A>err:XQST0049 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xquery-20070123.htm#dt-static-error">static 
  error</A> if two or more variables declared or imported by a <A title=module 
  href="REC-xquery-20070123.htm#dt-module">module</A> 
  have equal expanded QNames (as defined by the <CODE>eq</CODE> operator.)</P>
  <DT><A id=ERRXPDY0050 name=ERRXPDY0050></A>err:XPDY0050 
  <DD>
  <P>It is a <A title="dynamic error" 
  href="REC-xquery-20070123.htm#dt-dynamic-error">dynamic 
  error</A> if the <A title="dynamic type" 
  href="REC-xquery-20070123.htm#dt-dynamic-type">dynamic 
  type</A> of the operand of a <CODE>treat</CODE> expression does not match the 
  <A title="sequence type" 
  href="REC-xquery-20070123.htm#dt-sequence-type">sequence 
  type</A> specified by the <CODE>treat</CODE> expression. This error might also 
  be raised by a path expression beginning with "<CODE>/</CODE>" or 
  "<CODE>//</CODE>" if the context node is not in a tree that is rooted at a 
  document node. This is because a leading "<CODE>/</CODE>" or "<CODE>//</CODE>" 
  in a path expression is an abbreviation for an initial step that includes the 
  clause <CODE>treat as document-node()</CODE>.</P>
  <DT><A id=ERRXPST0051 name=ERRXPST0051></A>err:XPST0051 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xquery-20070123.htm#dt-static-error">static 
  error</A> if a QName that is used as an <A 
  href="REC-xquery-20070123.htm#doc-xquery-AtomicType">AtomicType</A> 
  in a <A 
  href="REC-xquery-20070123.htm#doc-xquery-SequenceType">SequenceType</A> 
  is not defined in the <A title="in-scope schema type" 
  href="REC-xquery-20070123.htm#dt-is-types">in-scope 
  schema types</A> as an atomic type.</P>
  <DT><A id=ERRXQDY0052 name=ERRXQDY0052></A>err:XQDY0052 
  <DD>
  <P>(Not currently used.)</P>
  <DT><A id=ERRXQST0053 name=ERRXQST0053></A>err:XQST0053 
  <DD>
  <P>(Not currently used.)</P>
  <DT><A id=ERRXQST0054 name=ERRXQST0054></A>err:XQST0054 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xquery-20070123.htm#dt-static-error">static 
  error</A> if a variable <A title="variable depends" 
  href="REC-xquery-20070123.htm#dt-variable-depends">depends</A> 
  on itself.</P>
  <DT><A id=ERRXQST0055 name=ERRXQST0055></A>err:XQST0055 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xquery-20070123.htm#dt-static-error">static 
  error</A> if a Prolog contains more than one <A 
  title="copy-namespaces declaration" 
  href="REC-xquery-20070123.htm#dt-copy-namespaces-decl">copy-namespaces 
  declaration</A>.</P>
  <DT><A id=ERRXQST0056 name=ERRXQST0056></A>err:XQST0056 
  <DD>
  <P>(Not currently used.)</P>
  <DT><A id=ERRXQST0057 name=ERRXQST0057></A>err:XQST0057 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xquery-20070123.htm#dt-static-error">static 
  error</A> if a schema import binds a namespace prefix but does not specify a 
  target namespace other than a zero-length string.</P>
  <DT><A id=ERRXQST0058 name=ERRXQST0058></A>err:XQST0058 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xquery-20070123.htm#dt-static-error">static 
  error</A> if multiple schema imports specify the same target namespace.</P>
  <DT><A id=ERRXQST0059 name=ERRXQST0059></A>err:XQST0059 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xquery-20070123.htm#dt-static-error">static 
  error</A> if an implementation is unable to process a schema or module import 
  by finding a schema or module with the specified target namespace.</P>
  <DT><A id=ERRXQST0060 name=ERRXQST0060></A>err:XQST0060 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xquery-20070123.htm#dt-static-error">static 
  error</A> if the name of a function in a function declaration is not in a 
  namespace (expanded QName has a null namespace URI).</P>
  <DT><A id=ERRXQDY0061 name=ERRXQDY0061></A>err:XQDY0061 
  <DD>
  <P>It is a <A title="dynamic error" 
  href="REC-xquery-20070123.htm#dt-dynamic-error">dynamic 
  error</A> if the operand of a validate expression is a document node whose 
  children do not consist of exactly one element node and zero or more comment 
  and processing instruction nodes, in any order.</P>
  <DT><A id=ERRXQDY0062 name=ERRXQDY0062></A>err:XQDY0062 
  <DD>
  <P>(Not currently used.)</P>
  <DT><A id=ERRXQST0063 name=ERRXQST0063></A>err:XQST0063 
  <DD>
  <P>(Not currently used.)</P>
  <DT><A id=ERRXQDY0064 name=ERRXQDY0064></A>err:XQDY0064 
  <DD>
  <P>It is a <A title="dynamic error" 
  href="REC-xquery-20070123.htm#dt-dynamic-error">dynamic 
  error</A> if the value of the name expression in a computed processing 
  instruction constructor is equal to "XML" (in any combination of upper and 
  lower case).</P>
  <DT><A id=ERRXQST0065 name=ERRXQST0065></A>err:XQST0065 
  <DD>
  <P>A <A title="static error" 
  href="REC-xquery-20070123.htm#dt-static-error">static 
  error</A> is raised if a Prolog contains more than one <A 
  title="ordering mode declaration" 
  href="REC-xquery-20070123.htm#dt-ordering-mode-decl">ordering 
  mode declaration</A>.</P>
  <DT><A id=ERRXQST0066 name=ERRXQST0066></A>err:XQST0066 
  <DD>
  <P>A <A title="static error" 
  href="REC-xquery-20070123.htm#dt-static-error">static 
  error</A> is raised if a Prolog contains more than one default element/type 
  namespace declaration, or more than one default function namespace 
  declaration.</P>
  <DT><A id=ERRXQST0067 name=ERRXQST0067></A>err:XQST0067 
  <DD>
  <P>A <A title="static error" 
  href="REC-xquery-20070123.htm#dt-static-error">static 
  error</A> is raised if a Prolog contains more than one <A 
  title="construction declaration" 
  href="REC-xquery-20070123.htm#dt-construction-decl">construction 
  declaration</A>.</P>
  <DT><A id=ERRXQST0068 name=ERRXQST0068></A>err:XQST0068 
  <DD>
  <P>A <A title="static error" 
  href="REC-xquery-20070123.htm#dt-static-error">static 
  error</A> is raised if a Prolog contains more than one <A 
  title="boundary-space declaration" 
  href="REC-xquery-20070123.htm#dt-boundary-space-decl">boundary-space 
  declaration</A>.</P>
  <DT><A id=ERRXQST0069 name=ERRXQST0069></A>err:XQST0069 
  <DD>
  <P>A <A title="static error" 
  href="REC-xquery-20070123.htm#dt-static-error">static 
  error</A> is raised if a Prolog contains more than one <A 
  title="empty order declaration" 
  href="REC-xquery-20070123.htm#dt-empty-order-decl">empty 
  order declaration</A>.</P>
  <DT><A id=ERRXQST0070 name=ERRXQST0070></A>err:XQST0070 
  <DD>
  <P>A <A title="static error" 
  href="REC-xquery-20070123.htm#dt-static-error">static 
  error</A> is raised if a namespace URI is bound to the predefined prefix 
  <CODE>xmlns</CODE>, or if a namespace URI other than 
  <CODE>http://www.w3.org/XML/1998/namespace</CODE> is bound to the prefix 
  <CODE>xml</CODE>, or if the prefix <CODE>xml</CODE> is bound to a namespace 
  URI other than <CODE>http://www.w3.org/XML/1998/namespace</CODE>.</P>
  <DT><A id=ERRXQST0071 name=ERRXQST0071></A>err:XQST0071 
  <DD>
  <P>A <A title="static error" 
  href="REC-xquery-20070123.htm#dt-static-error">static 
  error</A> is raised if the namespace declaration attributes of a direct 
  element constructor do not have distinct names.</P>
  <DT><A id=ERRXQDY0072 name=ERRXQDY0072></A>err:XQDY0072 
  <DD>
  <P>It is a <A title="dynamic error" 
  href="REC-xquery-20070123.htm#dt-dynamic-error">dynamic 
  error</A> if the result of the content expression of a computed comment 
  constructor contains two adjacent hyphens or ends with a hyphen.</P>
  <DT><A id=ERRXQST0073 name=ERRXQST0073></A>err:XQST0073 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xquery-20070123.htm#dt-static-error">static 
  error</A> if the graph of <A title="module import" 
  href="REC-xquery-20070123.htm#dt-module-import">module 
  imports</A> contains a cycle (that is, if there exists a sequence of modules 
  M<SUB>1</SUB> ... M<SUB>n</SUB> such that each M<SUB>i</SUB> imports 
  M<SUB>i+1</SUB> and M<SUB>n</SUB> imports M<SUB>1</SUB>), unless all the 
  modules in the cycle share a common namespace.</P>
  <DT><A id=ERRXQDY0074 name=ERRXQDY0074></A>err:XQDY0074 
  <DD>
  <P>It is a <A title="dynamic error" 
  href="REC-xquery-20070123.htm#dt-dynamic-error">dynamic 
  error</A> if the value of the name expression in a computed element or 
  attribute constructor cannot be converted to an <A title="expanded QName" 
  href="REC-xquery-20070123.htm#dt-expanded-qname">expanded 
  QName</A> (for example, because it contains a namespace prefix not found in <A 
  title="statically known namespaces" 
  href="REC-xquery-20070123.htm#dt-static-namespaces">statically 
  known namespaces</A>.)</P>
  <DT><A id=ERRXQST0075 name=ERRXQST0075></A>err:XQST0075 
  <DD>
  <P>An implementation that does not support the Validation Feature must raise a 
  <A title="static error" 
  href="REC-xquery-20070123.htm#dt-static-error">static 
  error</A> if it encounters a <CODE>validate</CODE> expression.</P>
  <DT><A id=ERRXQST0076 name=ERRXQST0076></A>err:XQST0076 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xquery-20070123.htm#dt-static-error">static 
  error</A> if a <CODE>collation</CODE> subclause in an <CODE>order by</CODE> 
  clause of a FLWOR expression does not identify a collation that is present in 
  <A title="statically known collations" 
  href="REC-xquery-20070123.htm#dt-static-collations">statically 
  known collations</A>.</P>
  <DT><A id=ERRXQST0077 name=ERRXQST0077></A>err:XQST0077 
  <DD>
  <P>(Not currently used.)</P>
  <DT><A id=ERRXQST0078 name=ERRXQST0078></A>err:XQST0078 
  <DD>
  <P>(Not currently used.)</P>
  <DT><A id=ERRXQST0079 name=ERRXQST0079></A>err:XQST0079 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xquery-20070123.htm#dt-static-error">static 
  error</A> if an extension expression contains neither a <A title=pragma 
  href="REC-xquery-20070123.htm#dt-pragma">pragma</A> 
  that is recognized by the implementation nor an expression enclosed in curly 
  braces.</P>
  <DT><A id=ERRXPST0080 name=ERRXPST0080></A>err:XPST0080 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xquery-20070123.htm#dt-static-error">static 
  error</A> if the target type of a <CODE>cast</CODE> or <CODE>castable</CODE> 
  expression is <CODE>xs:NOTATION</CODE> or <CODE>xs:anyAtomicType</CODE>.</P>
  <DT><A id=ERRXPST0081 name=ERRXPST0081></A>err:XPST0081 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xquery-20070123.htm#dt-static-error">static 
  error</A> if a QName used in <SPAN class=xquery><SPAN class=xquery>a 
  query</SPAN></SPAN> contains a namespace prefix that cannot be expanded into a 
  namespace URI by using the <A title="statically known namespaces" 
  href="REC-xquery-20070123.htm#dt-static-namespaces">statically 
  known namespaces</A>.</P>
  <DT><A id=ERRXQST0082 name=ERRXQST0082></A>err:XQST0082 
  <DD>
  <P>(Not currently used.)</P>
  <DT><A id=ERRXPST0083 name=ERRXPST0083></A>err:XPST0083 
  <DD>
  <P>(Not currently used.)</P>
  <DT><A id=ERRXQDY0084 name=ERRXQDY0084></A>err:XQDY0084 
  <DD>
  <P>It is a <A title="dynamic error" 
  href="REC-xquery-20070123.htm#dt-dynamic-error">dynamic 
  error</A> if the element validated by a <CODE>validate</CODE> statement does 
  not have a top-level element declaration in the <A 
  title="in-scope element declarations" 
  href="REC-xquery-20070123.htm#dt-is-elems">in-scope 
  element declarations</A>, if validation mode is <CODE>strict</CODE>.</P>
  <DT><A id=ERRXQST0085 name=ERRXQST0085></A>err:XQST0085 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xquery-20070123.htm#dt-static-error">static 
  error</A> if the namespace URI in a namespace declaration attribute is a 
  zero-length string, and the implementation does not support <A 
  href="REC-xquery-20070123.htm#XMLNAMES11">[XML Names 
  1.1]</A>.</P>
  <DT><A id=ERRXQTY0086 name=ERRXQTY0086></A>err:XQTY0086 
  <DD>
  <P>It is a <A title="type error" 
  href="REC-xquery-20070123.htm#dt-type-error">type 
  error</A> if the typed value of a copied element or attribute node is <A 
  title=namespace-sensitive 
  href="REC-xquery-20070123.htm#dt-namespace-sensitive">namespace-sensitive</A> 
  when <A title="construction mode" 
  href="REC-xquery-20070123.htm#dt-construction-mode">construction 
  mode</A> is <CODE>preserve</CODE> and <A title="copy-namespaces mode" 
  href="REC-xquery-20070123.htm#dt-copy-namespaces-mode">copy-namespaces 
  mode</A> is <CODE>no-preserve</CODE>.</P>
  <DT><A id=ERRXQST0087 name=ERRXQST0087></A>err:XQST0087 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xquery-20070123.htm#dt-static-error">static 
  error</A> if the encoding specified in a Version Declaration does not conform 
  to the definition of <CODE>EncName</CODE> specified in <A 
  href="REC-xquery-20070123.htm#XML">[XML 1.0]</A>.</P>
  <DT><A id=ERRXQST0088 name=ERRXQST0088></A>err:XQST0088 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xquery-20070123.htm#dt-static-error">static 
  error</A> if the literal that specifies the target namespace in a <A 
  title="module import" 
  href="REC-xquery-20070123.htm#dt-module-import">module 
  import</A> or a <A title="module declaration" 
  href="REC-xquery-20070123.htm#dt-module-declaration">module 
  declaration</A> is of zero length.</P>
  <DT><A id=ERRXQST0089 name=ERRXQST0089></A>err:XQST0089 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xquery-20070123.htm#dt-static-error">static 
  error</A> if a variable bound in a for clause of a FLWOR expression, and its 
  associated positional variable, do not have distinct names (expanded 
  QNames).</P>
  <DT><A id=ERRXQST0090 name=ERRXQST0090></A>err:XQST0090 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xquery-20070123.htm#dt-static-error">static 
  error</A> if a <A title="character reference" 
  href="REC-xquery-20070123.htm#dt-character-reference">character 
  reference</A> does not identify a valid character in the version of XML that 
  is in use.</P>
  <DT><A id=ERRXQDY0091 name=ERRXQDY0091></A>err:XQDY0091 
  <DD>
  <P>An implementation <A title=may 
  href="REC-xquery-20070123.htm#may">MAY</A> raise a <A 
  title="dynamic error" 
  href="REC-xquery-20070123.htm#dt-dynamic-error">dynamic 
  error</A> if an <CODE>xml:id</CODE> error, as defined in <A 
  href="REC-xquery-20070123.htm#XMLID">[XML ID]</A>, is 
  encountered during construction of an attribute named <CODE>xml:id</CODE>.</P>
  <DT><A id=ERRXQDY0092 name=ERRXQDY0092></A>err:XQDY0092 
  <DD>
  <P>An implementation <A title=may 
  href="REC-xquery-20070123.htm#may">MAY</A> raise a <A 
  title="dynamic error" 
  href="REC-xquery-20070123.htm#dt-dynamic-error">dynamic 
  error</A> if a constructed attribute named <CODE>xml:space</CODE> has a value 
  other than <CODE>preserve</CODE> or <CODE>default</CODE>.</P>
  <DT><A id=ERRXQST0093 name=ERRXQST0093></A>err:XQST0093 
  <DD>
  <P>It is a <A title="static error" 
  href="REC-xquery-20070123.htm#dt-static-error">static 
  error</A> to import a module M<SUB>1</SUB> if there exists a sequence of 
  modules M<SUB>1</SUB> ... M<SUB>i</SUB> ... M<SUB>1</SUB> such that each 
  module <A title="module directly depends" 
  href="REC-xquery-20070123.htm#dt-module-directly-depends">directly 
  depends</A> on the next module in the sequence (informally, if M<SUB>1</SUB> 
  depends on itself through some chain of module 
dependencies.)</P></DD></DL></DIV>
<DIV class=xquery>
<DIV class=div1>
<H2><A id=id-mime-type name=id-mime-type></A>G The 
<CODE>application/xquery</CODE> Media Type</H2>
<P>This Appendix specifies the media type for XQuery Version 1.0. XQuery is a 
language for querying over collections of data from XML data sources, as 
specified in the main body of this document. This media type is being submitted 
to the IESG (Internet Engineering Steering Group) for review, approval, and 
registration with IANA (Internet Assigned Numbers Authority.)</P>
<DIV class=div2>
<H3><A id=id-mime-type-intro name=id-mime-type-intro></A>G.1 Introduction</H3>
<P>This document, found at <SPAN class=xquery><A 
href="http://www.w3.org/TR/xquery/">http://www.w3.org/TR/xquery/</A></SPAN>, 
together with its normative references, defines the language XQuery Version 1.0. 
This Appendix provides information about the <CODE>application/xquery</CODE> 
media type, which is intended to be used for transmitting queries written in the 
XQuery language.</P>
<P>This document was prepared by members of the W3C XML Query Working Group. 
Please send comments to public-qt-comments@w3.org, a public mailing list with 
archives at <A 
href="http://lists.w3.org/Archives/Public/public-qt-comments">http://lists.w3.org/Archives/Public/public-qt-comments</A>.</P></DIV>
<DIV class=div2>
<H3><A id=id-registration-of-mime-type name=id-registration-of-mime-type></A>G.2 
Registration of MIME Media Type <CODE>application/xquery</CODE></H3>
<P>MIME media type name: <CODE>application</CODE></P>
<P>MIME subtype name: <CODE>xquery</CODE></P>
<P>Required parameters: none</P>
<P>Optional parameters: none</P>
<P>The syntax of XQuery is expressed in Unicode but may be written with any 
Unicode-compatible character encoding, including UTF-8 or UTF-16, or transported 
as US-ASCII or Latin-1 with Unicode characters outside the range of the given 
encoding represented using an XML-style <CODE>&amp;#xddd;</CODE> syntax.</P>
<DIV class=div3>
<H4><A id=id-interoperability-considerations 
name=id-interoperability-considerations></A>G.2.1 Interoperability 
Considerations</H4>
<P>None known.</P></DIV>
<DIV class=div3>
<H4><A id=id-applications-of-media-type 
name=id-applications-of-media-type></A>G.2.2 Applications Using this Media 
Type</H4>
<P>The public <A href="http://www.w3.org/XML/Query">XQuery Web page</A> lists 
more than two dozen implementations of the XQuery language, both proprietary and 
open source.</P>
<P>This new media type is being registered to allow for deployment of XQuery on 
the World Wide Web.</P></DIV>
<DIV class=div3>
<H4><A id=id-file-extensions name=id-file-extensions></A>G.2.3 File 
Extensions</H4>
<P>The most common file extensions in use for XQuery are <CODE>.xq</CODE> and 
<CODE>.xquery</CODE>.</P>
<P>The appropriate Macintosh file type code is <CODE>TEXT</CODE>.</P></DIV>
<DIV class=div3>
<H4><A id=id-intended-usage name=id-intended-usage></A>G.2.4 Intended Usage</H4>
<P>The intended usage of this media type is for interchange of XQuery 
expressions.</P></DIV>
<DIV class=div3>
<H4><A id=id-author-change-controller name=id-author-change-controller></A>G.2.5 
Author/Change Controller</H4>
<P>XQuery was produced by, and is maintained by, the World Wide Web Consortium's 
XML Query Working Group. The W3C has change control over this 
specification.</P></DIV></DIV>
<DIV class=div2>
<H3><A id=xquery-mime-encoding name=xquery-mime-encoding></A>G.3 Encoding 
Considerations</H3>
<P>For use with transports that are not 8-bit clean, quoted-printable encoding 
is recommended since the XQuery syntax itself uses the US-ASCII-compatible 
subset of Unicode.</P>
<P>An XQuery document may contain an <A title="encoding declaration" 
href="REC-xquery-20070123.htm#dt-encoding-declaration">encoding 
declaration</A> as part of its <A title="version declaration" 
href="REC-xquery-20070123.htm#dt-version-declaration">version 
declaration</A>:</P>
<DIV class=exampleInner><PRE>xquery version "1.0" encoding "utf-8";
</PRE></DIV></DIV>
<DIV class=div2>
<H3><A id=xquery-mime-recognizing name=xquery-mime-recognizing></A>G.4 
Recognizing XQuery Files</H3>
<P>An XQuery file may have the string <CODE>xquery version "V.V"</CODE> near the 
beginning of the document, where <CODE>"V.V"</CODE> is a version number. 
Currently the version number, if present, must be <CODE>"1.0"</CODE>.</P></DIV>
<DIV class=div2>
<H3><A id=id-charset-default-rules name=id-charset-default-rules></A>G.5 Charset 
Default Rules</H3>
<P>XQuery documents use the Unicode character set and, by default, the UTF-8 
encoding.</P></DIV>
<DIV class=div2>
<H3><A id=id-security-considerations name=id-security-considerations></A>G.6 
Security Considerations</H3>
<P>Queries written in XQuery may cause arbitrary URIs or IRIs to be 
dereferenced. Therefore, the security issues of <A 
href="REC-xquery-20070123.htm#RFC3987">[RFC3987]</A> 
Section 8 should be considered. In addition, the contents of resources 
identified by <CODE>file:</CODE> URIs can in some cases be accessed, processed 
and returned as results. XQuery expressions can invoke any of the functions 
defined in <A 
href="REC-xquery-20070123.htm#FunctionsAndOperators">[XQuery 
1.0 and XPath 2.0 Functions and Operators]</A>. For example, the 
<CODE>fn:doc()</CODE> and <CODE>fn:doc-available()</CODE> functions allow local 
filesystem probes as well as access to any URI-defined resource accessible from 
the system evaluating the XQuery expression.</P>
<P>XQuery is a full declarative programming language, and supports user-defined 
functions, external function libraries (modules) referenced by URI, and 
system-specific "native" functions.</P>
<P>Arbitrary recursion is possible, as is arbitrarily large memory usage, and 
implementations may place limits on CPU and memory usage, as well as restricting 
access to system-defined functions.</P>
<P>The XML Query Working group is working on a facility to allow XQuery 
expressions to create and update persistent data. Untrusted queries should not 
be given write access to data.</P>
<P>Furthermore, because the XQuery language permits extensions, it is possible 
that <CODE>application/xquery</CODE> may describe content that has security 
implications beyond those described here.</P></DIV></DIV></DIV>
<DIV class=div1>
<H2><A id=id-glossary name=id-glossary></A>H Glossary (Non-Normative)</H2>
<DL>
  <DT><A id=GLdt-atomic-value name=GLdt-atomic-value></A>atomic value 
  <DD>
  <P>An <B>atomic value</B> is a value in the value space of an <B>atomic 
  type</B>, as defined in <A 
  href="REC-xquery-20070123.htm#XMLSchema">[XML 
  Schema]</A>.</P>
  <DT><A id=GLdt-atomization name=GLdt-atomization></A>atomization 
  <DD>
  <P><B>Atomization</B> of a sequence is defined as the result of invoking the 
  <CODE>fn:data</CODE> function on the sequence, as defined in <A 
  href="REC-xquery-20070123.htm#FunctionsAndOperators">[XQuery 
  1.0 and XPath 2.0 Functions and Operators]</A>.</P>
  <DT><A id=GLdt-available-collections 
  name=GLdt-available-collections></A>available collections 
  <DD>
  <P><B>Available collections.</B> This is a mapping of strings onto sequences 
  of nodes. The string represents the absolute URI of a resource. The sequence 
  of nodes represents the result of the <CODE>fn:collection</CODE> function when 
  that URI is supplied as the argument.</P>
  <DT><A id=GLdt-available-docs name=GLdt-available-docs></A>available documents 

  <DD>
  <P><B>Available documents.</B> This is a mapping of strings onto document 
  nodes. The string represents the absolute URI of a resource. The document node 
  is the root of a tree that represents that resource using the <A 
  title="data model" 
  href="REC-xquery-20070123.htm#dt-datamodel">data 
  model</A>. The document node is returned by the <CODE>fn:doc</CODE> function 
  when applied to that URI.</P>
  <DT><A id=GLdt-axis-step name=GLdt-axis-step></A>axis step 
  <DD>
  <P>An <B>axis step</B> returns a sequence of nodes that are reachable from the 
  context node via a specified axis. Such a step has two parts: an <B>axis</B>, 
  which defines the "direction of movement" for the step, and a <A 
  title="node test" 
  href="REC-xquery-20070123.htm#dt-node-test">node 
  test</A>, which selects nodes based on their kind, name, and/or <A 
  title="type annotation" 
  href="REC-xquery-20070123.htm#dt-type-annotation">type 
  annotation</A>.</P>
  <DT><A id=GLdt-base-uri name=GLdt-base-uri></A>base URI 
  <DD>
  <P><B>Base URI.</B> This is an absolute URI, used when necessary in the 
  resolution of relative URIs (for example, by the <CODE>fn:resolve-uri</CODE> 
  function.)</P>
  <DT><A id=GLdt-base-uri-decl name=GLdt-base-uri-decl></A>base URI declaration 
  <DD>
  <P>A <B>base URI declaration</B> specifies the <A title="base URI" 
  href="REC-xquery-20070123.htm#dt-base-uri">base URI</A> 
  property of the <A title="static context" 
  href="REC-xquery-20070123.htm#dt-static-context">static 
  context</A>. The <A title="base URI" 
  href="REC-xquery-20070123.htm#dt-base-uri">base URI</A> 
  property is used when resolving relative URIs within a <A title=module 
  href="REC-xquery-20070123.htm#dt-module">module</A>.</P>
  <DT><A id=GLdt-binding-sequence name=GLdt-binding-sequence></A>binding 
  sequence 
  <DD>
  <P>The value of the expression associated with a variable in a 
  <CODE>for</CODE> clause is called the <B>binding sequence</B> for that 
  variable.</P>
  <DT><A id=GLdt-boundary-space-decl 
  name=GLdt-boundary-space-decl></A>boundary-space declaration 
  <DD>
  <P>A <B>boundary-space declaration</B> sets the <A 
  title="boundary-space policy" 
  href="REC-xquery-20070123.htm#dt-boundary-space-policy">boundary-space 
  policy</A> in the <A title="static context" 
  href="REC-xquery-20070123.htm#dt-static-context">static 
  context</A>, overriding any implementation-defined default. Boundary-space 
  policy controls whether <A title="boundary whitespace" 
  href="REC-xquery-20070123.htm#dt-boundary-whitespace">boundary 
  whitespace</A> is preserved by element constructors during processing of the 
  query.</P>
  <DT><A id=GLdt-boundary-space-policy 
  name=GLdt-boundary-space-policy></A>boundary-space policy 
  <DD>
  <P><B>Boundary-space policy.</B> This component controls the processing of <A 
  title="boundary whitespace" 
  href="REC-xquery-20070123.htm#dt-boundary-whitespace">boundary 
  whitespace</A> by <A title="direct element constructor" 
  href="REC-xquery-20070123.htm#dt-direct-elem-const">direct 
  element constructors</A>, as described in <A 
  href="REC-xquery-20070123.htm#id-whitespace"><B>3.7.1.4 
  Boundary Whitespace</B></A>.</P>
  <DT><A id=GLdt-boundary-whitespace name=GLdt-boundary-whitespace></A>boundary 
  whitespace 
  <DD>
  <P><B>Boundary whitespace</B> is a sequence of consecutive whitespace 
  characters within the content of a <A title="direct element constructor" 
  href="REC-xquery-20070123.htm#dt-direct-elem-const">direct 
  element constructor</A>, that is delimited at each end either by the start or 
  end of the content, or by a <A 
  href="REC-xquery-20070123.htm#doc-xquery-DirectConstructor">DirectConstructor</A>, 
  or by an <A 
  href="REC-xquery-20070123.htm#doc-xquery-EnclosedExpr">EnclosedExpr</A>. 
  For this purpose, characters generated by <A title="character reference" 
  href="REC-xquery-20070123.htm#dt-character-reference">character 
  references</A> such as <CODE>&amp;#x20;</CODE> or by <A 
  href="REC-xquery-20070123.htm#doc-xquery-CDataSection">CdataSections</A> 
  are not considered to be whitespace characters.</P>
  <DT><A id=GLdt-built-in-function name=GLdt-built-in-function></A>built-in 
  function 
  <DD>
  <P>The <B>built-in functions</B> supported by XQuery are defined in <A 
  href="REC-xquery-20070123.htm#FunctionsAndOperators">[XQuery 
  1.0 and XPath 2.0 Functions and Operators]</A>.</P>
  <DT><A id=GLdt-character-reference name=GLdt-character-reference></A>character 
  reference 
  <DD>
  <P>A <B>character reference</B> is an XML-style reference to a <A 
  href="REC-xquery-20070123.htm#Unicode">[Unicode]</A> 
  character, identified by its decimal or hexadecimal code point.</P>
  <DT><A id=GLdt-collation name=GLdt-collation></A>collation 
  <DD>
  <P>A <B>collation</B> is a specification of the manner in which strings and 
  URIs are compared and, by extension, ordered. For a more complete definition 
  of collation, see <A 
  href="REC-xquery-20070123.htm#FunctionsAndOperators">[XQuery 
  1.0 and XPath 2.0 Functions and Operators]</A>.</P>
  <DT><A id=GLdt-comma-operator name=GLdt-comma-operator></A>comma operator 
  <DD>
  <P>One way to construct a sequence is by using the <B>comma operator</B>, 
  which evaluates each of its operands and concatenates the resulting sequences, 
  in order, into a single result sequence.</P>
  <DT><A id=GLdt-computed-elem-const name=GLdt-computed-elem-const></A>computed 
  element constructor 
  <DD>
  <P>A <B>computed element constructor</B> creates an element node, allowing 
  both the name and the content of the node to be computed.</P>
  <DT><A id=GLdt-construction-decl name=GLdt-construction-decl></A>construction 
  declaration 
  <DD>
  <P>A <B>construction declaration</B> sets the <A title="construction mode" 
  href="REC-xquery-20070123.htm#dt-construction-mode">construction 
  mode</A> in the <A title="static context" 
  href="REC-xquery-20070123.htm#dt-static-context">static 
  context</A>, overriding any implementation-defined default.</P>
  <DT><A id=GLdt-construction-mode name=GLdt-construction-mode></A>construction 
  mode 
  <DD>
  <P><B>Construction mode.</B> The construction mode governs the behavior of 
  element and document node constructors. If construction mode is 
  <CODE>preserve</CODE>, the type of a constructed element node is 
  <CODE>xs:anyType</CODE>, and all attribute and element nodes copied during 
  node construction retain their original types. If construction mode is 
  <CODE>strip</CODE>, the type of a constructed element node is 
  <CODE>xs:untyped</CODE>; all element nodes copied during node construction 
  receive the type <CODE>xs:untyped</CODE>, and all attribute nodes copied 
  during node construction receive the type <CODE>xs:untypedAtomic</CODE>.</P>
  <DT><A id=GLdt-constructor-function 
  name=GLdt-constructor-function></A>constructor function 
  <DD>
  <P>The <B>constructor function</B> for a given type is used to convert 
  instances of other atomic types into the given type. The semantics of the 
  constructor function call <CODE>T($arg)</CODE> are defined to be equivalent to 
  the expression <CODE>(($arg) cast as T?)</CODE>.</P>
  <DT><A id=GLdt-content-expression name=GLdt-content-expression></A>content 
  expression 
  <DD>
  <P>The final part of a computed constructor is an expression enclosed in 
  braces, called the <B>content expression</B> of the constructor, that 
  generates the content of the node.</P>
  <DT><A id=GLdt-context-item name=GLdt-context-item></A>context item 
  <DD>
  <P>The <B>context item</B> is the item currently being processed. An item is 
  either an atomic value or a node.</P>
  <DT><A id=GLdt-context-item-static-type 
  name=GLdt-context-item-static-type></A>context item static type 
  <DD>
  <P><B>Context item static type.</B> This component defines the <A 
  title="static type" 
  href="REC-xquery-20070123.htm#dt-static-type">static 
  type</A> of the context item within the scope of a given expression.</P>
  <DT><A id=GLdt-context-node name=GLdt-context-node></A>context node 
  <DD>
  <P>When the context item is a node, it can also be referred to as the 
  <B>context node</B>.</P>
  <DT><A id=GLdt-context-position name=GLdt-context-position></A>context 
  position 
  <DD>
  <P>The <B>context position</B> is the position of the context item within the 
  sequence of items currently being processed.</P>
  <DT><A id=GLdt-context-size name=GLdt-context-size></A>context size 
  <DD>
  <P>The <B>context size</B> is the number of items in the sequence of items 
  currently being processed.</P>
  <DT><A id=GLdt-copy-namespaces-decl 
  name=GLdt-copy-namespaces-decl></A>copy-namespaces declaration 
  <DD>
  <P>A <B>copy-namespaces declaration</B> sets the value of <A 
  title="copy-namespaces mode" 
  href="REC-xquery-20070123.htm#dt-copy-namespaces-mode">copy-namespaces 
  mode</A> in the <A title="static context" 
  href="REC-xquery-20070123.htm#dt-static-context">static 
  context</A>, overriding any implementation-defined default. Copy-namespaces 
  mode controls the namespace bindings that are assigned when an existing 
  element node is copied by an element constructor or document constructor.</P>
  <DT><A id=GLdt-copy-namespaces-mode 
  name=GLdt-copy-namespaces-mode></A>copy-namespaces mode 
  <DD>
  <P><B>Copy-namespaces mode.</B> This component controls the namespace bindings 
  that are assigned when an existing element node is copied by an element 
  constructor, as described in <A 
  href="REC-xquery-20070123.htm#id-element-constructor"><B>3.7.1 
  Direct Element Constructors</B></A>. Its value consists of two parts: 
  <CODE>preserve</CODE> or <CODE>no-preserve</CODE>, and <CODE>inherit</CODE> or 
  <CODE>no-inherit</CODE>.</P>
  <DT><A id=GLdt-date-time name=GLdt-date-time></A>current dateTime 
  <DD>
  <P><B>Current dateTime.</B> This information represents an <A 
  title="implementation dependent" 
  href="REC-xquery-20070123.htm#dt-implementation-dependent">implementation-dependent</A> 
  point in time during the processing of <SPAN class=xquery><SPAN class=xquery>a 
  query</SPAN></SPAN>, and includes an explicit timezone. It can be retrieved by 
  the <CODE>fn:current-dateTime</CODE> function. If invoked multiple times 
  during the execution of <SPAN class=xquery><SPAN class=xquery>a 
  query</SPAN></SPAN>, this function always returns the same result.</P>
  <DT><A id=GLdt-datamodel name=GLdt-datamodel></A>data model 
  <DD>
  <P>XQuery operates on the abstract, logical structure of an XML document, 
  rather than its surface syntax. This logical structure, known as the <B>data 
  model</B>, is defined in <A 
  href="REC-xquery-20070123.htm#datamodel">[XQuery/XPath 
  Data Model (XDM)]</A>.</P>
  <DT><A id=GLdt-data-model-schema name=GLdt-data-model-schema></A>data model 
  schema 
  <DD>
  <P>For a given node in an <A title="XDM instance" 
  href="REC-xquery-20070123.htm#dt-data-model-instance">XDM 
  instance</A>, the <B>data model schema</B> is defined as the schema from which 
  the <A title="type annotation" 
  href="REC-xquery-20070123.htm#dt-type-annotation">type 
  annotation</A> of that node was derived.</P>
  <DT><A id=GLdt-def-collation name=GLdt-def-collation></A>default collation 
  <DD>
  <P><B>Default collation.</B> This identifies one of the collations in <A 
  title="statically known collations" 
  href="REC-xquery-20070123.htm#dt-static-collations">statically 
  known collations</A> as the collation to be used by functions and operators 
  for comparing and ordering values of type <CODE>xs:string</CODE> and 
  <CODE>xs:anyURI</CODE> (and types derived from them) when no explicit 
  collation is specified.</P>
  <DT><A id=GLdt-default-collation-decl 
  name=GLdt-default-collation-decl></A>default collation declaration 
  <DD>
  <P>A <B>default collation declaration</B> sets the value of the <A 
  title="default collation" 
  href="REC-xquery-20070123.htm#dt-def-collation">default 
  collation</A> in the <A title="static context" 
  href="REC-xquery-20070123.htm#dt-static-context">static 
  context</A>, overriding any implementation-defined default.</P>
  <DT><A id=GLdt-default-collection name=GLdt-default-collection></A>default 
  collection 
  <DD>
  <P><B>Default collection.</B> This is the sequence of nodes that would result 
  from calling the <CODE>fn:collection</CODE> function with no arguments.</P>
  <DT><A id=GLdt-def-elemtype-ns name=GLdt-def-elemtype-ns></A>default 
  element/type namespace 
  <DD>
  <P><B>Default element/type namespace.</B> This is a namespace URI or "none". 
  The namespace URI, if present, is used for any unprefixed QName appearing in a 
  position where an element or type name is expected.</P>
  <DT><A id=GLdt-def-fn-ns name=GLdt-def-fn-ns></A>default function namespace 
  <DD>
  <P><B>Default function namespace.</B> This is a namespace URI or "none". The 
  namespace URI, if present, is used for any unprefixed QName appearing in a 
  position where a function name is expected.</P>
  <DT><A id=GLdt-default-empty-order name=GLdt-default-empty-order></A>default 
  order for empty sequences 
  <DD>
  <P><B>Default order for empty sequences.</B> This component controls the 
  processing of empty sequences and <CODE>NaN</CODE> values as ordering keys in 
  an <CODE>order by</CODE> clause in a FLWOR expression, as described in <A 
  href="REC-xquery-20070123.htm#id-orderby-return"><B>3.8.3 
  Order By and Return Clauses</B></A>.</P>
  <DT><A id=GLdelimiting-token name=GLdelimiting-token></A>delimiting terminal 
  symbol 
  <DD>
  <P>The <B>delimiting terminal symbols</B> are: <A 
  href="REC-xquery-20070123.htm#prod-xquery-S">S</A>, 
  "-", (comma), (semi-colon), (colon), "::", ":=", "!=", "?", "?&gt;", "/", 
  "//", "/&gt;", (dot), "..", <A 
  href="REC-xquery-20070123.htm#prod-xquery-StringLiteral">StringLiteral</A>, 
  "(", "(#", ")", "[", "]", "]]&gt;", "{", "}", "@", "$", "*", "#)", "+", 
  "&lt;", "&lt;!--", "&lt;![CDATA[", "&lt;?", "&lt;/", "&lt;&lt;", "&lt;=", "=", 
  "&gt;", "--&gt;", "&gt;=", "&gt;&gt;", "|"</P>
  <DT><A id=GLdt-direct-elem-const name=GLdt-direct-elem-const></A>direct 
  element constructor 
  <DD>
  <P>A <B>direct element constructor</B> is a form of element constructor in 
  which the name of the constructed element is a constant.</P>
  <DT><A id=GLdt-document-order name=GLdt-document-order></A>document order 
  <DD>
  <P>Informally, <B>document order</B> is the order in which nodes appear in the 
  XML serialization of a document.</P>
  <DT><A id=GLdt-dynamic-context name=GLdt-dynamic-context></A>dynamic context 
  <DD>
  <P>The <B>dynamic context</B> of an expression is defined as information that 
  is available at the time the expression is evaluated.</P>
  <DT><A id=GLdt-dynamic-error name=GLdt-dynamic-error></A>dynamic error 
  <DD>
  <P>A <B>dynamic error</B> is an error that must be detected during the dynamic 
  evaluation phase and may be detected during the static analysis phase. Numeric 
  overflow is an example of a dynamic error.</P>
  <DT><A id=GLdt-dynamic-evaluation name=GLdt-dynamic-evaluation></A>dynamic 
  evaluation phase 
  <DD>
  <P>The <B>dynamic evaluation phase</B> is the phase during which the value of 
  an expression is computed.</P>
  <DT><A id=GLdt-dynamic-type name=GLdt-dynamic-type></A>dynamic type 
  <DD>
  <P>A <B>dynamic type</B> is associated with each value as it is computed. The 
  dynamic type of a value may be more specific than the <A title="static type" 
  href="REC-xquery-20070123.htm#dt-static-type">static 
  type</A> of the expression that computed it (for example, the static type of 
  an expression might be <CODE>xs:integer*</CODE>, denoting a sequence of zero 
  or more integers, but at evaluation time its value may have the dynamic type 
  <CODE>xs:integer</CODE>, denoting exactly one integer.)</P>
  <DT><A id=GLdt-ebv name=GLdt-ebv></A>effective boolean value 
  <DD>
  <P>The <B>effective boolean value</B> of a value is defined as the result of 
  applying the <CODE>fn:boolean</CODE> function to the value, as defined in <A 
  href="REC-xquery-20070123.htm#FunctionsAndOperators">[XQuery 
  1.0 and XPath 2.0 Functions and Operators]</A>.</P>
  <DT><A id=GLdt-effective-case name=GLdt-effective-case></A>effective case 
  <DD>
  <P>The <B>effective case</B> in a <CODE>typeswitch</CODE> expression is the 
  first <CODE>case</CODE> clause such that the value of the operand expression 
  matches the <A 
  href="REC-xquery-20070123.htm#doc-xquery-SequenceType">SequenceType</A> 
  in the <CODE>case</CODE> clause, using the rules of <A 
  title="SequenceType matching" 
  href="REC-xquery-20070123.htm#dt-sequencetype-matching">SequenceType 
  matching</A>.</P>
  <DT><A id=GLdt-empty-order-decl name=GLdt-empty-order-decl></A>empty order 
  declaration 
  <DD>
  <P>An <B>empty order declaration</B> sets the <A 
  title="default order for empty sequences" 
  href="REC-xquery-20070123.htm#dt-default-empty-order">default 
  order for empty sequences</A> in the <A title="static context" 
  href="REC-xquery-20070123.htm#dt-static-context">static 
  context,</A> overriding any implementation-defined default. This declaration 
  controls the processing of empty sequences and <CODE>NaN</CODE> values as 
  ordering keys in an <CODE>order by</CODE> clause in a FLWOR expression.</P>
  <DT><A id=GLdt-empty-sequence name=GLdt-empty-sequence></A>empty sequence 
  <DD>
  <P>A sequence containing zero items is called an <B>empty sequence</B>.</P>
  <DT><A id=GLdt-encoding-declaration 
  name=GLdt-encoding-declaration></A>encoding declaration 
  <DD>
  <P>If present, a version declaration may optionally include an <B>encoding 
  declaration</B>. The value of the string literal following the keyword 
  <CODE>encoding</CODE> is an encoding name, and must conform to the definition 
  of <CODE>EncName</CODE> specified in <A 
  href="REC-xquery-20070123.htm#XML">[XML 1.0]</A>[<A 
  title=err:XQST0087 
  href="REC-xquery-20070123.htm#ERRXQST0087">err:XQST0087</A>]. 
  The purpose of an encoding declaration is to allow the writer of a query to 
  provide a string that indicates how the query is encoded, such as 
  "<CODE>UTF-8</CODE>", "<CODE>UTF-16</CODE>", or "<CODE>US-ASCII</CODE>".</P>
  <DT><A id=GLdt-error-value name=GLdt-error-value></A>error value 
  <DD>
  <P>In addition to its identifying QName, a dynamic error may also carry a 
  descriptive string and one or more additional values called <B>error 
  values</B>.</P>
  <DT><A id=GLdt-expanded-qname name=GLdt-expanded-qname></A>expanded QName 
  <DD>
  <P>An <B>expanded QName</B> consists of an optional namespace URI and a local 
  name. An expanded QName also retains its original namespace prefix (if any), 
  to facilitate casting the expanded QName into a string.</P>
  <DT><A id=GLdt-expression-context name=GLdt-expression-context></A>expression 
  context 
  <DD>
  <P>The <B>expression context</B> for a given expression consists of all the 
  information that can affect the result of the expression.</P>
  <DT><A id=GLdt-extension-expression 
  name=GLdt-extension-expression></A>extension expression 
  <DD>
  <P>An <B>extension expression</B> is an expression whose semantics are <A 
  title="implementation defined" 
  href="REC-xquery-20070123.htm#dt-implementation-defined">implementation-defined</A>.</P>
  <DT><A id=GLdt-external-function name=GLdt-external-function></A>external 
  function 
  <DD>
  <P><B>External functions</B> are functions that are implemented outside the 
  query environment.</P>
  <DT><A id=GLdt-filter-expression name=GLdt-filter-expression></A>filter 
  expression 
  <DD>
  <P>A <B>filter expression</B> consists simply of a <B>primary expression</B> 
  followed by zero or more <A title=predicate 
  href="REC-xquery-20070123.htm#dt-predicate">predicates</A>. 
  The result of the filter expression consists of the items returned by the 
  primary expression, filtered by applying each predicate in turn, working from 
  left to right.</P>
  <DT><A id=GLdt-focus name=GLdt-focus></A>focus 
  <DD>
  <P>The first three components of the <A title="dynamic context" 
  href="REC-xquery-20070123.htm#dt-dynamic-context">dynamic 
  context</A> (context item, context position, and context size) are called the 
  <B>focus</B> of the expression.</P>
  <DT><A id=GLdt-full-axis-feature name=GLdt-full-axis-feature></A>Full Axis 
  Feature 
  <DD>
  <P>A conforming XQuery implementation that supports the <B>Full Axis 
  Feature</B> <A title=must 
  href="REC-xquery-20070123.htm#must">MUST</A> support 
  all the <A title="optional axis" 
  href="REC-xquery-20070123.htm#dt-optional-axis">optional 
  axes</A>.</P>
  <DT><A id=GLdt-function-depends name=GLdt-function-depends></A>function 
  depends 
  <DD>
  <P>A function <CODE>f1</CODE> <B>depends</B> on a variable <CODE>$y</CODE> or 
  a function <CODE>f2</CODE> if a reference to <CODE>$y</CODE> or 
  <CODE>f2</CODE> appears in the body of <CODE>f1</CODE>, or if there exists a 
  variable <CODE>$z</CODE> or a function <CODE>f3</CODE> such that 
  <CODE>f1</CODE> <A title="function depends" 
  href="REC-xquery-20070123.htm#dt-function-depends">depends</A> 
  on <CODE>$z</CODE> or <CODE>f3</CODE> and <CODE>$z</CODE> or <CODE>f3</CODE> 
  <A title="variable depends" 
  href="REC-xquery-20070123.htm#dt-variable-depends">depends</A> 
  on <CODE>$y</CODE> or <CODE>f2</CODE>.</P>
  <DT><A id=GLdt-function-implementation 
  name=GLdt-function-implementation></A>function implementation 
  <DD>
  <P><B>Function implementations</B>. Each function in <A 
  title="function signature" 
  href="REC-xquery-20070123.htm#dt-function-signature">function 
  signatures</A> has a function implementation that enables the function to map 
  instances of its parameter types into an instance of its result type. <SPAN 
  class=xquery><SPAN class=xquery>For a <A title="user-defined function" 
  href="REC-xquery-20070123.htm#dt-udf">user-defined 
  function</A>, the function implementation is an XQuery expression. For a <A 
  title="built-in function" 
  href="REC-xquery-20070123.htm#dt-built-in-function">built-in 
  function</A> or <A title="external function" 
  href="REC-xquery-20070123.htm#dt-external-function">external 
  function</A>, the function implementation is <A 
  title="implementation dependent" 
  href="REC-xquery-20070123.htm#dt-implementation-dependent">implementation-dependent</A>.</SPAN></SPAN></P>
  <DT><A id=GLdt-function-signature name=GLdt-function-signature></A>function 
  signature 
  <DD>
  <P><B>Function signatures.</B> This component defines the set of functions 
  that are available to be called from within an expression. Each function is 
  uniquely identified by its <A title="expanded QName" 
  href="REC-xquery-20070123.htm#dt-expanded-qname">expanded 
  QName</A> and its arity (number of parameters).</P>
  <DT><A id=GLdt-gregorian name=GLdt-gregorian></A>Gregorian 
  <DD>
  <P>In the operator mapping tables, the term <B>Gregorian</B> refers to the 
  types <CODE>xs:gYearMonth</CODE>, <CODE>xs:gYear</CODE>, 
  <CODE>xs:gMonthDay</CODE>, <CODE>xs:gDay</CODE>, and 
  <CODE>xs:gMonth</CODE>.</P>
  <DT><A id=GLIgnorableWhitespace name=GLIgnorableWhitespace></A>ignorable 
  whitespace 
  <DD>
  <P><B>Ignorable whitespace</B> consists of any <A title=whitespace 
  href="REC-xquery-20070123.htm#Whitespace">whitespace</A> 
  characters that may occur between <A title=terminal 
  href="REC-xquery-20070123.htm#terminal">terminals</A>, 
  unless these characters occur in the context of a production marked with a <A 
  href="REC-xquery-20070123.htm#ExplicitWhitespaceHandling">ws:explicit</A> 
  annotation, in which case they can occur only where explicitly specified (see 
  <A 
  href="REC-xquery-20070123.htm#ExplicitWhitespaceHandling"><B>A.2.4.2 
  Explicit Whitespace Handling</B></A>).</P>
  <DT><A id=GLdt-implementation-defined 
  name=GLdt-implementation-defined></A>implementation defined 
  <DD>
  <P><B>Implementation-defined</B> indicates an aspect that may differ between 
  implementations, but must be specified by the implementor for each particular 
  implementation.</P>
  <DT><A id=GLdt-implementation-dependent 
  name=GLdt-implementation-dependent></A>implementation dependent 
  <DD>
  <P><B>Implementation-dependent</B> indicates an aspect that may differ between 
  implementations, is not specified by this or any W3C specification, and is not 
  required to be specified by the implementor for any particular 
  implementation.</P>
  <DT><A id=GLdt-timezone name=GLdt-timezone></A>implicit timezone 
  <DD>
  <P><B>Implicit timezone.</B> This is the timezone to be used when a date, 
  time, or dateTime value that does not have a timezone is used in a comparison 
  or arithmetic operation. The implicit timezone is an <A 
  title="implementation defined" 
  href="REC-xquery-20070123.htm#dt-implementation-defined">implementation-defined</A> 
  value of type <CODE>xs:dayTimeDuration</CODE>. See <A 
  href="REC-xquery-20070123.htm#XMLSchema">[XML 
  Schema]</A> for the range of legal values of a timezone.</P>
  <DT><A id=GLdt-initializing-expression 
  name=GLdt-initializing-expression></A>initializing expression 
  <DD>
  <P>If a variable declaration includes an expression, the expression is called 
  an <B>initializing expression</B>.</P>
  <DT><A id=GLdt-is-attrs name=GLdt-is-attrs></A>in-scope attribute declarations 

  <DD>
  <P><B>In-scope attribute declarations.</B> Each attribute declaration is 
  identified either by an <A title="expanded QName" 
  href="REC-xquery-20070123.htm#dt-expanded-qname">expanded 
  QName</A> (for a top-level attribute declaration) or by an <A 
  title="implementation dependent" 
  href="REC-xquery-20070123.htm#dt-implementation-dependent">implementation-dependent</A> 
  attribute identifier (for a local attribute declaration). <SPAN 
  class=xquery><SPAN class=xquery>If the <A title="schema import feature" 
  href="REC-xquery-20070123.htm#dt-schema-import-feature">Schema 
  Import Feature</A> is supported, in-scope attribute declarations include all 
  attribute declarations found in imported schemas.</SPAN></SPAN></P>
  <DT><A id=GLdt-is-elems name=GLdt-is-elems></A>in-scope element declarations 
  <DD>
  <P><B>In-scope element declarations.</B> Each element declaration is 
  identified either by an <A title="expanded QName" 
  href="REC-xquery-20070123.htm#dt-expanded-qname">expanded 
  QName</A> (for a top-level element declaration) or by an <A 
  title="implementation dependent" 
  href="REC-xquery-20070123.htm#dt-implementation-dependent">implementation-dependent</A> 
  element identifier (for a local element declaration). <SPAN class=xquery><SPAN 
  class=xquery>If the <A title="schema import feature" 
  href="REC-xquery-20070123.htm#dt-schema-import-feature">Schema 
  Import Feature</A> is supported, in-scope element declarations include all 
  element declarations found in imported schemas.</SPAN></SPAN></P>
  <DT><A id=GLdt-in-scope-namespaces name=GLdt-in-scope-namespaces></A>in-scope 
  namespaces 
  <DD>
  <P>The <B>in-scope namespaces</B> property of an element node is a set of 
  <B>namespace bindings</B>, each of which associates a namespace prefix with a 
  URI, thus defining the set of namespace prefixes that are available for 
  interpreting QNames within the scope of the element. For a given element, one 
  namespace binding may have an empty prefix; the URI of this namespace binding 
  is the default namespace within the scope of the element.</P>
  <DT><A id=GLdt-issd name=GLdt-issd></A>in-scope schema definitions 
  <DD>
  <P><B>In-scope schema definitions.</B> This is a generic term for all the 
  element declarations, attribute declarations, and schema type definitions that 
  are in scope during processing of an expression.</P>
  <DT><A id=GLdt-is-types name=GLdt-is-types></A>in-scope schema type 
  <DD>
  <P><B>In-scope schema types.</B> Each schema type definition is identified 
  either by an <A title="expanded QName" 
  href="REC-xquery-20070123.htm#dt-expanded-qname">expanded 
  QName</A> (for a <B>named type</B>) or by an <A 
  title="implementation dependent" 
  href="REC-xquery-20070123.htm#dt-implementation-dependent">implementation-dependent</A> 
  type identifier (for an <B>anonymous type</B>). The in-scope schema types 
  include the predefined schema types described in <A 
  href="REC-xquery-20070123.htm#id-predefined-types"><B>2.5.1 
  Predefined Schema Types</B></A>. <SPAN class=xquery><SPAN class=xquery>If the 
  <A title="schema import feature" 
  href="REC-xquery-20070123.htm#dt-schema-import-feature">Schema 
  Import Feature</A> is supported, in-scope schema types also include all type 
  definitions found in imported schemas.</SPAN></SPAN></P>
  <DT><A id=GLdt-in-scope-variables name=GLdt-in-scope-variables></A>in-scope 
  variables 
  <DD>
  <P><B>In-scope variables.</B> This is a set of (expanded QName, type) pairs. 
  It defines the set of variables that are available for reference within an 
  expression. The <A title="expanded QName" 
  href="REC-xquery-20070123.htm#dt-expanded-qname">expanded 
  QName</A> is the name of the variable, and the type is the <A 
  title="static type" 
  href="REC-xquery-20070123.htm#dt-static-type">static 
  type</A> of the variable.</P>
  <DT><A id=GLdt-item name=GLdt-item></A>item 
  <DD>
  <P>An <B>item</B> is either an <A title="atomic value" 
  href="REC-xquery-20070123.htm#dt-atomic-value">atomic 
  value</A> or a <A title=node 
  href="REC-xquery-20070123.htm#dt-node">node</A>.</P>
  <DT><A id=GLdt-kind-test name=GLdt-kind-test></A>kind test 
  <DD>
  <P>An alternative form of a node test called a <B>kind test</B> can select 
  nodes based on their kind, name, and <A title="type annotation" 
  href="REC-xquery-20070123.htm#dt-type-annotation">type 
  annotation</A>.</P>
  <DT><A id=GLdt-library-module name=GLdt-library-module></A>library module 
  <DD>
  <P>A module that does not contain a <A title="query body" 
  href="REC-xquery-20070123.htm#dt-queryBody">Query 
  Body</A> is called a <B>library module</B>. A library module consists of a <A 
  title="module declaration" 
  href="REC-xquery-20070123.htm#dt-module-declaration">module 
  declaration</A> followed by a <A title=Prolog 
  href="REC-xquery-20070123.htm#dt-prolog">Prolog</A>.</P>
  <DT><A id=GLdt-literal name=GLdt-literal></A>literal 
  <DD>
  <P>A <B>literal</B> is a direct syntactic representation of an atomic 
  value.</P>
  <DT><A id=GLdt-main-module name=GLdt-main-module></A>main module 
  <DD>
  <P>A <B>main module</B> consists of a <A title=Prolog 
  href="REC-xquery-20070123.htm#dt-prolog">Prolog</A> 
  followed by a <A title="query body" 
  href="REC-xquery-20070123.htm#dt-queryBody">Query 
  Body</A>.</P>
  <DT><A id=GLmay name=GLmay></A>may 
  <DD>
  <P><B>MAY</B> means that an item is truly optional.</P>
  <DT><A id=GLdt-module name=GLdt-module></A>module 
  <DD>
  <P>A <B>module</B> is a fragment of XQuery code that conforms to the <A 
  href="REC-xquery-20070123.htm#doc-xquery-Module">Module</A> 
  grammar and can independently undergo the <A title="static analysis phase" 
  href="REC-xquery-20070123.htm#dt-static-analysis">static 
  analysis phase</A> described in <A 
  href="REC-xquery-20070123.htm#id-expression-processing"><B>2.2.3 
  Expression Processing</B></A>. Each module is either a <A title="main module" 
  href="REC-xquery-20070123.htm#dt-main-module">main 
  module</A> or a <A title="library module" 
  href="REC-xquery-20070123.htm#dt-library-module">library 
  module</A>.</P>
  <DT><A id=GLdt-module-declaration name=GLdt-module-declaration></A>module 
  declaration 
  <DD>
  <P>A <B>module declaration</B> serves to identify a <A title=module 
  href="REC-xquery-20070123.htm#dt-module">module</A> as 
  a <A title="library module" 
  href="REC-xquery-20070123.htm#dt-library-module">library 
  module</A>. A module declaration begins with the keyword <CODE>module</CODE> 
  and contains a namespace prefix and a <A 
  href="REC-xquery-20070123.htm#doc-xquery-URILiteral">URILiteral</A>.</P>
  <DT><A id=GLdt-module-directly-depends 
  name=GLdt-module-directly-depends></A>module directly depends 
  <DD>
  <P>A module M<SUB>1</SUB> <B>directly depends</B> on another module 
  M<SUB>2</SUB> (different from M<SUB>1</SUB>) if a variable or function 
  declared in M<SUB>1</SUB> <A title="variable depends" 
  href="REC-xquery-20070123.htm#dt-variable-depends">depends</A> 
  on a variable or function declared in M<SUB>2</SUB>.</P>
  <DT><A id=GLdt-module-feature name=GLdt-module-feature></A>module feature 
  <DD>
  <P>A conforming XQuery implementation that supports the <B>Module Feature</B> 
  allows a query Prolog to contain a <B>Module Import</B> and allows <B>library 
  modules</B> to be created.</P>
  <DT><A id=GLdt-module-import name=GLdt-module-import></A>module import 
  <DD>
  <P>A <B>module import</B> imports the function declarations and variable 
  declarations from one or more <A title="library module" 
  href="REC-xquery-20070123.htm#dt-library-module">library 
  modules</A> into the <A title="function signature" 
  href="REC-xquery-20070123.htm#dt-function-signature">function 
  signatures</A> and <A title="in-scope variables" 
  href="REC-xquery-20070123.htm#dt-in-scope-variables">in-scope 
  variables</A> of the importing <A title=module 
  href="REC-xquery-20070123.htm#dt-module">module</A>.</P>
  <DT><A id=GLmust name=GLmust></A>must 
  <DD>
  <P><B>MUST</B> means that the item is an absolute requirement of the 
  specification.</P>
  <DT><A id=GLdt-name-expression name=GLdt-name-expression></A>name expression 
  <DD>
  <P>When an expression is used to specify the name of a constructed node, that 
  expression is called the <B>name expression</B> of the constructor.</P>
  <DT><A id=GLdt-namespace-declaration 
  name=GLdt-namespace-declaration></A>namespace declaration 
  <DD>
  <P>A <B>namespace declaration</B> declares a namespace prefix and associates 
  it with a namespace URI, adding the (prefix, URI) pair to the set of <A 
  title="statically known namespaces" 
  href="REC-xquery-20070123.htm#dt-static-namespaces">statically 
  known namespaces</A>.</P>
  <DT><A id=GLdt-namespace-decl-attr name=GLdt-namespace-decl-attr></A>namespace 
  declaration attribute 
  <DD>
  <P>A <B>namespace declaration attribute</B> is used inside a direct element 
  constructor. Its purpose is to bind a namespace prefix or to set the <A 
  title="default element/type namespace" 
  href="REC-xquery-20070123.htm#dt-def-elemtype-ns">default 
  element/type namespace</A> for the constructed element node, including its 
  attributes.</P>
  <DT><A id=GLdt-namespace-sensitive 
  name=GLdt-namespace-sensitive></A>namespace-sensitive 
  <DD>
  <P>A value is <B>namespace-sensitive</B> if it includes an item whose <A 
  title="dynamic type" 
  href="REC-xquery-20070123.htm#dt-dynamic-type">dynamic 
  type</A> is <CODE>xs:QName</CODE> or <CODE>xs:NOTATION</CODE> or is derived by 
  restriction from <CODE>xs:QName</CODE> or <CODE>xs:NOTATION</CODE>.</P>
  <DT><A id=GLdt-name-test name=GLdt-name-test></A>name test 
  <DD>
  <P>A node test that consists only of a QName or a Wildcard is called a <B>name 
  test</B>.</P>
  <DT><A id=GLdt-node name=GLdt-node></A>node 
  <DD>
  <P>A <B>node</B> is an instance of one of the <B>node kinds</B> defined in <A 
  href="REC-xquery-20070123.htm#datamodel">[XQuery/XPath 
  Data Model (XDM)]</A>.</P>
  <DT><A id=GLdt-node-test name=GLdt-node-test></A>node test 
  <DD>
  <P>A <B>node test</B> is a condition that must be true for each node selected 
  by a <A title=step 
  href="REC-xquery-20070123.htm#dt-step">step</A>.</P>
  <DT><A id=GLnon-delimiting-token 
  name=GLnon-delimiting-token></A>non-delimiting terminal symbol 
  <DD>
  <P>The <B>non-delimiting terminal symbols</B> are: <A 
  href="REC-xquery-20070123.htm#prod-xquery-IntegerLiteral">IntegerLiteral</A>, 
  <A 
  href="REC-xquery-20070123.htm#prod-xquery-NCName">NCName</A>, 
  <A 
  href="REC-xquery-20070123.htm#prod-xquery-QName">QName</A>, 
  <A 
  href="REC-xquery-20070123.htm#prod-xquery-DecimalLiteral">DecimalLiteral</A>, 
  <A 
  href="REC-xquery-20070123.htm#prod-xquery-DoubleLiteral">DoubleLiteral</A>, 
  "ancestor", "ancestor-or-self", "and", "as", "ascending", "at", "attribute", 
  "base-uri", "boundary-space", "by", "case", "cast", "castable", "child", 
  "collation", "comment", "construction", "copy-namespaces", "declare", 
  "default", "descendant", "descendant-or-self", "descending", "div", 
  "document", "document-node", "element", "else", "empty", "empty-sequence", 
  "encoding", "eq", "every", "except", "external", "following", 
  "following-sibling", "for", "function", "ge", "greatest", "gt", "idiv", "if", 
  "import", "in", "inherit", "instance", "intersect", "is", "item", "lax", "le", 
  "least", "let", "lt", "mod", "module", "namespace", "ne", "node", 
  "no-inherit", "no-preserve", "of", "option", "or", "order", "ordered", 
  "ordering", "parent", "preceding", "preceding-sibling", "preserve", 
  "processing-instruction", "return", "satisfies", "schema", "schema-attribute", 
  "schema-element", "self", "some", "stable", "strict", "strip", "text", "then", 
  "to", "treat", "typeswitch", "union", "unordered", "validate", "variable", 
  "version", "where", "xquery"</P>
  <DT><A id=GLdt-numeric name=GLdt-numeric></A>numeric 
  <DD>
  <P>When referring to a type, the term <B>numeric</B> denotes the types 
  <CODE>xs:integer</CODE>, <CODE>xs:decimal</CODE>, <CODE>xs:float</CODE>, and 
  <CODE>xs:double</CODE>.</P>
  <DT><A id=GLdt-numeric-predicate name=GLdt-numeric-predicate></A>numeric 
  predicate 
  <DD>
  <P>A predicate whose predicate expression returns a numeric type is called a 
  <B>numeric predicate</B>.</P>
  <DT><A id=GLdt-operator-function name=GLdt-operator-function></A>operator 
  function 
  <DD>
  <P>For each operator and valid combination of operand types, the operator 
  mapping tables specify a result type and an <B>operator function</B> that 
  implements the semantics of the operator for the given types.</P>
  <DT><A id=GLdt-optional-axis name=GLdt-optional-axis></A>optional axis 
  <DD>
  <P>The following axes are designated as <B>optional axes</B>: 
  <CODE>ancestor</CODE>, <CODE>ancestor-or-self</CODE>, <CODE>following</CODE>, 
  <CODE>following-sibling</CODE>, <CODE>preceding</CODE>, and 
  <CODE>preceding-sibling</CODE>.</P>
  <DT><A id=GLdt-option-declaration name=GLdt-option-declaration></A>option 
  declaration 
  <DD>
  <P>An <B>option declaration</B> declares an option that affects the behavior 
  of a particular implementation. Each option consists of an identifying QName 
  and a StringLiteral.</P>
  <DT><A id=GLdt-ordering-mode name=GLdt-ordering-mode></A>ordering mode 
  <DD>
  <P><B>Ordering mode.</B> Ordering mode, which has the value 
  <CODE>ordered</CODE> or <CODE>unordered</CODE>, affects the ordering of the 
  result sequence returned by certain <A title="path expression" 
  href="REC-xquery-20070123.htm#dt-path-expression">path 
  expressions</A>, <CODE>union</CODE>, <CODE>intersect</CODE>, and 
  <CODE>except</CODE> expressions, and FLWOR expressions that have no 
  <CODE>order by</CODE> clause.</P>
  <DT><A id=GLdt-ordering-mode-decl name=GLdt-ordering-mode-decl></A>ordering 
  mode declaration 
  <DD>
  <P>An <B>ordering mode declaration</B> sets the <A title="ordering mode" 
  href="REC-xquery-20070123.htm#dt-ordering-mode">ordering 
  mode</A> in the <A title="static context" 
  href="REC-xquery-20070123.htm#dt-static-context">static 
  context</A>, overriding any implementation-defined default.</P>
  <DT><A id=GLdt-path-expression name=GLdt-path-expression></A>path expression 
  <DD>
  <P>A <B>path expression</B> can be used to locate nodes within trees. A path 
  expression consists of a series of one or more <A title=step 
  href="REC-xquery-20070123.htm#dt-step">steps</A>, 
  separated by "<CODE>/</CODE>" or "<CODE>//</CODE>", and optionally beginning 
  with "<CODE>/</CODE>" or "<CODE>//</CODE>".</P>
  <DT><A id=GLdt-pragma name=GLdt-pragma></A>pragma 
  <DD>
  <P>A <B>pragma</B> is denoted by the delimiters <CODE>(#</CODE> and 
  <CODE>#)</CODE>, and consists of an identifying QName followed by <A 
  title="implementation defined" 
  href="REC-xquery-20070123.htm#dt-implementation-defined">implementation-defined</A> 
  content.</P>
  <DT><A id=GLdt-predefined-entity-reference 
  name=GLdt-predefined-entity-reference></A>predefined entity reference 
  <DD>
  <P>A <B>predefined entity reference</B> is a short sequence of characters, 
  beginning with an ampersand, that represents a single character that might 
  otherwise have syntactic significance.</P>
  <DT><A id=GLdt-predicate name=GLdt-predicate></A>predicate 
  <DD>
  <P>A <B>predicate</B> consists of an expression, called a <B>predicate 
  expression</B>, enclosed in square brackets. A predicate serves to filter a 
  sequence, retaining some items and discarding others.</P>
  <DT><A id=GLdt-primary-expression name=GLdt-primary-expression></A>primary 
  expression 
  <DD>
  <P><B>Primary expressions</B> are the basic primitives of the language. They 
  include literals, variable references, context item expressions, <SPAN 
  class=xquery><SPAN class=xquery>constructors,</SPAN></SPAN> and function 
  calls. A primary expression may also be created by enclosing any expression in 
  parentheses, which is sometimes helpful in controlling the precedence of 
  operators.</P>
  <DT><A id=GLdt-principal-node-kind name=GLdt-principal-node-kind></A>principal 
  node kind 
  <DD>
  <P>Every axis has a <B>principal node kind</B>. If an axis can contain 
  elements, then the principal node kind is element; otherwise, it is the kind 
  of nodes that the axis can contain.</P>
  <DT><A id=GLdt-prolog name=GLdt-prolog></A>Prolog 
  <DD>
  <P>A <B>Prolog</B> is a series of declarations and imports that define the 
  processing environment for the <A title=module 
  href="REC-xquery-20070123.htm#dt-module">module</A> 
  that contains the Prolog.</P>
  <DT><A id=GLdt-qname name=GLdt-qname></A>QName 
  <DD>
  <P>Lexically, a <B>QName</B> consists of an optional namespace prefix and a 
  local name. If the namespace prefix is present, it is separated from the local 
  name by a colon.</P>
  <DT><A id=GLdt-query name=GLdt-query></A>query 
  <DD>
  <P>A <B>query</B> consists of one or more <A title=module 
  href="REC-xquery-20070123.htm#dt-module">modules</A>.</P>
  <DT><A id=GLdt-queryBody name=GLdt-queryBody></A>query body 
  <DD>
  <P>The <B>Query Body</B>, if present, consists of an expression that defines 
  the result of the query.</P>
  <DT><A id=GLdt-reverse-document-order 
  name=GLdt-reverse-document-order></A>reverse document order 
  <DD>
  <P>The node ordering that is the reverse of document order is called 
  <B>reverse document order</B>.</P>
  <DT><A id=GLdt-schema-import name=GLdt-schema-import></A>schema import 
  <DD>
  <P>A <B>schema import</B> imports the element declarations, attribute 
  declarations, and type definitions from a schema into the <A 
  title="in-scope schema definitions" 
  href="REC-xquery-20070123.htm#dt-issd">in-scope schema 
  definitions</A>.</P>
  <DT><A id=GLdt-schema-import-feature 
  name=GLdt-schema-import-feature></A>schema import feature 
  <DD>
  <P>The <B>Schema Import Feature</B> permits the query Prolog to contain a <A 
  title="schema import" 
  href="REC-xquery-20070123.htm#dt-schema-import">schema 
  import</A>.</P>
  <DT><A id=GLdt-schema-type name=GLdt-schema-type></A>schema type 
  <DD>
  <P>A <B>schema type</B> is a type that is (or could be) defined using the 
  facilities of <A 
  href="REC-xquery-20070123.htm#XMLSchema">[XML 
  Schema]</A> (including the built-in types of <A 
  href="REC-xquery-20070123.htm#XMLSchema">[XML 
  Schema]</A>).</P>
  <DT><A id=GLdt-schema-validation-feature 
  name=GLdt-schema-validation-feature></A>schema validation feature 
  <DD>
  <P>The <B>Schema Validation Feature</B> permits a query to contain a 
  <CODE>validate</CODE> expression (see <A 
  href="REC-xquery-20070123.htm#id-validate"><B>3.13 
  Validate Expressions</B></A>.)</P>
  <DT><A id=GLdt-sequence name=GLdt-sequence></A>sequence 
  <DD>
  <P>A <B>sequence</B> is an ordered collection of zero or more <A title=item 
  href="REC-xquery-20070123.htm#dt-item">items</A>.</P>
  <DT><A id=GLdt-sequence-type name=GLdt-sequence-type></A>sequence type 
  <DD>
  <P>A <B>sequence type</B> is a type that can be expressed using the <A 
  href="REC-xquery-20070123.htm#doc-xquery-SequenceType">SequenceType</A> 
  syntax. Sequence types are used whenever it is necessary to refer to a type in 
  an XQuery expression. The term <B>sequence type</B> suggests that this syntax 
  is used to describe the type of an XQuery value, which is always a 
  sequence.</P>
  <DT><A id=GLdt-sequencetype-matching 
  name=GLdt-sequencetype-matching></A>SequenceType matching 
  <DD>
  <P>During evaluation of an expression, it is sometimes necessary to determine 
  whether a value with a known <A title="dynamic type" 
  href="REC-xquery-20070123.htm#dt-dynamic-type">dynamic 
  type</A> "matches" an expected <A title="sequence type" 
  href="REC-xquery-20070123.htm#dt-sequence-type">sequence 
  type</A>. This process is known as <B>SequenceType matching</B>.</P>
  <DT><A id=GLdt-serialization name=GLdt-serialization></A>serialization 
  <DD>
  <P><B>Serialization</B> is the process of converting an <A 
  title="XDM instance" 
  href="REC-xquery-20070123.htm#dt-data-model-instance">XDM 
  instance</A> into a sequence of octets (step DM4 in Figure 1.)</P>
  <DT><A id=GLdt-serialization-feature 
  name=GLdt-serialization-feature></A>serialization feature 
  <DD>
  <P>A conforming XQuery implementation that supports the <B>Serialization 
  Feature</B> <A title=must 
  href="REC-xquery-20070123.htm#must">MUST</A> provide 
  means for serializing the result of a query, as specified in <A 
  href="REC-xquery-20070123.htm#id-serialization"><B>2.2.4 
  Serialization</B></A>.</P>
  <DT><A id=GLdt-setter name=GLdt-setter></A>setter 
  <DD>
  <P><B>Setters</B> are declarations that set the value of some property that 
  affects query processing, such as construction mode, ordering mode, or default 
  collation.</P>
  <DT><A id=GLshould name=GLshould></A>should 
  <DD>
  <P><B>SHOULD</B> means that there may exist valid reasons in particular 
  circumstances to ignore a particular item, but the full implications must be 
  understood and carefully weighed before choosing a different course.</P>
  <DT><A id=GLdt-singleton name=GLdt-singleton></A>singleton 
  <DD>
  <P>A sequence containing exactly one item is called a <B>singleton</B>.</P>
  <DT><A id=GLstable name=GLstable></A>stable 
  <DD>
  <P>Document order is <B>stable</B>, which means that the relative order of two 
  nodes will not change during the processing of a given <SPAN 
  class=xquery><SPAN class=xquery>query</SPAN></SPAN>, even if this order is <A 
  title="implementation dependent" 
  href="REC-xquery-20070123.htm#dt-implementation-dependent">implementation-dependent</A>.</P>
  <DT><A id=GLdt-static-collations name=GLdt-static-collations></A>statically 
  known collations 
  <DD>
  <P><B>Statically known collations.</B> This is an <A 
  title="implementation defined" 
  href="REC-xquery-20070123.htm#dt-implementation-defined">implementation-defined</A> 
  set of (URI, collation) pairs. It defines the names of the collations that are 
  available for use in processing <SPAN class=xquery><SPAN class=xquery>queries 
  and</SPAN></SPAN> expressions.</P>
  <DT><A id=GLdt-known-collections name=GLdt-known-collections></A>statically 
  known collections 
  <DD>
  <P><B>Statically known collections.</B> This is a mapping from strings onto 
  types. The string represents the absolute URI of a resource that is 
  potentially available using the <CODE>fn:collection</CODE> function. The type 
  is the type of the sequence of nodes that would result from calling the 
  <CODE>fn:collection</CODE> function with this URI as its argument.</P>
  <DT><A id=GLdt-known-default-collection 
  name=GLdt-known-default-collection></A>statically known default collection 
  type 
  <DD>
  <P><B>Statically known default collection type.</B> This is the type of the 
  sequence of nodes that would result from calling the 
  <CODE>fn:collection</CODE> function with no arguments.</P>
  <DT><A id=GLdt-known-docs name=GLdt-known-docs></A>statically known documents 
  <DD>
  <P><B>Statically known documents.</B> This is a mapping from strings onto 
  types. The string represents the absolute URI of a resource that is 
  potentially available using the <CODE>fn:doc</CODE> function. The type is the 
  <A title="static type" 
  href="REC-xquery-20070123.htm#dt-static-type">static 
  type</A> of a call to <CODE>fn:doc</CODE> with the given URI as its literal 
  argument.</P>
  <DT><A id=GLdt-static-namespaces name=GLdt-static-namespaces></A>statically 
  known namespaces 
  <DD>
  <P><B>Statically known namespaces.</B> This is a set of (prefix, URI) pairs 
  that define all the namespaces that are known during static processing of a 
  given expression.</P>
  <DT><A id=GLdt-static-analysis name=GLdt-static-analysis></A>static analysis 
  phase 
  <DD>
  <P>The <B>static analysis phase</B> depends on the expression itself and on 
  the <A title="static context" 
  href="REC-xquery-20070123.htm#dt-static-context">static 
  context</A>. The <B>static analysis phase</B> does not depend on input data 
  (other than schemas).</P>
  <DT><A id=GLdt-static-context name=GLdt-static-context></A>static context 
  <DD>
  <P>The <B>static context</B> of an expression is the information that is 
  available during static analysis of the expression, prior to its 
  evaluation.</P>
  <DT><A id=GLdt-static-error name=GLdt-static-error></A>static error 
  <DD>
  <P>A <B>static error</B> is an error that must be detected during the static 
  analysis phase. A syntax error is an example of a <A title="static error" 
  href="REC-xquery-20070123.htm#dt-static-error">static 
  error</A>.</P>
  <DT><A id=GLdt-static-type name=GLdt-static-type></A>static type 
  <DD>
  <P>The <B>static type</B> of an expression is a type such that, when the 
  expression is evaluated, the resulting value will always conform to the static 
  type.</P>
  <DT><A id=GLdt-static-typing-extension 
  name=GLdt-static-typing-extension></A>static typing extension 
  <DD>
  <P>A <B>static typing extension</B> is an <A title="implementation defined" 
  href="REC-xquery-20070123.htm#dt-implementation-defined">implementation-defined</A> 
  type inference rule that infers a more precise static type than that inferred 
  by the type inference rules in <A 
  href="REC-xquery-20070123.htm#XQueryFormalSemantics">[XQuery 
  1.0 and XPath 2.0 Formal Semantics]</A>.</P>
  <DT><A id=GLdt-static-typing-feature 
  name=GLdt-static-typing-feature></A>static typing feature 
  <DD>
  <P>The <B>Static Typing Feature</B> provides support for the static semantics 
  defined in <A 
  href="REC-xquery-20070123.htm#XQueryFormalSemantics">[XQuery 
  1.0 and XPath 2.0 Formal Semantics]</A>, and requires implementations to 
  detect and report <A title="type error" 
  href="REC-xquery-20070123.htm#dt-type-error">type 
  errors</A> during the <A title="static analysis phase" 
  href="REC-xquery-20070123.htm#dt-static-analysis">static 
  analysis phase</A>.</P>
  <DT><A id=GLdt-step name=GLdt-step></A>step 
  <DD>
  <P>A <B>step</B> is a part of a <A title="path expression" 
  href="REC-xquery-20070123.htm#dt-path-expression">path 
  expression</A> that generates a sequence of items and then filters the 
  sequence by zero or more <A title=predicate 
  href="REC-xquery-20070123.htm#dt-predicate">predicates</A>. 
  The value of the step consists of those items that satisfy the predicates, 
  working from left to right. A step may be either an <A title="axis step" 
  href="REC-xquery-20070123.htm#dt-axis-step">axis 
  step</A> or a <A title="filter expression" 
  href="REC-xquery-20070123.htm#dt-filter-expression">filter 
  expression</A>.</P>
  <DT><A id=GLdt-string-value name=GLdt-string-value></A>string value 
  <DD>
  <P>The <B>string value</B> of a node is a string and can be extracted by 
  applying the <CODE>fn:string</CODE> function to the node.</P>
  <DT><A id=GLdt-substitution-group 
  name=GLdt-substitution-group></A>substitution group 
  <DD>
  <P><B>Substitution groups</B> are defined in <A 
  href="REC-xquery-20070123.htm#XMLSchema">[XML 
  Schema]</A> Part 1, Section 2.2.2.2. Informally, the substitution group headed 
  by a given element (called the <B>head element</B>) consists of the set of 
  elements that can be substituted for the head element without affecting the 
  outcome of schema validation.</P>
  <DT><A id=GLdt-subtype-substitution name=GLdt-subtype-substitution></A>subtype 
  substitution 
  <DD>
  <P>The use of a value whose <A title="dynamic type" 
  href="REC-xquery-20070123.htm#dt-dynamic-type">dynamic 
  type</A> is derived from an expected type is known as <B>subtype 
  substitution</B>.</P>
  <DT><A id=GLsymbol name=GLsymbol></A>symbol 
  <DD>
  <P>Each rule in the grammar defines one <B>symbol</B>, using the following 
  format:</P>
  <DIV class=exampleInner><PRE>symbol ::= expression
</PRE></DIV>
  <DT><A id=GLsymbolseparators name=GLsymbolseparators></A>symbol separators 
  <DD>
  <P><A title=whitespace 
  href="REC-xquery-20070123.htm#Whitespace">Whitespace</A> 
  and <A 
  href="REC-xquery-20070123.htm#doc-xquery-Comment">Comments</A> 
  function as <B>symbol separators</B>. For the most part, they are not 
  mentioned in the grammar, and may occur between any two terminal symbols 
  mentioned in the grammar, except where that is forbidden by the <A 
  href="REC-xquery-20070123.htm#ws-explicit">/* ws: 
  explicit */</A> annotation in the EBNF, or by the <A 
  href="REC-xquery-20070123.htm#parse-note-xml-version">/* 
  xgs: xml-version */</A> annotation.</P>
  <DT><A id=GLdt-target-namespace name=GLdt-target-namespace></A>target 
  namespace 
  <DD>
  <P>Each imported schema or module is identified by its <B>target 
  namespace</B>, which is the namespace of the objects (such as elements or 
  functions) that are defined by the schema or module.</P>
  <DT><A id=GLterminal name=GLterminal></A>terminal 
  <DD>
  <P>A <B>terminal</B> is a symbol or string or pattern that can appear in the 
  right-hand side of a rule, but never appears on the left hand side in the main 
  grammar, although it may appear on the left-hand side of a rule in the grammar 
  for terminals.</P>
  <DT><A id=GLdt-type-annotation name=GLdt-type-annotation></A>type annotation 
  <DD>
  <P>Each element node and attribute node in an <A title="XDM instance" 
  href="REC-xquery-20070123.htm#dt-data-model-instance">XDM 
  instance</A> has a <B>type annotation</B> (referred to in <A 
  href="REC-xquery-20070123.htm#datamodel">[XQuery/XPath 
  Data Model (XDM)]</A> as its <CODE>type-name</CODE> property.) The type 
  annotation of a node is a <A title="schema type" 
  href="REC-xquery-20070123.htm#dt-schema-type">schema 
  type</A> that describes the relationship between the <A title="string value" 
  href="REC-xquery-20070123.htm#dt-string-value">string 
  value</A> of the node and its <A title="typed value" 
  href="REC-xquery-20070123.htm#dt-typed-value">typed 
  value</A>.</P>
  <DT><A id=GLdt-typed-value name=GLdt-typed-value></A>typed value 
  <DD>
  <P>The <B>typed value</B> of a node is a sequence of atomic values and can be 
  extracted by applying the <CODE>fn:data</CODE> function to the node.</P>
  <DT><A id=GLdt-type-error name=GLdt-type-error></A>type error 
  <DD>
  <P>A <B>type error</B> may be raised during the static analysis phase or the 
  dynamic evaluation phase. During the static analysis phase, a <A 
  title="type error" 
  href="REC-xquery-20070123.htm#dt-type-error">type 
  error</A> occurs when the <A title="static type" 
  href="REC-xquery-20070123.htm#dt-static-type">static 
  type</A> of an expression does not match the expected type of the context in 
  which the expression occurs. During the dynamic evaluation phase, a <A 
  title="type error" 
  href="REC-xquery-20070123.htm#dt-type-error">type 
  error</A> occurs when the <A title="dynamic type" 
  href="REC-xquery-20070123.htm#dt-dynamic-type">dynamic 
  type</A> of a value does not match the expected type of the context in which 
  the value occurs.</P>
  <DT><A id=GLdt-type-promotion name=GLdt-type-promotion></A>type promotion 
  <DD>
  <P>Under certain circumstances, an atomic value can be promoted from one type 
  to another. <B>Type promotion</B> is used in evaluating function calls (see <A 
  href="REC-xquery-20070123.htm#id-function-calls"><B>3.1.5 
  Function Calls</B></A>)<SPAN class=xquery><SPAN class=xquery>, <CODE>order 
  by</CODE> clauses (see <A 
  href="REC-xquery-20070123.htm#id-orderby-return"><B>3.8.3 
  Order By and Return Clauses</B></A>),</SPAN></SPAN> and operators that accept 
  numeric or string operands (see <A 
  href="REC-xquery-20070123.htm#mapping"><B>B.2 Operator 
  Mapping</B></A>).</P>
  <DT><A id=GLdt-URI name=GLdt-URI></A>URI 
  <DD>
  <P>Within this specification, the term <B>URI</B> refers to a Universal 
  Resource Identifier as defined in <A 
  href="REC-xquery-20070123.htm#RFC3986">[RFC3986]</A> 
  and extended in <A 
  href="REC-xquery-20070123.htm#RFC3987">[RFC3987]</A> 
  with the new name <B>IRI</B>.</P>
  <DT><A id=GLdt-udf name=GLdt-udf></A>user-defined function 
  <DD>
  <P>For a <B>user-defined function</B>, the function declaration includes an 
  expression called the <B>function body</B> that defines how the result of the 
  function is computed from its parameters.</P>
  <DT><A id=GLdt-value name=GLdt-value></A>value 
  <DD>
  <P>In the <A title="data model" 
  href="REC-xquery-20070123.htm#dt-datamodel">data 
  model</A>, a <B>value</B> is always a <A title=sequence 
  href="REC-xquery-20070123.htm#dt-sequence">sequence</A>.</P>
  <DT><A id=GLdt-variable-depends name=GLdt-variable-depends></A>variable 
  depends 
  <DD>
  <P>A variable <CODE>$x</CODE> <B>depends</B> on a variable <CODE>$y</CODE> or 
  a function <CODE>f2</CODE> if a reference to <CODE>$y</CODE> or 
  <CODE>f2</CODE> appears in the initializing expression of <CODE>$x</CODE>, or 
  if there exists a variable <CODE>$z</CODE> or a function <CODE>f3</CODE> such 
  that <CODE>$x</CODE> <A title="variable depends" 
  href="REC-xquery-20070123.htm#dt-variable-depends">depends</A> 
  on <CODE>$z</CODE> or <CODE>f3</CODE> and <CODE>$z</CODE> or <CODE>f3</CODE> 
  <A title="function depends" 
  href="REC-xquery-20070123.htm#dt-function-depends">depends</A> 
  on <CODE>$y</CODE> or <CODE>f2</CODE>.</P>
  <DT><A id=GLdt-variable-reference name=GLdt-variable-reference></A>variable 
  reference 
  <DD>
  <P>A <B>variable reference</B> is a QName preceded by a $-sign.</P>
  <DT><A id=GLdt-variable-values name=GLdt-variable-values></A>variable values 
  <DD>
  <P><B>Variable values</B>. This is a set of (expanded QName, value) pairs. It 
  contains the same <A title="expanded QName" 
  href="REC-xquery-20070123.htm#dt-expanded-qname">expanded 
  QNames</A> as the <A title="in-scope variables" 
  href="REC-xquery-20070123.htm#dt-in-scope-variables">in-scope 
  variables</A> in the <A title="static context" 
  href="REC-xquery-20070123.htm#dt-static-context">static 
  context</A> for the expression. The expanded QName is the name of the variable 
  and the value is the dynamic value of the variable, which includes its <A 
  title="dynamic type" 
  href="REC-xquery-20070123.htm#dt-dynamic-type">dynamic 
  type</A>.</P>
  <DT><A id=GLdt-version-declaration name=GLdt-version-declaration></A>version 
  declaration 
  <DD>
  <P>Any <A title=module 
  href="REC-xquery-20070123.htm#dt-module">module</A> may 
  contain a <B>version declaration</B>. If present, the version declaration 
  occurs at the beginning of the <A title=module 
  href="REC-xquery-20070123.htm#dt-module">module</A> and 
  identifies the applicable XQuery syntax and semantics for the <A title=module 
  href="REC-xquery-20070123.htm#dt-module">module</A>.</P>
  <DT><A id=GLdt-warning name=GLdt-warning></A>warning 
  <DD>
  <P>In addition to <A title="static error" 
  href="REC-xquery-20070123.htm#dt-static-error">static 
  errors</A>, <A title="dynamic error" 
  href="REC-xquery-20070123.htm#dt-dynamic-error">dynamic 
  errors</A>, and <A title="type error" 
  href="REC-xquery-20070123.htm#dt-type-error">type 
  errors</A>, an XQuery implementation may raise <B>warnings</B>, either during 
  the <A title="static analysis phase" 
  href="REC-xquery-20070123.htm#dt-static-analysis">static 
  analysis phase</A> or the <A title="dynamic evaluation phase" 
  href="REC-xquery-20070123.htm#dt-dynamic-evaluation">dynamic 
  evaluation phase</A>. The circumstances in which warnings are raised, and the 
  ways in which warnings are handled, are <A title="implementation defined" 
  href="REC-xquery-20070123.htm#dt-implementation-defined">implementation-defined</A>.</P>
  <DT><A id=GLWhitespace name=GLWhitespace></A>whitespace 
  <DD>
  <P>A <B>whitespace</B> character is any of the characters defined by <A 
  href="http://www.w3.org/TR/REC-xml#NT-S">[http://www.w3.org/TR/REC-xml#NT-S]</A>.</P>
  <DT><A id=GLdt-data-model-instance name=GLdt-data-model-instance></A>XDM 
  instance 
  <DD>
  <P>The term <B>XDM instance</B> is used, synonymously with the term 
  <B>value</B>, to denote an unconstrained sequence of <A title=node 
  href="REC-xquery-20070123.htm#dt-node">nodes</A> and/or 
  <A title="atomic value" 
  href="REC-xquery-20070123.htm#dt-atomic-value">atomic 
  values</A> in the <A title="data model" 
  href="REC-xquery-20070123.htm#dt-datamodel">data 
  model</A>.</P>
  <DT><A id=GLdt-xpath-compat-mode name=GLdt-xpath-compat-mode></A>XPath 1.0 
  compatibility mode 
  <DD>
  <P><B>XPath 1.0 compatibility mode.</B> <SPAN class=xquery><SPAN 
  class=xquery>This component must be set by all host languages that include 
  XPath 2.0 as a subset, indicating whether rules for compatibility with XPath 
  1.0 are in effect. XQuery sets the value of this component to 
  <CODE>false</CODE>.</SPAN></SPAN></P>
  <DT><A id=GLdt-anyAtomicType name=GLdt-anyAtomicType></A>xs:anyAtomicType 
  <DD>
  <P><CODE>xs:anyAtomicType</CODE> is an atomic type that includes all atomic 
  values (and no values that are not atomic). Its base type is 
  <CODE>xs:anySimpleType</CODE> from which all simple types, including atomic, 
  list, and union types, are derived. All primitive atomic types, such as 
  <CODE>xs:integer</CODE>, <CODE>xs:string</CODE>, and 
  <CODE>xs:untypedAtomic</CODE>, have <CODE>xs:anyAtomicType</CODE> as their 
  base type.</P>
  <DT><A id=GLdt-dayTimeDuration 
  name=GLdt-dayTimeDuration></A>xs:dayTimeDuration 
  <DD>
  <P><CODE>xs:dayTimeDuration</CODE> is derived by restriction from 
  <CODE>xs:duration</CODE>. The lexical representation of 
  <CODE>xs:dayTimeDuration</CODE> is restricted to contain only day, hour, 
  minute, and second components.</P>
  <DT><A id=GLdt-untyped name=GLdt-untyped></A>xs:untyped 
  <DD>
  <P><CODE>xs:untyped</CODE> is used as the <A title="type annotation" 
  href="REC-xquery-20070123.htm#dt-type-annotation">type 
  annotation</A> of an element node that has not been validated, or has been 
  validated in <CODE>skip</CODE> mode.</P>
  <DT><A id=GLdt-untypedAtomic name=GLdt-untypedAtomic></A>xs:untypedAtomic 
  <DD>
  <P><CODE>xs:untypedAtomic</CODE> is an atomic type that is used to denote 
  untyped atomic data, such as text that has not been assigned a more specific 
  type.</P>
  <DT><A id=GLdt-yearMonthDuration 
  name=GLdt-yearMonthDuration></A>xs:yearMonthDuration 
  <DD>
  <P><CODE>xs:yearMonthDuration</CODE> is derived by restriction from 
  <CODE>xs:duration</CODE>. The lexical representation of 
  <CODE>xs:yearMonthDuration</CODE> is restricted to contain only year and month 
  components.</P></DD></DL></DIV>
<DIV class=xquery>
<DIV class=div1>
<H2><A id=id-example-applications name=id-example-applications></A>I Example 
Applications (Non-Normative)</H2>
<P>This section contains examples of several important classes of queries that 
can be expressed using XQuery. The applications described here include joins 
across multiple data sources, grouping and aggregation, queries based on 
sequential relationships, recursive transformations, and selection of distinct 
combinations of values.</P>
<DIV class=div2>
<H3><A id=id-joins name=id-joins></A>I.1 Joins</H3>
<P>Joins, which combine data from multiple sources into a single result, are a 
very important type of query. In this section we will illustrate how several 
types of joins can be expressed in XQuery. We will base our examples on the 
following three documents:</P>
<OL class=enumar>
  <LI>
  <P>A document named <CODE>parts.xml</CODE> that contains many 
  <CODE>part</CODE> elements; each <CODE>part</CODE> element in turn contains 
  <CODE>partno</CODE> and <CODE>description</CODE> subelements.</P>
  <LI>
  <P>A document named <CODE>suppliers.xml</CODE> that contains many 
  <CODE>supplier</CODE> elements; each <CODE>supplier</CODE> element in turn 
  contains <CODE>suppno</CODE> and <CODE>suppname</CODE> subelements.</P>
  <LI>
  <P>A document named <CODE>catalog.xml</CODE> that contains information about 
  the relationships between suppliers and parts. The catalog document contains 
  many <CODE>item</CODE> elements, each of which in turn contains 
  <CODE>partno</CODE>, <CODE>suppno</CODE>, and <CODE>price</CODE> 
  subelements.</P></LI></OL>
<P>A conventional ("inner") join returns information from two or more related 
sources, as illustrated by the following example, which combines information 
from three documents. The example generates a "descriptive catalog" derived from 
the catalog document, but containing part descriptions instead of part numbers 
and supplier names instead of supplier numbers. The new catalog is ordered 
alphabetically by part description and secondarily by supplier name.</P>
<DIV class=parse-test>
<DIV class=exampleInner><PRE>&lt;descriptive-catalog&gt;
   { 
     for $i in fn:doc("catalog.xml")/items/item,
         $p in fn:doc("parts.xml")/parts/part[partno = $i/partno],
         $s in fn:doc("suppliers.xml")/suppliers
                  /supplier[suppno = $i/suppno]
     order by $p/description, $s/suppname
     return
        &lt;item&gt;
           {
           $p/description,
           $s/suppname,
           $i/price
           }
        &lt;/item&gt;
   }
&lt;/descriptive-catalog&gt;
</PRE></DIV></DIV>
<P>The previous query returns information only about parts that have suppliers 
and suppliers that have parts. An <B>outer join</B> is a join that preserves 
information from one or more of the participating sources, including elements 
that have no matching element in the other source. For example, a <B>left outer 
join</B> between suppliers and parts might return information about suppliers 
that have no matching parts.</P>
<P>The following query demonstrates a left outer join. It returns names of all 
the suppliers in alphabetic order, including those that supply no parts. In the 
result, each supplier element contains the descriptions of all the parts it 
supplies, in alphabetic order.</P>
<DIV class=parse-test>
<DIV class=exampleInner><PRE>for $s in fn:doc("suppliers.xml")/suppliers/supplier
order by $s/suppname
return
   &lt;supplier&gt;
      { 
        $s/suppname,
        for $i in fn:doc("catalog.xml")/items/item
                 [suppno = $s/suppno],
            $p in fn:doc("parts.xml")/parts/part
                 [partno = $i/pno]
        order by $p/description
        return $p/description 
      }
   &lt;/supplier&gt;
</PRE></DIV></DIV>
<P>The previous query preserves information about suppliers that supply no 
parts. Another type of join, called a <B>full outer join</B>, might be used to 
preserve information about both suppliers that supply no parts and parts that 
have no supplier. The result of a full outer join can be structured in any of 
several ways. The following query generates a list of <CODE>supplier</CODE> 
elements, each containing nested <CODE>part</CODE> elements for the parts that 
it supplies (if any), followed by a list of <CODE>part</CODE> elements for the 
parts that have no supplier. This might be thought of as a "supplier-centered" 
full outer join. Other forms of outer join queries are also possible.</P>
<DIV class=parse-test>
<DIV class=exampleInner><PRE>&lt;master-list&gt;
 {
    for $s in fn:doc("suppliers.xml")/suppliers/supplier
    order by $s/suppname
    return
        &lt;supplier&gt;
           { 
             $s/suppname,
             for $i in fn:doc("catalog.xml")/items/item
                     [suppno = $s/suppno],
                 $p in fn:doc("parts.xml")/parts/part
                     [partno = $i/partno]
             order by $p/description
             return
                &lt;part&gt;
                   {
                     $p/description,
                     $i/price
                   }
                &lt;/part&gt; 
           }
        &lt;/supplier&gt; 
    ,
    (: parts that have no supplier :)
    &lt;orphan-parts&gt;
       { for $p in fn:doc("parts.xml")/parts/part
         where fn:empty(fn:doc("catalog.xml")/items/item
               [partno = $p/partno] )
         order by $p/description
         return $p/description 
       }
    &lt;/orphan-parts&gt;
 }
&lt;/master-list&gt;
</PRE></DIV></DIV>
<P>The previous query uses an element constructor to enclose its output inside a 
<CODE>master-list</CODE> element. The concatenation operator (",") is used to 
combine the two main parts of the query. The result is an ordered sequence of 
<CODE>supplier</CODE> elements followed by an <CODE>orphan-parts</CODE> element 
that contains descriptions of all the parts that have no supplier.</P></DIV>
<DIV class=div2>
<H3><A id=id-grouping name=id-grouping></A>I.2 Grouping</H3>
<P>Many queries involve forming data into groups and applying some aggregation 
function such as <CODE>fn:count</CODE> or <CODE>fn:avg</CODE> to each group. The 
following example shows how such a query might be expressed in XQuery, using the 
catalog document defined in the previous section.</P>
<P>This query finds the part number and average price for parts that have at 
least 3 suppliers.</P>
<DIV class=parse-test>
<DIV class=exampleInner><PRE>for $pn in fn:distinct-values(
      fn:doc("catalog.xml")/items/item/partno)
let $i := fn:doc("catalog.xml")/items/item[partno = $pn]
where fn:count($i) &gt;= 3
order by $pn
return 
   &lt;well-supplied-item&gt;
      &lt;partno&gt; {$p} &lt;/partno&gt;
      &lt;avgprice&gt; {fn:avg($i/price)} &lt;/avgprice&gt;
   &lt;/well-supplied-item&gt;
</PRE></DIV></DIV>
<P>The <CODE>fn:distinct-values</CODE> function in this query eliminates 
duplicate part numbers from the set of all part numbers in the catalog document. 
The result of <CODE>fn:distinct-values</CODE> is a sequence in which order is 
not significant.</P>
<P>Note that <CODE>$pn</CODE>, bound by a for clause, represents an individual 
part number, whereas <CODE>$i</CODE>, bound by a let clause, represents a set of 
items which serves as argument to the aggregate functions 
<CODE>fn:count($i)</CODE> and <CODE>fn:avg($i/price)</CODE>. The query uses an 
element constructor to enclose each part number and average price in a 
containing element called <CODE>well-supplied-item</CODE>.</P>
<P>The method illustrated above generalizes easily to grouping by more than one 
data value. For example, consider a census document containing a sequence of 
<CODE>person</CODE> elements, each with subelements named <CODE>state</CODE>, 
<CODE>job</CODE>, and <CODE>income</CODE>. A census analyst might need to 
prepare a report listing the average <CODE>income</CODE> for each combination of 
<CODE>state</CODE> and <CODE>job</CODE>. This report might be produced using the 
following query:</P>
<DIV class=parse-test>
<DIV class=exampleInner><PRE>for $s in fn:distinct-values(
        fn:doc("census.xml")/census/person/state),
    $j in fn:distinct-values(
        fn:doc("census.xml")/census/person/job)
let $p := fn:doc("census.xml")/census/person
        [state = $s and job = $j]
order by $s, $j
return 
   if (fn:exists($p)) then
      &lt;group&gt;
         &lt;state&gt; {$s} &lt;/state&gt;
         &lt;job&gt; {$j} &lt;/job&gt;
         &lt;avgincome&gt; {fn:avg($p/income)} &lt;/avgincome&gt;
      &lt;/group&gt;
   else ()
</PRE></DIV></DIV>
<P>The <CODE>if-then-else</CODE> expression in the above example prevents 
generation of groups that contain no data. For example, the census data may 
contain some persons who live in Nebraska, and some persons whose job is Deep 
Sea Fisherman, but no persons who live in Nebraska and have the job of Deep Sea 
Fisherman. If output groups are desired for all possible combinations of states 
and jobs, the <CODE>if-then-else</CODE> expression can be omitted from the 
query. In this case, the output may include "empty" groups such as the 
following:</P>
<DIV class=parse-test>
<DIV class=exampleInner><PRE>&lt;group&gt;
   &lt;state&gt;Nebraska&lt;/state&gt;
   &lt;job&gt;Deep Sea Fisherman&lt;/job&gt;
   &lt;avgincome/&gt;
&lt;/group&gt;
</PRE></DIV></DIV></DIV>
<DIV class=div2>
<H3><A id=id-queries-on-sequence name=id-queries-on-sequence></A>I.3 Queries on 
Sequence</H3>
<P>XQuery uses the <CODE>&lt;&lt;</CODE> and <CODE>&gt;&gt;</CODE> operators to 
compare nodes based on document order. Although these operators are quite 
simple, they can be used to express complex queries for XML documents in which 
sequence is meaningful. The first two queries in this section involve a surgical 
report that contains <CODE>procedure</CODE>, <CODE>incision</CODE>, 
<CODE>instrument</CODE>, <CODE>action</CODE>, and <CODE>anesthesia</CODE> 
elements.</P>
<P>The following query returns all the <CODE>action</CODE> elements that occur 
between the first and second <CODE>incision</CODE> elements inside the first 
procedure. The original document order among these nodes is preserved in the 
result of the query.</P>
<DIV class=parse-test>
<DIV class=exampleInner><PRE>let $proc := /report/procedure[1]
for $i in $proc//action
where $i &gt;&gt; ($proc//incision)[1]
   and $i &lt;&lt; ($proc//incision)[2]
return $i
</PRE></DIV></DIV>
<P>It is worth noting here that document order is defined in such a way that a 
node is considered to precede its descendants in document order. In the surgical 
report, an <CODE>action</CODE> is never part of an <CODE>incision</CODE>, but an 
<CODE>instrument</CODE> is. Since the <CODE>&gt;&gt;</CODE> operator is based on 
document order, the predicate <CODE>$i &gt;&gt; ($proc//incision)[1]</CODE> is 
true for any <CODE>instrument</CODE> element that is a descendant of the first 
<CODE>incision</CODE> element in the first procedure.</P>
<P>For some queries, it may be helpful to define a function that can test 
whether a node precedes another node without being its ancestor. The following 
function returns <CODE>true</CODE> if its first operand precedes its second 
operand but is not an ancestor of its second operand; otherwise it returns 
<CODE>false</CODE>:</P>
<DIV class=frag-prolog-parse-test>
<DIV class=exampleInner><PRE>declare function local:precedes($a as node(), $b as node()) 
   as boolean
   {
      $a &lt;&lt; $b
        and
      fn:empty($a//node() intersect $b) 
   };
</PRE></DIV></DIV>
<P>Similarly, a <CODE>local:follows</CODE> function could be written:</P>
<DIV class=frag-prolog-parse-test>
<DIV class=exampleInner><PRE>declare function local:follows($a as node(), $b as node()) 
   as boolean
   {
      $a &gt;&gt; $b
        and
      fn:empty($b//node() intersect $a) 
   };
</PRE></DIV></DIV>
<P>Using the <CODE>local:precedes</CODE> function, we can write a query that 
finds <CODE>instrument</CODE> elements between the first two incisions, 
excluding from the query result any <CODE>instrument</CODE> that is a descendant 
of the first <CODE>incision</CODE>:</P>
<DIV class=parse-test>
<DIV class=exampleInner><PRE>let $proc := /report/procedure[1]
for $i in $proc//instrument
where local:precedes(($proc//incision)[1], $i)
   and local:precedes($i, ($proc//incision)[2])
return $i
</PRE></DIV></DIV>
<P>The following query reports incisions for which no prior anesthesia was 
recorded in the surgical report. Since an <CODE>anesthesia</CODE> is never part 
of an <CODE>incision</CODE>, we can use <CODE>&lt;&lt;</CODE> instead of the 
less-efficient <CODE>local:precedes</CODE> function:</P>
<DIV class=parse-test>
<DIV class=exampleInner><PRE>for $proc in /report/procedure
where some $i in $proc//incision satisfies
         fn:empty($proc//anesthesia[. &lt;&lt; $i])
return $proc
</PRE></DIV></DIV>
<P>In some documents, particular sequences of elements may indicate a logical 
hierarchy. This is most commonly true of HTML. The following query returns the 
introduction of an XHTML document, wrapping it in a <CODE>div</CODE> element. In 
this example, we assume that an <CODE>h2</CODE> element containing the text 
"Introduction" marks the beginning of the introduction, and the introduction 
continues until the next <CODE>h2</CODE> or <CODE>h1</CODE> element, or the end 
of the document, whichever comes first.</P>
<DIV class=parse-test>
<DIV class=exampleInner><PRE>let $intro := //h2[text()="Introduction"],
    $next-h := //(h1|h2)[. &gt;&gt; $intro][1]
return
   &lt;div&gt;
     {
       $intro,
       if (fn:empty($next-h))
         then //node()[. &gt;&gt; $intro]
         else //node()[. &gt;&gt; $intro and . &lt;&lt; $next-h]
     }
   &lt;/div&gt;
</PRE></DIV></DIV>
<P>Note that the above query makes explicit the hierarchy that was implicit in 
the original document. In this example, we assume that the <CODE>h2</CODE> 
element containing the text "Introduction" has no subelements.</P></DIV>
<DIV class=div2>
<H3><A id=id-recursive-transformations name=id-recursive-transformations></A>I.4 
Recursive Transformations</H3>
<P>Occasionally it is necessary to scan over a hierarchy of elements, applying 
some transformation at each level of the hierarchy. In XQuery this can be 
accomplished by defining a recursive function. In this section we will present 
two examples of such recursive functions.</P>
<P>Suppose that we need to compute a table of contents for a given document by 
scanning over the document, retaining only elements named <CODE>section</CODE> 
or <CODE>title</CODE>, and preserving the hierarchical relationships among these 
elements. For each <CODE>section</CODE>, we retain subelements named 
<CODE>section</CODE> or <CODE>title</CODE>; but for each <CODE>title</CODE>, we 
retain the full content of the element. This might be accomplished by the 
following recursive function:</P>
<DIV class=frag-prolog-parse-test>
<DIV class=exampleInner><PRE>declare function local:sections-and-titles($n as node()) as node()?
   {
   if (fn:local-name($n) = "section")
   then element
          { fn:local-name($n) }
          { for $c in $n/* return local:sections-and-titles($c) }
   else if (fn:local-name($n) = "title")
   then $n
   else ( )
   };
</PRE></DIV></DIV>
<P>The "skeleton" of a given document, containing only its sections and titles, 
can then be obtained by invoking the <CODE>local:sections-and-titles</CODE> 
function on the root node of the document, as follows:</P>
<DIV class=parse-test>
<DIV class=exampleInner><PRE>local:sections-and-titles(fn:doc("cookbook.xml"))
</PRE></DIV></DIV>
<P>As another example of a recursive transformation, suppose that we wish to 
scan over a document, transforming every attribute named <CODE>color</CODE> to 
an element named <CODE>color</CODE>, and every element named <CODE>size</CODE> 
to an attribute named <CODE>size</CODE>. This can be accomplished by the 
following recursive function (note that the element constructor in case 
<CODE>$e</CODE> generates attributes before child elements):</P>
<DIV class=frag-prolog-parse-test>
<DIV class=exampleInner><PRE>declare function local:swizzle($n as node()) as node() 
  { 
   typeswitch($n)
     case $a as attribute(color)
       return element color { fn:string($a) } 
     case $es as element(size) 
       return attribute size { fn:string($es) } 
     case $e as element() 
       return element 
         { fn:local-name($e) } 
         { for $c in 
             ($e/@* except $e/@color,     (: attr -&gt; attr :)
              $e/size,                    (: elem -&gt; attr :)
              $e/@color,                  (: attr -&gt; elem :)
              $e/node() except $e/size )  (: elem -&gt; elem :)
           return local:swizzle($c) }
     case $d as document-node() 
       return document 
         { for $c in $d/* return local:swizzle($c) } 
     default return $n 
  };
</PRE></DIV></DIV>
<P>The transformation can be applied to a whole document by invoking the 
<CODE>local:swizzle</CODE> function on the root node of the document, as 
follows:</P>
<DIV class=parse-test>
<DIV class=exampleInner><PRE>local:swizzle(fn:doc("plans.xml"))
</PRE></DIV></DIV></DIV>
<DIV class=div2>
<H3><A id=id-select-distinct name=id-select-distinct></A>I.5 Selecting Distinct 
Combinations</H3>
<P>It is sometimes necessary to search through a set of data to find all the 
distinct combinations of a given list of properties. For example, an input data 
set might consist of a large set of <CODE>order</CODE> elements, each of which 
has the same basic structure, as illustrated by the following example:</P>
<DIV class=exampleInner><PRE>&lt;order&gt;
   &lt;date&gt;2003-10-15&lt;/date&gt;
   &lt;product&gt;Dress Shirt&lt;/product&gt;
   &lt;size&gt;M&lt;/size&gt;
   &lt;color&gt;Blue&lt;/color&gt;
   &lt;supplier&gt;Fashion Trends&lt;/supplier&gt;
   &lt;quantity&gt;50&lt;/quantity&gt;
&lt;/order&gt;
</PRE></DIV>
<P>From this data set, a user might wish to find all the distinct combinations 
of <CODE>product</CODE>, <CODE>size</CODE>, and <CODE>color</CODE> that occur 
together in an <CODE>order</CODE>. The following query returns this list, 
enclosing each distinct combination in a new element named 
<CODE>option</CODE>:</P>
<DIV class=parse-test>
<DIV class=exampleInner><PRE>for $p in fn:distinct-values(/orders/order/product),
    $s in fn:distinct-values(/orders/order/size),
    $c in fn:distinct-values(/orders/order/color)
    order by $p, $s, $c
    return
       if (fn:exists(/orders/order[product eq $p
                and size eq $s and color eq $c]))
       then
          &lt;option&gt;
             &lt;product&gt;{$p}&lt;/product&gt;
             &lt;size&gt;{$s}&lt;/size&gt;
             &lt;color&gt;{$c}&lt;/color&gt;
          &lt;/option&gt;
       else ()
</PRE></DIV></DIV></DIV></DIV></DIV>
<DIV class=div1>
<H2><A id=id-revisions-log name=id-revisions-log></A>J Revision Log 
(Non-Normative)</H2>
<DIV class=xquery>
<P class=xquery>This log records changes that have been made to this document 
since the Proposed Recommendation Draft of 21 November 2006.</P></DIV>
<DIV class=xquery>
<OL class=enumar>
  <LI>
  <P>Additional details have been added to <A 
  href="REC-xquery-20070123.htm#id-security-considerations"><B>G.6 
  Security Considerations</B></A>.</P>
  <LI>
  <P>Rules preventing multiple bindings of a namespace prefix within a module 
  have been clarified.</P>
  <P>This change closes Bugzilla entry 3951. Sections affected: <A 
  href="REC-xquery-20070123.htm#id-module-declaration"><B>4.2 
  Module Declaration</B></A>, <A 
  href="REC-xquery-20070123.htm#id-schema-import"><B>4.10 
  Schema Import</B></A>, <A 
  href="REC-xquery-20070123.htm#id-module-import"><B>4.11 
  Module Import</B></A>, <A 
  href="REC-xquery-20070123.htm#id-namespace-declaration"><B>4.12 
  Namespace Declaration</B></A>, and error code 
XQST0033.</P></LI></OL></DIV></DIV></DIV></BODY></HTML>
